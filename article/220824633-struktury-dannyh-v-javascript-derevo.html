
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Структуры данных в JavaScript: дерево... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Структуры данных в JavaScript: дерево... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Структуры данных в JavaScript: дерево... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Структуры данных в JavaScript: дерево... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Деревья являются одной из наиболее часто используемых структур данных в веб-разработке. Это утверждение справедливо как для разработчиков, так и для пользователей. Каждый веб-разработчик, который писал HTML и загружал его в веб-браузер, создавал дерево, которое называется Document Object Model (DOM). Каждый пользователь Интернета, который, в свою о...">
<meta property="og:description" content="Деревья являются одной из наиболее часто используемых структур данных в веб-разработке. Это утверждение справедливо как для разработчиков, так и для пользователей. Каждый веб-разработчик, который писал HTML и загружал его в веб-браузер, создавал дерево, которое называется Document Object Model (DOM). Каждый пользователь Интернета, который, в свою о...">
<meta name="twitter:description" content="Деревья являются одной из наиболее часто используемых структур данных в веб-разработке. Это утверждение справедливо как для разработчиков, так и для пользователей. Каждый веб-разработчик, который писал HTML и загружал его в веб-браузер, создавал дерево, которое называется Document Object Model (DOM). Каждый пользователь Интернета, который, в свою о...">
<meta property="aiturec:description" content="Деревья являются одной из наиболее часто используемых структур данных в веб-разработке. Это утверждение справедливо как для разработчиков, так и для пользователей. Каждый веб-разработчик, который писал HTML и загружал его в веб-браузер, создавал дерево, которое называется Document Object Model (DOM). Каждый пользователь Интернета, который, в свою о...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=447/uploads/users/423/posts/23393/final_image/data-structures-4-of-4.jpg">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=447/uploads/users/423/posts/23393/final_image/data-structures-4-of-4.jpg">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=447/uploads/users/423/posts/23393/final_image/data-structures-4-of-4.jpg">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=447/uploads/users/423/posts/23393/final_image/data-structures-4-of-4.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=447/uploads/users/423/posts/23393/final_image/data-structures-4-of-4.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article/220824633-struktury-dannyh-v-javascript-derevo.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article/220824633-struktury-dannyh-v-javascript-derevo.html">
<link rel="canonical" href="https://norma-studio.github.io/article/220824633-struktury-dannyh-v-javascript-derevo.html">
<meta property="og:url" content="https://norma-studio.github.io/article/220824633-struktury-dannyh-v-javascript-derevo.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article/220824633-struktury-dannyh-v-javascript-derevo.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article/220824633-struktury-dannyh-v-javascript-derevo.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article/220824633-struktury-dannyh-v-javascript-derevo.html" title="Структуры данных в JavaScript: дерево... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Структуры данных в JavaScript: дерево... | envatomarket.ru | norma-studio.github.io" title="Структуры данных в JavaScript: дерево... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/64533jghfdd.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article/220824633-struktury-dannyh-v-javascript-derevo.html" class="tm-user-info__username" title="
Д. Слесарев" aria-label="
Д. Слесарев">
Д. Слесарев</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Структуры данных в JavaScript: дерево...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824633-struktury-dannyh-v-javascript-derevo" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="JavaScript" href="https://norma-studio.github.io/article/220824633-struktury-dannyh-v-javascript-derevo" class="tm-article-snippet__hubs-item-link"><span>JavaScript</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article/220824633-struktury-dannyh-v-javascript-derevo.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=447/uploads/users/423/posts/23393/final_image/data-structures-4-of-4.jpg">
    <meta itemprop="headline name" content="Структуры данных в JavaScript: дерево... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Деревья являются одной из наиболее часто используемых структур данных в веб-разработке. Это утверждение справедливо как для разработчиков, так и для пользователей. Каждый веб-разработчик, который писал HTML и загружал его в веб-браузер, создавал дерево, которое называется Document Object Model (DOM). Каждый пользователь Интернета, который, в свою о...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Деревья являются одной из наиболее часто используемых структур данных в веб-разработке. Это утверждение справедливо как для разработчиков, так и для пользователей. Каждый веб-разработчик, который писал HTML и загружал его в веб-браузер, создавал дерево, которое называется Document Object Model (DOM). Каждый пользователь Интернета, который, в свою о...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Деревья являются одной из наиболее часто используемых структур данных в веб-разработке. Это утверждение справедливо как для разработчиков, так и для пользователей. Каждый веб-разработчик, который писал HTML и загружал его в веб-браузер, создавал дерево, которое называется Document Object Model (DOM). Каждый пользователь Интернета, который, в свою очередь, потреблял информацию в Интернете, получал ее в виде дерева - DOM. <br></p><p>Теперь, вот кульминация: статья, которую вы читаете в данный момент, отображается в вашем браузере как дерево! Абзац, который вы читаете, представлен как текст в элементе <code class="inline">&lt;p&gt;</code>; Элемент <code class="inline">&lt;p&gt;</code> вложен внутри элемента <code class="inline">&lt;body&gt;</code>; И элемент <code class="inline">&lt;body&gt;</code> вложен внутри элемента <code class="inline">&lt;html&gt;</code>. </p><p>Вложение данных аналогично генеалогическому дереву. Элемент <code class="inline">&lt;html&gt;</code> является родителем, элемент <code class="inline">&lt;body&gt;</code> является дочерним, а элемент <code class="inline">&lt;p&gt;</code> является дочерним элементом элемента <code class="inline">&lt;body&gt;</code>. Если эта аналогия дерева кажется вам полезной, то вам определенно понравится идея того, что во время нашей реализации дерева будет использовано еще больше аналогий. </p><p>В этой статье мы создадим дерево, используя два разных метода обхода дерева: поиск по глубине (DFS) и поиск по ширине (BFS). (Если слово обход незнакомо вам, считайте его посещением каждого узла дерева.) Оба этих типа обхода выделяют различные способы взаимодействия с деревом; Более того, оба путешествия включают использование структур данных, которые мы рассмотрели в этой серии. DFS использует стек, а BFS использует очередь для посещения узлов. Это круто!</p><h2>Дерево (поиск по глубине и поиск по ширине)<br></h2><p>В информатике дерево представляет собой структуру данных, имитирующую иерархические данные с узлами. Каждый узел дерева содержит свои собственные данные и указатели на другие узлы.</p><p>Терминология узлов и указателей может быть новой для некоторых читателей, поэтому давайте опишем их далее с помощью аналогии. Давайте сравним дерево с графиком организации. График имеет позицию верхнего уровня (корневой узел), например, CEO. Прямо под этой позицией находятся другие должности, такие как вице-президент (VP). </p><p>Чтобы представить это соотношение, мы используем стрелки, указывающие от генерального директора на VP. Позиция, такая как генеральный директор, является узлом; Отношения, которые мы создаем от генерального директора к VP, являются указателями. Чтобы создать больше связей в нашем графике, мы просто повторяем этот процесс - у нас есть узел, указывающий на другой узел. </p><p>На концептуальном уровне я надеюсь, что узлы и указатели вам и так понятны. На практическом уровне мы можем воспользоваться более техническим примером. Рассмотрим DOM. DOM имеет элемент <code class="inline">&lt;html&gt;</code> в качестве позиции верхнего уровня (корневой узел). Этот узел указывает на элемент <code class="inline">&lt;head&gt;</code> и <code class="inline">&lt;body&gt;</code>. Этот процесс повторяется для всех узлов в DOM. </p><p>Красота этого дизайна заключается в способности встраивать узлы: элемент <code class="inline">&lt;ul&gt;</code>, например, может содержать много элементов <code class="inline">&lt;li&gt;</code>, вложенных в него; Кроме того, каждый элемент <code class="inline">&lt;li&gt;</code> может иметь узлы-соседи <code class="inline">&lt;li&gt;</code>. Это странно, но забавно и верно!</p><h3>Операции над деревом<br></h3><p>Поскольку каждое дерево содержит узлы, которые могут быть отдельным конструктором из дерева, мы будем описывать операции для обоих конструкторов: <code class="inline">Node</code> и <code class="inline">Tree</code>.<br></p><h4>Узел<br></h4><ul><li> <code class="inline">data</code> хранит значение.</li> <li> <code class="inline">parent</code> указывает на родительский элемент узла.</li> <li> <code class="inline">children</code> указывают на следующий узел в списке.</li> </ul><h4>Дерево<br></h4><ul><li> <code class="inline">_root</code> указывает на корневой узел дерева.</li> <li> <code class="inline">traverseDF(callback)</code> обходит узлы дерева с DFS.</li> <li> <code class="inline">traverseBF(callback)</code> перемещает узлы дерева с BFS.</li> <li> <code class="inline">contains(data, traversal)</code> ищет узел в дереве.</li> <li> <code class="inline">add(data, toData, traverse)</code> добавляет узел в дерево.</li> <li> <code class="inline">remove(child, parent)</code> удаляет узел из дерева. </li> </ul><h3>Реализация дерева<br></h3><p>Теперь давайте напишем код для дерева!<br></p><h4>Свойства узла <br></h4><p>Для нашей реализации мы сначала определим функцию с именем <code class="inline">Node</code>, а затем конструктор с именем <code class="inline">Tree</code>.</p><pre class="brush: javascript noskimlinks noskimwords">function Node(data) {    this.data = data;    this.parent = null;    this.children = [];}</pre><p>Каждый экземпляр узла содержит три свойства: <code class="inline">data</code>, <code class="inline">parent</code> и <code class="inline">children</code>. Первое свойство содержит данные, связанные с узлом. Второе свойство указывает на один узел. Третье свойство указывает на множество дочерних узлов.</p><h4>Свойства дерева<br></h4><p>Теперь давайте определим наш конструктор для <code class="inline">Tree</code>, который включает в себя конструктор <code class="inline">Node</code> в его определении: </p><pre class="brush: javascript noskimlinks noskimwords">function Tree(data) {    var node = new Node(data);    this._root = node;}</pre><p><code class="inline">Tree</code> содержит две строки кода. Первая строка создает новый экземпляр <code class="inline">Node</code>; Вторая строка назначает <code class="inline">node</code> как корень дерева. </p><p>Определения <code class="inline">Tree</code> и <code class="inline">Node</code> требуют только лишь нескольких строк кода. Однако этих строк достаточно, чтобы помочь нам имитировать иерархические данные. Чтобы доказать этот момент, давайте использовать некоторые примеры для создания экземпляра <code class="inline">Tree</code> (и, косвенно, <code class="inline">Node</code>).</p><pre class="brush: javascript noskimlinks noskimwords">var tree = new Tree("CEO");// {data: "CEO", parent: null, children: []}tree._root;</pre><p>Благодаря существованию <code class="inline">parent</code> и <code class="inline">children</code>, мы можем добавлять узлы как дочерние элементы <code class="inline">_root</code>, а также присваивать <code class="inline">_root</code> родителям этих узлов. Другими словами, мы можем имитировать создание иерархических данных. </p><h4>Методы дерева<br></h4><p>Затем мы создадим следующие пять методов: <br></p><p><strong>Tree</strong><br></p><ol><li><code class="inline">traverseDF(callback)</code></li> <li><code class="inline">traverseBF(callback)</code></li> <li><code class="inline">contains(data, traversal)</code></li> <li><code class="inline">add(child, parent)</code></li> <li><code class="inline">remove(node, parent)</code></li> </ol><p>Поскольку каждый метод дерева требует от нас обхода дерева, мы сначала реализуем методы, которые определяют разные типы обхода дерева. (Обход дерева - это формально посещение каждого узла дерева.) </p><p><strong>1 из 5: <code class="inline">traverseDF(callback)</code></strong><br></p><p>Этот метод обходит дерево с поиском в глубину. </p><pre class="brush: javascript noskimlinks noskimwords">Tree.prototype.traverseDF = function(callback) {    // this is a recurse and immediately-invoking function     (function recurse(currentNode) {        // step 2        for (var i = 0, length = currentNode.children.length; i &lt; length; i++) {            // step 3            recurse(currentNode.children[i]);        }        // step 4        callback(currentNode);                // step 1    })(this._root);};</pre><p><code class="inline">traverseDF(callback)</code> имеет параметр с именем <code class="inline">callback</code>. Если это непонятно из имени, считается, что <code class="inline">callback</code> является функцией, которая будет называться позже в <code class="inline">traverseDF(callback)</code>. </p><p>Тело <code class="inline">traverseDF(callback)</code> включает в себя другую функцию с именем <code class="inline">recurse</code>. Эта функция является рекурсивной функцией! Другими словами, она сама себя вызывает. Используя шаги, упомянутые в комментариях <code class="inline">recurse</code>, я опишу общий процесс, который <code class="inline">recurse</code> использует для перемещения по всему дереву. </p><p>Вот эти шаги: </p><ol><li>Сразу вызовите <code class="inline">recurse</code> с корневым узлом дерева в качестве аргумента. В настоящий момент <code class="inline">currentNode</code> указывает на текущий узел. </li> <li>Входим в цикл <code class="inline">for</code> и проходимся по каждому элементу <code class="inline">currentNode</code>, начиная с первого дочернего элемента. </li> <li>Внутри тела цикла <code class="inline">for</code> вызывается recurse с дочерним элементом <code class="inline">currentNode</code>. Каждый конкретный дочерний элемент зависит от текущей итерации цикла <code class="inline">for</code>. </li> <li>Когда <code class="inline">currentNode</code> больше не имеет дочерних элементов, мы выходим из цикла <code class="inline">for</code> и вызываем <code class="inline">callback</code>, который мы передали во время вызова <code class="inline">traverseDF(callback)</code>. </li> </ol><p>Шаги 2 (выход из функции), 3 (вызов себя) и 4 (callback) повторяются до тех пор, пока мы не пройдем каждый узел дерева. <br></p><p>Рекурсия - очень трудная тема для обучения и требует подробного объяснения. Поскольку объяснение рекурсии не в центре внимания этой статьи, основное внимание уделяется внедрению дерева. Я предлагаю, чтобы все читатели, не обладающие хорошим пониманием рекурсии, сделали следующие две вещи.</p><p>Во-первых, экспериментируйте с нашей текущей реализацией <code class="inline">traverseDF(callback)</code> и попытайтесь понять, как это работает. Во-вторых, если вы хотите, чтобы я написал статью о рекурсии, пожалуйста, запросите ее в комментариях к этой статье.</p><p>В следующем примере показано, как дерево будет пройдено через <code class="inline">traverseDF(callback)</code>. Чтобы обойти дерево, я создам его в следующем примере. Подход, который я буду использовать в данный момент, не идеален, но он работает. Лучшим подходом было бы использовать <code class="inline">add(value)</code>, который мы реализуем на шаге 4 из 5. </p><pre class="brush: javascript noskimlinks noskimwords">var tree = new Tree("one");tree._root.children.push(new Node("two"));tree._root.children[0].parent = tree;tree._root.children.push(new Node("three"));tree._root.children[1].parent = tree;tree._root.children.push(new Node("four"));tree._root.children[2].parent = tree;tree._root.children[0].children.push(new Node("five"));tree._root.children[0].children[0].parent = tree._root.children[0];tree._root.children[0].children.push(new Node("six"));tree._root.children[0].children[1].parent = tree._root.children[0];tree._root.children[2].children.push(new Node("seven"));tree._root.children[2].children[0].parent = tree._root.children[2];/*creates this tree one ├── two │   ├── five │   └── six ├── three └── four     └── seven*/</pre><p>Теперь давайте обратимся к <code class="inline">traverseDF(callback)</code>.</p><pre class="brush: javascript noskimlinks noskimwords">tree.traverseDF(function(node) {    console.log(node.data)});/*logs the following strings to the console"five""six""two""three""seven""four""one"*/</pre><p><strong>2 из 5: <code class="inline">traverseBF(callback)</code></strong></p><p>Этот метод использует поиск по ширине для перемещения по дереву. </p><p>Разница между поиском в глубину и поиском в ширину включает в себя последовательность, в которой посещаются узлы дерева. Чтобы проиллюстрировать этот момент, давайте используем дерево, которое мы создали из <code class="inline">traverseDF(callback)</code>.</p><pre class="brush: javascript noskimlinks noskimwords">/* tree one (depth: 0) ├── two (depth: 1) │   ├── five (depth: 2) │   └── six (depth: 2) ├── three (depth: 1) └── four (depth: 1)     └── seven (depth: 2) */</pre><p>Теперь давайте пройдем <code class="inline">traverseBF(callback)</code> тот же обратный вызов, который мы использовали для <code class="inline">traverseDF(callback)</code>. </p><pre class="brush: javascript noskimlinks noskimwords">tree.traverseBF(function(node) {    console.log(node.data)});/*logs the following strings to the console"one""two""three""four""five""six""seven"*/</pre><p>Логи с консоли и диаграммы нашего дерева показывают образец поиска в ширину. Начните с корневого узла; Затем пройдите одну глубину и посетите каждый узел на этой глубине слева направо. Повторяйте этот процесс до тех пор, пока не будет больше глубины для перемещения. </p><p>Поскольку у нас есть концептуальная модель поиска в ширину, давайте теперь реализуем код, который заставит наш пример работать. </p><pre class="brush: javascript noskimlinks noskimwords">Tree.prototype.traverseBF = function(callback) {    var queue = new Queue();        queue.enqueue(this._root);    currentTree = queue.dequeue();    while(currentTree){        for (var i = 0, length = currentTree.children.length; i &lt; length; i++) {            queue.enqueue(currentTree.children[i]);        }        callback(currentTree);        currentTree = queue.dequeue();    }};</pre><p>Наше определение <code class="inline">traverseBF(callback)</code> содержит много логики. По этой причине я объясню логику в управляемых шагах: </p><ol><li>Создайте экземпляр <code class="inline">Queue</code>.</li> <li>Добавьте узел, который вызвал <code class="inline">traverseBF(callback)</code> к экземпляру <code class="inline">Queue</code>. </li> <li>Объявите переменную с именем <code class="inline">currentNode</code> и инициализируйте ее к <code class="inline">node</code>, который мы только что добавили в нашу очередь. </li> <li>Пока <code class="inline">currentNode</code> указывает на узел, выполните код внутри цикла <code class="inline">while</code>. </li> <li>Используйте цикл <code class="inline">for</code> для итерации по дочерним элементам <code class="inline">currentNode</code>.</li> <li>Внутри тела цикла <code class="inline">for</code> добавьте каждый дочерний элемент в очередь. </li> <li>Возьмите <code class="inline">currentNode</code> и передайте его как аргумент в <code class="inline">callback</code>. </li> <li>Перенесите <code class="inline">currentNode</code> на удаляемый узел из очереди. </li> <li>Пока <code class="inline">currentNode</code> не указывает на узел - каждый узел в дереве был посещен - повторите шаги с 4 по 8.</li> </ol><p><strong>3 из 5: <code class="inline">contains(callback, traversal)</code></strong><br></p><p>Давайте определим метод, который позволит нам искать конкретное значение в нашем дереве. Чтобы использовать любой из наших методов обхода дерева, я определил <code class="inline">contains(callback, traversal)</code> таким образом, чтобы он принимал два аргумента: данные для поиска и тип обхода. </p><pre class="brush: javascript noskimlinks noskimwords">Tree.prototype.contains = function(callback, traversal) {    traversal.call(this, callback);};</pre><p>В теле <code class="inline">contains(callback, traversal)</code>, мы используем метод с именем <code class="inline">call</code> для передачи <code class="inline">this</code> и <code class="inline">callback</code>. Первый аргумент связывает <code class="inline">traversal</code> с деревом которые вызывало <code class="inline">contains(callback, traversal)</code>; второй аргумент - это функция, которая вызывается на каждом узле нашего дерева. </p><p>Представьте себе, что мы хотим отобразить в консоли любые узлы, содержащие данные с нечетным числом, и обойти при этом каждый узел нашего дерева с помощью BFS. Это код, который мы напишем:</p><pre class="brush: javascript noskimlinks noskimwords">// tree is an example of a root nodetree.contains(function(node){    if (node.data === "two") {        console.log(node);    }}, tree.traverseBF);</pre><p><strong>4 из 5: <code class="inline">add(data, toData, traversal)</code></strong></p><p>Теперь у нас есть метод поиска определенного узла в нашем дереве. Давайте теперь определим метод, который позволит нам добавить узел к определенному узлу. </p><pre class="brush: javascript noskimlinks noskimwords">Tree.prototype.add = function(data, toData, traversal) {    var child = new Node(data),        parent = null,        callback = function(node) {            if (node.data === toData) {                parent = node;            }        };    this.contains(callback, traversal);    if (parent) {        parent.children.push(child);        child.parent = parent;    } else {        throw new Error("Cannot add node to a non-existent parent.");    }};</pre><p><code class="inline">add(data, toData, traversal)</code> определяет три параметра. Первый параметр, <code class="inline">data</code>, используется для создания нового экземпляра <code class="inline">Node</code>. Второй параметр <code class="inline">toData</code> используется для сравнения с каждым узлом в дереве. Третий параметр, <code class="inline">traversal</code>, является типом обхода дерева, используемого в этом методе. </p><p>В теле <code class="inline">add(data, toData, traversal)</code> мы объявляем три переменные. Первая переменная, <code class="inline">child</code>  инициализируется как новый экземпляр <code class="inline">Node</code>. Вторая переменная, <code class="inline">parent</code>, инициализируется как <code class="inline">null</code>; Но позже она укажет на любой узел в дереве, который соответствует значению <code class="inline">toData</code>. Перераспределение <code class="inline">parent</code> происходит в третьей переменной, которую мы объявляем - <code class="inline">callback</code>. </p><p><code class="inline">callback</code> - это функция, которая сравнивает <code class="inline">toData</code> с данными <code class="inline">data</code> каждого узла. Если оператор <code class="inline">if</code> возвращает значение <code class="inline">true</code>, то <code class="inline">parent</code> назначается узлу, который сравнивался в инструкции <code class="inline">if</code>. </p><p>Фактическое сравнение каждого узла с <code class="inline">toData</code> происходит в <code class="inline">contains(callback, traversal)</code>. Тип обхода и <code class="inline">callback</code> должны быть переданы в качестве аргументов <code class="inline">contains(callback, traversal)</code>. </p><p>Наконец, если <code class="inline">parent</code> существует в дереве, мы помещаем <code class="inline">child</code> в <code class="inline">parent.children</code>; Мы также назначаем <code class="inline">parent</code> родительскому элементу <code class="inline">child</code>. Иначе мы выкидываем ошибку. </p><p>Давайте воспользуемся <code class="inline">add(data, toData, traversal)</code> на примере: </p><pre class="brush: javascript noskimlinks noskimwords">var tree = new Tree("CEO");tree.add("VP of Happiness", "CEO", tree.traverseBF);/*our tree"CEO"└── "VP of Happiness"*/</pre><p>Вот более сложный пример для <code class="inline">add(addData, toData, traversal)</code>: </p><pre class="brush: javascript noskimlinks noskimwords">var tree = new Tree("CEO");tree.add("VP of Happiness", "CEO", tree.traverseBF);tree.add("VP of Finance", "CEO", tree.traverseBF);tree.add("VP of Sadness", "CEO", tree.traverseBF);tree.add("Director of Puppies", "VP of Finance", tree.traverseBF);tree.add("Manager of Puppies", "Director of Puppies", tree.traverseBF);/* tree "CEO" ├── "VP of Happiness" ├── "VP of Finance" │   ├── "Director of Puppies" │   └── "Manager of Puppies" └── "VP of Sadness" */</pre><p><strong>5 из 5: <code class="inline">remove(data, fromData, traversal)</code></strong></p><p>Чтобы завершить нашу реализацию <code class="inline">Tree</code>, мы добавим метод с именем <code class="inline">remove(data, fromData, traversal)</code>. Подобно удалению узла из DOM, этот метод удалит узел и все его дочерние элементы.</p><pre class="brush: javascript noskimlinks noskimwords">Tree.prototype.remove = function(data, fromData, traversal) {    var tree = this,        parent = null,        childToRemove = null,        index;    var callback = function(node) {        if (node.data === fromData) {            parent = node;        }    };    this.contains(callback, traversal);    if (parent) {        index = findIndex(parent.children, data);        if (index === undefined) {            throw new Error("Node to remove does not exist.");        } else {            childToRemove = parent.children.splice(index, 1);        }    } else {        throw new Error("Parent does not exist.");    }    return childToRemove;};</pre><p>Подобно <code class="inline">add(data, toData, traversal)</code>, метод remove обходит дерево, чтобы найти узел, содержащий второй аргумент <code class="inline">fromData</code>. Если этот узел найден, то <code class="inline">parent</code> указывает на него. </p><p>В этот момент мы достигаем нашего первого <code class="inline">if</code> выражения. Если <code class="inline">parent</code> не существует, мы выдаем ошибку. Если <code class="inline">parent</code> существует, мы вызываем <code class="inline">findIndex()</code> с <code class="inline">parent.children</code> и данные, которые мы хотим удалить из дочерних узлов <code class="inline">parent</code>. (<code class="inline">findIndex()</code> - вспомогательный метод, который я определил ниже.)</p><pre class="brush: javascript noskimlinks noskimwords">function findIndex(arr, data) {    var index;    for (var i = 0; i &lt; arr.length; i++) {        if (arr[i].data === data) {            index = i;        }    }    return index;}</pre><p>Внутри <code class="inline">findIndex()</code> происходит следующая логика. Если какой-либо из узлов в <code class="inline">parent.children</code> содержит данные, соответствующие <code class="inline">data</code>, переменной <code class="inline">index</code> присваивается целое число. Если ни одно из данных у дочерних элементов не соответствует <code class="inline">data</code>, <code class="inline">index</code> сохраняет значение по умолчанию <code class="inline">undefined</code>. В последней строке <code class="inline">findIndex()</code> мы возвращаем <code class="inline">index</code>. </p><p>Теперь мы возвращаемся назад к <code class="inline">remove(data, fromData, traversal</code>). Если <code class="inline">index</code> равен <code class="inline">undefined</code>, возникает ошибка. Если <code class="inline">index</code> определен, мы используем его для сращивания узла, который хотим удалить из дочерних элементов <code class="inline">parent</code>; Мы также присваиваем удаленный дочерний элемент переменной <code class="inline">childToRemove</code>. </p><p>Наконец, мы возвращаем <code class="inline">childToRemove</code>. </p><h3>Полная реализация дерева<br></h3><p>Наша реализация <code class="inline">Tree</code> завершена. Взгляните - мы многое сделали: </p><pre class="brush: javascript noskimlinks noskimwords">function Node(data) {    this.data = data;    this.parent = null;    this.children = [];}function Tree(data) {    var node = new Node(data);    this._root = node;}Tree.prototype.traverseDF = function(callback) {    // this is a recurse and immediately-invoking function    (function recurse(currentNode) {        // step 2        for (var i = 0, length = currentNode.children.length; i &lt; length; i++) {            // step 3            recurse(currentNode.children[i]);        }        // step 4        callback(currentNode);        // step 1    })(this._root);};Tree.prototype.traverseBF = function(callback) {    var queue = new Queue();    queue.enqueue(this._root);    currentTree = queue.dequeue();    while(currentTree){        for (var i = 0, length = currentTree.children.length; i &lt; length; i++) {            queue.enqueue(currentTree.children[i]);        }        callback(currentTree);        currentTree = queue.dequeue();    }};Tree.prototype.contains = function(callback, traversal) {    traversal.call(this, callback);};Tree.prototype.add = function(data, toData, traversal) {    var child = new Node(data),        parent = null,        callback = function(node) {            if (node.data === toData) {                parent = node;            }        };    this.contains(callback, traversal);    if (parent) {        parent.children.push(child);        child.parent = parent;    } else {        throw new Error("Cannot add node to a non-existent parent.");    }};Tree.prototype.remove = function(data, fromData, traversal) {    var tree = this,        parent = null,        childToRemove = null,        index;    var callback = function(node) {        if (node.data === fromData) {            parent = node;        }    };    this.contains(callback, traversal);    if (parent) {        index = findIndex(parent.children, data);        if (index === undefined) {            throw new Error("Node to remove does not exist.");        } else {            childToRemove = parent.children.splice(index, 1);        }    } else {        throw new Error("Parent does not exist.");    }    return childToRemove;};function findIndex(arr, data) {    var index;    for (var i = 0; i &lt; arr.length; i++) {        if (arr[i].data === data) {            index = i;        }    }    return index;}</pre><h2>Вывод </h2><p>Деревья моделируют иерархические данные. Большая часть окружающего нас мира напоминает этот тип иерархии, как например веб-страницы и наши семьи. Каждый раз, когда вам нужно структурировать данные в виде иерархии, подумайте об использовании дерева. <br></p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824633-struktury-dannyh-v-javascript-derevo" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="JavaScript" href="https://norma-studio.github.io/article/220824633-struktury-dannyh-v-javascript-derevo" class="tm-article-body__tags-item-link">JavaScript</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
36318</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
330</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>


<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Как использовать Map, Filter и Reduce в JavaScript... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Как использовать Map, Filter и Reduce в JavaScript... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Как использовать Map, Filter и Reduce в JavaScript... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Как использовать Map, Filter и Reduce в JavaScript... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="На данный момент функциональное программирование становится всё популярнее и популярнее . И на это есть веская причина: функциональный подход позволяет вам писать более декларативный код, который легко понять при изучении, рефакторинге и тестировании. ...">
<meta property="og:description" content="На данный момент функциональное программирование становится всё популярнее и популярнее . И на это есть веская причина: функциональный подход позволяет вам писать более декларативный код, который легко понять при изучении, рефакторинге и тестировании. ...">
<meta name="twitter:description" content="На данный момент функциональное программирование становится всё популярнее и популярнее . И на это есть веская причина: функциональный подход позволяет вам писать более декларативный код, который легко понять при изучении, рефакторинге и тестировании. ...">
<meta property="aiturec:description" content="На данный момент функциональное программирование становится всё популярнее и популярнее . И на это есть веская причина: функциональный подход позволяет вам писать более декларативный код, который легко понять при изучении, рефакторинге и тестировании. ...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1304/profiles/19815/profileImage/profile400.jpg">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1304/profiles/19815/profileImage/profile400.jpg">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1304/profiles/19815/profileImage/profile400.jpg">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1304/profiles/19815/profileImage/profile400.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1304/profiles/19815/profileImage/profile400.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article/220824650-kak-ispolzovat-map-filter-i-reduce-v-javascript.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article/220824650-kak-ispolzovat-map-filter-i-reduce-v-javascript.html">
<link rel="canonical" href="https://norma-studio.github.io/article/220824650-kak-ispolzovat-map-filter-i-reduce-v-javascript.html">
<meta property="og:url" content="https://norma-studio.github.io/article/220824650-kak-ispolzovat-map-filter-i-reduce-v-javascript.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article/220824650-kak-ispolzovat-map-filter-i-reduce-v-javascript.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article/220824650-kak-ispolzovat-map-filter-i-reduce-v-javascript.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article/220824650-kak-ispolzovat-map-filter-i-reduce-v-javascript.html" title="Как использовать Map, Filter и Reduce в JavaScript... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Как использовать Map, Filter и Reduce в JavaScript... | envatomarket.ru | norma-studio.github.io" title="Как использовать Map, Filter и Reduce в JavaScript... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/636536435.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article/220824650-kak-ispolzovat-map-filter-i-reduce-v-javascript.html" class="tm-user-info__username" title="
С. Торгашев" aria-label="
С. Торгашев">
С. Торгашев</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Как использовать Map, Filter и Reduce в JavaScript...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824650-kak-ispolzovat-map-filter-i-reduce-v-javascript" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="JavaScript" href="https://norma-studio.github.io/article/220824650-kak-ispolzovat-map-filter-i-reduce-v-javascript" class="tm-article-snippet__hubs-item-link"><span>JavaScript</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article/220824650-kak-ispolzovat-map-filter-i-reduce-v-javascript.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1304/profiles/19815/profileImage/profile400.jpg">
    <meta itemprop="headline name" content="Как использовать Map, Filter и Reduce в JavaScript... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="На данный момент функциональное программирование становится всё популярнее и популярнее . И на это есть веская причина: функциональный подход позволяет вам писать более декларативный код, который легко понять при изучении, рефакторинге и тестировании. ...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">На данный момент функциональное программирование становится всё популярнее и популярнее . И на это есть веская причина: функциональный подход позволяет вам писать более декларативный код, который легко понять при изучении, рефакторинге и тестировании. ...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>На данный момент функциональное программирование становится всё популярнее и популярнее . И на это есть веская причина: функциональный подход позволяет вам писать более декларативный код, который легко понять при изучении, рефакторинге и тестировании. <br></p><p>Одно из отличительных особенностей функционального программирование - использование списков и операторов для работы со списками. И это как раз то, как это звучит: массивы каких-либо вещей и возможность взаимодействовать c ними. Но подход к этому в функциональном программировании немного отличается от того, что вы возможно ожидаете.</p><p>В данной статье мы взглянем на то что я называю "большая тройка" операторы списков: <code class="inline">map</code>, <code class="inline">filter</code> и <code class="inline">reduce</code>. Понимание как работают вышеперечисленные, три функции, важный шаг в сторону написания чистого, функционального кода, что в свою очередь откроет вам двери к мощным техниками функционального и реактивного программирования.</p><p>Также это означает, что у вас не будет больше необходимости писать цикл <code class="inline">for</code>.</p><p>Любопытно? Давайте же начнём.</p><h2>Map от списка к списку</h2><p>Довольно часто нам нужно модифицировать каждый элемент массива, используя один и тот же подход. Типичный пример - возвести каждый элемент массива чисел в квадрат, получить имя из списка пользователей или обработать строки регулярным выражением.</p><p><code class="inline">map</code> является встроенным методом, который делает как раз то что мы хотим. Данный метод определён в <code class="inline">Array.prototype</code>, следовательно его можно вызвать на любом массиве, после чего передать каллбек в качестве первого аргумента. </p><p>Когда вы вызываете <code class="inline">map</code> для массива, каллбек выполняется для каждого элемента данного массива, затем возвращается <em>новый</em> массив со значениями обработанными каллбеком.</p><p>Под капотом, <code class="inline">map</code> передаёт три аргумента каллбеку:</p><ol><li><em>Текущий элемент</em> массива</li> <li><em>Индекс в массиве</em> текущего элемента</li> <li><em>Весь массив</em> для которого был вызван map </li> </ol><p>Давайте взглянем на код.</p><h3> <code class="inline">map</code> на практике</h3><p>Предположим у нас есть приложение, в котором содержится массив всех задач, которые стоит выполнить в течении дня. Каждый <code class="inline">task</code> является объектом, у которого есть свойства <code class="inline">name</code> и <code class="inline">duration</code>:</p><pre class="brush: javascript noskimlinks noskimwords">// Durations are in minutesvar tasks = [  {    "name"     : "Write for Envato Tuts+",    "duration" : 120  },  {    "name"     : "Work out",    "duration" : 60  },  {    "name"     : "Procrastinate on Duolingo",    "duration" : 240  }];</pre><p>Возможно мы хотим создать новый массив только с name для каждого task, что в свою очередь позволит нам взглянуть на всё задачи, которые мы выполнили на сегодня. Используя цикл <code class="inline">for</code>, мы бы написали что-то, что выглядит следующим образом:</p><pre class="brush: javascript noskimlinks noskimwords">var task_names = [];for (var i = 0, max = tasks.length; i &lt; max; i += 1) {    task_names.push(tasks[i].name);}</pre><p>JavaScript также предоставляет нам цикл <code class="inline">forEach</code>. Он работает примерно также как и цикл <code class="inline">for</code>, но нам не нужно сравнивать индекс элемента с длинной массива, всё это делается за нас:</p><pre class="brush: plain noskimlinks noskimwords">var task_names = [];tasks.forEach(function (task) {    task_names.push(task.name);    });</pre><p>Используя <code class="inline">map</code>, мы можем написать:</p><pre class="brush: javascript noskimlinks noskimwords">var task_names = tasks.map(function (task, index, array) {    return task.name; });</pre><p>Я добавил <code class="inline">index</code> и <code class="inline">array</code> параметры, чтобы вы не забывали, что мы можем ими воспользоваться, если это необходимо. Так как в примере я их не использую, можно их убрать и код будет продолжать работать.</p><p>Есть два важных отличия между этими двумя подходами:</p><ol><li>Используя <code class="inline">map</code>, вам не придётся управлять состоянием цикла <code class="inline">for</code> самостоятельно.</li> <li>Вы можете взаимодействовать с элементами напрямую, вместо индексирования массива.</li> <li>Вам не придётся создавать новый массив и добавлять (<code class="inline">push</code>) элементы в него. <code class="inline">map</code> возвращает конечный результат за один подход, нам остаётся лишь добавить возвращаемое значение новой переменной.</li> <li>Не забывайте <em>добавить</em> <code class="inline">return</code> вашему каллбеку. Если этого не сделать, мы получим новый массив заполненный <code class="inline">undefined</code>. </li> </ol><p><em>Всё</em> функции, которые мы будем разбирать сегодня обладают теми же характеристиками.</p><p>Факт того, что нам в ручную не нужно управлять состоянием цикла, делает наш код проще и его легче поддерживать. А также факт того, что можно взаимодействовать с каждым элементом напрямую, вместо индексирования массива, делает код более читабельным. </p><p>Использование цикла <code class="inline">forEach</code> решает обе проблемы. Но у <code class="inline">map</code> всё равно есть по крайней мере два преимущества:</p><ol><li> <code class="inline">forEach</code> возвращает <code class="inline">undefined</code>, поэтому его нельзя связать с другими методами массива. <code class="inline">map</code> возвращает массив, тем самым мы <em>можем</em> связывать его с другими методами массива.</li> <li> <code class="inline">map</code> возвращает массив с конечным результатом, нам не приходится изменять массив внутри цикла. </li> </ol><p>Обладая несколькими местами где состояние модифицируется по минимуму, важный принцип функционального программирования. Код становится более безопасным и понятным.</p><p>Пришло время упомянуть, если вы используете Node, тестируете примеры в консоли браузера Firefox или используете <span>Babel</span> или <span>Traceur</span>, можно писать короткую стрелочную функцию из ES6:</p><pre class="brush: javascript noskimlinks noskimwords">var task_names = tasks.map((task) =&gt; task.name );</pre><p>Со стрелочной функцией нет необходимости использовать <code class="inline">return</code>, вся функция помещается на одной строке. </p><p>Пожалуй более читабельный результат получить нельзя.</p><h3>Подводные камни</h3><p>В каллбеке передаваемом <code class="inline">map</code> должен быть явный <code class="inline">return</code> или <code class="inline">map</code> возвратит массив заполненный <code class="inline">undefined</code>. Не так сложно запомнить что мы должны возвращать (<code class="inline">return</code>) значение, но в свою очередь можно и забыть об этом. </p><p>Если вы <em>забудете</em> об этом, <code class="inline">map</code> не покажет ошибок. Вместо этого, будет возвращён пустой массив. Такие тихие ошибки на удивление сложно искать. </p><p>К счастью данный подводный камень относится <em>только</em> к <code class="inline">map</code>. Но это часто встречаемая ошибка, на которой я должен заострить внимание: Всегда добавляйте <code class="inline">return</code> в ваши каллбеки!</p><h3>Реализация</h3><p>Изучение реализации важный шаг на пути полного понимания работы функции. Давайте напишем наш собственный, небольшой <code class="inline">map</code> для лучшего понимания, что происходит внутри. Если хотите ознакомиться с оригинальной реализацией, взгляните на <span>Mozilla полифил на MDN</span>.</p><pre class="brush: javascript noskimlinks noskimwords">var map = function (array, callback) {    var new_array = [];    array.forEach(function (element, index, array) {       new_array.push(callback(element));     });    return new_array;};var task_names = map(tasks, function (task) {    return task.name;});</pre><p>Данный код принимает массив и каллбек функцию в качестве аргументов. Затем создаётся новый массив; каллбек вызывается для каждого элемента массива, который мы передали изначально; результат добавляется в новый массив; новый массив возвращается в качестве результата. Если вы запустите код в консоли, получите тот же результат, как и прежде. Не забудьте инициализировать <code class="inline">tasks</code>, перед тем как тестировать код!</p><p>Мы используем цикл for внутри функции, детали реализации спрятаны и вместо этого мы работаем с абстракцией. </p><p>Тем самым наш код более декларативный - показывает <em>что</em> делать, а не то <em>как</em> это делать. Вы должны оценить насколько код более читабельный, простой в поддержке и <em>отладке</em> ошибок.</p><h2>Фильтрация шума</h2><p>Следующий метод, который мы рассмотрим является <code class="inline">filter</code>. Соответствуя своему названию метод берёт массив и фильтрует его, убирая ненужные элементы.</p><p>Также как и <code class="inline">map</code>, <code class="inline">filter</code> определяется в <code class="inline">Array.prototype</code>. Метод доступен для любого массива, в качестве первого аргумента передаётся каллбек. <code class="inline">filter</code> вызывает каллбек для каждого элемента массива, в результате возвращается <em>новый</em> массив, содержащий <em>только</em> элементы, для которых каллбек возвратил <code class="inline">true</code>.</p><p>Также как и <code class="inline">map</code>, <code class="inline">filter</code> передаёт каллбеку три аргумента:</p><ol><li>Текущий элемент </li> <li>Текущий индекс </li> <li><em>Массив</em>, для которого вызывается <code class="inline">filter</code></li> </ol><h3> <code class="inline">filter</code> на практике</h3><p>Давайте вернёмся к нашему приложению с задачами на день. Вместо того, чтобы получать называния каждой задачи, предположим мне нужен список задач на выполнение которых я потратил два часа. </p><p>Используя <code class="inline">forEach</code>, мы напишем:</p><pre class="brush: javascript noskimlinks noskimwords">var difficult_tasks = [];tasks.forEach(function (task) {    if (task.duration &gt;= 120) {        difficult_tasks.push(task);    }});</pre><p>С <code class="inline">filter</code>:</p><pre class="brush: javascript noskimlinks noskimwords">var difficult_tasks = tasks.filter(function (task) {    return task.duration &gt;= 120;});// Using ES6var difficult_tasks = tasks.filter((task) =&gt; task.duration &gt;= 120 );</pre><p>В коде выше я не использовал аргументы <code class="inline">index</code> и <code class="inline">array</code> для нашего каллбека, так как в них нет необходимости.</p><p>Также как и <code class="inline">map</code>, <code class="inline">filter</code> позволяет нам:</p><ul><li>Избежать мутации массива внутри <code class="inline">forEach</code> или <code class="inline">for</code> циклах</li> <li>добавить результат новой переменной, вместо передачи значений в новый массив, который мы создали ранее</li> </ul><h3>Подводные камни</h3><p>Каллбек, который вы передаёте map должен содержать <code class="inline">return</code>, если вы хотите, чтобы всё работало, так как вы задумали. С <code class="inline">filter</code>, вы также должны использовать return и <em>убедиться</em>, что он возвращает булево значение.</p><p>Если забыть о return, каллбек возвратит <code class="inline">undefined</code>, и результат <code class="inline">filter</code> всегда будет <code class="inline">false</code>. Вместо ошибки будет возвращён пустой массив! </p><p>В том случае если возвращается что-то отличное от <code class="inline">true</code> или <code class="inline">false</code>, тогда <code class="inline">filter</code> попытается решить что вы пытаетесь получить, согласно <span>правилам приведения JavaScript</span>. Скорее всего вы опять же получите ошибку. И также как и забыв return, ошибка будет на так очевидна. </p><p><em>Никогда</em> не забывайте добавлять return в каллбеки. Также для <code class="inline">filter</code> значение <em>всегда</em> должно быть <code class="inline">true</code> или <code class="inline">false</code>. Это поможет вам сохранить рассудок, в случае ошибок.</p><h3>Реализация</h3><p>Опять же лучший способ понять как работает код - написать его. Давайте создадим наш собственный <code class="inline">filter</code>. Ребята из Mozilla написали <span>полифил</span>, который мы можем изучить.</p><pre class="brush: javascript noskimlinks noskimwords">var filter = function (array, callback) {    var filtered_array = [];    array.forEach(function (element, index, array) {        if (callback(element, index, array)) {            filtered_array.push(element);            }    });    return filtered_array;};</pre><h2>Reduce массива</h2><p><code class="inline">map</code> создаёт новый массив, меняя каждый элемент массива индивидуально. <code class="inline">filter</code> создаёт новый массив убирая элементы, которые не соответствуют условиям. <code class="inline">reduce</code> в свою очередь, берёт все элементы в массиве, складывает их в новое значение.</p><p>Также как <code class="inline">map</code> и <code class="inline">filter</code>, <code class="inline">reduce</code> определяется в <code class="inline">Array.prototype</code> и также доступен для любого массива, и вы передаёте каллбек в качестве первого аргумента. Помимо этого можно передать необязательный второй аргумент: значение, индекс с которого стоит начать складывать элементы вашего массива. </p><p><code class="inline">reduce</code> передаёт каллбеку четыре аргумента:<br></p><ol><li>Текущее значение </li> <li>Предыдущее значение<em> </em> </li> <li>Текущий индекс </li> <li><em>Массив</em>, для которого вы вызываете <code class="inline">reduce</code></li> </ol><p>Обратите внимание, что каллбек имеет доступ к <em>предыдущему</em> значению на каждой итерации. На первой интерации предыдущего значения <em>нет</em>. Вот почему у вас есть выбор передать <code class="inline">reduce</code> начальное значение: данное значение и будет "предыдущим значением" при первой итерации, и как я уже упоминал в противном случае предыдущее значение будет равно нулю.</p><p>Наконец, запомните, что <code class="inline">reduce</code> возвращает одно значение, <em>не</em> массив содержащий один элемент. Это важнее, чем может показаться на первый взгляд и я вернусь к этому моменту во время разбора нашего примера.</p><h3> <code class="inline">reduce</code> на практике</h3><p>Так как <code class="inline">reduce</code> функция, которая поначалу многим может показаться слегка непонятной, мы начнём, шаг за шагом разбирать что-то более простое.<br></p><p>Давайте предположим, что мы хотим найти сумму списка чисел. Используя цикл, это будет выглядеть следующим образом:</p><pre class="brush: javascript noskimlinks noskimwords">var numbers = [1, 2, 3, 4, 5],    total = 0;    numbers.forEach(function (number) {    total += number;});</pre><p>Несмотря на то что это неплохой случай воспользоваться <code class="inline">forEach</code>, <code class="inline">reduce</code> всё равно имеет преимущество, применяя его мы избегаем мутаций. С <code class="inline">reduce</code> мы напишем следующий код:</p><pre class="brush: javascript noskimlinks noskimwords">var total = [1, 2, 3, 4, 5].reduce(function (previous, current) {    return previous + current;}, 0);</pre><p>Для начала, мы вызовем <code class="inline">reduce</code> для нашего списка чисел (<code class="inline">numbers</code>). Мы передадим его каллбеку, который принимает предыдущее значение и текущее значение в качестве аргументов и вернём результат сложения их вместе. Так как мы передали <code class="inline">0</code> в качестве второго аргумента <code class="inline">reduce</code>, 0 будет использоваться, как предыдущее (<code class="inline">previous</code>) значение при первой итерации.<br></p><p>Взглянем, как это работает шаг за шагом:</p><table><thead><tr><th>Итерация </th> <th>Предыдущее</th> <th>Текущее</th> <th>Общее</th> </tr></thead><tbody><tr><td>1</td> <td>0</td> <td>1</td> <td>1</td> </tr><tr><td>2</td> <td>1</td> <td>2</td> <td>3</td> </tr><tr><td>3</td> <td>3</td> <td>3</td> <td>6</td> </tr><tr><td>4</td> <td>6</td> <td>4</td> <td>10</td> </tr><tr><td>5</td> <td>10</td> <td>5</td> <td>15</td> </tr></tbody></table><p>Если вы не любитель таблиц, запустите этот кусочек кода в консоли:</p><pre class="brush: javascript noskimlinks noskimwords">var total = [1, 2, 3, 4, 5].reduce(function (previous, current, index) {    var val = previous + current;    console.log("The previous value is " + previous +                 "; the current value is " + current +                ", and the current iteration is " + (index + 1));    return val;}, 0);console.log("The loop is done, and the final value is " + total + ".");</pre><p>Напомню: <code class="inline">reduce</code> складывает все элементы массива на каждой интерации, комбинируя их таким образом, как вы укажете в каллбеке. При каждой итерации, каллбек имеет доступ к <em>предыдущему значению</em>, которое на данный момент равно <em>общему значению</em> или <em>аккумулированному значению</em>; также как к <em>текущему значению</em>; <em>текущему индексу</em> и <em>всему массиву</em>, если они нужны вам.</p><p>Давайте вернёмся к примеру с приложением для задач на день. Мы получили список названий задач благодаря <code class="inline">map</code> и отфильтровали список используя <code class="inline">filter</code>. </p><p>Что если вы хотите узнать общее количество времени, которое было затрачено на работу, сегодня?;</p><p>Используя цикл <code class="inline">forEach</code> решение будет выглядеть следующим образом:</p><pre class="brush: plain noskimlinks noskimwords">var total_time = 0;    tasks.forEach(function (task) {    // The plus sign just coerces     // task.duration from a String to a Number    total_time += (+task.duration);});</pre><p>Решение с <code class="inline">reduce</code>:</p><pre class="brush: plain noskimlinks noskimwords">var total_time = tasks.reduce(function (previous, current) {    return previous + current;}, 0);// Using arrow functionsvar total_time = tasks.reduce((previous, current) previous + current );</pre><p>Просто. </p><p>На этом почти всё. Почти, потому что JavaScript предоставляет малоизвестный метод, под названием <code class="inline">reduceRight</code>. В примере выше, <code class="inline">reduce</code> начинает с <em>первого</em> элемента массива, затем процесс итерации проходит слева направо:</p><pre class="brush: javascript noskimlinks noskimwords">var array_of_arrays = [[1, 2], [3, 4], [5, 6]];var concatenated = array_of_arrays.reduce( function (previous, current) {        return previous.concat(current);});console.log(concatenated); // [1, 2, 3, 4, 5, 6];</pre><p><code class="inline">reduceRight</code> делает тоже самое, но в противоположном направлении:</p><pre class="brush: plain noskimlinks noskimwords">var array_of_arrays = [[1, 2], [3, 4], [5, 6]];var concatenated = array_of_arrays.reduceRight( function (previous, current) {        return previous.concat(current);});console.log(concatenated); // [5, 6, 3, 4, 1, 2];</pre><p>Я использую <code class="inline">reduce</code> каждый день, но у меня никогда не было необходимости использовать <code class="inline">reduceRight</code>. Думаю вам он также не пригодится. Однако, на тот случай если данный метод вам понадобится, не забывайте, что он существует.</p><h3>Подводные камни</h3><p>Три огромных подводный камня с <code class="inline">reduce</code>:</p><ol><li>Забыли <code class="inline">return</code> </li> <li>Забыли начальное значение</li> <li>Ожидать, что <code class="inline">reduce</code> вернёт массив, когда он возвращает одно значение</li> </ol><p>К счастью первые два пункта легко избежать. Начальное значение зависит от того, что вы пытаетесь сделать, но вы быстро к этому привыкните.</p><p>Последний пункт может показаться немного странным. Если <code class="inline">reduce</code> возвращает одно значение, почему вы будете ждать в качестве результата массив?</p><p>На то есть две причины. Для начала, <code class="inline">reduce</code> всегда возвращает одно <em>значение</em>, не всегда это значение является <em>числом</em>. К примеру если вы обрабатываете reduce"ом массив содержащий массивы, возвратится один массив. Если у вас привычка обрабатывать reduce"ом массивы, справедливо ожидать, что массив содержащий один элемент будет исключительным случаем.</p><p>Во вторых, если <code class="inline">reduce</code> <em>возвратит</em> массив с одним единственным значением, он будет отлично взаимодействовать с <code class="inline">map</code> и <code class="inline">filter</code>, а также другими функциями массивов, которые можно использовать. </p><h3>Реализация</h3><p>Пришло время последний раз взглянуть на внутреннюю реализацию функции. Как обычно, у Mozilla есть <span>надёжный полифил для reduce</span>, на тот случай если у вас есть желание ознакомиться с ним. </p><pre class="brush: javascript noskimlinks noskimwords">var reduce = function (array, callback, initial) {    var accumulator = initial || 0;        array.forEach(function (element) {       accumulator = callback(accumulator, array[i]);    });        return accumulator;};</pre><p>Обратите внимание на две вещи:</p><ol><li>В этот раз я использовал название <code class="inline">accumulator</code> вместо <code class="inline">previous</code>. Такое часто можно встретить на практике.</li> <li>Я присвоил <code class="inline">accumulator</code> начальное значение, если пользователь предоставляет данные и значение будет равно <code class="inline">0</code>, в том случае если данных от пользователя не будет. Настоящий <code class="inline">reduce</code> работает таким же образом.</li> </ol><h2>Всё вместе: Map, Filter, Reduce и связывание</h2><p>На данный момент, возможно описанные методы кажутся не <em>такими</em> уж впечатляющими. </p><p>Довольно справедливо: <code class="inline">map</code>, <code class="inline">filter</code> и <code class="inline">reduce</code>, по одиночки не такие уж интересные. </p><p>Настоящая сила этих методов заключается в их связываемости. </p><p>Давайте предположим я хочу сделать следующее:<br></p><ol><li>Собрать все выполненные задачи за два дня.</li> <li>Сконвертировать время потраченное на выполнение задач в часы, вместо минут.</li> <li>Отфильтровать задачи, на выполнение, которых ушло два часа или больше.</li> <li>Сложить всё это.</li> <li>Умножить результат на часовую ставку.</li> <li>Показать результат в долларовом эквиваленте.</li> </ol><p>Для начала, давайте определим наши задачи на понедельник и вторник:</p><pre class="brush: javascript noskimlinks noskimwords">var monday = [        {            "name"     : "Write a tutorial",            "duration" : 180        },        {            "name"     : "Some web development",            "duration" : 120        }    ];var tuesday = [        {            "name"     : "Keep writing that tutorial",            "duration" : 240        },        {            "name"     : "Some more web development",            "duration" : 180        },        {            "name"     : "A whole lot of nothing",            "duration"  : 240        }    ];    var tasks = [monday, tuesday];</pre><p>Теперь, взглянем на эту замечательную трансформацию:</p><pre class="brush: javascript noskimlinks noskimwords">    var result = tasks.reduce(function (accumulator, current) {                        return accumulator.concat(current);                    }).map(function (task) {                        return (task.duration / 60);                    }).filter(function (duration) {                        return duration &gt;= 2;                    }).map(function (duration) {                        return duration * 25;                    }).reduce(function (accumulator, current) {                        return [(+accumulator) + (+current)];                    }).map(function (dollar_amount) {                        return "$" + dollar_amount.toFixed(2);                    }).reduce(function (formatted_dollar_amount) {                        return formatted_dollar_amount;                    });</pre><p>Или более лаконично:</p><pre class="brush: javascript noskimlinks noskimwords">                  // Concatenate our 2D array into a single listvar result = tasks.reduce((acc, current) =&gt; acc.concat(current))                  // Extract the task duration, and convert minutes to hours                  .map((task) =&gt; task.duration / 60)                  // Filter out any task that took less than two hours                  .filter((duration) =&gt; duration &gt;= 2)                  // Multiply each tasks" duration by our hourly rate                  .map((duration) =&gt; duration * 25)                  // Combine the sums into a single dollar amount                  .reduce((acc, current) =&gt; [(+acc) + (+current)])                  // Convert to a "pretty-printed" dollar amount                  .map((amount) =&gt; "$" + amount.toFixed(2))                  // Pull out the only element of the array we got from map                  .reduce((formatted_amount) =&gt;formatted_amount); </pre><p>Если вы дошли до этого места, всё должно стать очевидным. Однако есть две странные особенности, которые стоит объяснить. </p><p>Сперва, на строке 10 я написал:</p><pre class="brush: javascript noskimlinks noskimwords">// Remainder omittedreduce(function (accumulator, current) {    return [(+accumulator) + (+current_];})</pre><p>Две вещи следуют объяснить:</p><ol><li>Знак плюс перед <code class="inline">accumulator</code> и <code class="inline">current</code> конвертирует значению в число. Если этого не сделать, возвращаемое значение будет представлять из себя бесполезную строку, "<code class="inline">12410075100</code>".</li> <li>Если не обернуть сумму в квадратные скобки, <code class="inline">reduce</code> вернёт обычное значение, а <em>не</em> массив. В результате вы получите <code class="inline">TypeError</code>, так как <code class="inline">map</code> может использоваться только для массива! <br></li> </ol><p>Следующий момент, который покажется странным - последний <code class="inline">reduce</code>, а именно:</p><pre class="brush: javascript noskimlinks noskimwords">// Remainder omittedmap(function (dollar_amount) {    return "$" + dollar_amount.toFixed(2);}).reduce(function (formatted_dollar_amount) {    return formatted_dollar_amount;});</pre><p>Вызов <code class="inline">map</code> возвращает массив содержащий одно значение. Здесь мы вызываем <code class="inline">reduce</code> для получения значения.</p><p>Другой способ сделать это - убрать вызов reduce и проиндексировать массив, который получается после работы <code class="inline">map</code>:</p><pre class="brush: javascript noskimlinks noskimwords">var result = tasks.reduce(function (accumulator, current) {                    return accumulator.concat(current);                }).map(function (task) {                    return (task.duration / 60);                }).filter(function (duration) {                    return duration &gt;= 2;                }).map(function (duration) {                    return duration * 25;                }).reduce(function (accumulator, current) {                    return [(+accumulator) + (+current)];                }).map(function (dollar_amount) {                    return "$" + dollar_amount.toFixed(2);                })[0];</pre><p>Это абсолютно правильно. Если вам более комфортно использовать индекс массива, я не буду вас останавливать.</p><p>Но всё же лучше этого не делать. Лучше всего использовать эти функции в, так сказать, среде реактивного программирования, где вы можете обойтись без использования индексов массива. Данная привычка позволит вам быстрее выучить техники реактивного программирования.</p><p>Наконец, давайте посмотрим на нашего друга, как бы с этим справился цикл <code class="inline">forEach</code>:</p><pre class="brush: plain noskimlinks noskimwords">var concatenated = monday.concat(tuesday),    fees = [],    formatted_sum,    hourly_rate = 25,    total_fee = 0;concatenated.forEach(function (task) {    var duration = task.duration / 60;        if (duration &gt;= 2) {        fees.push(duration * hourly_rate);    }});fees.forEach(function (fee) {    total_fee += fee});var formatted_sum = "$" + total_fee.toFixed(2);</pre><p>Неплохо, но всё же громоздко.</p><h2>Заключение и следующие шаги</h2><p>В этом туториале вы изучили, как <code class="inline">map</code>, <code class="inline">filter</code> и <code class="inline">reduce</code> работают; как их использовать; также мы поверхностно рассмотрели, как методы реализованы. Все они позволяют избежать мутации состояния, необходимое условие для циклов <code class="inline">for</code> и <code class="inline">forEach</code> и теперь вы должны прекрасно представлять, как связать данные методы вместе. </p><p>Теперь я думаю вы ждёте не дождётесь дальнейшей практики и дополнительного чтения. Вот три отличных рекомендации куда двигаться дальше:</p><ol><li> Замечательный набор упражнения от <span>Jafar Husain</span> по <span>функциональному программированию на JavaScript</span>, в завершении которого вы найдёте вводную информацию по <span>Rx.js</span> </li> <li>Курс инструктора Envato Tuts+ <span>Jason Rhodes</span> по <span>функциональному программированию на JavaScript</span> </li> <li> <span>Самый адекватный путеводитель по функциональному программированию</span>, объясняющий на более глубоком уровне, почему следует избегать мутаций, а также о функциональном мышлении в своей основе</li> </ol><p> JavaScript стал де-факто языком для веб-разработки. Естественно процесс обучения имеет свои сложности, также как и огромный набор фреймворков и библиотек, в которых легко заблудиться. Если вы ищите дополнительные ресурсы для изучении или какой-либо инструмент для работы, обратите <span>внимание на Envato marketplace</span>.<br></p><p>Если вам понравился материал и вы хотите больше, время от времени <span>проверяйте мой профиль</span>; свяжитесь со мной на Twitter (<span>@PelekeS</span>); или посетите мой блог <span>http://peleke.me</span>. </p><p>Вопросы, комментарии или непонятные моменты? Оставляйте их ниже и я сделаю всё возможное, чтобы ответить на каждый из них индивидуально.</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824650-kak-ispolzovat-map-filter-i-reduce-v-javascript" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="JavaScript" href="https://norma-studio.github.io/article/220824650-kak-ispolzovat-map-filter-i-reduce-v-javascript" class="tm-article-body__tags-item-link">JavaScript</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
37737</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
320</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>


<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Основы метапрограммирования в Elixir
... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Основы метапрограммирования в Elixir
... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Основы метапрограммирования в Elixir
... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Основы метапрограммирования в Elixir
... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Метапрограммирование - это мощная, но довольно сложная техника, это означает, что программа может анализировать или даже модифицировать себя во время исполнения. Многие современные языки поддерживают эту функцию, а Elixir не является исключением. ...">
<meta property="og:description" content="Метапрограммирование - это мощная, но довольно сложная техника, это означает, что программа может анализировать или даже модифицировать себя во время исполнения. Многие современные языки поддерживают эту функцию, а Elixir не является исключением. ...">
<meta name="twitter:description" content="Метапрограммирование - это мощная, но довольно сложная техника, это означает, что программа может анализировать или даже модифицировать себя во время исполнения. Многие современные языки поддерживают эту функцию, а Elixir не является исключением. ...">
<meta property="aiturec:description" content="Метапрограммирование - это мощная, но довольно сложная техника, это означает, что программа может анализировать или даже модифицировать себя во время исполнения. Многие современные языки поддерживают эту функцию, а Elixir не является исключением. ...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1463/profiles/19974/profileImage/AAEAAQAAAAAAAAPnAAAAJGMwZGE5NzIzLTAxM2UtNDVjNi04YTI5LTU5NDg2Nzk2MjMwZg.jpg">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1463/profiles/19974/profileImage/AAEAAQAAAAAAAAPnAAAAJGMwZGE5NzIzLTAxM2UtNDVjNi04YTI5LTU5NDg2Nzk2MjMwZg.jpg">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1463/profiles/19974/profileImage/AAEAAQAAAAAAAAPnAAAAJGMwZGE5NzIzLTAxM2UtNDVjNi04YTI5LTU5NDg2Nzk2MjMwZg.jpg">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1463/profiles/19974/profileImage/AAEAAQAAAAAAAAPnAAAAJGMwZGE5NzIzLTAxM2UtNDVjNi04YTI5LTU5NDg2Nzk2MjMwZg.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1463/profiles/19974/profileImage/AAEAAQAAAAAAAAPnAAAAJGMwZGE5NzIzLTAxM2UtNDVjNi04YTI5LTU5NDg2Nzk2MjMwZg.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article/220824832-osnovy-metaprogrammirovaniya-v-elixir.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article/220824832-osnovy-metaprogrammirovaniya-v-elixir.html">
<link rel="canonical" href="https://norma-studio.github.io/article/220824832-osnovy-metaprogrammirovaniya-v-elixir.html">
<meta property="og:url" content="https://norma-studio.github.io/article/220824832-osnovy-metaprogrammirovaniya-v-elixir.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article/220824832-osnovy-metaprogrammirovaniya-v-elixir.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article/220824832-osnovy-metaprogrammirovaniya-v-elixir.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article/220824832-osnovy-metaprogrammirovaniya-v-elixir.html" title="Основы метапрограммирования в Elixir
... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Основы метапрограммирования в Elixir
... | envatomarket.ru | norma-studio.github.io" title="Основы метапрограммирования в Elixir
... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/64535356345.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article/220824832-osnovy-metaprogrammirovaniya-v-elixir.html" class="tm-user-info__username" title="
В. Чендылов" aria-label="
В. Чендылов">
В. Чендылов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Основы метапрограммирования в Elixir
...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824832-osnovy-metaprogrammirovaniya-v-elixir" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Elixir" href="https://norma-studio.github.io/article/220824832-osnovy-metaprogrammirovaniya-v-elixir" class="tm-article-snippet__hubs-item-link"><span>Elixir</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article/220824832-osnovy-metaprogrammirovaniya-v-elixir.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1463/profiles/19974/profileImage/AAEAAQAAAAAAAAPnAAAAJGMwZGE5NzIzLTAxM2UtNDVjNi04YTI5LTU5NDg2Nzk2MjMwZg.jpg">
    <meta itemprop="headline name" content="Основы метапрограммирования в Elixir
... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Метапрограммирование - это мощная, но довольно сложная техника, это означает, что программа может анализировать или даже модифицировать себя во время исполнения. Многие современные языки поддерживают эту функцию, а Elixir не является исключением. ...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Метапрограммирование - это мощная, но довольно сложная техника, это означает, что программа может анализировать или даже модифицировать себя во время исполнения. Многие современные языки поддерживают эту функцию, а Elixir не является исключением. ...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p><span>Метапрограммирование</span> - это мощная, но довольно сложная техника, это означает, что программа может анализировать или даже модифицировать себя во время исполнения. Многие современные языки поддерживают эту функцию, а Elixir не является исключением. </p><p>С метапрограммированием вы можете создавать новые сложные макросы, динамически определять и откладывать исполнение кода, что позволяет писать более сжатый и мощный код. Это действительно продвинутая тема, но, надеюсь, после прочтения этой статьи вы получите общее представление о том, как начать работу с метапрограммированием в Elixir.</p><p>В этой статье вы узнаете:</p><ul><li>Что такое абстрактное синтаксическое дерево и как код Elixir представлен под капотом.</li> <li>Что означают функции <code class="inline">quote</code> и <code class="inline">unquote</code>.</li> <li>Что такое макросы и как работать с ними.</li> <li>Как внедрять значения со связыванием.</li> <li>Почему макросы гигиеничны.</li> </ul><p>Прежде чем начать, позвольте мне дать вам небольшой совет. Помните, что дядя Человека-паука сказал: "С великой силой приходит большая ответственность"? Это может быть применено и к метапрограммированию, потому что это очень мощная фича, которая позволяет вам скручивать и сгибать код по своему желанию. </p><p>Тем не менее, вы не должны злоупотреблять им, и вы должны придерживаться более простых решений, когда это разумно и возможно. Слишком много метапрограммирования может сделать ваш код намного сложнее для понимания и поддержки, поэтому будьте осторожны.</p><h2>Абстрактное синтаксическое дерево и <em>Quote</em> </h2><p>Первое, что нам нужно понять, - это то, как на самом деле представлен наш Elixir код. Эти представления часто называются <span>абстрактными синтаксическими деревьями</span> (AST), но <span>официальное руководство Elixir</span> рекомендует называть их просто <em>цитируемыми выражениями</em>. </p><p>Похоже, что выражения имеют структуру в виде кортежей с тремя элементами. Но как мы можем в этом убедится? Есть функция, называемая <span><code class="inline">quote</code></span>, которая возвращает внутреннее представление для некоторого переданного кода. В принципе, он превращает код в <em>неисполненную форму</em>. Например:</p><pre class="brush: erlang noskimlinks noskimwords">quote do  1 + 2end # =&gt; {:+, [context: Elixir, import: Kernel], [1, 2]}</pre><p>Так что здесь происходит? Кортеж, возвращаемый функцией <code class="inline">quote</code>, всегда имеет следующие три элемента:</p><ol><li>Atom или другой кортеж с тем же представлением. В этом случае это атом <code class="inline">:+</code>, что означает, что мы выполняем добавление. Кстати, эта форма написания операций должна быть знакома, если вы пришли из мира Ruby.</li> <li>Список ключевых слов с метаданными. В этом примере мы видим, что модуль <code class="inline">Kernel</code> был импортирован для нас автоматически.</li> <li>Список аргументов или атом. В этом случае это список с аргументами <code class="inline">1</code> и <code class="inline">2</code>.</li> </ol><p>Конечно, представление может быть намного сложнее:</p><pre class="brush: erlang noskimlinks noskimwords">quote do  Enum.each([1,2,3], &amp;(IO.puts(&amp;1)))end # =&gt; {{:., [], [{:__aliases__, [alias: false], [:Enum]}, :each]}, [], # [[1, 2, 3], # {:&amp;, [], # [{{:., [], [{:__aliases__, [alias: false], [:IO]}, :puts]}, [], # [{:&amp;, [], [1]}]}]}]}</pre><p>С другой стороны, некоторые литералы возвращают себя во внутреннем представлении, а именно:</p><ul><li>атомы</li> <li>Числа</li> <li>числа с плавающей точкой</li> <li>списки</li> <li>сткоки</li> <li>кортежи (только с двумя элементами!)</li> </ul><p>В следующем примере мы видим, что передача атома в quote возвращает этот атом:</p><pre class="brush: erlang noskimlinks noskimwords">quote do  :hiend # =&gt; :hi</pre><p>Теперь, когда мы знаем, как код представлен под капотом, перейдем к следующему разделу и посмотрим, что такое макросы и почему выражения переведенные во внутреннее представление важны.</p><h2>Макросы</h2><p><span>Макросы</span> - это специальные формы, такие как функции, но те, которые возвращают код во внутреннем представлении. Затем этот код помещается в приложение, и его исполнение откладывается. Интересно, что макросы также не исполняют переданные им параметры, они также представлены в качестве quoted выражений. Макросы могут использоваться для создания пользовательских сложных функций, используемых во всем вашем проекте. </p><p>Однако, имейте в виду, что макросы более сложны, чем обычные функции, и в <span>официальном руководстве</span> говорится, что они должны использоваться только в при необходимости. Другими словами, если вы можете использовать функцию, не создавайте макрос, потому что таким образом ваш код становится излишне сложным и, тем более, сложнее поддерживаемым. Тем не менее, макросы имеют свои варианты использования, поэтому давайте посмотрим, как их создать.</p><p>Все начинается с вызова <code class="inline"><span>defmacro</span></code> (который фактически является макросом):</p><pre class="brush: erlang noskimlinks noskimwords">defmodule MyLib do  defmacro test(arg) do    arg |&gt; IO.inspect  endend</pre><p>Этот макрос просто принимает аргумент и печатает его.</p><p>Кроме того, стоит упомянуть, что макросы могут быть приватными, как функции. Приватные макросы можно вызывать только из модуля, где они были определены. Чтобы определить такой макрос, используйте <code class="inline"><span>defmacrop</span></code>.<br></p><p>Теперь давайте создадим отдельный модуль, который будет использоваться в качестве нашей песочницы:</p><pre class="brush: erlang noskimlinks noskimwords">defmodule Main do  require MyLib  def start! do    MyLib.test({1,2,3})  endendMain.start!</pre><p>Когда вы запустите этот код, будут напечатаны <code class="inline">{:{}, [line: 11], [1, 2, 3]}</code>, что на самом деле означает, что аргумент имеет форму внутреннего представления (unevaluated). Однако, прежде чем продолжить, позвольте мне сделать небольшую заметку.</p><h3><em>Require</em></h3><p>Почему мы создали два отдельных модуля: один для определения макроса и другой для запуска кода примера? Похоже, что мы должны сделать это так, потому что макросы обрабатываются до запуска программы. Мы также должны убедиться, что определенный макрос доступен в модуле, и это делается с помощью <code class="inline">require</code>. Эта функция, в основном, гарантирует, что данный модуль скомпилирован до текущего.</p><p>Вы можете спросить, почему мы не можем избавиться от  модуля Main? Давайте попробуем сделать это:</p><pre class="brush: erlang noskimlinks noskimwords">defmodule MyLib do  defmacro test(arg) do    arg |&gt; IO.inspect  endendMyLib.test({1,2,3})# =&gt; ** (UndefinedFunctionError) function MyLib.test/1 is undefined or private. However there is a macro with the same name and arity. Be sure to require MyLib if you intend to invoke this macro#    MyLib.test({1, 2, 3})#    (elixir) lib/code.ex:376: Code.require_file/2</pre><p>К сожалению, мы получаем сообщение о том, что функция test не найдена, хотя есть макрос с тем же именем. Это происходит потому, что модуль <code class="inline">MyLib</code> определен в той же области (и в том же файле), где мы пытаемся ее использовать. Это может показаться немного странным, но на данный момент просто помните, что для предотвращения подобных ситуаций должен быть создан отдельный модуль.</p><p>Также обратите внимание, что макросы нельзя использовать глобально: сначала вы должны импортировать или реквайрить соответствующий модуль.</p><h2> Макросы и выражения во внутреннем представлении<br></h2><p>Таким образом, мы знаем, как выражения Elixir представлены внутри и что такое макросы...  Что теперь? Итак, теперь мы можем использовать эти знания и посмотреть, как код во внутреннем представлении может быть исполнен.</p><p>Вернемся к нашим макросам. Важно знать, что <em>последним выражением</em> любого макроса считается код во внутреннем представлении, который будет исполнятся и возвращаться автоматически при вызове макроса. Мы можем переписать пример из предыдущего раздела, переместив <code class="inline">IO.inspect</code> в модуль <code class="inline">Main</code>: </p><pre class="brush: erlang noskimlinks noskimwords">defmodule MyLib do  defmacro test(arg) do    arg  endenddefmodule Main do  require MyLib  def start! do    MyLib.test({1,2,3}) |&gt; IO.inspect  endendMain.start! # =&gt; {1, 2, 3}</pre><p>Видите, что происходит? Кортеж, возвращенный макросом, не является кодом во внутреннем представлении, но исполняется! Вы можете попробовать добавить два целых числа:</p><pre class="brush: erlang noskimlinks noskimwords">MyLib.test(1 + 2) |&gt; IO.inspect # =&gt; 3</pre><p>Еще раз, код был выполнен, и было возвращено <code class="inline">3</code>. Мы даже можем попытаться использовать функцию <code class="inline">quote</code> напрямую, и последняя строка будет по-прежнему исполняться:</p><pre class="brush: erlang noskimlinks noskimwords">defmodule MyLib do  defmacro test(arg) do    arg |&gt; IO.inspect    quote do      {1,2,3}    end  endend# ...def start! do    MyLib.test(1 + 2) |&gt; IO.inspect    # =&gt; {:+, [line: 14], [1, 2]}    # {1, 2, 3}end</pre><p><code class="inline">arg</code> является кодом во внутреннем представлении (отметим, кстати, что мы даже можем видеть номер строки, где был вызван макрос), но для нас исполнялось  выражение во внутреннем представлении с кортежем <code class="inline">{1,2,3}</code>, так как это последняя строка макроса.</p><p>У нас может возникнуть соблазн попытаться использовать <code class="inline">arg</code> в математическом выражении:</p><pre class="brush: erlang noskimlinks noskimwords">  defmacro test(arg) do    quote do      arg + 1    end  end</pre><p>Но это вызовет ошибку, говорящую, что <code class="inline">arg</code> не существует. Почему так? Это потому, что <code class="inline">arg</code> буквально вставлен в строку, которую мы передаем в quote. Но вместо этого мы должны исполнить <code class="inline">arg</code>, вставить результат в строку и затем выполнить quote. Для этого нам понадобится еще одна функция, называемая <code class="inline">unquote</code>.</p><h3>Перевод кода из внутреннего представления</h3><p><span><code class="inline">unquote</code></span> - это функция, которая вводит результат исполнения кода во внутреннем представлении. Это может показаться немного странным, но на самом деле все довольно просто. Давайте возьмем предыдущий пример кода:</p><pre class="brush: erlang noskimlinks noskimwords">  defmacro test(arg) do    quote do      unquote(arg) + 1    end  end</pre><p>Теперь наша программа вернет <code class="inline">4</code>, что мы и хотели! Случается, что код, переданный в функцию <code class="inline">unquote</code>, запускается только тогда, когда выполняется код во внутреннем представлении, а не когда он сначала разбирается.</p><p>Давайте рассмотрим несколько более сложный пример. Предположим, мы хотели бы создать функцию, которая запускает некоторое выражение, если данная строка является <span>palindrome</span>. Мы могли бы написать что-то вроде этого:</p><pre class="brush: erlang noskimlinks noskimwords">  def if_palindrome_f?(str, expr) do    if str == String.reverse(str), do: expr  end</pre><p>Суффикс <code class="inline">_f</code> здесь означает, что это функция для которой позже мы создадим макрос. Однако, если мы попытаемся запустить эту функцию сейчас, текст будет распечатан, даже если строка не является палиндром:</p><pre class="brush: erlang noskimlinks noskimwords">  def start! do    MyLib.if_palindrome_f?("745", IO.puts("yes")) # =&gt; "yes"  end</pre><p>Аргументы, переданные функции, исполняются до того, как функция фактически вызывается, поэтому мы видим, что строка "yes" напечатана на экране. Это действительно не то, чего мы хотим достичь, поэтому давайте попробуем использовать макрос:</p><pre class="brush: erlang noskimlinks noskimwords">  defmacro if_palindrome?(str, expr) do    quote do      if(unquote(str) == String.reverse( unquote(str) )) do        unquote(expr)      end    end  end    # ...    MyLib.if_palindrome?("745", IO.puts("yes"))</pre><p>Здесь мы переводим код во внутреннее представление, содержащий условие <code class="inline">if</code>, и используем <code class="inline">unquote</code> внутри для оценки значений аргументов при фактическом вызове макроса. В этом примере на экран ничего не будет напечатано, что правильно!</p><h3>Инъекция значений с привязкой</h3><p>Использование <code class="inline">unquote</code> - не единственный способ вставить код во внутреннее представление. Мы также можем использовать функцию, называемую <em>binding</em>. Фактически, это просто опция, переданная функции <code class="inline">quote</code>, которая принимает список ключевых слов со всеми переменными, которые должны быть обработанны <em>только раз</em>.</p><p>Чтобы выполнить привязку, передайте <code class="inline">bind_quoted</code> в функцию <code class="inline">quote</code> следующим образом:</p><pre class="brush: erlang noskimlinks noskimwords">quote bind_quoted: [expr: expr] doend</pre><p>Это может пригодиться, если вы хотите, чтобы выражение, используемое в нескольких местах, исполнялось только один раз. Как показано в <span>этом примере</span>, мы можем создать простой макрос, который выводит строку дважды с задержкой в ​​две секунды:</p><pre class="brush: erlang noskimlinks noskimwords">defmodule MyLib do  defmacro test(arg) do    quote bind_quoted: [arg: arg] do      arg |&gt; IO.inspect      Process.sleep 2000      arg |&gt; IO.inspect    end  endend</pre><p>Теперь, если вы вызываете его, передавая системное время, две строки будут иметь тот же результат:</p><pre class="brush: erlang noskimlinks noskimwords">:os.system_time |&gt; MyLib.test# =&gt; 1547457831862272# =&gt; 1547457831862272</pre><p>Это не относится к <code class="inline">unquote</code>, потому что аргумент будет оцениваться дважды с небольшой задержкой, поэтому результаты не будут одинаковыми:</p><pre class="brush: erlang noskimlinks noskimwords">  defmacro test(arg) do    quote do      unquote(arg) |&gt; IO.inspect      Process.sleep(2000)      unquote(arg) |&gt; IO.inspect    end  end    # ...  def start! do    :os.system_time |&gt; MyLib.test    # =&gt; 1547457934011392    # =&gt; 1547457936059392  end</pre><h2>Преобразование кода во внутреннем представлении</h2><p>Иногда вы, возможно, захотите понять, как выглядит ваш  код который конвертирован во внутреннее представление, например, для его отладки. Это можно сделать, используя функцию <code class="inline"><span>to_string</span></code>:</p><pre class="brush: erlang noskimlinks noskimwords">  defmacro if_palindrome?(str, expr) do    quoted = quote do      if(unquote(str) == String.reverse( unquote(str) )) do        unquote(expr)      end    end    quoted |&gt; Macro.to_string |&gt; IO.inspect    quoted  end</pre><p>Распечатанная строка:</p><pre class="brush: plain noskimlinks noskimwords">"if(\"745\" == String.reverse(\"745\")) do\n  IO.puts(\"yes\")\nend"</pre><p>Мы видим, что переданный аргумент <code class="inline">str</code> был исполнен, и результат был вставлен прямо в код. <code class="inline">\n</code> здесь означает "новая строка".</p><p> Кроме того, мы можем расширить код во внутреннем представлении с помощью <code class="inline"><span>expand_once</span></code> и <code class="inline"><span>expand</span></code>:</p><pre class="brush: erlang noskimlinks noskimwords">  def start! do    quoted = quote do      MyLib.if_palindrome?("745", IO.puts("yes"))    end    quoted |&gt; Macro.expand_once(__ENV__) |&gt; IO.inspect  end</pre><p>Что производит:</p><pre class="brush: plain noskimlinks noskimwords">{:if, [context: MyLib, import: Kernel], [{:==, [context: MyLib, import: Kernel],   ["745",    {{:., [],      [{:__aliases__, [alias: false, counter: -576460752303423103], [:String]},       :reverse]}, [], ["745"]}]},  [do: {{:., [],     [{:__aliases__, [alias: false, counter: -576460752303423103], [:IO]},      :puts]}, [], ["yes"]}]]}</pre><p>Конечно, это представление можно вернуть обратно к строке:</p><pre class="brush: erlang noskimlinks noskimwords">quoted |&gt; Macro.expand_once(__ENV__) |&gt; Macro.to_string |&gt; IO.inspect</pre><p>Мы получим тот же результат, что и раньше:</p><pre class="brush: plain noskimlinks noskimwords">"if(\"745\" == String.reverse(\"745\")) do\n  IO.puts(\"yes\")\nend"</pre><p>Функция <code class="inline">expand</code> более сложна, так как она пытается развернуть каждый макрос в переданном коде:</p><pre class="brush: erlang noskimlinks noskimwords">quoted |&gt; Macro.expand(__ENV__) |&gt; Macro.to_string |&gt; IO.inspect</pre><p>Результатом будет:</p><pre class="brush: plain noskimlinks noskimwords">"case(\"745\" == String.reverse(\"745\")) do\n  x when x in [false, nil] -&gt;\n    nil\n  _ -&gt;\n IO.puts(\"yes\")\nend"</pre><p>Мы видим этот результат, потому что <code class="inline">if</code> на самом деле сам является макросом и полагается на оператор <code class="inline">case</code>, он также расширен.</p><p>В этих примерах <code class="inline"><span>__ENV__</span></code> - это специальная форма, которая возвращает информацию об окружающей среде, такую ​​как текущий модуль, файл, строка, переменная в текущей области и импорты.</p><h2>Макросы являются гигиеничными</h2><p>Возможно, вы слышали, что макросы на самом деле <em>гигиеничны</em>. Это означает, что они не перезаписывают какие-либо переменные за пределами их скоупа. Чтобы доказать это, добавим образец переменной, попробуйте изменить его значение в разных местах, а затем выведите его:</p><pre class="brush: erlang noskimlinks noskimwords">  defmacro if_palindrome?(str, expr) do    other_var = "if_palindrome?"    quoted = quote do      other_var = "quoted"      if(unquote(str) == String.reverse( unquote(str) )) do        unquote(expr)      end      other_var |&gt; IO.inspect    end    other_var |&gt; IO.inspect    quoted  end    # ...    def start! do    other_var = "start!"    MyLib.if_palindrome?("745", IO.puts("yes"))    other_var |&gt; IO.inspect  end</pre><p>Таким образом, <code class="inline">other_var</code> получил значение внутри функции <code class="inline">start!</code> , внутри макроса и внутри <code class="inline">quote</code>. Вы увидите следующий результат:</p><pre class="brush: erlang noskimlinks noskimwords">"if_palindrome?""quoted""start!"</pre><p>Это означает, что наши переменные независимы, и мы не вводим никаких конфликтов, используя одно и то же имя везде (хотя, конечно, было бы лучше избегать такого подхода). </p><p>Если вам действительно нужно изменить внешнюю переменную из макроса, вы можете использовать <span><code class="inline">var!</code></span> как здесь:</p><pre class="brush: erlang noskimlinks noskimwords">  defmacro if_palindrome?(str, expr) do    quoted = quote do      var!(other_var) = "quoted"      if(unquote(str) == String.reverse( unquote(str) )) do        unquote(expr)      end    end    quoted  end    # ...    def start! do    other_var = "start!"    MyLib.if_palindrome?("745", IO.puts("yes"))    other_var |&gt; IO.inspect # =&gt; "quoted"  end</pre><p>Используя <code class="inline">var!</code>, мы фактически говорим, что данная переменная не должна быть гигиеничной. Однако будьте осторожны при использовании этого подхода, поскольку вы можете потерять информацию о том, что там переписывается.</p><h2>Заключение</h2><p>В этой статье мы обсудили основы метапрограммирования на языке Elixir. Мы рассмотрели использование <code class="inline">quote</code>, <code class="inline">unquote</code>, макросов и привязок при просмотре некоторых примеров и случаев использования. На этом этапе вы готовы применить эти знания на практике и создать более сжатые и мощные программы. Помните, однако, что обычно лучше иметь понятный код, чем сжатый код, поэтому не злоупотребляйте метапрограммированием в ваших проектах.</p><p>Если вы хотите больше узнать о функциях, которые я описал, не стесняйтесь читать официальную документацию о <span>макросах</span>, <span>quote и ​​unquote</span>. Я действительно надеюсь, что эта статья дала вам хорошее введение в метапрограммирование в Elixir, которое действительно может показаться довольно сложным вначале. Во всяком случае, не бойтесь экспериментировать с этими новыми инструментами!</p><p>Я благодарю вас за то, что оставались со мной, и скоро увидимся.</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824832-osnovy-metaprogrammirovaniya-v-elixir" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Elixir" href="https://norma-studio.github.io/article/220824832-osnovy-metaprogrammirovaniya-v-elixir" class="tm-article-body__tags-item-link">Elixir</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
45117</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
494</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

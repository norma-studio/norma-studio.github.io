
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Создание многопользовательских игр сложно по нескольким причинам: они могут быть дорогими для хоста, сложны в дизайне и сложны в реализации. В этом уроке я надеюсь заняться этим последним барьером. ...">
<meta property="og:description" content="Создание многопользовательских игр сложно по нескольким причинам: они могут быть дорогими для хоста, сложны в дизайне и сложны в реализации. В этом уроке я надеюсь заняться этим последним барьером. ...">
<meta name="twitter:description" content="Создание многопользовательских игр сложно по нескольким причинам: они могут быть дорогими для хоста, сложны в дизайне и сложны в реализации. В этом уроке я надеюсь заняться этим последним барьером. ...">
<meta property="aiturec:description" content="Создание многопользовательских игр сложно по нескольким причинам: они могут быть дорогими для хоста, сложны в дизайне и сложны в реализации. В этом уроке я надеюсь заняться этим последним барьером. ...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/728/posts/23311/image/pirategame_screenshot.png">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/728/posts/23311/image/pirategame_screenshot.png">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/728/posts/23311/image/pirategame_screenshot.png">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/728/posts/23311/image/pirategame_screenshot.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/728/posts/23311/image/pirategame_screenshot.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article/220824923-sozdajte-mnogopolzovatelskuyu-igru-dlya-piratskih-shuterov-v-vashem-brauzere.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article/220824923-sozdajte-mnogopolzovatelskuyu-igru-dlya-piratskih-shuterov-v-vashem-brauzere.html">
<link rel="canonical" href="https://norma-studio.github.io/article/220824923-sozdajte-mnogopolzovatelskuyu-igru-dlya-piratskih-shuterov-v-vashem-brauzere.html">
<meta property="og:url" content="https://norma-studio.github.io/article/220824923-sozdajte-mnogopolzovatelskuyu-igru-dlya-piratskih-shuterov-v-vashem-brauzere.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article/220824923-sozdajte-mnogopolzovatelskuyu-igru-dlya-piratskih-shuterov-v-vashem-brauzere.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article/220824923-sozdajte-mnogopolzovatelskuyu-igru-dlya-piratskih-shuterov-v-vashem-brauzere.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article/220824923-sozdajte-mnogopolzovatelskuyu-igru-dlya-piratskih-shuterov-v-vashem-brauzere.html" title="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере... | envatomarket.ru | norma-studio.github.io" title="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/e_09402063.jpg" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article/220824923-sozdajte-mnogopolzovatelskuyu-igru-dlya-piratskih-shuterov-v-vashem-brauzere.html" class="tm-user-info__username" title="
А. Карпов" aria-label="
А. Карпов">
А. Карпов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824923-sozdajte-mnogopolzovatelskuyu-igru-dlya-piratskih-shuterov-v-vashem-brauzere" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Glitch" href="https://norma-studio.github.io/article/220824923-sozdajte-mnogopolzovatelskuyu-igru-dlya-piratskih-shuterov-v-vashem-brauzere" class="tm-article-snippet__hubs-item-link"><span>Glitch</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article/220824923-sozdajte-mnogopolzovatelskuyu-igru-dlya-piratskih-shuterov-v-vashem-brauzere.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/728/posts/23311/image/pirategame_screenshot.png">
    <meta itemprop="headline name" content="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Создание многопользовательских игр сложно по нескольким причинам: они могут быть дорогими для хоста, сложны в дизайне и сложны в реализации. В этом уроке я надеюсь заняться этим последним барьером. ...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Создание многопользовательских игр сложно по нескольким причинам: они могут быть дорогими для хоста, сложны в дизайне и сложны в реализации. В этом уроке я надеюсь заняться этим последним барьером. ...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Создание многопользовательских игр сложно по нескольким причинам: они могут быть дорогими для хоста, сложны в дизайне и сложны в реализации. В этом уроке я надеюсь заняться этим последним барьером. </p><p>Это предназначено для разработчиков, которые знают, как делать игры и знакомы с JavaScript, но никогда не делали многопользовательскую онлайн-игру. Как только вы закончите, вам должно быть удобно внедрять базовые сетевые компоненты в любую игру и быть в состоянии строить на ней оттуда! </p><p>Это то, что мы будем строить:</p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/728/posts/23311/image/pirategame_screenshot.png" alt="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере..." title="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере..." width="50" height="50"></figure><p><span>Вы можете попробовать живую версию игры здесь</span>! W или Up, чтобы перейти к мыши и щелкнуть, чтобы стрелять. (<em>Если никто не подключен к сети, попробуйте открыть два окна браузера на одном компьютере или один на вашем телефоне, чтобы посмотреть, как работает многопользовательский режим</em>). Если вы заинтересованы в его запуске, полный исходный код также доступен на <span>GitHub</span>.<br></p><p>Я объединил эту игру,<span> используя искусство Kenney"s Pirate Pack</span> и основную работу <span>Phaser</span>. Вы будете играть роль сетевого программиста для этого урока. Отправной точкой будет полноценная версия с одним игроком в этой игре, и ваша работа будет заключаться в том, чтобы написать сервер в Node.js, используя <span>Socket.io</span> для сетевой части. Чтобы этот учебник был управляемым, я сосредоточусь на многопользовательских частях и скрою конкретные концепции Phaser и Node.js. <br></p><p>Не нужно ничего настраивать локально, потому что мы будем делать эту игру полностью в браузере на <span>Glitch.com</span>! Glitch - отличный инструмент для создания веб-приложений, включая задний конец, базу данных и все такое. Это отлично подходит для прототипирования, обучения и сотрудничества, и я очень рад познакомить вас с этим во всем этом учебном пособии. <br></p><p>Давай погрузимся.  <br></p><h2> 1.<span class="sectionnum"> Настройка</span></h2><p>Я поставил стартовый комплект <span>на Glitch.com</span>.</p><p>Некоторые советы по быстрому интерфейсу: в любое время вы можете просмотреть предварительный просмотр своего приложения, нажав кнопку <strong>«Показать»</strong> (вверху слева).</p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/728/posts/23311/image/show_button_edited.png" alt="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере..." title="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере..." width="50" height="50"></figure><p>Вертикальная боковая панель слева содержит все файлы в вашем приложении. Чтобы изменить это приложение, вам нужно «пересоздать» его. Это создаст копию его в вашей учетной записи (или разветвит ее в git lingo). Нажмите кнопку <strong>Remix для этой</strong> кнопки. <br></p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/728/posts/23311/image/remix_button_edited.png" alt="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере..." title="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере..." width="50" height="50"></figure><p>На этом этапе вы будете редактировать приложение под анонимной учетной записью. Вы можете войти в систему (вверху справа), чтобы сохранить свою работу. <br></p><p>Теперь, прежде чем идти дальше, важно ознакомиться с кодом для игры, в которую вы пытаетесь добавить многопользовательскую игру. Взгляните на <strong>index.html.</strong> Существует три важных функции, чтобы быть в курсе: <code class="inline">pre load</code> (линия 99), <code class="inline">create </code>(линии 115), и <code class="inline">GameLoop</code> (линия 142), в дополнение к игроку объект (линия 35). <br></p><p>Если вы предпочитаете учиться, попробуйте эти проблемы, чтобы убедиться, что вы получаете суть работы игры:</p><ul><li>Сделайте мир более крупным<em> (строка 29) - отметьте, что для игрового мира есть отдельный размер мира, а размер окна - для фактического холста на странице</em>.</li> <li>Сделать ПРОБЕЛ также направленной вперед (<em>строка 53</em>). </li> <li>Измените тип корабля вашего игрока (<em>строка 129</em>). </li> <li>Сделайте пули медленнее (<em>строка 155</em>). </li> </ul><h3>Установка Socket.io </h3><p>Socket.io - это библиотека для управления связью в реальном времени в браузере с использованием <span>WebSockets</span> (в отличие от использования протокола UDP, если вы создаете многопользовательскую настольную игру). Он также имеет резервные копии, чтобы убедиться, что он все еще работает, даже если WebSockets не поддерживается. Таким образом, он заботится о протоколах обмена сообщениями и предоставляет хорошую систему сообщений на основе событий для вас. <br></p><p>Первое, что нам нужно сделать, это установить модуль Socket.io. В Glitch вы можете сделать это, перейдя в файл <strong>package.json </strong>и либо набрав требуемый модуль в зависимостях, либо щелкнув «<strong>Add package</strong>» и набрав «socket.io».</p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/728/posts/23311/image/add_package.png" alt="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере..." title="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере..." width="50" height="50"></figure><p>Это было бы подходящее время, чтобы указать журналы сервера. Нажмите кнопку «<strong>Logs</strong>» слева, чтобы открыть журнал сервера. Вы должны увидеть, что он устанавливает Socket.io вместе со всеми его зависимостями. Здесь вы увидите ошибки или вывод из кода сервера. <br></p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=846/uploads/users/728/posts/23311/image/Logs_button_complete.png" alt="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере..." title="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере..." width="50" height="50"></figure><p>Теперь нужно перейти<strong> server.js.</strong> Вот где живет ваш код сервера. Сейчас у него просто есть базовый шаблон для обслуживания нашего HTML. Добавьте эту строку вверху, чтобы включить Socket.io:</p><pre class="brush: javascript noskimlinks noskimwords">var io = require("socket.io")(http); // Make sure to put this after http has been defined</pre><p>Теперь нам также нужно включить Socket.io на клиенте, поэтому вернитесь к <strong>index.html </strong>и добавьте это вверху внутри  твой <code class="inline">"head"</code> ярлык :</p><pre class="brush: html noskimlinks noskimwords">&lt;!-- Load the Socket.io networking library --&gt;&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;</pre><p><em>Примечание. Socket.io автоматически обрабатывает обслуживание клиентской библиотеки по этому пути, поэтому эта строка работает, даже если вы не видите каталог /socket.io/ в своих папках.</em><br></p><p>Теперь Socket.io включен и готов к работе! <br></p><h2> <span class="sectionnum">2. Обнаружение и нереста игроков</span></h2><p>Нашим первым реальным шагом будет принятие соединений на сервере и появление новых игроков на клиенте. </p><h3>Принятие соединений на сервере</h3><p>В нижней части <strong>server.js</strong> добавьте этот код:</p><pre class="brush: javascript noskimlinks noskimwords">// Tell Socket.io to start accepting connectionsio.on("connection", function(socket){    console.log("New client has connected with id:",socket.id);})</pre><p>Это указывает Socket.io прослушивать любое событие <code class="inline">соединения</code>, которое автоматически запускается при подключении клиента. Он создаст новый объект<code class="inline"> гнездо  socket</code> для каждого клиента, где <code class="inline">socket.id</code> - уникальный идентификатор для этого клиента.</p><p>Чтобы убедиться, что это работает, вернитесь к клиенту (<strong>index.html</strong>) и добавьте эту строку где-нибудь в <strong>create</strong> functio</p><pre class="brush: javascript noskimlinks noskimwords">var socket = io(); // This triggers the "connection" event on the server</pre><p>Если вы запустите игру, а затем посмотрите на журнал своего сервера (нажмите кнопку «<strong>Logs</strong>»), вы увидите, что он регистрирует это событие соединения! </p><p>Теперь, когда новый игрок подключается, мы ожидаем, что они отправят нам информацию об их состоянии. В этом случае нам нужно знать, по крайней мере,<strong> х</strong>, <strong>у</strong> и <strong>угол</strong>, чтобы правильно порождать их в нужном месте. </p><p><code class="inline">Соединение</code> с событием было встроенным событием, которое Socket.io запускает для нас. Мы можем слушать любое пользовательское событие, которое мы хотим. Я собираюсь назвать своего <code class="inline">нового игрока</code>, и я ожидаю, что клиент отправит его, как только они свяжутся с информацией об их местоположении. Это будет выглядеть так:</p><pre class="brush: javascript noskimlinks noskimwords">// Tell Socket.io to start accepting connectionsio.on("connection", function(socket){    console.log("New client has connected with id:",socket.id);    socket.on("new-player",function(state_data){ // Listen for new-player event on this client       console.log("New player has state:",state_data);    })})</pre><p>Вы не увидите ничего в журнале сервера, если вы запустите это. Это связано с тем, что мы еще не сказали клиенту выпустить это событие <code class="inline">нового игрока</code>. Но давайте притворимся, что на это позаботились, и продолжайте идти по серверу. Что должно произойти после того, как мы получим местоположение нового игрока, который присоединился? <br></p><p>Мы могли бы отправить сообщение каждому <em>подключенному игроку</em>, чтобы сообщить им, что к нему присоединился новый игрок. Socket.io предоставляет удобную функцию для этого:</p><pre class="brush: javascript noskimlinks noskimwords">socket.broadcast.emit("create-player",state_data);</pre><p>Вызов <code class="inline">socket.emit</code> просто отправит сообщение обратно одному клиенту. Вызов <code class="inline">socket.broadcast.emit </code>отправляет его каждому клиенту, подключенному к серверу, за исключением того, что он вызван одним сокетом. <br></p><p>Использование <code class="inline">io.emit </code>отправит сообщение каждому клиенту, подключенному к серверу, без каких-либо исключений. Мы не хотим делать это с нашей текущей настройкой, потому что, если вы получили сообщение с сервера с просьбой создать свой собственный корабль, будет дубликат спрайта, поскольку мы уже создаем корабль собственного игрока, когда игра начнется. <span>Вот удобная версия </span>для различных функций обмена сообщениями, которые мы будем использовать в этом уроке. </p><p>Код сервера теперь должен выглядеть так:</p><pre class="brush: javascript noskimlinks noskimwords">// Tell Socket.io to start accepting connectionsio.on("connection", function(socket){    console.log("New client has connected with id:",socket.id);    socket.on("new-player",function(state_data){ // Listen for new-player event on this client       console.log("New player has state:",state_data);      socket.broadcast.emit("create-player",state_data);    })})</pre><p>Поэтому каждый раз, когда игрок подключается, мы ожидаем, что они отправят нам сообщение с данными о местоположении, и мы отправим эти данные обратно всем другим игрокам, чтобы они могли породить этот спрайт.<br></p><h3>Нерест на клиенте<br></h3><p>Теперь, чтобы завершить этот цикл, мы знаем, что нам нужно сделать две вещи на клиенте:</p><ol><li>Извлеките сообщение с нашими данными о местоположении после подключения.</li> <li>Прослушай результат <code class="inline">создания игрока</code>  и вызывай игрока в этом месте.<br></li> </ol><p>Для первой задачи после создания игрока в нашей <strong>create </strong>функции  (вокруг строки 135) мы можем отправить сообщение, содержащее данные местоположения, которые мы хотим отправить следующим образом:</p><pre class="brush: javascript noskimlinks noskimwords">socket.emit("new-player",{x:player.sprite.x,y:player.sprite.y,angle:player.sprite.rotation})</pre><p>Вам не нужно беспокоиться о сериализации данных, которые вы отправляете. Вы можете передать любой объект, и Socket.io обработает его для вас. </p><p>Прежде чем двигаться вперед, <em>проверьте, что это работает</em>. Вы должны увидеть сообщение в журналах сервера, в котором говорится:</p><pre class="brush: bash noskimlinks noskimwords">New player has state: { x: 728.8180247836519, y: 261.9979387913289, angle: 0 }</pre><p>Мы знаем, что наш сервер получает наше объявление о подключении нового игрока, а также правильное получение данных о местоположении! </p><p>Затем мы хотим прослушать запрос на создание нового игрока. Мы можем разместить этот код сразу после нашего испускания, и он должен выглядеть примерно так:</p><pre class="brush: javascript noskimlinks noskimwords">socket.on("create-player",function(state){  // CreateShip is a function I"ve already defined to create and return a sprite   CreateShip(1,state.x,state.y,state.angle)})</pre><p><em>Теперь проверьте это. Откройте два окна вашей игры и посмотрите, работает ли это.</em></p><p>Вы должны увидеть, что после открытия двух клиентов первый клиент будет иметь два порожденных корабля, а второй - только один. <br></p><blockquote>Задача: можете ли вы понять, почему это происходит? Или как вы можете это исправить? Выполните описанную нами клиентскую / серверную логику и попытайтесь ее отладить.<br></blockquote><p>Надеюсь, у вас был шанс подумать об этом сами! Что происходит, когда первый игрок подключился, сервер отправил событие для создателя для каждого <code class="inline">другого игрока</code>, но другого игрока не было, чтобы его получить. Как только второй игрок подключается, сервер снова отправляет свою трансляцию, а игрок 1 получает ее и правильно порождает спрайт, в то время как игрок 2 пропускает начальную передачу соединения 1 игрока. </p><p>Таким образом, проблема происходит, потому что игрок 2 присоединяется к концу игры и должен знать состояние игры. Нам нужно сообщить любому новому игроку, который соединяет то, что уже существует (или то, что уже произошло в мире игроков), чтобы они могли догнать. Прежде чем мы перейдем к этому, у меня есть краткое предупреждение.</p><h3>Предупреждение о синхронизации состояния игры</h3><p>Существует два подхода к синхронизации игры каждого игрока. Первый из них заключается в том, чтобы отправлять минимальный объем информации о том, что было изменено по сети. Поэтому каждый раз, когда подключается новый игрок,вы отправляете только информацию для этого нового игрока всем другим игрокам (и отправляете нового игрока список всех других игроков в мире), а когда они отключаются, вы сообщаете всем другим игрокам, что этот отдельный клиент отключился.</p><p> Второй подход - отправить все состояние игры. В этом случае вы просто отправляете полный список всех игроков каждому при каждом подключении или отключении.<br></p><p>Первый из них лучше в том смысле, что он сводит к минимуму информацию, передаваемую по сети, но может быть очень сложной и имеет риск выхода игроков из синхронизации. Второй гарантирует, что игроки всегда будут синхронизироваться, но вовлекают отправку большего количества данных с каждым сообщением.</p><p>В нашем случае вместо попыток отправить сообщения, когда новый игрок подключился к их созданию, когда они отключились, чтобы удалить их, и когда они переместились для обновления своей позиции, мы можем объединить все это в одно событие <code class="inline">обновления</code> , Это событие обновления всегда отправляет позиции каждого доступного игрока всем клиентам. Это все, что нужно сделать серверу. Затем клиент отвечает за поддержание своего мира в состоянии, которое он получает. </p><p> Чтобы реализовать это, я буду:</p><ol><li>Держите словарь игроков, причем ключ является их идентификатором, а значение - их данными о местоположении.</li> <li>Добавьте игрока в этот словарь, когда они подключаются и отправляют событие обновления.</li> <li>Извлеките плеер из этого словаря, когда они отсоединяют и отправляют событие обновления. <br></li> </ol><p>Вы можете попытаться реализовать это самостоятельно, поскольку эти шаги довольно просты (<span>обманщик</span> может пригодиться). Вот как выглядит полная реализация:<br></p><pre class="brush: javascript noskimlinks noskimwords">// Tell Socket.io to start accepting connections// 1 - Keep a dictionary of all the players as key/value var players = {};io.on("connection", function(socket){    console.log("New client has connected with id:",socket.id);    socket.on("new-player",function(state_data){ // Listen for new-player event on this client       console.log("New player has state:",state_data);      // 2 - Add the new player to the dict      players[socket.id] = state_data;      // Send an update event      io.emit("update-players",players);    })    socket.on("disconnect",function(){      // 3- Delete from dict on disconnect      delete players[socket.id];      // Send an update event     })})</pre><p>Клиентская сторона немного сложнее. С одной стороны, нам нужно только беспокоиться о событии <code class="inline">update-players</code>, но, с другой стороны, мы должны учитывать создание большего количества кораблей, если сервер отправляет нам больше кораблей, чем мы знаем, или уничтожаем, если у нас слишком много , <br></p><p>Вот как я обработал это событие на клиенте:</p><pre class="brush: javascript noskimlinks noskimwords">// Listen for other players connecting// NOTE: You must have other_players = {} defined somewhere socket.on("update-players",function(players_data){    var players_found = {};    // Loop over all the player data received    for(var id in players_data){        // If the player hasn"t been created yet        if(other_players[id] == undefined &amp;&amp; id != socket.id){ // Make sure you don"t create yourself            var data = players_data[id];            var p = CreateShip(1,data.x,data.y,data.angle);            other_players[id] = p;            console.log("Created new player at (" + data.x + ", " + data.y + ")");        }        players_found[id] = true;                // Update positions of other players         if(id != socket.id){          other_players[id].x  = players_data[id].x; // Update target, not actual position, so we can interpolate          other_players[id].y  = players_data[id].y;          other_players[id].rotation  = players_data[id].angle;        }                    }    // Check if a player is missing and delete them     for(var id in other_players){        if(!players_found[id]){            other_players[id].destroy();            delete other_players[id];        }    }   })</pre><p>Я отслеживаю корабли на клиенте в словаре под названием <code class="inline">other_players</code>, который я просто определил в верхней части моего сценария (не показано здесь). Поскольку сервер отправляет данные игрока всем игрокам, я должен добавить чек, чтобы клиент не создавал дополнительный спрайт для себя. (Если у вас возникли проблемы с структурированием этого, <span>вот полный код, который должен быть в index.html</span> на данный момент).</p><p><em>Теперь проверьте это</em>. Вы должны иметь возможность создавать и закрывать несколько клиентов и видеть правильное количество нереста кораблей в правильных положениях! <br></p><h2> <span class="sectionnum">3. Синхронизация позиций кораблей</span><br></h2><p>Здесь мы добираемся до действительно веселой части. Мы хотим фактически синхронизировать позиции кораблей со всеми клиентами. Именно здесь на самом деле демонстрируется простота структуры, которую мы создали. У нас уже есть событие обновления, которое может синхронизировать местоположение каждого пользователя. Все, что нам нужно сделать сейчас, это:</p><ol><li>Заставляйте клиента излучать каждый раз, когда они перемещаются с новым местоположением. <br></li> <li>Сделайте сервер прослушиванием этого сообщения и обновите запись этого игрока в словаре <code class="inline">игроков</code>. <br></li> <li>Выполните обновление для всех клиентов. <br></li> </ol><p>И это должно быть! Теперь ваша очередь попытаться реализовать это самостоятельно. <br></p><p> Если вы полностью застряли и вам нужен намек, вы можете посмотреть <span>окончательный завершенный проект</span> в качестве ссылки.</p><h3>Примечание по минимизации сетевых данных</h3><p><em>Самый простой способ реализовать это - обновить всех игроков новыми местами каждый раз, когда вы получаете сообщение о движении от любого игрока.</em> Это здорово, что игроки всегда получат самую последнюю информацию, как только она будет доступна, но количество сообщений, отправленных по сети, может легко вырасти до сотен на кадр. Представьте себе, что у вас было 10 игроков, каждый из которых отправил сообщение о движении каждого кадра, которое затем сервер должен передать всем 10 игрокам. Это уже 100 сообщений за кадр!</p><p> Лучшим способом сделать это может быть ждать, пока сервер не получит все сообщения от игроков, прежде чем отправлять большое обновление, содержащее всю информацию, всем игрокам. Таким образом вы раздавите количество сообщений, которые вы отправляете, до количества игроков, которые у вас есть в игре (в отличие от квадрата этого номера). Проблема с этим, однако, в том, что каждый будет испытывать такое же отставание, как и игрок с самым медленным соединением в игре. </p><p>Другой способ сделать это - просто отправить серверу обновления с постоянной скоростью, независимо от того, сколько сообщений он получил от игроков. Наличие обновления сервера примерно в 30 раз в секунду кажется общим стандартом. <br></p><p>Однако вы решили структурировать свой сервер, помните о том, сколько сообщений вы отправляете на каждый строение на раннем этапе по мере развития своей игры. <br></p><h2> 4. Синхронизация пуль</h2><p>Мы почти там! Последней большой частью будет синхронизация пули по сети. Мы могли бы сделать это так же, как мы синхронизировали игроков:</p><ul><li>Каждый клиент отправляет позиции всех своих пуль каждый кадр.</li> <li>Сервер передает это каждому игроку.</li> </ul><p>Но есть проблема.</p><h3>Защита от читов<br></h3><p>Если вы передаете то, что клиент отправляет вам в качестве истинной позиции пуль, тогда игрок может обмануть, изменив своего клиента, чтобы отправить вам поддельные данные, например, пули, которые телепортируются туда, где находятся другие корабли. Вы можете легко попробовать это, загрузив веб-страницу, изменив JavaScript и снова запустив ее. Это не просто проблема для игр, сделанных для браузера. В общем, вы никогда не сможете доверять данным, поступающим от клиента. </p><p>Чтобы смягчить это, мы попробуем другую схему:</p><ul><li>Клиент испускает всякий раз, когда они запускают пулю с указанием местоположения и направления.</li> <li>Сервер имитирует движение пуль.<br></li> <li>Сервер обновляет каждый клиент с указанием местоположения всех пуль.</li> <li>Клиенты выдают маркеры в местах, полученных сервером.</li> </ul><p>Таким образом, клиент отвечает за то, где появляется пуля, но не то, как быстро она движется, или где она идет после этого. Клиент может изменить расположение маркеров в своем собственном представлении, но они не могут изменить то, что видят другие клиенты. </p><p>Теперь, чтобы реализовать это, я добавлю, когда вы стреляете. Я больше не буду создавать фактический спрайт, так как его существование и местоположение теперь полностью определяются сервером. Теперь наш новый код стрельбы в файле <strong>index.html</strong> должен выглядеть так:<br></p><pre class="brush: javascript noskimlinks noskimwords">// Shoot bullet if(game.input.activePointer.leftButton.isDown &amp;&amp; !this.shot){    var speed_x = Math.cos(this.sprite.rotation + Math.PI/2) * 20;    var speed_y = Math.sin(this.sprite.rotation + Math.PI/2) * 20;    /* The server is now simulating the bullets, clients are just rendering bullet locations, so no need to do this anymore    var bullet = {};    bullet.speed_x = speed_x;    bullet.speed_y = speed_y;    bullet.sprite = game.add.sprite(this.sprite.x + bullet.speed_x,this.sprite.y + bullet.speed_y,"bullet");    bullet_array.push(bullet);     */    this.shot = true;    // Tell the server we shot a bullet     socket.emit("shoot-bullet",{x:this.sprite.x,y:this.sprite.y,angle:this.sprite.rotation,speed_x:speed_x,speed_y:speed_y})}</pre><p>Вы также можете прокомментировать весь этот раздел, который обновляет маркеры на клиенте:</p><pre class="brush: javascript noskimlinks noskimwords">/* We"re updating the bullets on the server, so we don"t need to do this on the client anymore // Update bullets for(var i=0;i&lt;bullet_array.length;i++){    var bullet = bullet_array[i];    bullet.sprite.x += bullet.speed_x;     bullet.sprite.y += bullet.speed_y;     // Remove if it goes too far off screen     if(bullet.sprite.x &lt; -10 || bullet.sprite.x &gt; WORLD_SIZE.w || bullet.sprite.y &lt; -10 || bullet.sprite.y &gt; WORLD_SIZE.h){        bullet.sprite.destroy();        bullet_array.splice(i,1);        i--;    }} */</pre><p>Наконец, нам нужно заставить клиента прослушивать обновления пули. Я решил обработать это так же, как и с игроками, где сервер просто отправляет массив всех мест маркеров в событие с именем <code class="inline">bullets-update</code>, и клиент будет создавать или уничтожать патроны для синхронизации. Вот что это выглядит:</p><pre class="brush: javascript noskimlinks noskimwords">// Listen for bullet update events socket.on("bullets-update",function(server_bullet_array){  // If there"s not enough bullets on the client, create them for(var i=0;i&lt;server_bullet_array.length;i++){      if(bullet_array[i] == undefined){          bullet_array[i] = game.add.sprite(server_bullet_array[i].x,server_bullet_array[i].y,"bullet");      } else {          //Otherwise, just update it!           bullet_array[i].x = server_bullet_array[i].x;           bullet_array[i].y = server_bullet_array[i].y;      }  }  // Otherwise if there"s too many, delete the extra   for(var i=server_bullet_array.length;i&lt;bullet_array.length;i++){       bullet_array[i].destroy();       bullet_array.splice(i,1);       i--;   }                                  })</pre><p>Это должно быть все на клиенте. Я предполагаю, что вы знаете, где положить эти фрагменты и как собрать все вместе в этот момент, но если вы столкнулись с какими-либо проблемами, помните, что вы всегда можете взглянуть на <span>конечный результат</span> для справки.</p><p>Теперь, на server.js, нам нужно отслеживать и моделировать пули. Во-первых, мы создаем массив для отслеживания пуль, точно так же, как и у игроков:</p><pre class="brush: javascript noskimlinks noskimwords">var bullet_array = []; // Keeps track of all the bullets to update them on the server </pre><p>Затем мы слушаем событие нашей стрелялки:</p><pre class="brush: javascript noskimlinks noskimwords">// Listen for shoot-bullet events and add it to our bullet array  socket.on("shoot-bullet",function(data){    if(players[socket.id] == undefined) return;    var new_bullet = data;    data.owner_id = socket.id; // Attach id of the player to the bullet     bullet_array.push(new_bullet);  });</pre><p>Теперь мы моделируем пули 60 раз в секунду:</p><pre class="brush: javascript noskimlinks noskimwords">// Update the bullets 60 times per frame and send updates function ServerGameLoop(){  for(var i=0;i&lt;bullet_array.length;i++){    var bullet = bullet_array[i];    bullet.x += bullet.speed_x;     bullet.y += bullet.speed_y;         // Remove if it goes too far off screen     if(bullet.x &lt; -10 || bullet.x &gt; 1000 || bullet.y &lt; -10 || bullet.y &gt; 1000){        bullet_array.splice(i,1);        i--;    }          }  }setInterval(ServerGameLoop, 16); </pre><p>И последний шаг - отправить событие обновления где-нибудь внутри этой функции (но определенно вне цикла for):</p><pre class="brush: javascript noskimlinks noskimwords">// Tell everyone where all the bullets are by sending the whole array  io.emit("bullets-update",bullet_array);</pre><p>Теперь вы можете проверить его! Если все пойдет хорошо, вы должны увидеть, что пули синхронизируются по клиентам правильно. Тот факт, что мы сделали это на сервере, - больше работы, но также дает нам намного больше контроля. Например, когда мы получаем событие выстрела, мы можем проверить, что скорость пули находится в определенном диапазоне, иначе мы знаем, что этот игрок обманывает. <br></p><h2> <span class="sectionnum">5. Булевое столкновение</span></h2><p>Это последний основной механик, который мы реализуем. Надеюсь, к настоящему времени вы привыкли к процедуре планирования нашей реализации, полностью завершая реализацию клиента, прежде чем переходить на сервер (или наоборот). Это гораздо менее подверженный ошибкам способ, чем переход туда и обратно по мере его реализации.</p><p>Проверка на столкновение - важнейший игровой механик, поэтому мы хотели бы, чтобы он был чит-доказательством. Мы реализуем его на сервере тем же, что и для пули. Нам нужно:</p><ul><li>Проверьте, достаточно ли пуля достаточно для любого игрока на сервере.</li> <li>Выпускайте событие для всех клиентов всякий раз, когда попадает определенный игрок.<br></li> <li>Попросите клиента прослушать событие хита и заставить корабль мигать при ударе.</li> </ul><p>Вы можете попробовать сделать это полностью самостоятельно. Чтобы заставить игрока мигать при ударе, просто установите их альфа в 0:</p><pre class="brush: javascript noskimlinks noskimwords">player.sprite.alpha = 0;</pre><p>И это снова облегчит полную альфа-версию (это делается в обновлении плеера). Для других игроков вы сделали бы аналогичную вещь, но вам придется позаботиться о том, чтобы вернуть их альфу обратно к чему-то вроде этого в функции обновления:</p><pre class="brush: javascript noskimlinks noskimwords">for(var id in other_players){ if(other_players[id].alpha &lt; 1){        other_players[id].alpha += (1 - other_players[id].alpha) * 0.16;    } else {        other_players[id].alpha = 1;    }}</pre><p> Единственная сложная часть, которую вам, возможно, придется обработать, - убедиться, что собственная пуля игрока не может поразить их (иначе вы всегда можете попасть с вашей собственной пулей каждый раз, когда стреляете). <br></p><p>Единственная сложная часть, которую вам, возможно, придется обработать, - убедиться, что собственная пуля игрока не может поразить их (иначе вы всегда можете попасть с вашей собственной пулей каждый раз, когда стреляете). <br></p><h2> <span class="sectionnum">6. Более плавное движение</span></h2><p>Если бы вы выполнили все шаги до этого момента, я хотел бы поздравить вас. Вы только что создали многопользовательскую игру! Идите вперед, отправьте его другу и понаблюдайте за волшебством онлайн-игроков, объединяющих многопользовательские игры! <br></p><p>Игра полностью функциональна, но наша работа здесь не прекращается. Есть несколько проблем, которые могут повлиять на опыт игрока, который нам необходимо решить:</p><ul><li>Движение других игроков будет выглядеть очень изменчивым, если у всех не будет быстрого соединения.</li> <li>Пули могут чувствовать себя невосприимчивыми, так как пуля не срабатывает немедленно. Он ожидает сообщения с сервера до его появления на экране клиента.</li> </ul><p>Мы можем исправить первый, путем интерполяции данных о местоположении для кораблей на клиенте. Поэтому, даже если мы не получим обновлений достаточно быстро, мы можем плавно перемещать корабль туда, где он должен быть, а не телепортировать его туда. </p><p>Пули потребуют немного более изощренности. Мы хотим, чтобы сервер управлял пулями, потому что таким образом он чит-доказательство, но мы также хотим иметь немедленную обратную связь о стрельбе пулей и наблюдении за ее стрельбой. Лучший способ - это гибридный подход. И сервер, и клиент могут имитировать маркеры, а сервер по-прежнему отправляет обновления позиции пули. Если они не синхронизированы, предположите, что сервер прав, и переопределите позицию пули клиента. </p><p>Реализация пулевой системы, описанной выше, выходит за рамки этого руководства, но хорошо знать, что этот метод существует. <br></p><p>Простая интерполяция для позиций кораблей очень проста. Вместо того, чтобы устанавливать позицию непосредственно в событии обновления, где мы сначала получаем новые данные позиции, мы просто сохраняем целевую позицию:</p><pre class="brush: javascript noskimlinks noskimwords">// Update positions of other players if(id != socket.id){  other_players[id].target_x  = players_data[id].x; // Update target, not actual position, so we can interpolate  other_players[id].target_y  = players_data[id].y;  other_players[id].target_rotation  = players_data[id].angle;}</pre><p>Затем внутри нашей функции обновления (все еще на клиенте) мы перебираем всех других игроков и нажимаем их на эту цель:</p><pre class="brush: javascript noskimlinks noskimwords">// Interpolate all players to where they should be for(var id in other_players){    var p = other_players[id];    if(p.target_x != undefined){        p.x += (p.target_x - p.x) * 0.16;        p.y += (p.target_y - p.y) * 0.16;        // Interpolate angle while avoiding the positive/negative issue         var angle = p.target_rotation;        var dir = (angle - p.rotation) / (Math.PI * 2);        dir -= Math.round(dir);        dir = dir * Math.PI * 2;        p.rotation += dir * 0.16;    }}</pre><p>Таким образом, ваш сервер может отправлять вам обновления 30 раз в секунду, но все равно играть в игру со скоростью 60 кадров в секунду, и это будет выглядеть гладко!<br></p><h2>Заключение</h2><p>Уф! Мы просто постигли многое. Мы просто рассмотрим, как отправлять сообщения между клиентом и сервером, и как синхронизировать состояние игры, передавая серверу всем своим игрокам. Это самый простой способ создать многопользовательский онлайн-опыт. </p><p>Мы также увидели, как вы можете защитить свою игру от обмана путем моделирования важных частей на сервере и информирования клиентов о результатах. Чем меньше вы доверяете своему клиенту, тем безопаснее будет игра. <br></p><p>Наконец, мы увидели, как преодолеть отставание путем интерполяции на клиенте. Компенсация лагерей является широкой темой и имеет решающее значение (некоторые игры просто становятся неиграбельными с достаточно высоким запаздыванием). Интерполяция при ожидании следующего обновления с сервера - это лишь один из способов смягчения этого. Другой способ - попытаться заранее предсказать следующие несколько кадров и исправить, как только вы получите фактические данные с сервера, но, конечно, это может быть очень сложно. <br></p><p>Совершенно другой способ смягчить влияние отставания - это просто спроектировать вокруг него. Преимущество того, что корабли медленно поворачиваются, чтобы двигаться, действует как уникальный механик движения, а также способ предотвратить внезапные изменения в движении. Таким образом, даже при медленном соединении, это все равно не испортит опыт. Учет отставания при разработке основных элементов вашей игры, как это, может иметь огромное значение. Иногда лучшие решения не являются техническими. <br></p><p>Одна из последних особенностей Glitch, которую вы можете найти полезной, заключается в том, что вы можете загружать или экспортировать свой проект, перейдя в расширенные настройки в левом верхнем углу:</p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=848/uploads/users/728/posts/23311/image/Download_project.png" alt="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере..." title="Создайте многопользовательскую игру для пиратских шутеров: в вашем браузере..." width="50" height="50"></figure><p>Если вы сделаете что-нибудь классное, пожалуйста, поделитесь им в комментариях ниже! Или, если у вас есть какие-либо вопросы или разъяснения о чем-либо, я был бы более чем счастлив помочь. </p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824923-sozdajte-mnogopolzovatelskuyu-igru-dlya-piratskih-shuterov-v-vashem-brauzere" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Glitch" href="https://norma-studio.github.io/article/220824923-sozdajte-mnogopolzovatelskuyu-igru-dlya-piratskih-shuterov-v-vashem-brauzere" class="tm-article-body__tags-item-link">Glitch</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
34803</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
503</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

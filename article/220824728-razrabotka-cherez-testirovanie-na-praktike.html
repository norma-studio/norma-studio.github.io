
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Разработка через тестирование на практике... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Разработка через тестирование на практике... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Разработка через тестирование на практике... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Разработка через тестирование на практике... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Разработка через тестирование (test-driven development,-TDD) просто означает, что вы сначала пишете свои тесты. Вы заранее создаете ожидания для правильного кода, прежде чем вы даже напишите хотя бы одну строку бизнес-логики. TDD не только помогает убедиться, что ваш код правильно работает, но он также помогает писать меньше по размеру функции, зан...">
<meta property="og:description" content="Разработка через тестирование (test-driven development,-TDD) просто означает, что вы сначала пишете свои тесты. Вы заранее создаете ожидания для правильного кода, прежде чем вы даже напишите хотя бы одну строку бизнес-логики. TDD не только помогает убедиться, что ваш код правильно работает, но он также помогает писать меньше по размеру функции, зан...">
<meta name="twitter:description" content="Разработка через тестирование (test-driven development,-TDD) просто означает, что вы сначала пишете свои тесты. Вы заранее создаете ожидания для правильного кода, прежде чем вы даже напишите хотя бы одну строку бизнес-логики. TDD не только помогает убедиться, что ваш код правильно работает, но он также помогает писать меньше по размеру функции, зан...">
<meta property="aiturec:description" content="Разработка через тестирование (test-driven development,-TDD) просто означает, что вы сначала пишете свои тесты. Вы заранее создаете ожидания для правильного кода, прежде чем вы даже напишите хотя бы одну строку бизнес-логики. TDD не только помогает убедиться, что ваш код правильно работает, но он также помогает писать меньше по размеру функции, зан...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1896/profiles/20411/profileImage/avatar.jpeg">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1896/profiles/20411/profileImage/avatar.jpeg">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1896/profiles/20411/profileImage/avatar.jpeg">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1896/profiles/20411/profileImage/avatar.jpeg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1896/profiles/20411/profileImage/avatar.jpeg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article/220824728-razrabotka-cherez-testirovanie-na-praktike.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article/220824728-razrabotka-cherez-testirovanie-na-praktike.html">
<link rel="canonical" href="https://norma-studio.github.io/article/220824728-razrabotka-cherez-testirovanie-na-praktike.html">
<meta property="og:url" content="https://norma-studio.github.io/article/220824728-razrabotka-cherez-testirovanie-na-praktike.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article/220824728-razrabotka-cherez-testirovanie-na-praktike.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article/220824728-razrabotka-cherez-testirovanie-na-praktike.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article/220824728-razrabotka-cherez-testirovanie-na-praktike.html" title="Разработка через тестирование на практике... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Разработка через тестирование на практике... | envatomarket.ru | norma-studio.github.io" title="Разработка через тестирование на практике... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/64533jghfdd.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article/220824728-razrabotka-cherez-testirovanie-na-praktike.html" class="tm-user-info__username" title="
Д. Слесарев" aria-label="
Д. Слесарев">
Д. Слесарев</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Разработка через тестирование на практике...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824728-razrabotka-cherez-testirovanie-na-praktike" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="TDD" href="https://norma-studio.github.io/article/220824728-razrabotka-cherez-testirovanie-na-praktike" class="tm-article-snippet__hubs-item-link"><span>TDD</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article/220824728-razrabotka-cherez-testirovanie-na-praktike.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1896/profiles/20411/profileImage/avatar.jpeg">
    <meta itemprop="headline name" content="Разработка через тестирование на практике... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Разработка через тестирование (test-driven development,-TDD) просто означает, что вы сначала пишете свои тесты. Вы заранее создаете ожидания для правильного кода, прежде чем вы даже напишите хотя бы одну строку бизнес-логики. TDD не только помогает убедиться, что ваш код правильно работает, но он также помогает писать меньше по размеру функции, зан...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Разработка через тестирование (test-driven development,-TDD) просто означает, что вы сначала пишете свои тесты. Вы заранее создаете ожидания для правильного кода, прежде чем вы даже напишите хотя бы одну строку бизнес-логики. TDD не только помогает убедиться, что ваш код правильно работает, но он также помогает писать меньше по размеру функции, зан...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<h2>Что такое разработка через тестирование?</h2><p>Разработка через тестирование (test-driven development, TDD) просто означает, что вы сначала пишете свои тесты. Вы заранее создаете ожидания для правильного кода, прежде чем вы даже напишите хотя бы одну строку бизнес-логики. TDD не только помогает убедиться, что ваш код правильно работает, но он также помогает писать меньше по размеру функции, заниматься рефакторингом кода без нарушения функциональности, а также лучше понять вашу проблему. </p><p>В этой статье я расскажу о некоторых концепциях TDD, создав небольшую утилиту. Мы также рассмотрим некоторые практические сценарии, в которых TDD сделает вашу жизнь простой.</p><h2>Построение HTTP-клиента с TDD</h2><h3>Что мы будем создавать</h3><p>Мы будем пошагово создавать простой HTTP-клиент, который абстрагирует различные HTTP-методы. Чтобы сделать рефакторинг гладким, мы будем следовать методам TDD. Для тестирования мы будем использовать Jasmine, Sinon и Karma. Для начала работы скопируйте файл <span>package.json</span>, <span>karma.conf.js</span> и <span>webpack.test.js</span> из примера проекта, либо просто склонируйте пример проекта из репозитория на GitHub. </p><p>Будет легче, если вы понимаете, как работает новый <span>API Fetch</span>, но примерам должны быть легкие для понимания. Для тех, кто не работал с API Fetch, XMLHttpRequest — лучшая альтернатива ему. Он упрощает взаимодействие с сетью и хорошо работает с промисами. </p><h3>Обертка над GET<br></h3><p>Сначала создайте пустой файл в <strong>src/http.js</strong> и соответствующий тестовый файл <strong>src/__tests__/http-test.js</strong>.</p><p>Давайте создадим тестовое окружение для этого сервиса. </p><pre class="brush: javascript noskimlinks noskimwords">import * as http from "../http.js";import sinon from "sinon";import * as fetch from "isomorphic-fetch";describe("TestHttpService", () =&gt; {  describe("Test success scenarios", () =&gt; {    beforeEach(() =&gt; {      stubedFetch = sinon.stub(window, "fetch");      window.fetch.returns(Promise.resolve(mockApiResponse()));      function mockApiResponse(body = {}) {        return new window.Response(JSON.stringify(body), {          status: 200,          headers: { "Content-type": "application/json" }        });      }    });  });});</pre><p>Мы используем как Jasmine, так и Sinon — Jasmine, чтобы определить тестовые сценарии, а Sinon, чтобы утверждать и создавать шпионов для объектов. (Jasmine имеет свой собственный способ создать шпионы и заглушки в тестах, но мне больше нравится API в Sinon.)</p><p>Вышеприведенный код не требует пояснений. Перед каждым тестовым запуском мы перехватываем вызов API Fetch, поскольку нет сервера, а вместо этого возвращаем объект-заглушку промиса. Цель этого заключается в модульном тестировании, если API Fetch вызывается с корректными параметрами и видит, может ли оболочка правильно обрабатывать любые ошибки сети. </p><p>Начнем с неудачного тестового примера:</p><pre class="brush: javascript noskimlinks noskimwords"> describe("Test get requests", () =&gt; {  it("should make a GET request", done =&gt; {    http.get(url).then(response =&gt; {      expect(stubedFetch.calledWith(`${url}`)).toBeTruthy();      expect(response).toEqual({});      done();    });  });});</pre><p>Вызовите исполнитель тестов с помощью <code class="inline">karma start</code>. Тесты, очевидно, будут терпеть неудачу, поскольку в <code class="inline">http</code> нет метода <code class="inline">get</code>. Давайте это исправим.</p><pre class="brush: javascript noskimlinks noskimwords">const status = response =&gt; {  if (response.ok) {    return Promise.resolve(response);  }  return Promise.reject(new Error(response.statusText));};export const get = (url, params = {}) =&gt; {  return fetch(url)    .then(status);};</pre><p>Если вы сейчас запустите свои тесты, вы увидите сообщение об ошибке <code class="inline">Expected [object Response] to equal Object({ })</code>. Объект потока — это ответ. Потоковые объекты, как следует из названия, представляют собой поток данных. Для получения данных из потока, сначала необходимо прочитать поток, используя некоторые из его вспомогательных методов. На данный момент мы можем предположить, что поток будет JSON и десериализуем его, вызвав <code class="inline">response.json()</code>. </p><pre class="brush: javascript noskimlinks noskimwords">const deserialize = response =&gt; response.json();export const get = (url, params = {}) =&gt; {  return fetch(url)    .then(status)    .then(deserialize)    .catch(error =&gt; Promise.reject(new Error(error)));};</pre><p>Теперь наш тестовый набор должен быть зеленым. </p><h4>Добавление параметров из строки запроса</h4><p>До сих пор метод <code class="inline">get</code> просто делал простой вызов без каких-либо параметров запроса. Давайте напишем неудачный тест, чтобы увидеть, как он должен работать с параметрами запроса. Если мы передадим <code class="inline">{ users: [1, 2], limit: 50, isDetailed: false }</code> в качестве параметров строки запроса, наш HTTP-клиент должен сделать вызов по URL-адресу <code class="inline">/api/v1/users/?users=1&amp;users=2&amp;limit=50&amp;isDetailed=false</code>. </p><pre class="brush: javascript noskimlinks noskimwords">  it("should serialize array parameter", done =&gt; {    const users = [1, 2];    const limit = 50;    const isDetailed = false;    const params = { users, limit, isDetailed };    http      .get(url, params)      .then(response =&gt; {        expect(stubedFetch.calledWith(`${url}?isDetailed=false&amp;limit=50&amp;users=1&amp;users=2/`)).toBeTruthy();        done();      })  });</pre><p>Теперь, когда у нас есть тест, давайте расширим наш метод <code class="inline">get</code> для обработки параметров запроса.</p><pre class="brush: javascript noskimlinks noskimwords">import { stringify } from "query-string";export const get = (url, params) =&gt; {  const prefix = url.endsWith("/") ? url : `${url}/`;  const queryString = params ? `?${stringify(params)}/` : "";    return fetch(`${prefix}${queryString}`)    .then(status)    .then(deserializeResponse)    .catch(error =&gt; Promise.reject(new Error(error)));};</pre><p>Если параметры присутствуют, мы формируем строку запроса и добавляем ее к URL-адресу. </p><p>Здесь я использовал библиотеку <span>query-string</span> — это небольшая вспомогательная библиотека, которая помогает обрабатывать различные сценарии параметров запроса.</p><h3>Обработка мутаций</h3><p>GET — это, пожалуй, самый простой из HTTP-методов для реализации. GET также идемпотентный метод, что означает, что его нельзя использовать для любых мутаций (изменений). Обычно метод POST предназначен для обновления некоторых записей на сервере. Это означает, что POST-запросы нуждаются в определенных способах защиты по умолчанию, например токен CSRF. Подробнее об этом в следующем разделе. </p><p>Начнем с создания теста для простого запроса POST:</p><pre class="brush: javascript noskimlinks noskimwords">describe(`Test post requests`, () =&gt; {    it("should send request with custom headers", done =&gt; {        const postParams = {         users: [1, 2]         };        http.post(url, postParams, { contentType: http.HTTP_HEADER_TYPES.text })        .then(response =&gt; {            const [uri, params] = [...stubedFetch.getCall(0).args];            expect(stubedFetch.calledWith(`${url}`)).toBeTruthy();            expect(params.body).toEqual(JSON.stringify(postParams));            expect(params.headers.get("Content-Type")).toEqual(http.HTTP_HEADER_TYPES.text);            done();        });    });});</pre><p>Метод POST очень похож на GET. Он использует свойство <code class="inline">options</code>, где вы можете определить заголовки, тело и, самое главное, <code class="inline">method</code>. Метод также выражается глаголом, в данном случае — <code class="inline">"post"</code>. </p><p>Допустим, что теперь тип контента — JSON, и с этого начинается реализация запроса POST. </p><pre class="brush: javascript noskimlinks noskimwords">export const HTTP_HEADER_TYPES = {  json: "application/json",  text: "application/text",  form: "application/x-www-form-urlencoded",  multipart: "multipart/form-data"};export const post = (url, params) =&gt; {  const headers = new Headers();  headers.append("Content-Type", HTTP_HEADER_TYPES.json);  return fetch(url, {    headers,    method: "post",    body: JSON.stringify(params),  });};</pre><p>На данный момент наш метод <code class="inline">post</code> очень примитивен. Он не поддерживает ничего, кроме запроса JSON. </p><h4>Альтернативные типы содержимого и CSRF-токены</h4><p>Давайте позвоним вызывающему коду выбрать тип контента и передать токен CSRF. В зависимости от ваших требований вы можете сделать CSRF опциональным. В нашем случае мы предположим, что это возможность выбора и позволяет вызывающему коду определить, нужно ли вам устанавливать токен CSRF в заголовке.</p><p>Для этого начните с передачи объекта options в качестве третьего параметра в наш метод. </p><pre class="brush: javascript noskimlinks noskimwords">   it("should send request with CSRF", done =&gt; {        const postParams = {         users: [1, 2 ]         };        http.post(url, postParams, {            contentType: http.HTTP_HEADER_TYPES.text,            includeCsrf: true         }).then(response =&gt; {            const [uri, params] = [...stubedFetch.getCall(0).args];            expect(stubedFetch.calledWith(`${url}`)).toBeTruthy();            expect(params.body).toEqual(JSON.stringify(postParams));            expect(params.headers.get("Content-Type")).toEqual(http.HTTP_HEADER_TYPES.text);            expect(params.headers.get("X-CSRF-Token")).toEqual(csrf);            done();        });    });</pre><p>Когда мы предоставим <code class="inline">options</code> как <code class="inline">{contentType: http.HTTP_HEADER_TYPES.text,includeCsrf: true}</code>, он должен соответствующим образом устанавливать заголовок содержимого и заголовки CSRF. Давайте обновим функцию <code class="inline">post</code> для поддержки этих новых параметров.</p><pre class="brush: javascript noskimlinks noskimwords">export const post = (url, params, options={}) =&gt; {  const {contentType, includeCsrf} = options;  const headers = new Headers();  headers.append("Content-Type", contentType || HTTP_HEADER_TYPES.json());  if (includeCsrf) {    headers.append("X-CSRF-Token", getCSRFToken());  }  return fetch(url, {    headers,    method: "post",    body: JSON.stringify(params),  });};const getCsrfToken = () =&gt; {    //This depends on your implementation detail    //Usually this is part of your session cookie    return "csrf"}</pre><p>Обратите внимание, что получение токена CSRF — это деталь реализации. Обычно это часть вашего cookie-сеанса, и вы можете извлечь его оттуда. Я не буду касаться этого дальше в этой статье.<br></p><p>Теперь ваш тестовый набор должен проходить успешно. </p><h4>Кодирование форм</h4><p>Сейчас наш метод <code class="inline">post</code> формируется, но это все еще довольно тривиально при отправке тела. Вам придется отправлять ваши данные по-разному в зависимости от типа содержимого. При работе с формами мы должны кодировать данные как строку перед отправкой по проводке. </p><pre class="brush: javascript noskimlinks noskimwords">   it("should send a form-encoded request", done =&gt; {        const users = [1, 2];        const limit = 50;        const isDetailed = false;        const postParams = { users, limit, isDetailed };        http.post(url, postParams, {            contentType: http.HTTP_HEADER_TYPES.form,            includeCsrf: true         }).then(response =&gt; {            const [uri, params] = [...stubedFetch.getCall(0).args];            expect(stubedFetch.calledWith(`${url}`)).toBeTruthy();            expect(params.body).toEqual("isDetailed=false&amp;limit=50&amp;users=1&amp;users=2");            expect(params.headers.get("Content-Type")).toEqual(http.HTTP_HEADER_TYPES.form);            expect(params.headers.get("X-CSRF-Token")).toEqual(csrf);            done();        });    });</pre><p>Давайте создадим небольшой вспомогательный метод, которую сделает всю грязную работу. На основе значения <code class="inline">contentType</code> он обрабатывает данные по-разному. </p><pre class="brush: javascript noskimlinks noskimwords">const encodeRequests = (params, contentType) =&gt; {  switch (contentType) {    case HTTP_HEADER_TYPES.form: {      return stringify(params);    }        default:      return JSON.stringify(params);  }}export const post = (url, params, options={}) =&gt; {  const {includeCsrf, contentType} = options;  const headers = new Headers();  headers.append("Content-Type", contentType || HTTP_HEADER_TYPES.json);  if (includeCsrf) {    headers.append("X-CSRF-Token", getCSRFToken());  }  return fetch(url, {    headers,    method="post",    body: encodeRequests(params, contentType || HTTP_HEADER_TYPES.json)  }).then(deserializeResponse)  .catch(error =&gt; Promise.reject(new Error(error)));};</pre><p>Посмотрите на это! Наши тесты все еще проходят даже после рефакторинга основного компонента. </p><h3>Обработка PATCH-запросов</h3><p>Другим широко используемым HTTP-методом является PATCH. Теперь PATCH — это вызов на изменение данных, что означает, что подпись этих двух действий очень похожа. Это единственная разница в HTTP-методе. Мы можем повторно использовать все тесты, которые мы писали для POST, но с простым изменением. <br></p><pre class="brush: plain noskimlinks noskimwords">["post", "patch"].map(verb =&gt; {describe(`Test ${verb} requests`, () =&gt; {let stubCSRF, csrf;beforeEach(() =&gt; {  csrf = "CSRF";  stub(http, "getCSRFToken").returns(csrf);});afterEach(() =&gt; {  http.getCSRFToken.restore();});it("should send request with custom headers", done =&gt; {  const postParams = {     users: [1, 2]   };  http[verb](url, postParams, { contentType: http.HTTP_HEADER_TYPES.text })    .then(response =&gt; {      const [uri, params] = [...stubedFetch.getCall(0).args];      expect(stubedFetch.calledWith(`${url}`)).toBeTruthy();      expect(params.body).toEqual(JSON.stringify(postParams));      expect(params.headers.get("Content-Type")).toEqual(http.HTTP_HEADER_TYPES.text);      done();    });});it("should send request with CSRF", done =&gt; {  const postParams = {     users: [1, 2 ]   };  http[verb](url, postParams, {      contentType: http.HTTP_HEADER_TYPES.text,      includeCsrf: true     }).then(response =&gt; {      const [uri, params] = [...stubedFetch.getCall(0).args];      expect(stubedFetch.calledWith(`${url}`)).toBeTruthy();      expect(params.body).toEqual(JSON.stringify(postParams));      expect(params.headers.get("Content-Type")).toEqual(http.HTTP_HEADER_TYPES.text);      expect(params.headers.get("X-CSRF-Token")).toEqual(csrf);      done();    });});it("should send a form-encoded request", done =&gt; {  const users = [1, 2];  const limit = 50;  const isDetailed = false;  const postParams = { users, limit, isDetailed };  http[verb](url, postParams, {      contentType: http.HTTP_HEADER_TYPES.form,      includeCsrf: true     }).then(response =&gt; {      const [uri, params] = [...stubedFetch.getCall(0).args];      expect(stubedFetch.calledWith(`${url}`)).toBeTruthy();      expect(params.body).toEqual("isDetailed=false&amp;limit=50&amp;users=1&amp;users=2");      expect(params.headers.get("Content-Type")).toEqual(http.HTTP_HEADER_TYPES.form);      expect(params.headers.get("X-CSRF-Token")).toEqual(csrf);      done();    });});});});</pre><p>Точно так же мы можем повторно использовать текущий метод <code class="inline">post</code>, сделав метод (глагол) настраиваемый, и переименуем имя метода, чтобы отразить что-то общее. </p><pre class="brush: plain noskimlinks noskimwords">const request = (url, params, options={}, method="post") =&gt; {  const {includeCsrf, contentType} = options;  const headers = new Headers();  headers.append("Content-Type", contentType || HTTP_HEADER_TYPES.json);  if (includeCsrf) {    headers.append("X-CSRF-Token", getCSRFToken());  }  return fetch(url, {    headers,    method,    body: encodeRequests(params, contentType)  }).then(deserializeResponse)  .catch(error =&gt; Promise.reject(new Error(error)));};export const post = (url, params, options = {}) =&gt; request(url, params, options, "post");</pre><p>Теперь, когда все наши тесты POST проходят, все, что осталось, это добавить еще один метод для <code class="inline">patch</code>.</p><pre class="brush: javascript noskimlinks noskimwords">export const patch = (url, params, options = {}) =&gt; request(url, params, options, "patch");</pre><p>Просто, не так ли? В качестве упражнения попробуйте самостоятельно добавить запрос PUT или DELETE. Если у вас возникли трудности с реализацией, не стесняйтесь обращаться к репозиторию.</p><h2>Когда нужен TDD?</h2><p>Сообщество разделяется в этом вопросе. Некоторые программисты бегут и прячутся, когда они слышат слово TDD, в то время как другие живут им. Вы можете достичь некоторых полезных эффектов TDD, просто имея хороший набор тестов. Здесь нет правильного ответа. Это все о том, насколько вы комфортно относитесь к своей команде с вашим подходом. </p><p>Как правило, я использую TDD для сложных, неструктурированных проблем, для которых мне нужно больше ясности. Оценивая подход или сравнивая несколько подходов, я считаю полезным для начала определить постановку задачи и границы. Это помогает в выработке требований и крайних случаев, которые должна обрабатывать ваша функция. Если количество случаев слишком велико, это говорит о том, что ваша программа может делать слишком много, и, возможно, пришло время разделить ее на более мелкие фрагменты кода. Если требования просты, я пропускаю использование TDD и добавляю тесты позже. </p><h2>Заключение</h2><p>На эту тему много шума, и легко потеряться. Если я могу дать вам некоторый совет перед окончанием, то он был такой: не беспокойтесь слишком много о самой концепции TDD, но сосредоточьтесь на основополагающих его  принципах. Все дело в написании чистого, понятного и удобного кода. TDD — полезный навык в поясе инструментов программиста. Со временем вы будете развивать интуицию о том, когда применять этот подход. </p><p>Спасибо за чтение и дайте нам знать, что вы думаете в разделе комментариев.</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824728-razrabotka-cherez-testirovanie-na-praktike" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="TDD" href="https://norma-studio.github.io/article/220824728-razrabotka-cherez-testirovanie-na-praktike" class="tm-article-body__tags-item-link">TDD</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
38848</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
683</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

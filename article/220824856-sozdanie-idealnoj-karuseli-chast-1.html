
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Создание идеальной карусели, часть 1... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Создание идеальной карусели, часть 1... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Создание идеальной карусели, часть 1... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Создание идеальной карусели, часть 1... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Карусели являются основным продуктом сайтов для потоковой передачи и электронной коммерции. Оба Amazon и Netflix используют их в качестве выдающихся инструментов навигации. В этом уроке мы будем оценивать дизайн взаимодействия и того, и другого, и использовать наши результаты для реализации идеальной карусели....">
<meta property="og:description" content="Карусели являются основным продуктом сайтов для потоковой передачи и электронной коммерции. Оба Amazon и Netflix используют их в качестве выдающихся инструментов навигации. В этом уроке мы будем оценивать дизайн взаимодействия и того, и другого, и использовать наши результаты для реализации идеальной карусели....">
<meta name="twitter:description" content="Карусели являются основным продуктом сайтов для потоковой передачи и электронной коммерции. Оба Amazon и Netflix используют их в качестве выдающихся инструментов навигации. В этом уроке мы будем оценивать дизайн взаимодействия и того, и другого, и использовать наши результаты для реализации идеальной карусели....">
<meta property="aiturec:description" content="Карусели являются основным продуктом сайтов для потоковой передачи и электронной коммерции. Оба Amazon и Netflix используют их в качестве выдающихся инструментов навигации. В этом уроке мы будем оценивать дизайн взаимодействия и того, и другого, и использовать наши результаты для реализации идеальной карусели....">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/1875/posts/29481/image/amazon-cut-off.jpg">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/1875/posts/29481/image/amazon-cut-off.jpg">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/1875/posts/29481/image/amazon-cut-off.jpg">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/1875/posts/29481/image/amazon-cut-off.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/1875/posts/29481/image/amazon-cut-off.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article/220824856-sozdanie-idealnoj-karuseli-chast-1.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article/220824856-sozdanie-idealnoj-karuseli-chast-1.html">
<link rel="canonical" href="https://norma-studio.github.io/article/220824856-sozdanie-idealnoj-karuseli-chast-1.html">
<meta property="og:url" content="https://norma-studio.github.io/article/220824856-sozdanie-idealnoj-karuseli-chast-1.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article/220824856-sozdanie-idealnoj-karuseli-chast-1.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article/220824856-sozdanie-idealnoj-karuseli-chast-1.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article/220824856-sozdanie-idealnoj-karuseli-chast-1.html" title="Создание идеальной карусели, часть 1... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Создание идеальной карусели, часть 1... | envatomarket.ru | norma-studio.github.io" title="Создание идеальной карусели, часть 1... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/45343254534.jpg" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article/220824856-sozdanie-idealnoj-karuseli-chast-1.html" class="tm-user-info__username" title="
С. Баранов" aria-label="
С. Баранов">
С. Баранов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Создание идеальной карусели, часть 1...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824856-sozdanie-idealnoj-karuseli-chast-1" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="JavaScript" href="https://norma-studio.github.io/article/220824856-sozdanie-idealnoj-karuseli-chast-1" class="tm-article-snippet__hubs-item-link"><span>JavaScript</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article/220824856-sozdanie-idealnoj-karuseli-chast-1.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/1875/posts/29481/image/amazon-cut-off.jpg">
    <meta itemprop="headline name" content="Создание идеальной карусели, часть 1... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Карусели являются основным продуктом сайтов для потоковой передачи и электронной коммерции. Оба Amazon и Netflix используют их в качестве выдающихся инструментов навигации. В этом уроке мы будем оценивать дизайн взаимодействия и того, и другого, и использовать наши результаты для реализации идеальной карусели....">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Карусели являются основным продуктом сайтов для потоковой передачи и электронной коммерции. Оба Amazon и Netflix используют их в качестве выдающихся инструментов навигации. В этом уроке мы будем оценивать дизайн взаимодействия и того, и другого, и использовать наши результаты для реализации идеальной карусели....</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Карусели являются основным продуктом сайтов для потоковой передачи и электронной коммерции. Оба Amazon и Netflix используют их в качестве выдающихся инструментов навигации. В этом уроке мы будем оценивать дизайн взаимодействия и того, и другого, и использовать наши результаты для реализации идеальной карусели.</p><p>В этой серии учебников мы также изучим некоторые функции движка движения по движению <span>«Popmotion (Попмотион)»</span>. Он предлагает анимационные инструменты, такие как tweens (полезно для разбивки на страницы), отслеживание указателей (для прокрутки) и весеннюю физику (для наших восхитительных штрихов).</p><p>Часть 1 будет оценивать, как Amazon и Netflix реализовали прокрутку. Затем мы реализуем карусель, который можно прокручивать прикосновением.</p><p>К концу этой серии мы проведем прокрутку колес и тачпада, разбивку на страницы, индикаторы хода, навигацию по клавиатуре и некоторые незначительные штрихи с использованием весенней физики. Мы также будем подвержены некоторой базовой функциональной композиции.</p><h2>Идеальный?</h2><p>Что нужно, чтобы карусель была «идеальной»? Он должен быть доступен:</p><ul><li> <strong>Мышь</strong>. Он должен предлагать предыдущие и следующие кнопки, которые легко нажимать и не скрывать контент.</li> <li> <strong>Коснитесь</strong> (сенсорный ввод): он должен отследить палец, а затем прокрутиться с тем же импульсом, что и при падении пальца с экрана.</li> <li> <strong>Колесико прокрутки</strong>: Часто пропускается, Apple Magic Mouse и многие треки для ноутбука обеспечивают плавное горизонтальное прокручивание. Мы должны использовать эти возможности!</li> <li> <strong>Клавиатура</strong>. Многие пользователи предпочитают не использовать или использовать мышь для навигации. Важно сделать нашу карусель доступной, чтобы пользователи могли использовать наш продукт.</li> </ul><p>Наконец, мы сделаем еще один шаг вперед и сделаем это уверенным, восхитительным элементом UX, сделав карусель отчетливо и в явном виде с весенней физикой, когда ползунок достигнет конца.</p><h2>Установка</h2><p>Во-первых, давайте получим HTML и CSS, необходимые для создания рудиментарной карусели, разворачивая этот <span>CodePen</span>. </p><p>Перо настроено на Sass для предварительной обработки CSS и Babel для трансляции JavaScript ES6. Я также включил Popmotion, к которому можно получить доступ с помощью <code class="inline">window.popmotion</code>.</p><p>Вы можете скопировать код в локальный проект, если хотите, но вы должны убедиться, что ваша среда поддерживает Sass и ES6. Вам также потребуется установить Popmotion с <code class="inline">npm install popmotion</code>.</p><h3>Создание новой карусели</h3><p>На любой данной странице у нас может быть много каруселей. Поэтому нам нужен способ инкапсуляции состояния и функциональности каждого из них.</p><p>Я собираюсь использовать <strong>фабричную функцию</strong>, а не <code class="inline">класс</code>. Фабричные функции исключают необходимость использования часто путающего <code class="inline">этого</code> ключевого слова и упрощают код для целей данного руководства.</p><p>В своем редакторе JavaScript добавьте эту простую функцию:</p><pre class="brush: javascript noskimlinks noskimwords">function carousel(container) {}carousel(document.querySelector(".container"));</pre><p>Мы добавим код этой карусели в эту функцию <code class="inline">карусели</code>.</p><h2>Способы  прокрутки и для чего она.</h2><p>Наша первая задача - сделать карусельный свиток. Мы можем сделать два способа:</p><h3>Прокрутка собственного браузера</h3><p>Очевидным решением было бы установить <code class="inline">переполнение-x: прокрутка </code>по ползунку. Это позволит использовать прокрутку на всех браузерах, включая сенсорные и горизонтальные устройства колесика мыши.</p><p>Однако есть и недостатки такого подхода:</p><ul><li>Содержимое вне контейнера не будет видно, что может быть ограничительным для нашего дизайна.</li> <li>Это также ограничивает способы использования анимаций, чтобы показать, что мы достигли конца.</li> <li>Настольные браузеры будут иметь уродливую (хотя и доступную!) Горизонтальную полосу прокрутки.</li> </ul><p>В качестве альтернативы:</p><h3>Анимация <code class="inline">translateX</code> </h3><p>Мы также могли бы анимировать свойство <code class="inline">translateX</code> в карусели. Это было бы очень универсально, поскольку мы могли бы реализовать именно тот дизайн, который нам нравится. <code class="inline">translateX</code> также очень эффективен, поскольку в отличие от свойства CSS <code class="inline">left</code> он может обрабатываться графическим процессором устройства.</p><p>С другой стороны, нам придется переопределить функциональность прокрутки с помощью JavaScript. Это больше работы, больше кода.<br></p><h3>Как проложить прокрутку Amazon и Netflix?</h3><p>Оба карусели Amazon и Netflix делают разные компромиссы в решении этой проблемы.</p><p><strong>Amazon</strong> оживляет свойство карусели <code class="inline">слева</code> в режиме «рабочий стол». Анимация <code class="inline">слева</code> - невероятно плохой выбор, так как изменение этого параметра приводит к <span>пересчету компоновки</span>. Это интенсивность процессора, и более старые машины будут бороться за 60 кадров в секунду.</p><p>Тот, кто принял решение анимировать <code class="inline">левый</code>, а не <code class="inline">translate X</code>, должен быть настоящим идиотом (<strong>spoiler (прерыватель потока):</strong> это я, еще в 2012 году. В те дни мы не были такими просвещенными).</p><p>Когда он обнаруживает сенсорное устройство, карусель использует собственную прокрутку браузера. Проблема с возможностью включения этого режима в «мобильном» режиме - это пользователи настольных компьютеров с пропущенными горизонтальными колесами прокрутки. Это также означает, что любое содержимое вне карусели должно быть визуально отрезано:</p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/1875/posts/29481/image/amazon-cut-off.jpg" alt="Создание идеальной карусели, часть 1..." title="Создание идеальной карусели, часть 1..." width="50" height="50"></figure><p><strong>Netflix</strong> правильно анимирует свойство <code class="inline">translateX</code> carousel, и он делает это на всех устройствах. Это позволяет им иметь дизайн, который выходит за пределы карусели:</p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=772/uploads/users/1875/posts/29481/image/netflix-not-cut-off2.jpg" alt="Создание идеальной карусели, часть 1..." title="Создание идеальной карусели, часть 1..." width="50" height="50"></figure><p>Это, в свою очередь, позволяет им придумывать дизайн, где предметы увеличены за пределами краев x и y карусели, а окружающие предметы перемещаются с пути:</p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/1875/posts/29481/image/netflix-enlarged-item.jpg" alt="Создание идеальной карусели, часть 1..." title="Создание идеальной карусели, часть 1..." width="50" height="50"></figure><p>К сожалению, повторная реализация прокрутки Netflix для сенсорных устройств неудовлетворительна: в ней используется система разбиения на страницы на жестов, которая кажется медленной и громоздкой. Кроме того, для горизонтальных колес прокрутки не учитывается.</p><p>Мы можем сделать лучше. Давайте сделаем код!</p><h2>Прокрутка Как Pro</h2><p>Наш первый шаг - захватить узел <code class="inline">.slider</code>. Пока мы на нем, давайте возьмем элементы, которые он содержит, чтобы мы могли определить размер ползунка.</p><pre class="brush: javascript noskimlinks noskimwords">function carousel(container) {  const slider = container.querySelector(".slider");  const items = slider.querySelectorAll(".item");}</pre><h3>Измерение карусели </h3><p>Мы можем определить видимую область ползунка, измеряя его ширину:</p><pre class="brush: javascript noskimlinks noskimwords">const sliderVisibleWidth = slider.offsetWidth;</pre><p>Мы также хотим, чтобы общая ширина всех элементов содержалась внутри. Чтобы наша функция <code class="inline">карусели</code> была относительно чистой, давайте сделаем это вычисление отдельной функцией в верхней части нашего файла.</p><p>Используя <code class="inline">getBoundingClientRect</code> для измерения смещения <code class="inline">слева</code> нашего первого элемента и смещения <code class="inline">справа</code> от нашего последнего элемента, мы можем использовать разницу между ними, чтобы найти полную ширину всех элементов.</p><pre class="brush: javascript noskimlinks noskimwords">function getTotalItemsWidth(items) {  const { left } = items[0].getBoundingClientRect();  const { right } = items[items.length - 1].getBoundingClientRect();  return right - left;}</pre><p>После измерения <code class="inline">sliderVisibleWidth</code> напишите:</p><pre class="brush: javascript noskimlinks noskimwords">const totalItemsWidth = getTotalItemsWidth(items);</pre><p>Теперь мы можем определить максимальное расстояние, на которое должна прокручиваться карусель. Это общая ширина всех наших предметов, <em>минус</em> одна полная ширина нашего видимого слайдера. Это дает число, которое позволяет самому правому элементу выравниваться справа от нашего слайдера:</p><pre class="brush: javascript noskimlinks noskimwords">const maxXOffset = 0;const minXOffset = - (totalItemsWidth - sliderVisibleWidth);</pre><p>Благодаря этим измерениям мы готовы начать прокрутку нашей карусели.</p><h3>Настройка <code class="inline">translateX</code> </h3><p>Popmotion поставляется с <span>рендерером CSS</span> для простой и эффективной настройки свойств CSS. Он также имеет функцию <span>значения</span>, которая может использоваться для отслеживания чисел и, что важно (как мы вскоре увидим), запросить их скорость.</p><p>В верхней части вашего файла JavaScript импортируйте их так:</p><pre class="brush: javascript noskimlinks noskimwords">const { css, value } = window.popmotion;</pre><p>атем на линии после установки <code class="inline">minXOffset</code> создайте рендеринг CSS для нашего слайдера:</p><pre class="brush: javascript noskimlinks noskimwords">const sliderRenderer = css(slider);</pre><p>И создайте <code class="inline">значение</code> для отслеживания смещения x слайдера и обновите свойство <code class="inline">translateX</code> слайдера, когда оно изменится:</p><pre class="brush: javascript noskimlinks noskimwords">const sliderX = value(0, (x) =&gt; sliderRenderer.set("x", x));</pre><p>Теперь перемещение ползунка горизонтально так же просто, как и запись:</p><pre class="brush: javascript noskimlinks noskimwords">sliderX.set(-100);</pre><p>Попробуй! </p><h3>Сенсорная прокрутка</h3><p>Мы хотим, чтобы наша карусель начала прокручивать, когда пользователь перетаскивает ползунок горизонтально и останавливает прокрутку, когда пользователь перестает касаться экрана. Наши обработчики событий будут выглядеть так:</p><pre class="brush: javascript noskimlinks noskimwords">let action;function stopTouchScroll() {  document.removeEventListener("touchend", stopTouchScroll);}function startTouchScroll(e) {  document.addEventListener("touchend", stopTouchScroll);}slider.addEventListener("touchstart", startTouchScroll, { passive: false });</pre><p>В нашей функции <code class="inline">startTouchScroll</code> мы хотим:</p><ul><li>Остановите любые другие действия, включив <code class="inline">slider (слайдер)X.</code></li> <li>Найдите точку касания начала.</li> <li>Прослушайте следующее событие <code class="inline">touchmove</code>, чтобы узнать, перетаскивается ли пользователь по вертикали или по горизонтали.</li> </ul><p>После <code class="inline">document.addEventListener</code> добавьте:</p><pre class="brush: javascript noskimlinks noskimwords">if (action) action.stop();</pre><p>Это остановит любые другие действия (например, прокрутку импульсов с физическим питанием, которые мы будем использовать в <code class="inline">stopTouchScroll</code>), перемещая ползунок. Это позволит пользователю немедленно «поймать» слайдер, если он прокручивает элемент или заголовок, на который они хотят щелкнуть.</p><p>Затем нам нужно сохранить точку начала происшествия. Это позволит нам увидеть, куда пользователь перемещает свой палец дальше. Если это вертикальное движение, мы разрешим прокрутку страницы, как обычно. Если это горизонтальное движение, мы будем прокручивать слайдер.</p><p>Мы хотим поделиться этим <code class="inline">touchOrigin</code> между обработчиками событий. Итак, после <code class="inline">let action; (действия;) </code>Добавить:</p><pre class="brush: javascript noskimlinks noskimwords">let touchOrigin = {};</pre><p>Вернемся в наш обработчик <code class="inline">startTouchScroll</code>, добавьте:</p><pre class="brush: javascript noskimlinks noskimwords">const touch = e.touches[0];touchOrigin = {  x: touch.pageX,  y: touch.pageY};</pre><p>Теперь мы можем добавить <code class="inline">touchmove (прослушиватель) </code>событий  в <code class="inline">документ</code>, чтобы определить направление перетаскивания на основе этого <code class="inline">touchOrigin</code>:</p><pre class="brush: javascript noskimlinks noskimwords">document.addEventListener("touchmove", determineDragDirection);</pre><p>Наша функция <code class="inline">(определения) determeDragDirection</code> будет измерять следующее местоположение касания, проверить, что она действительно переместилась, и если да, измерьте угол, чтобы определить, является ли он вертикальным или горизонтальным:</p><pre class="brush: javascript noskimlinks noskimwords">function determineDragDirection(e) {  const touch = e.changedTouches[0];  const touchLocation = {    x: touch.pageX,    y: touch.pageY  };}</pre><p>Popmotion включает некоторые полезные <span>калькуляторы</span> для измерения таких вещей, как расстояние между двумя координатами x / y. Мы можем импортировать таких:</p><pre class="brush: javascript noskimlinks noskimwords">const { calc, css, value } = window.popmotion;</pre><p>Тогда измерение расстояния между двумя точками зависит от использования калькулятора <code class="inline">расстояния</code>:</p><pre class="brush: javascript noskimlinks noskimwords">const distance = calc.distance(touchOrigin, touchLocation);</pre><p>Теперь, если касание переместилось, мы можем отключить этот прослушиватель событий.</p><pre class="brush: javascript noskimlinks noskimwords">if (!distance) return;document.removeEventListener("touchmove", determineDragDirection);</pre><p>Измерьте угол между двумя точками с помощью калькулятора <code class="inline">угла</code>:</p><pre class="brush: javascript noskimlinks noskimwords">const angle = calc.angle(touchOrigin, touchLocation);</pre><p>Мы можем использовать это, чтобы определить, является ли этот угол горизонтальным или вертикальным, передавая его следующей функции. Добавьте эту функцию в самую верхнюю часть нашего файла:</p><pre class="brush: javascript noskimlinks noskimwords">function angleIsVertical(angle) {  const isUp = (    angle &lt;= -90 + 45 &amp;&amp;    angle &gt;= -90 - 45  );  const isDown = (    angle &lt;= 90 + 45 &amp;&amp;    angle &gt;= 90 - 45  );  return (isUp || isDown);}</pre><p>Эта функция возвращает <code class="inline">true</code>, если заданный угол находится в пределах -90 +/- 45 градусов (прямо вверх) или 90 +/- 45 градусов (прямо вниз). Таким образом, мы можем добавить другое предложение <code class="inline">возврата</code>, если эта функция вернет <code class="inline">true</code>.</p><pre class="brush: javascript noskimlinks noskimwords">if (angleIsVertical(angle)) return;</pre><h3>Отслеживание указателя</h3><p>Теперь мы знаем, что пользователь пытается прокрутить карусель, мы можем начать отслеживать их пальцы. Popmotion предлагает действие <span>указателя</span>, которое выводит координаты x / y мыши или указателя касания.</p><p>Во-первых, <code class="inline">указатель</code> импорта:</p><pre class="brush: javascript noskimlinks noskimwords">const { calc, css, pointer, value } = window.popmotion;</pre><p>Чтобы отслеживать сенсорный ввод, предоставьте исходное событие<code class="inline"> указателю</code>:</p><pre class="brush: javascript noskimlinks noskimwords">action = pointer(e).start();</pre><p>Мы хотим измерить начальную позицию <code class="inline">x</code> нашего указателя и применить любое движение к слайдеру. Для этого мы можем использовать <span>трансформатор</span> под названием <code class="inline">applyOffset</code>.<br></p><p>Трансформаторы - это чистые функции, которые принимают значение и возвращают его - да-трансформируются. Например:<code class="inline"> const double = (v) =&gt; v * 2</code>.</p><pre class="brush: javascript noskimlinks noskimwords">const { calc, css, pointer, transform, value } = window.popmotion;const { applyOffset } = transform;</pre><p><code class="inline">applyOffset</code> - это валютная функция. Это означает, что когда мы вызываем его, он создает новую функцию, которая затем может быть передана значение. Сначала мы вызываем его числом, которое мы хотим измерить смещение, в этом случае текущее значение <code class="inline">action.x </code>и число, чтобы применить это смещение к. В этом случае это наш <code class="inline">sliderX</code>.<br></p><p>Поэтому наша функция <code class="inline">applyOffset</code> будет выглядеть так:</p><pre class="brush: javascript noskimlinks noskimwords">const applyPointerMovement = applyOffset(action.x.get(), sliderX.get());</pre><p>Теперь мы можем использовать эту функцию в обратном <code class="inline">вызове</code> указателя, чтобы применить движение указателя к ползунку.</p><pre class="brush: javascript noskimlinks noskimwords">action.output(({ x }) =&gt; slider.set(applyPointerMovement(x)));</pre><h3>Остановка, со стилем<br></h3><p>Карусель теперь перетаскивается прикосновением! Вы можете проверить это, используя эмуляцию устройства в Инструментах разработчика Chrome.</p><p>Он чувствует себя немного болтливым, не так ли? Возможно, вы столкнулись с прокруткой, которая кажется такой до этого: вы поднимаете палец, и прокрутка останавливается. Или прокрутка останавливается, а затем небольшая анимация захватывает продолжение прокрутки.</p><p>Мы не собираемся это делать. Мы можем использовать <span>физическое</span> действие в Popmotion, чтобы взять истинную скорость <code class="inline">sliderX</code> и применить к нему трение в течение продолжительного времени.</p><p>Во-первых, добавьте его в наш постоянно растущий список импорта:</p><pre class="brush: plain noskimlinks noskimwords">const { calc, css, physics, pointer, value } = window.popmotion;</pre><p>Затем, в конце нашей функции <code class="inline">stopTouchScroll</code>, добавьте:</p><pre class="brush: javascript noskimlinks noskimwords">if (action) action.stop();action = physics({  from: sliderX.get(),  velocity: sliderX.getVelocity(),  friction: 0.2})  .output((v) =&gt; sliderX.set(v))  .start();</pre><p>Здесь <code class="inline">от</code> и <code class="inline">скорость</code> устанавливаются с текущим значением и скоростью <code class="inline">sliderX</code>. Это гарантирует, что наше физическое моделирование имеет те же начальные начальные условия, что и перемещение движения пользователя.</p><p><code class="inline">трение</code> устанавливается равным <code class="inline">0,2</code>. Трение задается как значение от <code class="inline">0</code> до <code class="inline">1</code>, при этом <code class="inline">0</code> не является трением вообще, а <code class="inline">1</code> является абсолютным трением. Попробуйте сыграть с этим значением, чтобы увидеть, какое изменение он внесет в «чувство» карусели, когда пользователь перестает перетаскивать.<br></p><p>Меньшие числа заставят его чувствовать себя легче, а большие числа сделают движение более тяжелым. Для движения с прокруткой я чувствую, что <code class="inline">0.2</code> ударяет хороший баланс между неустойчивым и вялым.</p><h3>Границы</h3><p>Но есть проблема! Если вы играете с новой карусели, это очевидно. У нас нет ограниченного движения, позволяющего буквально выбросить вашу карусель!</p><p>Есть еще один трансформатор для этой работы, <code class="inline">зажим</code>. Это также функция в карри, то есть, если мы назовем ее минимальным и максимальным значением, скажем <code class="inline">0</code> и <code class="inline">1</code>, она вернет новую функцию. В этом примере новая функция будет ограничивать любое число, присвоенное ему, между <code class="inline">0</code> и <code class="inline">1</code>:<br></p><pre class="brush: javascript noskimlinks noskimwords">clamp(0, 1)(5); // returns 1</pre><p>Во-первых, импортный <code class="inline">зажим</code>:</p><pre class="brush: javascript noskimlinks noskimwords">const { applyOffset, clamp } = transform;</pre><p>Мы хотим использовать эту функцию зажима на нашей карусели, поэтому добавьте эту строку после определения <code class="inline">minXOffset</code>:</p><pre class="brush: javascript noskimlinks noskimwords">const clampXOffset = clamp(minXOffset, maxXOffset);</pre><p>Мы собираемся изменить два <code class="inline">выхода</code>, которые мы установили в наших действиях, используя некоторую легкую функциональную композицию с трансформатором <code class="inline">трубы</code>.</p><h3>труба</h3><p>Когда мы вызываем функцию, мы пишем ее так:</p><pre class="brush: javascript noskimlinks noskimwords">foo(0);</pre><p>Если мы хотим передать результат этой функции другой функции, мы можем написать следующее:</p><pre class="brush: javascript noskimlinks noskimwords">bar(foo(0));</pre><p>Это становится немного трудным для чтения, и это только ухудшается, когда мы добавляем все больше и больше функций.</p><p>С <code class="inline">трубой</code> мы можем создать новую функцию из <code class="inline">foo</code> и <code class="inline">bar</code>, которую мы можем использовать повторно:</p><pre class="brush: javascript noskimlinks noskimwords">const foobar = pipe(foo, bar);foobar(0);</pre><p>Он также написан в естественном порядке начала -&gt; завершения, что облегчает его выполнение. Мы можем использовать это, чтобы составить <code class="inline">applyOffset</code> и <code class="inline">clamp</code> в одну функцию. Импорт т<code class="inline">рубы</code>:</p><pre class="brush: javascript noskimlinks noskimwords">const { applyOffset, clamp, pipe } = transform;</pre><p>Замените обратный вызов <code class="inline">вывода</code> нашего <code class="inline">указателя</code> на:</p><pre class="brush: javascript noskimlinks noskimwords">pipe(  ({ x }) =&gt; x,  applyOffset(action.x.get(), sliderX.get()),  clampXOffset,  (v) =&gt; sliderX.set(v))</pre><p>И замените выходной обратный <code class="inline">вызов</code> <code class="inline">физики</code>:</p><pre class="brush: javascript noskimlinks noskimwords">pipe(clampXOffset, (v) =&gt; sliderX.set(v))</pre><p>Такая функциональная компоновка может довольно аккуратно создавать описательные, поэтапные процессы из меньших, многоразовых функций.</p><p>Теперь, когда вы тащите и бросаете карусель, он не сдвинется с места за пределы своих границ.<br></p><p>Резкая остановка не очень удовлетворяет. Но это проблема для более поздней части!</p><h2>Вывод<br></h2><p>Это все для части 1. До сих пор мы рассмотрели существующие карусели, чтобы увидеть сильные и слабые стороны различных подходов к прокрутке. Мы использовали отслеживание входных данных Popmotion и физику для того, чтобы наглядно анимировать наш перевод карусели <code class="inline">translateX</code> с сенсорной прокруткой. Мы также познакомились с функциональным составом и карриными функциями.</p><p>Вы можете получить прокомментированную версию «истории до сих пор» на этом <span>CodePen</span>.</p><p>В следующих выпусках мы рассмотрим:</p><ul><li>прокрутка с помощью колеса мыши</li> <li>повторное измерение карусели при изменении размера окна</li> <li>разбиение на страницы, доступность клавиатуры и мыши</li> <li>восхитительные прикосновения, с помощью источника физики</li> </ul><p>Ждем Вас там!</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824856-sozdanie-idealnoj-karuseli-chast-1" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="JavaScript" href="https://norma-studio.github.io/article/220824856-sozdanie-idealnoj-karuseli-chast-1" class="tm-article-body__tags-item-link">JavaScript</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
40768</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
590</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>


<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Шаблоны проектирования для коммуникации между компонентами Vue.js... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Шаблоны проектирования для коммуникации между компонентами Vue.js... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Шаблоны проектирования для коммуникации между компонентами Vue.js... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Шаблоны проектирования для коммуникации между компонентами Vue.js... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="(* шаблон проектирования – обобщенное описание способа решения определённого класса задач. Здесь и далее примеч. пер.). Как разработчики мы хотим создавать код, которым легко управлять и который удобно сопровождать, а также легче отлаживать и тестировать. Для этого мы заимствуем установившиеся практики, известные как шаблоны. Шаблоны – проверенны...">
<meta property="og:description" content="(* шаблон проектирования – обобщенное описание способа решения определённого класса задач. Здесь и далее примеч. пер.). Как разработчики мы хотим создавать код, которым легко управлять и который удобно сопровождать, а также легче отлаживать и тестировать. Для этого мы заимствуем установившиеся практики, известные как шаблоны. Шаблоны – проверенны...">
<meta name="twitter:description" content="(* шаблон проектирования – обобщенное описание способа решения определённого класса задач. Здесь и далее примеч. пер.). Как разработчики мы хотим создавать код, которым легко управлять и который удобно сопровождать, а также легче отлаживать и тестировать. Для этого мы заимствуем установившиеся практики, известные как шаблоны. Шаблоны – проверенны...">
<meta property="aiturec:description" content="(* шаблон проектирования – обобщенное описание способа решения определённого класса задач. Здесь и далее примеч. пер.). Как разработчики мы хотим создавать код, которым легко управлять и который удобно сопровождать, а также легче отлаживать и тестировать. Для этого мы заимствуем установившиеся практики, известные как шаблоны. Шаблоны – проверенны...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=650/uploads/users/2028/posts/32354/image/vueccparentchild.png">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=650/uploads/users/2028/posts/32354/image/vueccparentchild.png">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=650/uploads/users/2028/posts/32354/image/vueccparentchild.png">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=650/uploads/users/2028/posts/32354/image/vueccparentchild.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=650/uploads/users/2028/posts/32354/image/vueccparentchild.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article/220824706-shablony-proektirovaniya-dlya-kommunikatsii-mezhdu-komponentami-vuejs.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article/220824706-shablony-proektirovaniya-dlya-kommunikatsii-mezhdu-komponentami-vuejs.html">
<link rel="canonical" href="https://norma-studio.github.io/article/220824706-shablony-proektirovaniya-dlya-kommunikatsii-mezhdu-komponentami-vuejs.html">
<meta property="og:url" content="https://norma-studio.github.io/article/220824706-shablony-proektirovaniya-dlya-kommunikatsii-mezhdu-komponentami-vuejs.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article/220824706-shablony-proektirovaniya-dlya-kommunikatsii-mezhdu-komponentami-vuejs.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article/220824706-shablony-proektirovaniya-dlya-kommunikatsii-mezhdu-komponentami-vuejs.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article/220824706-shablony-proektirovaniya-dlya-kommunikatsii-mezhdu-komponentami-vuejs.html" title="Шаблоны проектирования для коммуникации между компонентами Vue.js... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Шаблоны проектирования для коммуникации между компонентами Vue.js... | envatomarket.ru | norma-studio.github.io" title="Шаблоны проектирования для коммуникации между компонентами Vue.js... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/e_09402063.jpg" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article/220824706-shablony-proektirovaniya-dlya-kommunikatsii-mezhdu-komponentami-vuejs.html" class="tm-user-info__username" title="
А. Карпов" aria-label="
А. Карпов">
А. Карпов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Шаблоны проектирования для коммуникации между компонентами Vue.js...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824706-shablony-proektirovaniya-dlya-kommunikatsii-mezhdu-komponentami-vuejs" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Vue" href="https://norma-studio.github.io/article/220824706-shablony-proektirovaniya-dlya-kommunikatsii-mezhdu-komponentami-vuejs" class="tm-article-snippet__hubs-item-link"><span>Vue</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article/220824706-shablony-proektirovaniya-dlya-kommunikatsii-mezhdu-komponentami-vuejs.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=650/uploads/users/2028/posts/32354/image/vueccparentchild.png">
    <meta itemprop="headline name" content="Шаблоны проектирования для коммуникации между компонентами Vue.js... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="(* шаблон проектирования – обобщенное описание способа решения определённого класса задач. Здесь и далее примеч. пер.). Как разработчики мы хотим создавать код, которым легко управлять и который удобно сопровождать, а также легче отлаживать и тестировать. Для этого мы заимствуем установившиеся практики, известные как шаблоны. Шаблоны – проверенны...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">(* шаблон проектирования – обобщенное описание способа решения определённого класса задач. Здесь и далее примеч. пер.). Как разработчики мы хотим создавать код, которым легко управлять и который удобно сопровождать, а также легче отлаживать и тестировать. Для этого мы заимствуем установившиеся практики, известные как шаблоны. Шаблоны – проверенны...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>(* шаблон проектирования – обобщенное описание способа решения определённого класса задач. Здесь и далее примеч. пер.). Как разработчики мы хотим создавать код, которым легко управлять и который удобно сопровождать, а также легче отлаживать и тестировать. Для этого мы заимствуем установившиеся практики, известные как шаблоны. Шаблоны – проверенные алгоритмы и архитектуры, которые помогают нам эффективно и предсказуемо решать конкретные задачи. </p><p>В этом руководстве мы рассмотрим наиболее распространенные шаблоны проектирования для коммуникации между компонентами Vue.js, а также «подводные камни», которых следует избегать. Все мы знаем, что в реальной жизни нет одного единственного способа решения всех проблем. Подобно этому при создании приложений Vue.js отсутствует универсальный шаблон для всех сценариев разработки. Каждый шаблон имеет свои преимущества и недостатки и предназначен для конкретных ситуаций. Разработчикам, использующим Vue.js, обязательно нужно знать все наиболее распространенные шаблоны, чтобы мы могли выбрать подходящий шаблон для конкретного проекта. Тогда в нашем приложении коммуникация будет происходить эффективно и так, как нам нужно.</p><h2>Почему подходящий вариант коммуникации между компонентами важен?</h2><p>Когда мы создаем приложение при помощи фреймворка, работающего на основе компонентов, вроде <span>Vue.js</span>, мы стремимся сделать компоненты нашего приложения настолько изолированными, насколько это возможно. За счет этого они ставятся пригодными для повторного использования, удобными в сопровождении и для тестирования. Для того чтобы добавить для компонента возможность повторного использования, нам необходимо оформить его в более абстрактной и изолированной (или слабосвязанной) форме, и в таком виде мы можем добавить в наше приложение или удалить его, не нарушая работу функциональных возможностей приложения. </p><p>Однако, невозможно достичь полной изоляции и независимости компонентов нашего приложения. В какой-то момент времени им нужно общаться друг с другом: обмениваться некоторыми данными, изменять состояние приложения и т.д. Так что нам важно научиться реализовывать подходящий вариант коммуникации и при этом по-прежнему поддерживать приложение в рабочем состоянии, гибким и масштабируемым.<br></p><h2>Краткий обзор коммуникации между компонентами Vue.js </h2><p>Во Vue.js имеется два главных типа коммуникации между компонентами: </p><ol><li> <strong>Непосредственная коммуникация между родительскими и дочерними компонентами</strong>, основанная на строгих отношениях типа родитель – потомок и потомок – родитель. </li> <li> <strong>Опосредованная коммуникация</strong>, при которой один компонент может «обращаться» к любому другому, независимо от типа их отношений. </li> </ol><p>В следующих разделах мы разберем оба типа вместе с соответствующими примерами. </p><h2>Непосредственная коммуникация типа родитель – потомок</h2><p>Стандартной моделью коммуникации между компонентами, которую Vue.js изначально поддерживает, является модель типа родитель – потомок, реализованная за счет пропов (* пользовательские атрибуты, которые вы можете зарегистрировать для компонента. При передаче значения этому атрибуту оно становится свойством образца того компонента) и пользовательских (* пользователей фреймворка) событий. На схеме ниже вы можете ознакомиться с визуальным представлением того, как эта модель выглядит в действии.</p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=650/uploads/users/2028/posts/32354/image/vueccparentchild.png" alt="Шаблоны проектирования для коммуникации между компонентами Vue.js..." title="Шаблоны проектирования для коммуникации между компонентами Vue.js..." width="50" height="50"></figure><p>Как вы видите, родительский компонент может общаться только с его непосредственными дочерними компонентами, а дочерние компоненты могут общаться только непосредственно с их родительскими компонентами. В этой модели невозможна коммуникация между сиблингами (* потомство одних родителей) или опосредованная коммуникация. </p><p>В следующих разделах мы реализуем приведенные на схеме выше компоненты в серии практических примеров.<br></p><h2>Коммуникация типа родитель – потомок</h2><p>Давайте предположим, что имеющиеся у нас компоненты являются частью игры. В большинстве игр отображается счет очков где-то в интерфейсе. Представьте, что у нас в компоненте <strong>Parent A</strong> имеется переменная <code class="inline">score</code>, и мы хотим отобразить ее значение в компоненте <strong>Child A</strong>. Что ж, как нам это сделать? </p><p>Для передачи данных от родительского компонента его дочерним компонентам во Vue.js используются <span>пропы</span>. Передача пропа осуществляется в три шага:</p><ol><li>Регистрация пропа в дочернем компоненте, например так: <code class="inline">props: ["score"]</code> </li> <li>Использование зарегистрированного пропа в шаблоне родительского компонента, например так: <code class="inline">&lt;span&gt;Score: {{ score }}&lt;/span&gt;</code> </li> <li>Привязывание пропа к переменной <code class="inline">score</code> (в шаблоне родительского компонента), например так: <code class="inline">&lt;child-a :score="score"/&gt;</code> </li> </ol><p>Давайте разберем полный пример, чтобы лучше понять, что в действительности происходит:<br></p><pre class="brush: javascript noskimlinks noskimwords">// HTML part&lt;div id="app"&gt;  &lt;grand-parent/&gt;&lt;/div&gt;// JavaScript partVue.component("ChildB",{  template:`    &lt;div id="child-b"&gt;      &lt;h2&gt;Child B&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;    &lt;/div&gt;`,})Vue.component("ChildA",{  template:`    &lt;div id="child-a"&gt;      &lt;h2&gt;Child A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;span&gt;Score: {{ score }}&lt;/span&gt;  // 2.Using    &lt;/div&gt;`,  props: ["score"]  // 1.Registering})Vue.component("ParentB",{  template:`    &lt;div id="parent-b"&gt;      &lt;h2&gt;Parent B&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;    &lt;/div&gt;`,})Vue.component("ParentA",{  template:`    &lt;div id="parent-a"&gt;      &lt;h2&gt;Parent A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;child-a :score="score"/&gt;  // 3.Binding      &lt;child-b/&gt;    &lt;/div&gt;`,  data() {    return {      score: 100    }  }})Vue.component("GrandParent",{  template:`    &lt;div id="grandparent"&gt;      &lt;h2&gt;Grand Parent&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;parent-a/&gt;      &lt;parent-b/&gt;    &lt;/div&gt;`,})new Vue ({  el: "#app"})</pre><p><span>Пример на CodePen</span></p><h3>Проверка правильности данных, передаваемых в пропы</h3><p>Для краткости и понятности я зарегистрировал пропы, используя их сокращенную форму записи. Однако в реальном мире разработки рекомендуется проверять <span>правильность данных, передаваемых в пропы</span>. Благодаря этому будет гарантировано, что пропы получат значения правильного типа. Например, такую проверку для нашего пропа <code class="inline">score</code> можно было бы выполнить следующим образом:</p><pre class="brush: javascript noskimlinks noskimwords">props: {    // Simple type validation    score: Number,    // or Complex type validation    score: {      type: Number,      default: 100,      required: true    }  }</pre><p>При использовании пропов, пожалуйста, убедитесь, что вы понимаете разницу между их литеральным (* литерал –  представление в программе какого-либо числового (numeric literal) или символьного (string literal) значения) и динамическим вариантами. Проп динамический, если мы привязываем его к переменной (например, <code class="inline">v-bind:score="score"</code> или its shorthand <code class="inline">:score="score"</code>), и соответственно значение пропа будет изменяться в зависимости от значения переменной. Если мы просто задаем значение без привязывания, то оно будет проинтерпретировано буквально, и результат будет статическим. В нашем случае, если мы пишем <code class="inline">score="score"</code>, то будет отображено <strong>score</strong> вместо <strong>100</strong>. Это литеральный проп. Вам следует всегда учитывать это тонкое различие.</p><h3>Обновление пропа дочернего компонента </h3><p>На данный момент мы успешно реализовали возможность отображения счета очков, однако в какой-то момент нам понадобится его обновить. Давайте попробуем реализовать эту возможность.</p><pre class="brush: javascript noskimlinks noskimwords">Vue.component("ChildA",{  template:`    &lt;div id="child-a"&gt;      &lt;h2&gt;Child A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;button @click="changeScore"&gt;Change Score&lt;/button&gt;      &lt;span&gt;Score: {{ score }}&lt;/span&gt;    &lt;/div&gt;`,  props: ["score"],  methods: {    changeScore() {      this.score = 200;    }  }})</pre><p>Мы создали метод <code class="inline">changeScore()</code>, при помощи которого должен будет обновиться счет очков после нажатия кнопки <strong>Change Score</strong>. Похоже, что при этом счет обновляется корректно, однако в консоли выводится следующее предупреждение Vue:</p><blockquote>[предупреждение Vue]: избегайте непосредственного изменения значения пропа, поскольку значение будет перезаписываться каждый раз при повторном вычислении значений характеристик родительского компонента.  Вместо этого используйте свойство объекта, возвращаемого функцией data, или свойством computed (* от англ. вычисленный, рассчитанный; используется при реализации какой-либо сложной логики, чтобы шаблоны оставались простыми и описательными), значение которого определяется на основании значения пропа. Проп, значение которого было изменено: "score"<br></blockquote><p>Как вы видите, Vue сообщает нам, что значение пропа будет перезаписываться при повторном вычислении значений характеристик родительского компонента. Давайте проверим, так ли это, за счет симулирования этой ситуации при помощи встроенного метода <code class="inline">$forceUpdate()</code>:<br></p><pre class="brush: javascript noskimlinks noskimwords">Vue.component("ParentA",{  template:`    &lt;div id="parent-a"&gt;      &lt;h2&gt;Parent A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;button @click="reRender"&gt;Rerender Parent&lt;/button&gt;      &lt;hr/&gt;      &lt;child-a :score="score"/&gt;      &lt;child-b/&gt;    &lt;/div&gt;`,  data() {    return {      score: 100    }  },  methods: {    reRender() {      this.$forceUpdate();    }  }})</pre><p><span>Пример на CodePen</span></p><p>Теперь, когда мы изменяем счет и затем нажимаем кнопку <strong>Rerender Parent</strong>, то видим, что счет возвращается к изначальному значению, заданному в родительском компоненте. Так что Vue говорит правду!</p><p>Тем не менее, помните, что массивы и объекты, заданные в дочерних компонентах, <em>будут</em> влиять на родительские компоненты, поскольку они не копируются, а передаются по ссылке.</p><p>Так что, когда нам необходимо изменить значение пропа в дочернем компоненте, имеется два способа избежать этого побочного эффекта (* изменение глобальных значений переменных или состояния вычислительной среды при выполнении подпрограммы или функции), возникающего при повторном вычислении значений характеристик родительского компонента.</p><h4>Изменение значения пропа при помощи свойства объекта, возвращаемого функцией data</h4><p>Первым способ заключается в том, чтобы заменить переменную <code class="inline">score</code> на локальное свойство (<code class="inline">localScore</code>) объекта, возвращаемого функцией data, которое мы можем использовать в методе <code class="inline">changeScore()</code> и в шаблоне:</p><pre class="brush: javascript noskimlinks noskimwords">Vue.component("ChildA",{  template:`    &lt;div id="child-a"&gt;      &lt;h2&gt;Child A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;button @click="changeScore"&gt;Change Score&lt;/button&gt;      &lt;span&gt;Score: {{ localScore }}&lt;/span&gt;    &lt;/div&gt;`,  props: ["score"],  data() {    return {      localScore: this.score    }  },  methods: {    changeScore() {      this.localScore = 200;    }  }})</pre><p><span>Пример на CodePen</span></p><p>Теперь, если мы нажмем кнопку <strong>Rerender Parent</strong> снова, после того как изменили счет, то увидим, что в этот раз счет остается тем же.</p><h4>Изменение значения пропа при помощи свойства сomputed</h4><p>Второй способ заключается в том, чтобы воспользоваться переменной <code class="inline">score</code> в свойстве computed, где его значение будет изменено на новое.</p><pre class="brush: javascript noskimlinks noskimwords">Vue.component("ChildA",{  template:`    &lt;div id="child-a"&gt;      &lt;h2&gt;Child A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;span&gt;Score: {{ doubleScore }}&lt;/span&gt;    &lt;/div&gt;`,  props: ["score"],  computed: {    doubleScore() {      return this.score * 2    }  }})</pre><p><span>Пример на CodePen</span><br></p><p>Здесь мы создали метод <code class="inline">doubleScore()</code> объекта computed, при помощи которого значение переменной <code class="inline">score</code> родительского компонента помножается на два, и затем результат отображается в шаблоне. Очевидно, что после нажатия <strong>Rerender Parent</strong> не будет никаких побочных эффектов.</p><h2>Коммуникация типа потомок – родитель</h2><p>Теперь давайте посмотрим, как компоненты могут общаться в обратном направлении.</p><p>Только что мы видели, как изменить проп в дочернем компоненте. Но что если нам нужно его использовать в более чем одном дочернем компоненте? В этом случае нам было бы необходимо изменить проп из его источника в родительском компоненте, чтобы все компоненты, использующие этот проп, были обновлены соответствующим образом. Чтобы это было возможным, во Vue имеются <span>пользовательские события</span>. </p><p>Суть принципа заключается в том, что мы оповещаем родительский компонент об изменении, которое хотим внести, оно происходит в родительском компоненте и отображается за счет переданного пропа. Ниже перечислены шаги, которые необходимо выполнить для совершения этой операции:</p><ol><li>В дочернем компоненте генерируется событие, описывающее изменение, которое мы хотим сделать, следующим образом: <code class="inline">this.$emit("updatingScore", 200)</code>. </li> <li>В родительском компоненте регистрируется обработчик для сгенерированного события следующим образом: <code class="inline">@updatingScore="updateScore"</code>. </li> <li>После возникновения события проп будет обновлен при помощи назначенного метода следующим образом: <code class="inline">this.score = newValue</code>. </li> </ol><p>Давайте разберем полный пример, чтобы лучше понять, как это происходит:<br></p><pre class="brush: javascript noskimlinks noskimwords">Vue.component("ChildA",{  template:`    &lt;div id="child-a"&gt;      &lt;h2&gt;Child A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;button @click="changeScore"&gt;Change Score&lt;/button&gt;      &lt;span&gt;Score: {{ score }}&lt;/span&gt;    &lt;/div&gt;`,  props: ["score"],  methods: {    changeScore() {      this.$emit("updatingScore", 200)  // 1. Emitting    }  }})...Vue.component("ParentA",{  template:`    &lt;div id="parent-a"&gt;      &lt;h2&gt;Parent A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;button @click="reRender"&gt;Rerender Parent&lt;/button&gt;      &lt;hr/&gt;      &lt;child-a :score="score" @updatingScore="updateScore"/&gt;  // 2.Registering      &lt;child-b/&gt;    &lt;/div&gt;`,  data() {    return {      score: 100    }  },  methods: {    reRender() {      this.$forceUpdate()    },    updateScore(newValue) {      this.score = newValue  // 3.Updating    }  }})</pre><p><span>Пример на CodePen</span></p><p>Мы используем встроенный метод <code class="inline">$emit()</code> для генерирования события. Метод принимает два аргумента. В качестве первого аргумента выступает событие, которое хотим сгенерировать, а в качестве второго – новое значение.</p><h3>Модификатор <code class="inline">.sync</code></h3><p>Во Vue вам предлагается <span>модификатор</span> <code class="inline"><span>.sync</span></code>, при помощи которого вышеописанный прием выполняется подобным образом, и мы, возможно, захотим его использовать в качестве краткой формы в некоторых случаях. В этом случае мы используем метод <code class="inline">$emit()</code> немного по-другому. В качестве аргумента события мы передаем <code class="inline">update:score</code> следующим образом: <code class="inline">this.$emit("update:score", 200)</code>. Затем при привязывании пропа <code class="inline">score</code> мы добавляем модификатор <code class="inline">.sync</code> следующим образом: <code class="inline">&lt;child-a :score.sync="score"/&gt;</code>. В компоненте <strong>Parent A</strong> мы удаляем метод <code class="inline">updateScore()</code> и код для регистрации события (<code class="inline">@updatingScore="updateScore"</code>), поскольку они нам более не нужны.</p><pre class="brush: javascript noskimlinks noskimwords">Vue.component("ChildA",{  template:`    &lt;div id="child-a"&gt;      &lt;h2&gt;Child A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;button @click="changeScore"&gt;Change Score&lt;/button&gt;      &lt;span&gt;Score: {{ score }}&lt;/span&gt;    &lt;/div&gt;`,  props: ["score"],  methods: {    changeScore() {      this.$emit("update:score", 200)    }  }})...Vue.component("ParentA",{  template:`    &lt;div id="parent-a"&gt;      &lt;h2&gt;Parent A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;button @click="reRender"&gt;Rerender Parent&lt;/button&gt;      &lt;hr/&gt;      &lt;child-a :score.sync="score"/&gt;      &lt;child-b/&gt;    &lt;/div&gt;`,  data() {    return {      score: 100    }  },  methods: {    reRender() {      this.$forceUpdate()    }  }})</pre><p><span>Пример на CodePen</span></p><h4>Почему бы не воспользоваться <code class="inline">this.$parent</code> и <code class="inline">this.$children</code> для непосредственной коммуникации типа родитель – потомок?</h4><p>Во Vue имеется два метода API, которые предоставляют нам непосредственный доступ к родительским и дочерним компонентам: <code class="inline">this.$parent</code> и <code class="inline">this.$children</code>. По началу может показаться заманчивым использовать их в качестве более быстрой и простой альтернативы пропам и событиям, однако нам не следует этого делать. Это считается плохой практикой, или анти-шаблоном, поскольку при их использовании между родительским и дочерним компонентами образуется тесная связь. В результате получаются неподатливые и ненадежные компоненты, с которыми тяжело работать и которые тяжело отлаживать. Эти методы API редко используются, и на практике нам следует избегать их использования или использовать с осторожностью.</p><h3>Двухсторонняя коммуникация между компонентами</h3><p>Пропы и события передаются в одном направлении. Пропы опускаются вниз, события поднимаются вверх. Однако за счет совместного использования пропов и событий мы можем обеспечить эффективную коммуникацию с выше- и нижерасположенными компонентами дерева компонентов, в результате чего реализуется двухсторонняя привязка данных (* механизм уведомления, связывающий поля свойств (property) управляющего элемента, помещенного в контейнер, с источником (source) данных, напр., полем БД; например, связывание данных с их источником). Именно по этому механизму собственно работает <code class="inline">v-model</code>. </p><h2>Опосредованная коммуникация<br></h2><p>Паттерн коммуникации типа родитель – потомок быстро становится неудобным и непрактичным по мере усложнения нашего приложения. Проблема системы, работающей на основе пропов и событий, заключается в том, что в ней нет промежуточных ступеней и она тесно привязана к дереву компонентов. События во Vue не всплывают (* от внутреннего элемента вверх через родителей), в отличие от нативных событий, и поэтому нам необходимо повторно генерировать их, пока не достигнем целевого компонента. В результате наш код переполняется множеством обработчиков и генераторов событий. Поэтому в более сложных приложениях нам стоит задуматься об использовании шаблона опосредованной коммуникации. </p><p>Давайте рассмотрим схему ниже:</p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=650/uploads/users/2028/posts/32354/image/vuecccross.png" alt="Шаблоны проектирования для коммуникации между компонентами Vue.js..." title="Шаблоны проектирования для коммуникации между компонентами Vue.js..." width="50" height="50"></figure><p>Как вы видите, при этом типе коммуникации, когда она осуществляется между любыми компонентами, каждый компонент может отправлять и/или получать данные от любого другого компонента без необходимости в промежуточных этапах и компонентах.<br></p><p>В следующих разделах мы разберем наиболее распространенные варианты реализации опосредованной коммуникации.</p><h3>Глобальный автобус событий</h3><p>Глобальный автобус событий – образец Vue, который мы используем для генерирования и прослушивания событий. Давайте разберемся с ним на практике.</p><pre class="brush: javascript noskimlinks noskimwords">const eventBus = new Vue () // 1.Declaring...Vue.component("ChildA",{  template:`    &lt;div id="child-a"&gt;      &lt;h2&gt;Child A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;button @click="changeScore"&gt;Change Score&lt;/button&gt;      &lt;span&gt;Score: {{ score }}&lt;/span&gt;    &lt;/div&gt;`,  props: ["score"],  methods: {    changeScore() {      eventBus.$emit("updatingScore", 200)  // 2.Emitting    }  }})...Vue.component("ParentA",{  template:`    &lt;div id="parent-a"&gt;      &lt;h2&gt;Parent A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;button @click="reRender"&gt;Rerender Parent&lt;/button&gt;      &lt;hr/&gt;      &lt;child-a :score="score"/&gt;      &lt;child-b/&gt;    &lt;/div&gt;`,  data() {    return {      score: 100    }  },  created () {    eventBus.$on("updatingScore", this.updateScore)  // 3.Listening  },  methods: {    reRender() {      this.$forceUpdate()    },    updateScore(newValue) {      this.score = newValue    }  }})</pre><p><span>Пример на CodePen</span></p><p>Ниже перечислены шаги, которые необходимо выполнить для создания и использования автобуса событий:</p><ol><li>Объявление нашего автобуса событий, в качестве которого выступает новый образец Vue, следующим образом: <code class="inline">const eventBus = new Vue ()</code> </li> <li>Генерирование события в компоненте, который является его источником, следующим образом: <code class="inline">eventBus.$emit("updatingScore", 200)</code> </li> <li>Прослушивание сгенерированного события в целевом компоненте следующим образом: <code class="inline">eventBus.$on("updatingScore", this.updateScore)</code> </li> </ol><p>В примере кода выше мы удаляем <code class="inline">@updatingScore="updateScore"</code> из дочернего элемента и используем вместо этого зацепку жизненного цикла <code class="inline">created</code> Vue (* каждый экземпляр проходит серию шагов инициализации при создании. Также при этом запускаются зацепки – место в программе, куда можно подсоединить дополнительный код (обычно для расширения её функциональных возможностей), за счет которых у пользователя появляется возможность добавления своего собственного кода на определенных стадиях) для прослушивания события <code class="inline">updatingScore</code>. После возникновения события будет выполнен метод <code class="inline">updateScore()</code>. Также мы можем передать метод для обновления данных в виде анонимной функции:</p><pre class="brush: javascript noskimlinks noskimwords">created () {  eventBus.$on("updatingScore", newValue =&gt; {this.score = newValue})}</pre><p>При помощи шаблона "глобальный автобус событий" может решиться до некоторой степени проблема переполнения кода множеством обработчиков и генераторов событий, однако возникают новые проблемы. Данные приложения могут быть изменены бесследно из любой части приложения. Из-за этого усложняется процесс отладки и тестирования приложения. Для более сложных приложений, в которых дела могут быстро выйти из-под контроля, нам стоит подумать об использовании специального шаблона управления состоянием, например <span>Vuex</span>, за счет которого мы получим возможность более тонко гранулированного (* метафорическое определение (обозначение) процесса или системы для работы с небольшими объектами, например, отдельными битами и байтами, а не с относительно большими объектами, например файлами или записями) контроля, полезные возможности отслеживания изменений и отладки, а также улучшиться структура и организация кода. </p><h3>Vuex</h3><p>Vuex – библиотека для управления состоянием, предназначенная для создания сложных и масштабируемых приложений Vue.js. Код, написанный при помощи Vuex, получается более многословным, однако со временем это может окупиться. В приложении, разработанном при помощи Vuex, для всех компонентов используется централизованное хранилище, за счет чего наши приложения становятся более организованными, прозрачными и легкими для отслеживания изменений и отладки. Хранилище реагирует на всевозможные изменения, за счет чего вносимые нами изменения немедленно отображаются.</p><p>Здесь я дам вам краткое объяснение того, чем является Vuex, а также проиллюстрирую его в контексте рассматриваемого нами в этом руководстве примера. Если вы хотите глубже изучить Vuex, то я вам рекомендую взглянуть на мое специально посвященное этой теме <span>руководство о создании сложных приложений при помощи Vuex</span>.</p><p>Давайте теперь рассмотрим следующую схему:</p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=650/uploads/users/2028/posts/32354/image/vueccvuex.png" alt="Шаблоны проектирования для коммуникации между компонентами Vue.js..." title="Шаблоны проектирования для коммуникации между компонентами Vue.js..." width="50" height="50"></figure><p>Как видите, приложение Vuex состоит из четырех отдельных частей:</p><ul><li> <strong>State</strong> (* Состояние) – место, где мы храним данные нашего приложения.         </li> <li> <strong>Getters</strong> (* Геттеры) – методы для получения состояния хранилища и передачи его компонентам.</li> <li> <strong>Mutations</strong> (* Мутации (скачкообразные изменения)) – фактические и единственные методы для изменения состояния.</li> <li> <strong>Actions</strong> (* Действия) – методы для выполнения асинхронного кода и запуска мутаций.</li> </ul><p>Давайте создадим простое хранилище и посмотрим, как все это работает на практике.</p><pre class="brush: javascript noskimlinks noskimwords">const store = new Vuex.Store({  state: {    score: 100  },  mutations: {    incrementScore (state, payload) {      state.score += payload    }  },  getters: {    score (state){      return state.score    }  },  actions: {    incrementScoreAsync: ({commit}, payload) =&gt; {      setTimeout(() =&gt; {        commit("incrementScore", 100)      }, payload)    }  }})Vue.component("ChildB",{  template:`    &lt;div id="child-b"&gt;      &lt;h2&gt;Child B&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;    &lt;/div&gt;`,})Vue.component("ChildA",{  template:`    &lt;div id="child-a"&gt;      &lt;h2&gt;Child A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;button @click="changeScore"&gt;Change Score&lt;/button&gt;      &lt;span&gt;Score: {{ score }}&lt;/span&gt;    &lt;/div&gt;`,  computed: {    score () {      return store.getters.score;    }  },  methods: {    changeScore (){      store.commit("incrementScore", 100)    }  }})Vue.component("ParentB",{  template:`    &lt;div id="parent-b"&gt;      &lt;h2&gt;Parent B&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;button @click="changeScore"&gt;Change Score&lt;/button&gt;      &lt;span&gt;Score: {{ score }}&lt;/span&gt;    &lt;/div&gt;`,  computed: {    score () {      return store.getters.score;    }  },  methods: {    changeScore (){      store.dispatch("incrementScoreAsync", 3000);    }  }})Vue.component("ParentA",{  template:`    &lt;div id="parent-a"&gt;      &lt;h2&gt;Parent A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;child-a/&gt;      &lt;child-b/&gt;    &lt;/div&gt;`,})Vue.component("GrandParent",{  template:`    &lt;div id="grandparent"&gt;      &lt;h2&gt;Grand Parent&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;parent-a/&gt;      &lt;parent-b/&gt;    &lt;/div&gt;`,})new Vue ({  el: "#app",})</pre><p><span>Пример на CodePen</span></p><p>В хранилище у нас имеется следующее:</p><ul><li>Переменная <code class="inline">score</code>, значение которой задано в объекте состояния.</li> <li>Мутация <code class="inline">incrementScore()</code>, при помощи которой значение счета будет увеличено на переданное значение.</li> <li>Геттер <code class="inline">score()</code>, при помощи которого значение переменной <code class="inline">score</code> будет получено из состояния и передано компонентам.</li> <li>Действие <code class="inline">incrementScoreAsync()</code>, в котором будет использована мутация <code class="inline">incrementScore()</code> для увеличения значение счета по истечении переданного периода времени. </li> </ul><p>В образце Vue мы используем вместо пропов свойства объекта computed для получения значения счета при помощи геттеров. Затем для изменения счета в компоненте <strong>Child A</strong> мы используем мутацию <code class="inline">store.commit("incrementScore", 100)</code>. В компоненте <strong>Parent B</strong> мы используем действие <code class="inline">store.dispatch("incrementScoreAsync", 3000)</code>. </p><h3>Внедрение зависимости</h3><p>Перед тем как завершить, давайте разберем еще один шаблон. Он используется, главным образом, при работе с библиотеками общедоступных компонентов, однако его стоит упомянуть для полноты картины.</p><p><span>За счет внедрения зависимости</span> мы можем определить сервис при помощи свойства <code class="inline">provide</code>, которое должно являться функцией или объектом, возвращающим объект, и сделать его доступным для всех дочерних компонентов родительского компонента, а не только для его непосредственных дочерних компонентов. Затем мы можем использовать этот сервис при помощи свойства <code class="inline">inject</code>.</p><p>Давайте посмотрим, как это выглядит в действии:</p><pre class="brush: javascript noskimlinks noskimwords">Vue.component("ChildB",{  template:`    &lt;div id="child-b"&gt;      &lt;h2&gt;Child B&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;span&gt;Score: {{ score }}&lt;/span&gt;    &lt;/div&gt;`,  inject: ["score"]})Vue.component("ChildA",{  template:`    &lt;div id="child-a"&gt;      &lt;h2&gt;Child A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;span&gt;Score: {{ score }}&lt;/span&gt;    &lt;/div&gt;`,  inject: ["score"],})Vue.component("ParentB",{  template:`    &lt;div id="parent-b"&gt;      &lt;h2&gt;Parent B&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;span&gt;Score: {{ score }}&lt;/span&gt;    &lt;/div&gt;`,  inject: ["score"]})Vue.component("ParentA",{  template:`    &lt;div id="parent-a"&gt;      &lt;h2&gt;Parent A&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;span&gt;Score: {{ score }}&lt;/span&gt;      &lt;child-a/&gt;      &lt;child-b/&gt;    &lt;/div&gt;`,  inject: ["score"],  methods: {    reRender() {      this.$forceUpdate()    }  }})Vue.component("GrandParent",{  template:`    &lt;div id="grandparent"&gt;      &lt;h2&gt;Grand Parent&lt;/h2&gt;      &lt;pre&gt;data {{ this.$data }}&lt;/pre&gt;      &lt;hr/&gt;      &lt;parent-a/&gt;      &lt;parent-b/&gt;    &lt;/div&gt;`,  provide: function () {    return {      score: 100    }  }})new Vue ({  el: "#app",})</pre><p><span>Пример на CodePen</span></p><p>За счет опции <code class="inline">provide</code> компонента <strong>GrandParent</strong> переменная <code class="inline">score</code> становится доступной для всех его дочерних компонентов. Каждый из них может получить доступ к ней за счет объявления свойства <code class="inline">inject: ["score"]</code>. И, как вы видите, счет отображается во всех компонентах. </p><p>Обратите внимание: Привязанные при помощи внедрения зависимости данные не реагируют на изменения. Так что, если мы хотим, чтобы сделанные нами в компоненте, предоставляющем данные для внедрения, изменения отображались в его дочерних компонентах, мы должны присвоить объект свойству объекта, возвращаемого функцией data, и использовать этот объект в предоставленном сервисе.</p><h4>Почему бы не воспользоваться <code class="inline">this.$root</code> для опосредованной коммуникации?</h4><p>Причины, по которым нам не следует использовать <code class="inline">this.$root</code>, подобны тем, что были указаны для описанных выше случаев с использованием <code class="inline">this.$parent</code> и <code class="inline">this.$children</code> – при этом компоненты становятся слишком тесно связанными. Использования любого из этих методов для реализации коммуникации между компонентами следует избегать.</p><h2>Как выбрать подходящий шаблон?</h2><p>Что же, теперь вы в курсе обо всех распространенных методах коммуникации между компонентами. Но как вам понять, какой больше всего подходит для вашего случая?</p><p>Выбор подходящего шаблона зависит от проекта, в котором вы работаете, или от приложения, которое вы хотите создать. Он зависит от сложности и типа вашего приложения. Давайте рассмотрим наиболее распространенные случаи:</p><ul><li>При создании <strong>простых приложений</strong> все, что вам будет необходимо, – пропы и события.</li> <li> При создании <strong>среднемасштабных приложений</strong> вам будут необходимы более гибкие пути коммуникации, например автобус событий и внедрение зависимости.</li> <li>При создании <strong>сложных, крупномасштабных приложений</strong> вам точно понадобятся возможности Vuex как полнофункциональной системы управления состоянием.</li> </ul><p>И последнее. Вы не обязаны использовать никакой из рассмотренных шаблонов лишь потому, что кто-то вам так говорит. Вы запросто можете выбрать и использовать любой шаблон, который хотите, пока ваше приложение остается в рабочем состоянии, удобным в сопровождении и легко масштабируемым.<br></p><h2>Заключение</h2><p>В этом руководстве мы разобрали наиболее распространенные шаблоны проектирования для коммуникации между компонентами. Мы увидели, как их реализовать на практике и как выбрать наиболее подходящий для нашего проекта. За счет этого будет гарантировано, что в созданном нами приложении используется подходящих тип коммуникации между компонентами, благодаря чего оно становится полностью рабочим, масштабируемым и удобным в сопровождении и тестировании. </p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824706-shablony-proektirovaniya-dlya-kommunikatsii-mezhdu-komponentami-vuejs" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Vue" href="https://norma-studio.github.io/article/220824706-shablony-proektirovaniya-dlya-kommunikatsii-mezhdu-komponentami-vuejs" class="tm-article-body__tags-item-link">Vue</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
43582</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
411</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

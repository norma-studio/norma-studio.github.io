
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Создание безупречной карусели. Часть 3... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Создание безупречной карусели. Часть 3... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Создание безупречной карусели. Часть 3... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Создание безупречной карусели. Часть 3... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Это третья и последняя часть серии руководств ">
<meta property="og:description" content="Это третья и последняя часть серии руководств ">
<meta name="twitter:description" content="Это третья и последняя часть серии руководств ">
<meta property="aiturec:description" content="Это третья и последняя часть серии руководств ">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=800/uploads/users/1875/posts/29636/image/netflixkeyboardfail.jpg">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=800/uploads/users/1875/posts/29636/image/netflixkeyboardfail.jpg">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=800/uploads/users/1875/posts/29636/image/netflixkeyboardfail.jpg">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=800/uploads/users/1875/posts/29636/image/netflixkeyboardfail.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=800/uploads/users/1875/posts/29636/image/netflixkeyboardfail.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article/220824854-sozdanie-bezuprechnoi-karuseli-chast-3.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article/220824854-sozdanie-bezuprechnoi-karuseli-chast-3.html">
<link rel="canonical" href="https://norma-studio.github.io/article/220824854-sozdanie-bezuprechnoi-karuseli-chast-3.html">
<meta property="og:url" content="https://norma-studio.github.io/article/220824854-sozdanie-bezuprechnoi-karuseli-chast-3.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article/220824854-sozdanie-bezuprechnoi-karuseli-chast-3.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article/220824854-sozdanie-bezuprechnoi-karuseli-chast-3.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article/220824854-sozdanie-bezuprechnoi-karuseli-chast-3.html" title="Создание безупречной карусели. Часть 3... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Создание безупречной карусели. Часть 3... | envatomarket.ru | norma-studio.github.io" title="Создание безупречной карусели. Часть 3... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/636536435.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article/220824854-sozdanie-bezuprechnoi-karuseli-chast-3.html" class="tm-user-info__username" title="
С. Торгашев" aria-label="
С. Торгашев">
С. Торгашев</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Создание безупречной карусели. Часть 3...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824854-sozdanie-bezuprechnoi-karuseli-chast-3" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="JavaScript" href="https://norma-studio.github.io/article/220824854-sozdanie-bezuprechnoi-karuseli-chast-3" class="tm-article-snippet__hubs-item-link"><span>JavaScript</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article/220824854-sozdanie-bezuprechnoi-karuseli-chast-3.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=800/uploads/users/1875/posts/29636/image/netflixkeyboardfail.jpg">
    <meta itemprop="headline name" content="Создание безупречной карусели. Часть 3... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Это третья и последняя часть серии руководств ">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Это третья и последняя часть серии руководств </span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Это третья и последняя часть серии руководств "Создание безупречной карусели". В <span>первой части</span> мы оценили карусели на сайтах Netflix и Amazon, две из наиболее активно используемых каруселей в мире. Мы создали карусель и реализовали возможность ее прокрутки при помощи касаний пальцами.</p><p>Затем во <span>второй части</span> мы добавили возможность прокрутки контента по горизонтали, пагинации и индикатор хода процесса. Оп, и готово.</p><p>Теперь, в последней части серии, мы заглянем в тяжелый для понимания и часто упускаемый мир возможности управления каруселью при помощи клавиатуры. Мы внесем поправки в код для выполнения перерасчета размера карусели при изменении размера окна просмотра (* видимая для пользователя область веб-страницы. Здесь и далее примеч. пер.). И, наконец, мы добавим несколько последних штрихов при помощи эффекта усилия пружины.</p><p>Вы можете освежить в памяти, где мы остановились, посетив<span> этот Pen</span> (* фрагмента кода) на Codepen.</p><h2>Возможность управления каруселью при помощи клавиатуры</h2><p>Действительно, большинство пользователей не используют клавиатуру для навигации, поэтому, к сожалению, мы иногда забываем о тех, кто использует. В некоторых странах недоступность веб-сайта для некоторых категорий населения может рассматриваться как <span>противоправное действие</span>. Еще хуже то, что это подлый поступок.</p><p>Хорошая новость заключается в том, что эту возможность обычно легко реализовать! На самом деле браузера делают большую часть работы за нас. Серьезно: попробуйте попереходить по элементам созданной нами карусели при помощи клавиши табуляции. Поскольку мы воспользовались смысловой HTML-разметкой (* когда сами элементы до некоторой степени подсказывают, что за контент в них находится), то вы уже можете!</p><p>Однако вы заметите, что наши навигационные кнопки пропадают. Это так, поскольку браузер не позволяет сфокусироваться на элементе, который располагается за пределами нашего окна просмотра. Поэтому, несмотря на то что мы задали правило <code class="inline">overflow: hidden</code>, мы не можем прокрутить карусель по горизонтали; в ином случае она и правду будет прокручиваться для показа элемента в фокусе.</p><p>Это нормально, и такое решение считалось бы, на мой взгляд, «работоспособным», хотя и не совсем восхитительным.</p><p>Карусель на Netflix работает таким же образом. Однако поскольку большинство их заголовков подгружаются по мере необходимости (* по мере прокручивания пользователем страницы), а также имеется пассивная возможность их просмотра при помощи клавиатуры (то есть они не писали специально никакого кода для реализации этой возможности), мы не можем собственно получить никаких заголовков за исключением тех, что уже загрузились. Это также выглядит ужасно: </p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=800/uploads/users/1875/posts/29636/image/netflixkeyboardfail.jpg" alt="Создание безупречной карусели. Часть 3..." title="Создание безупречной карусели. Часть 3..." width="50" height="50"></figure><p>Мы можем сделать лучше.</p><h3>Обработка события <code class="inline">focus</code></h3><p>Для этого мы будем прослушивать событие <code class="inline">focus</code>, возникающее при фокусировании любого элемента карусели. При попадании элемента в фокус мы запросим у него его позицию. Затем мы сверим это значение со <code class="inline">sliderX</code> и <code class="inline">sliderVisibleWidth</code>, чтобы узнать, находится ли тот элемент в пределах окна просмотра. Если нет, то мы перейдем к нему при помощи того же кода, что написали в части 2.</p><p>В конце функции <code class="inline">carousel</code> добавьте следующий слушатель событий:</p><pre class="brush: javascript noskimlinks noskimwords">slider.addEventListener("focus", onFocus, true);</pre><p>Вы заметите, что мы передали третий аргумент, <code class="inline">true</code>. Вместо назначения обработчика событий каждому элементу мы можем воспользоваться приемом разработки под названием <span>делегирование событий</span>, чтобы прослушивать события, возникающие только для одного элемента, их прямого предка. Событие <code class="inline">focus</code> не всплывает, поэтому при помощи <code class="inline">true</code> обработчику дается указание прослушивать событие на стадии <em>перехвата</em>, стадии, когда событие возникает для каждого элемента, начиная с <code class="inline">window</code> до целевого элемента (в нашем случае это элемент, попавший в фокус).</p><p>Выше нашего растущего набора обработчиков добавьте функцию <code class="inline">onFocus</code>:</p><pre class="brush: javascript noskimlinks noskimwords">function onFocus(e) {}</pre><p>Мы будем работать в этой функции до конца текущего раздела.</p><p>Нам необходимо измерить отступы левой и правой сторон элемента и проверить, лежит ли какое-либо из этих значений за пределами текущей области просмотра.</p><p>Мы получаем целевой элемент при помощи свойства <code class="inline">target</code> события и можем измерить его за счет <code class="inline">getBoundingClientRect</code>: </p><pre class="brush: javascript noskimlinks noskimwords">const { left, right } = e.target.getBoundingClientRect();</pre><p>Значения <code class="inline">left</code> и <code class="inline">right</code> заданы относительно <em>окна просмотра</em>, а не карусели. Так что нам необходимо получить отступ левой стороны контейнера карусели, чтобы учесть это. В нашем примере это будет <code class="inline">0</code>, но для того чтобы карусель была надежной, необходимо, чтобы учитывалось то, что она может быть помещена где угодно.<br></p><pre class="brush: javascript noskimlinks noskimwords">const carouselLeft = container.getBoundingClientRect().left;</pre><p>Далее мы можем просто проверить, располагается ли элемент за пределами видимой области карусели, и перейти в том направлении:</p><pre class="brush: javascript noskimlinks noskimwords">if (left &lt; carouselLeft) {  gotoPrev();} else if (right &gt; carouselLeft + sliderVisibleWidth) {  gotoNext();}</pre><p>Теперь, при нажатии клавиши табуляции, в карусели четко происходит переход по элементам при помощи нашей клавиатурной фокусировки (* состояние окна или элемента изображения, при котором они принимают данные с клавиатуры)! Всего лишь несколько строк кода для проявления дополнительной заботы о пользователях.</p><h2>Перерасчет размера карусели</h2><p>Вы, вероятно, заметили по ходу работы с руководством, что при изменении размера окна просмотра вашего браузера переход по элементам карусели уже не работает должным образом. Это так, поскольку мы измерили ширину карусели относительно ее видимой области лишь единожды, в момент инициализации (* установка известного исходного состояния, например присваивание начальных значений переменным).</p><p>Для того чтобы убедиться в том, что наша карусель работает как следует, нам необходимо заменить некоторую часть нашего кода для вычисления размеров на новый обработчик событий, который срабатывает при изменении размеров окна.</p><p>Теперь, недалеко от начала нашей функции <code class="inline">carousel</code>, сразу после строки, где мы определяем <code class="inline">progressBar</code>, нам нужно заменить три из этих результатов вычислений размеров, хранящихся в константах, объявленных при помощи <code class="inline">const</code>, на значения, что хранятся в переменных, объявленных при помощи <code class="inline">let</code>, поскольку они будут меняться при изменениях окна просмотра:</p><pre class="brush: javascript noskimlinks noskimwords">const totalItemsWidth = getTotalItemsWidth(items);const maxXOffset = 0;let minXOffset = 0;let sliderVisibleWidth = 0;let clampXOffset;</pre><p>Затем мы можем переместить логику, при помощи которой ранее вычислялись эти значения размеров, на новую функцию под названием <code class="inline">measureCarousel</code>:</p><pre class="brush: javascript noskimlinks noskimwords">function measureCarousel() {  sliderVisibleWidth = slider.offsetWidth;  minXOffset = - (totalItemsWidth - sliderVisibleWidth);  clampXOffset = clamp(minXOffset, maxXOffset);}</pre><p>Нам необходимо сразу же вызвать эту функцию так, чтобы эти значения по-прежнему задавались при инициализации: Прямо в следующей строке вызовите <code class="inline">measureCarousel</code>:</p><pre class="brush: javascript noskimlinks noskimwords">measureCarousel();</pre><p>Карусель должна работать так же, как и ранее. Для обновления результатов вычисления размеров при изменении размера окна мы просто добавляем следующий обработчик событий в самом конце функции <code class="inline">carousel</code>:</p><pre class="brush: javascript noskimlinks noskimwords">window.addEventListener("resize", measureCarousel);</pre><p>Теперь, если вы измените размер карусели и попробуете попереходить по элементам, то карусель продолжит работать как положено.</p><h3>Примечание по поводу производительности</h3><p>Стоит учитывать, что в реальном мире разработки у вас может быть несколько каруселей на одной и той же странице, из-за чего влияние кода для перерасчета размера карусели на производительность приумножается на их количество.</p><p>Как мы коротко обсудили в части 2, неразумно выполнять ресурсоемкие вычисления чаще, чем это необходимо. Мы сказали, что в случае событий, возникающих при прокрутке и действиях с мышкой, вам нужно, чтобы они выполнялись единожды за фрейм для поддержания частоты смены кадров (* скорость сканирования или вывода на экран видеокадров - дискретных изображений (30 кадр/с в стандарте NTSC и 25 кадр/с в стандарте PAL/SECAM)) на уровне 60 кадров в секунду. События, возникающие при изменении размеров окна, немного отличаются тем, что при их возникновении размеры элементов всего документа будут повторно рассчитаны и некоторые элементы перераспределятся, что представляет из себя, вероятно, наиболее ресурсоемкий момент, который может случиться с веб-страницей.</p><p>Нам не нужно повторно рассчитывать размер карусели до тех пор, пока пользователи не перестали менять размер окна, поскольку они не будут взаимодействовать с ним в это время. Мы можем обернуть нашу функцию <code class="inline">measureCarousel</code> в специальную функцию под названием <em>debounce</em> (* от англ. устранение дребезга).</p><p>При помощи функции debounce по сути сообщается следующее: «Запускать эту функцию только в том случае, если она не вызывалась в течение <code class="inline">x</code> миллисекунд». Вы можете обратиться за дополнительной информацией о debounce к <span>замечательному учебнику для начинающих, написанному David Walsh,</span> а также ознакомиться там с некоторыми примерами кода.</p><h2>Последние штрихи</h2><p>На данный момент у нас получилась довольно хорошая карусель. Она доступна для применения (* атрибут (свойство) программного или аппаратного продукта, характеризующий возможность использовать этот продукт для людей с физическими ограничениями), красиво анимируется, работает на устройствах, управляемых при помощи касаний, и на устройствах, управляемых при помощи мышки, и обладает такой большой гибкостью, которую карусели с изначально имеющейся возможностью прокрутки, не предоставляют.</p><p>Однако это не серия руководств под названием "Создание довольно хорошей карусели". Пришло время немного покрасоваться, и для этого у нас имеется секретное оружие. <em>Эффекты усилия пружин</em>.</p><p>Мы добавим два таких эффекта. Один для случаев, когда каруселью управляют при помощи касаний пальцами, а другой для случаев, когда каруселью управляют при помощи пагинации. Они оба позволят пользователям понять в веселой и увлекательной манере, что они достигли конца карусели.</p><h3>Эффект усилия пружины при касаниях пальцами</h3><p>Для начала давайте добавим дерганье в стиле iOS для случаев, когда пользователь пытается прокрутить карусель за ее пределы. В данный момент мы задаем пределы прокрутки при помощи касаний за счет <code class="inline">clampXOffset</code>. Давайте заменим ее некоторым кодом, за счет которого добавляется дерганье при выходе значения рассчитанного отступа за пределы границ карусели.</p><p>Для начала нам необходимо импортировать <span>преобразовател</span>ь для создания нашей пружины. Имеется преобразователь под названием <code class="inline">nonlinearSpring</code>, за счет которого к позиции, заданной при помощи предоставленного ему нами числа, применяется экспоненциально возрастающая сила по направлению к <code class="inline">origin</code> (* от англ. начало). Это означает, что чем дальше мы тянем карусель, тем быстрее она отскочит обратно.  Мы можем импортировать его следующим образом:</p><pre class="brush: javascript noskimlinks noskimwords">const { applyOffset, clamp, nonlinearSpring, pipe } = transform;</pre><p>В функции <code class="inline">determineDragDirection</code> у нас имеется следующий код:<br></p><pre class="brush: javascript noskimlinks noskimwords">action.output(pipe(  ({ x }) =&gt; x,  applyOffset(action.x.get(), sliderX.get()),  clampXOffset,  (v) =&gt; sliderX.set(v)));</pre><p>Сразу выше него давайте создадим наши две пружины, по одной для каждого предела прокрутки карусели:</p><pre class="brush: javascript noskimlinks noskimwords">const elasticity = 5;const tugLeft = nonlinearSpring(elasticity, maxXOffset);const tugRight = nonlinearSpring(elasticity, minXOffset);</pre><p>Значение <code class="inline">elasticity</code> (* от англ. эластичности) определяется путем экспериментирования и выбора того, что вам подходит. Задайте  его слишком низким, и пружина будет казаться слишком тугой. Задайте его слишком высоким, и вы не заметите ее отскока, или еще хуже, она оттянет карусель еще дальше от пальца пользователя!</p><p>Теперь нам всего лишь необходимо написать простую функцию, при помощи которой будет применена одна из этих двух пружин, если переданное значение находится за пределами допустимого диапазона:</p><pre class="brush: javascript noskimlinks noskimwords">const applySpring = (v) =&gt; {  if (v &gt; maxXOffset) return tugLeft(v);  if (v &lt; minXOffset) return tugRight(v);  return v;};</pre><p>Мы можем заменить <code class="inline">clampXOffset</code> в коде выше на <code class="inline">applySpring</code>. Теперь, если вы оттянете карусель за ее пределы, то она отскочит обратно!</p><p>Но когда мы отпускаем пружину, то она как бы просто отскакивает в исходную позицию. Нам нужно внести изменения в функцию <code class="inline">stopTouchScroll</code>, при помощи которой реализуется возможность инерциальной прокрутки, для проверки того, находится ли карусель по-прежнему за пределами допустимого диапазона, и, если это так, применить вместо ранее добавленной пружину, реализуемую при помощи действия <code class="inline">physics</code> (* каждая анимация Popmotion является действием).</p><h3>Эффект усилия пружины, реализуемый при помощи physics</h3><p>При помощи действия <code class="inline">physics</code> также можно симулировать пружины. Нам лишь необходимо передать этой функции в объекте свойства <code class="inline">spring</code> и <code class="inline">to</code>.</p><p>В <code class="inline">stopTouchScroll</code> переместите имеющийся код для инициализации функции <code class="inline">physics</code>, за счет которой реализуется возможность прокрутки контента при помощи касаний, в часть логики, при помощи которой гарантируется, что мы находимся в пределах прокрутки:<br></p><pre class="brush: javascript noskimlinks noskimwords">const currentX = sliderX.get();if (currentX &lt; minXOffset || currentX &gt; maxXOffset) {  } else {  action = physics({    from: currentX,    velocity: sliderX.getVelocity(),    friction: 0.2  }).output(pipe(    clampXOffset,    (v) =&gt; sliderX.set(v)  )).start();}</pre><p>Мы знаем, что в первой ветви инструкции <code class="inline">if</code> выполняется код для случаев, когда карусель находится за пределами границ прокрутки, так что мы можем добавить нашу пружину:</p><pre class="brush: javascript noskimlinks noskimwords">action = physics({  from: currentX,  to: (currentX &lt; minXOffset) ? minXOffset : maxXOffset,  spring: 800,  friction: 0.92}).output((v) =&gt; sliderX.set(v))  .start();</pre><p>Мы хотим создать эффект усилия тугой и отзывчивой пружины. Я выбрал относительно высокое значение <code class="inline">spring</code> для получения резкого «щелчка» и понизил значение <code class="inline">friction</code> до <code class="inline">0.92</code>, чтобы добавить небольшой отскок. Вы могли бы задать в качестве значения трения <code class="inline">1</code>, чтобы совсем убрать отскок.</p><p>В качестве небольшого домашнего задания попробуйте заменить <code class="inline">clampXOffset</code> в методе <code class="inline">output</code> объекта <code class="inline">physics</code>, за счет которого реализуется возможность прокрутки контента при помощи касаний, на функцию, при помощи которой добавляется подобный эффект пружины, когда отступ по оси Х достигает границ карусели. Вместо имеющейся на данный момент резкой остановки попробуйте сделать так, чтобы она смягчалась в конце.</p><h3>Эффект усилия пружины при пагинации</h3><p>Владельцам устройств, управляемых при помощи касаний, всегда предоставляется крутой эффект усилия пружины, верно? Давайте позаботимся и о пользователях настольных компьютеров, определяя момент, когда карусель находится у границ своей прокрутки, и добавляя подсказывающее дерганье, чтобы четко и ясно показать пользователям, что они находятся в конце.</p><p>Во-первых, нам необходимо сделать так, чтобы кнопки для пагинации становились неактивными по достижении границ прокрутки. Для начала давайте добавим правило CSS, при помощи которого для кнопок задается специальное стилевое оформление, чтобы показать, что они неактивны. В правиле для <code class="inline">button</code> добавьте:</p><pre class="brush: css noskimlinks noskimwords">transition: background 200ms linear;&amp;.disabled {  background: #eee;}</pre><p>Мы используем здесь класс вместо более смыслового атрибута <code class="inline">disabled</code>, поскольку нам по-прежнему нужно, чтобы срабатывали обработчики события click, чему, как следует из имени, <code class="inline">disabled</code> помешало бы.</p><p>Добавьте этот класс <code class="inline">disabled</code> кнопке Prev, поскольку изначально отступ каждой карусели имеет значение <code class="inline">0</code>:<br></p><pre class="brush: html noskimlinks noskimwords">&lt;button class="prev disabled"&gt;Prev&lt;/button&gt;</pre><p>Ближе к верхней части функции <code class="inline">carousel</code> создайте новую функцию под названием <code class="inline">checkNavButtonStatus</code>. Нам нужно, чтобы при помощи этой функция переданное значение просто сравнивалось с <code class="inline">minXOffset</code> и <code class="inline">maxXOffset</code> и соответствующим образом добавлялся класс <code class="inline">disabled</code> кнопки:<br></p><pre class="brush: javascript noskimlinks noskimwords">function checkNavButtonStatus(x) {  if (x &lt;= minXOffset) {    nextButton.classList.add("disabled");  } else {    nextButton.classList.remove("disabled");    if (x &gt;= maxXOffset) {      prevButton.classList.add("disabled");    } else {      prevButton.classList.remove("disabled");    }  }}</pre><p>Заманчиво было бы вызывать ее каждый раз при изменении значения <code class="inline">sliderX</code>. В этом случае кнопки начали бы мигать каждый раз при колебании пружины около границ прокрутки. Также это бы привело к странному поведению карусели, если бы была нажата одна из кнопок во время одного из тех анимационных эффектов усилия пружины. Дерганье «конца прокрутки» должно всегда запускаться при достижении конца карусели, даже если выполняется анимационный эффект усилия пружины, из-за которого она оттягивается от абсолютного конца.</p><p>Так что нам необходимо быть более избирательными насчет того, где вызывать вышеупомянутую функцию. Кажется целесообразным вызывать ее в нижеперечисленных местах:</p><p>В последней строке <code class="inline">onWheel</code> добавьте <code class="inline">checkNavButtonStatus(newX);</code>.</p><p>В последней строке <code class="inline">goto</code> добавьте <code class="inline">checkNavButtonStatus(targetX);</code>.</p><p>И, наконец, в конце <code class="inline">determineDragDirection</code> и в ветви кода для добавления возможности инерциальной прокрутки (код, находящийся в блоке <code class="inline">else</code>) функции <code class="inline">stopTouchScroll</code> замените:</p><pre class="brush: javascript noskimlinks noskimwords">(v) =&gt; sliderX.set(v)</pre><p>На:</p><pre class="brush: plain noskimlinks noskimwords">(v) =&gt; {  sliderX.set(v);  checkNavButtonStatus(v);}</pre><p>Теперь все, что нам осталось, – добавить в функции <code class="inline">gotoPrev</code> и <code class="inline">gotoNext</code> код для проверки наличия класса <code class="inline">disabled</code> в classList кнопок, при помощи которых они запускаются, и выполнить пагинацию только в том случае, если он отсутствует:</p><pre class="brush: javascript noskimlinks noskimwords">const gotoNext = (e) =&gt; !e.target.classList.contains("disabled")  ? goto(1)  : notifyEnd(-1, maxXOffset);const gotoPrev = (e) =&gt; !e.target.classList.contains("disabled")  ? goto(-1)  : notifyEnd(1, minXOffset);</pre><p>При помощи функции <code class="inline">notifyEnd</code> создается просто еще одна пружина, реализуемая при помощи <code class="inline">physics</code>, и она выглядит следующим образом:</p><pre class="brush: plain noskimlinks noskimwords">function notifyEnd(delta, targetOffset) {  if (action) action.stop();  action = physics({    from: sliderX.get(),    to: targetOffset,    velocity: 2000 * delta,    spring: 300,    friction: 0.9  })    .output((v) =&gt; sliderX.set(v))    .start();}</pre><p>Поэкспериментируйте с ней и, опять-таки, подгоните значения аргументов <code class="inline">physics</code>, как вам нужно.</p><p>Остался только один небольшой баг. При оттягивании карусели за пределы крайней левой границы индикатор хода процесса поворачивается в обратном направлении. Мы можем это быстро исправить, заменив:</p><pre class="brush: javascript noskimlinks noskimwords">progressBarRenderer.set("scaleX", progress);</pre><p>На:</p><pre class="brush: javascript noskimlinks noskimwords">progressBarRenderer.set("scaleX", Math.max(progress, 0));</pre><p>Мы <em>могли бы</em> предотвратить продвижение индикатора и в другое направление, однако лично мне кажется крутым то, что он отображает движение пружины. Просто кажется странным, когда он переворачивается.</p><h2>Прибираем за собой</h2><p>В случае одностраничных приложений веб-контент остается дольше в сессии пользователя (* по сравнению с обычными). Часто бывает так, что при изменении страницы по-прежнему остается запущенной та же среда исполнения JS, что и при начальной загрузке. Мы не можем рассчитывать на наличие чистого состояния при каждом переходе пользователя по ссылке, и это означает, что мы должны прибрать за собой, чтобы предотвратить срабатывание обработчиков событий, зарегистрированных для мертвых элементов.</p><p>В React код для этого помещен в метод <code class="inline">componentWillLeave</code>. Во Vue с этой целью используется <code class="inline">beforeDestroy</code>. В этой серии руководств мы реализуем карусель только при помощи JS, однако мы по-прежнему можем предоставить метод для отвязывания обработчиков, которых работал бы сходным образом в любом фреймворке.</p><p>На данный момент функция <code class="inline">carousel</code> ничего не вернула. Давайте это изменим.</p><p>Для начала давайте изменим последнюю строку, в которой происходит вызов <code class="inline">carousel</code>, на:</p><pre class="brush: javascript noskimlinks noskimwords">const destroyCarousel = carousel(document.querySelector(".container"));</pre><p>Мы вернем из <code class="inline">carousel</code> только функцию, при помощи которой отвязываются все обработчики событий. В самом конце функции <code class="inline">carousel</code> добавьте следующий код:</p><pre class="brush: javascript noskimlinks noskimwords">return () =&gt; {  container.removeEventListener("touchstart", startTouchScroll);  container.removeEventListener("wheel", onWheel);  nextButton.removeEventListener("click", gotoNext);  prevButton.removeEventListener("click", gotoPrev);  slider.removeEventListener("focus", onFocus);  window.removeEventListener("resize", measureCarousel);};</pre><p>Теперь, если вы вызовите <code class="inline">destroyCarousel</code> и попробуете поиграться с каруселью, то ничего не произойдет! Немного печально видеть ее в таком состоянии.</p><h2>И на этом все!</h2><p>Фух-х-х. Мы со многим разобрались! Что у нас получилось. Вы можете ознакомиться с конечным результатом, посетив<span> этот Pen на Codepen</span>. В этой последней части мы добавили возможность управления каруселью при помощи клавиатуры, возможность перерасчета размера карусели при изменении размера окна просмотра, несколько прикольных дополнений, реализованных при помощи эффекта усилия пружины, и огорчительный, но обязательный этап разрушения всего созданного.</p><p>Надеюсь, что вам понравилось работать с этим руководством так же, как и мне писать его. Я бы хотел услышать ваши мысли по поводу дальнейших способов улучшения доступности применения или добавления дополнительных прикольных небольших штрихов.</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824854-sozdanie-bezuprechnoi-karuseli-chast-3" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="JavaScript" href="https://norma-studio.github.io/article/220824854-sozdanie-bezuprechnoi-karuseli-chast-3" class="tm-article-body__tags-item-link">JavaScript</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
42327</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
430</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

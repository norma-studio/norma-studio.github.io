
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Котлин с нуля: классы и объекты... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Котлин с нуля: классы и объекты... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Котлин с нуля: классы и объекты... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Котлин с нуля: классы и объекты... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Kotlin - это современный язык программирования, который компилируется в байт-код Java. Он бесплатный и с открытым исходным кодом, и обещает сделать кодирование для Android еще более увлекательным. ...">
<meta property="og:description" content="Kotlin - это современный язык программирования, который компилируется в байт-код Java. Он бесплатный и с открытым исходным кодом, и обещает сделать кодирование для Android еще более увлекательным. ...">
<meta name="twitter:description" content="Kotlin - это современный язык программирования, который компилируется в байт-код Java. Он бесплатный и с открытым исходным кодом, и обещает сделать кодирование для Android еще более увлекательным. ...">
<meta property="aiturec:description" content="Kotlin - это современный язык программирования, который компилируется в байт-код Java. Он бесплатный и с открытым исходным кодом, и обещает сделать кодирование для Android еще более увлекательным. ...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1499/posts/29328/preview_image/kotlin.jpg">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1499/posts/29328/preview_image/kotlin.jpg">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1499/posts/29328/preview_image/kotlin.jpg">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1499/posts/29328/preview_image/kotlin.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1499/posts/29328/preview_image/kotlin.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article/220824576-kotlin-s-nulya-klassy-i-obekty.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article/220824576-kotlin-s-nulya-klassy-i-obekty.html">
<link rel="canonical" href="https://norma-studio.github.io/article/220824576-kotlin-s-nulya-klassy-i-obekty.html">
<meta property="og:url" content="https://norma-studio.github.io/article/220824576-kotlin-s-nulya-klassy-i-obekty.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article/220824576-kotlin-s-nulya-klassy-i-obekty.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article/220824576-kotlin-s-nulya-klassy-i-obekty.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article/220824576-kotlin-s-nulya-klassy-i-obekty.html" title="Котлин с нуля: классы и объекты... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Котлин с нуля: классы и объекты... | envatomarket.ru | norma-studio.github.io" title="Котлин с нуля: классы и объекты... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/54332343.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article/220824576-kotlin-s-nulya-klassy-i-obekty.html" class="tm-user-info__username" title="
В. Бухтеев" aria-label="
В. Бухтеев">
В. Бухтеев</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Котлин с нуля: классы и объекты...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824576-kotlin-s-nulya-klassy-i-obekty" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Kotlin" href="https://norma-studio.github.io/article/220824576-kotlin-s-nulya-klassy-i-obekty" class="tm-article-snippet__hubs-item-link"><span>Kotlin</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article/220824576-kotlin-s-nulya-klassy-i-obekty.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1499/posts/29328/preview_image/kotlin.jpg">
    <meta itemprop="headline name" content="Котлин с нуля: классы и объекты... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Kotlin - это современный язык программирования, который компилируется в байт-код Java. Он бесплатный и с открытым исходным кодом, и обещает сделать кодирование для Android еще более увлекательным. ...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Kotlin - это современный язык программирования, который компилируется в байт-код Java. Он бесплатный и с открытым исходным кодом, и обещает сделать кодирование для Android еще более увлекательным. ...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p><span>Kotlin</span> - это современный язык программирования, который компилируется в байт-код Java. Он бесплатный и с <span>открытым</span> <span>исходным кодом</span>, и обещает сделать кодирование для Android еще более увлекательным. <br></p><p>В <span>предыдущей статье</span> вы узнали о расширенном использовании функций, таких как функции расширения, смыкания, функции высшего порядка и встроенные функции в Kotlin. </p><p>В этой статье вы познакомитесь с объектно-ориентированным программированием в Kotlin, изучив классы: конструкторы и свойства, приведение типов и более продвинутые функции классов, которые Kotlin упрощает. </p><h2>  <span class="sectionnum">1.</span> Классы</h2><p>Класс - это программный блок, который группирует функции и данные для выполнения некоторых связанных задач. Мы объявляем класс в Kotlin, используя ключевое слово <code class="inline">class</code> - аналогично Java. </p><pre class="brush: java noskimlinks noskimwords">class Book</pre><p>Предыдущий код - самое простое объявление класса - мы только что создали пустой класс с именем <code class="inline">Book</code>. Мы все еще можем создать экземпляр этого класса, даже если он не содержит тела, используя конструктор по умолчанию.</p><pre class="brush: java noskimlinks noskimwords">val book = Book()</pre><p>Как вы можете заметить в приведенном выше коде, мы не использовали ключевое слово <code class="inline">new</code> для создания экземпляра этого класса - как обычно в других языках программирования. <code class="inline">new</code> не ключевое слово в Kotlin. Это делает наш исходный код сжатым при создании экземпляра класса. Но имейте в виду, что создание экземпляра класса Kotlin в Java потребует <code class="inline">нового</code> ключевого слова. </p><pre class="brush: java noskimlinks noskimwords">// In a Java fileBook book = new Book()</pre><h3>Конструкторы класса и свойства</h3><p>Давайте посмотрим, как добавить конструктор и свойства в наш класс. Но сначала давайте посмотрим на типичный класс в Java:</p><pre class="brush: java noskimlinks noskimwords">/* Java */public class Book  {    private String title;    private Long isbn;    public Book(String title, Long isbn) {        this.title = title;        this.isbn = isbn;    }    public String getTitle() {        return title;    }    public void setTitle(String title) {        this.title = title;    }    public Long getIsbn() {        return isbn;    }    public void setIsbn(Long isbn) {        this.isbn = isbn;    }}</pre><p>Глядя на наш класс модели <code class="inline">Book</code> выше, мы имеем следующее:</p><ul><li>два поля: <code class="inline">title</code> и <code class="inline">isbn</code> </li> <li> один конструктор</li> <li>методы получения и установки для двух полей (к счастью, IntelliJ IDEA может помочь нам сгенерировать эти методы)</li> </ul><p>Теперь давайте посмотрим, как вместо этого можно написать предыдущий код на Kotlin:</p><pre class="brush: java noskimlinks noskimwords">/* Kotlin */class Book {    var title: String    var isbn: Long    constructor(title: String, isbn: Long) {        this.title = title        this.isbn = isbn    }}</pre><p>Довольно аккуратный класс! Теперь мы сократили количество строк кода с 20 до просто 9. Функция <code class="inline">constructor()</code> называется <em>вторичным конструктором</em> в Kotlin. Этот конструктор эквивалентен конструктору Java, который мы вызывали при создании экземпляра класса. </p><p>В Котлине нет понятия поля, с которым вы, возможно, знакомы; вместо этого он использует понятие «свойства». Например, у нас есть два изменяемых свойства (чтение-запись), объявленных с ключевым словом <code class="inline">var</code>: <code class="inline">title</code> и <code class="inline">isbn</code> в классе <code class="inline">Book</code>. (Если вам нужно освежить в памяти переменные в Kotlin, пожалуйста, посетите первый пост в этой серии: <span>Variables, Basic Types, и Arrays</span>). </p><ul class="roundup-block__contents posts--half-width roundup-block--list"><li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1499/posts/29328/preview_image/kotlin.jpg" alt="Котлин с нуля: классы и объекты..." title="Котлин с нуля: классы и объекты..." width="50" height="50"><div class="roundup-block__primary-category topic-code">Kotlin</div> <div class="roundup-block__content-title">Kotlin от Scratch: Variables, Basic Types, и Arrays</div> <div class="roundup-block__author">Chike Mgbemena </div></span></li></ul><p>Удивительно, что геттеры и сеттеры для этих свойств автоматически генерируются для нас компилятором Kotlin. Обратите внимание, что мы не указали никаких модификаторов видимости для этих свойств - поэтому по умолчанию они общедоступны. Другими словами, к ним можно получить доступ откуда угодно.</p><p>Давайте посмотрим на другую версию того же класса в Kotlin:</p><pre class="brush: java noskimlinks noskimwords">class Book constructor(title: String, isbn: Long) {    var title: String    var isbn: Long    init {       this.title = title       this.isbn = isbn    }}</pre><p>В этом коде мы удалили вторичный конструктор. Вместо этого мы объявили конструктор в заголовке класса, который называется <em>первичным конструктором</em>. Первичный конструктор не имеет места для размещения блока кода, поэтому мы используем модификатор <code class="inline">init</code> для инициализации входящих параметров из первичного конструктора. Обратите внимание, что блок <code class="inline">init</code> кода инициализации выполняется сразу при создании экземпляра класса.</p><p>Как вы можете видеть, наш код все еще содержит много шаблонов. Давайте уменьшим это далее:</p><pre class="brush: java noskimlinks noskimwords">class Book constructor(var title: String, var isbn: Long)</pre><p>Наш класс <code class="inline">Book</code> теперь представляет собой всего одну строку кода. Это действительно круто! Обратите внимание, что в списке параметров первичного конструктора мы определили наши изменяемые свойства: <code class="inline">title</code> и <code class="inline">isbn</code> непосредственно внутри первичного конструктора с ключевым словом <code class="inline">var</code>. </p><p>Мы также можем добавить значения по умолчанию к любому из свойств класса прямо внутри конструктора.</p><pre class="brush: java noskimlinks noskimwords">class Book constructor(var title: String = "default value", var isbn: Long)</pre><p>Фактически, мы также можем опустить ключевое слово <code class="inline">constructor</code>, но только если у него нет модификатора видимости (<code class="inline">public</code>, <code class="inline">private</code> или <code class="inline">protected</code>) или каких-либо аннотаций. </p><pre class="brush: java noskimlinks noskimwords">class Book (var title: String = "default value", var isbn: Long)</pre><p>Очень аккуратный класс, должен сказать!</p><p>Теперь мы можем создать экземпляр класса следующим образом:</p><pre class="brush: java noskimlinks noskimwords">val book = Book("A Song of Ice and Fire", 9780007477159)val book2 = Book(1234) // uses the title property"s default value</pre><h3> Доступ и настройка свойств </h3><p>В Kotlin мы можем получить свойство с помощью <code class="inline">book</code> объектов класса, за которой следует разделитель <code class="inline">.</code> , а затем <code class="inline">title</code> имени свойства. Этот краткий стиль доступа к свойствам называется <em>синтаксисом доступа к свойствам</em>. Другими словами, нам не нужно вызывать метод получения свойства для доступа или вызывать метод установки для установки свойства в Kotlin - как мы делаем в Java. <br></p><pre class="brush: java noskimlinks noskimwords">println(book.title) // "A Song of Ice and Fire"</pre><p>Поскольку свойство <code class="inline">isbn</code> объявлено с ключевым словом <code class="inline">var</code> (чтение-запись), мы также можем изменить значение свойства, используя оператор присваивания <code class="inline">=</code>.</p><pre class="brush: java noskimlinks noskimwords">book.isbn = 1234println(book.isbn) // 1234</pre><p>Давайте посмотрим на другой пример:<br></p><pre class="brush: java noskimlinks noskimwords">class Book (    var title: String,     val isbn: Long)val book = Book("A Song of Ice and Fire", 9780007477159)book.isbn = 1234 // error: read-only propertybook.title = "Things Fall Apart" // reassigned title with value</pre><p>Здесь мы обновили параметр <code class="inline">isbn</code>, чтобы он стал неизменным (только для чтения) - с помощью ключевого слова <code class="inline">val</code>. Мы создали экземпляр экземпляра <code class="inline">book</code> класса и присвоили свойству <code class="inline">title</code> значение «Things Fall Apart». Обратите внимание, что когда мы попытались переназначить значение свойства <code class="inline">isbn</code> на <code class="inline">1234</code>, компилятор пожаловался. Это связано с тем, что свойство является неизменным, поскольку оно определено с помощью ключевого слова <code class="inline">val</code>. </p><h3> Совместимость Java</h3><p>Имейте в виду, что, объявив параметр с модификатором <code class="inline">var</code> внутри основного конструктора, компилятор Kotlin (за кулисами) помог нам сгенерировать оба метода доступа: getter и setter. Если вы используете <code class="inline">val</code>, он будет генерировать только геттер. </p><pre class="brush: java noskimlinks noskimwords">/* Kotlin */class Book (    var title: String,     val isbn: Long)</pre><p>Это означает, что Java-вызывающие пользователи могут просто получить или установить поле свойства, вызвав метод setter или getter свойства соответственно. Помните, это зависит от модификатора, используемого для определения свойства Kotlin: <code class="inline">var</code> или <code class="inline">val</code>. </p><pre class="brush: java noskimlinks noskimwords">/* Java */Book book = new Book("A Song of Ice and Fire", 9780385474542)println(book.getTitle()) // "A Song of Ice and Fire"book.setTitle("Things Fall Apart") // sets new valueprintln(book.getTitle()) // "Things Fall Apart"book.getIsbn() // 9780385474542book.setIsbn(4545454) // won"t compile</pre><h3> Пользовательские Getters и Setters</h3><p>В этом разделе я покажу вам, как создать собственные средства доступа (геттеры и сеттеры) для свойства в Kotlin, если вы хотите. Создание пользовательского установщика может быть полезно, если вы хотите проверить или подтвердить значение до того, как оно будет установлено в свойство класса. И пользовательский метод получения свойств может быть полезен, когда вы хотите изменить или изменить значение, которое должно быть возвращено. </p><h4> Создание настраиваемого сеттера</h4><p>Поскольку мы хотим создать свой собственный метод получения или установки для свойства, мы должны определить это свойство в теле класса вместо заголовка конструктора. <br></p><pre class="brush: java noskimlinks noskimwords">class Book (val isbn: Long) {    var title = "default value"}</pre><p>Вот почему мы переместили изменяемое свойство <code class="inline">title</code> (чтение-запись) в тело класса и присвоили ему значение по умолчанию (иначе оно не будет компилироваться). </p><pre class="brush: java noskimlinks noskimwords">class Book (val isbn: Long) {    var title = "default value"    set(value) {        if (!value.isNotEmpty()) {            throw IllegalArgumentException("Title must not be empty")        }        field = value    }}</pre><p>Вы можете видеть, что мы определили наш собственный метод <code>set(value)</code> для <code>title</code> прямо под определением свойства - обратите внимание, что вы не можете изменить эту сигнатуру метода <code>set()</code>, потому что это то, что компилятор ожидает как функцию установки собственного свойства.</p><p><code>Значение</code> параметра, переданное методу <code>set</code>, представляет собой фактическое значение, которое было присвоено свойству пользователями - вы можете изменить имя параметра, если хотите, но <code>значение</code> является гораздо более предпочтительным. Мы проверили <code>значение</code>, проверив, является ли оно пустым. Если пусто, остановите выполнение и сгенерируйте исключение; в противном случае переназначьте значение специальной переменной<code> field</code>.</p><p>Это специальное <code>field</code> переменной поля внутри метода <code>set</code> является псевдонимом для базового поля свойства - вспомогательное поле - это просто поле, которое используется свойствами, когда вы хотите изменить или использовать данные этого поля. В отличие от <code>value</code>, вы не можете переименовать эту специальную переменную <code>field</code>.</p><h3> Создание пользовательского Getter<br></h3><p>Создать собственный геттер для недвижимости в Котлине очень просто. </p><pre class="brush: java noskimlinks noskimwords">class Book (val isbn: Long) {    var title = "default value"    //... set method    get() {        return field.toUpperCase()    }}</pre><p>Внутри метода <code class="inline">get</code> мы просто возвращаем измененное <code class="inline">field</code> - в нашем случае мы возвращаем название книги в верхнем регистре. </p><pre class="brush: java noskimlinks noskimwords">val book = Book(9780007477159)book.title = "A Song of Ice and Fire"println(book.title) // "A SONG OF ICE AND FIRE"println(book.isbn) // 9780007477159</pre><p>Обратите внимание, что каждый раз, когда мы устанавливаем значение для свойства <code class="inline">title</code>, выполняется его блок метода <code class="inline">set</code> - то же самое касается метода <code class="inline">get</code> каждый раз, когда мы его извлекаем. </p><p>Если вы хотите узнать о функциях-членах для класса Kotlin (вид функции, которая определена внутри класса, объекта или интерфейса), посетите пост «<span>Больше возможностей с функциями</span>» в этой серии. </p><ul class="roundup-block__contents posts--half-width roundup-block--list"><li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1499/posts/29479/preview_image/kotlin.jpg" alt="Котлин с нуля: классы и объекты..." title="Котлин с нуля: классы и объекты..." width="50" height="50"><div class="roundup-block__primary-category topic-code">Kotlin</div> <div class="roundup-block__content-title">Kotlin From Scratch: больше веселья с функциями</div> <div class="roundup-block__author">Chike Mgbemena </div></span></li></ul><h3> Подробнее о конструкторах</h3><p>Как я уже говорил ранее, у нас есть два типа конструкторов в Kotlin: первичный и вторичный. У нас есть свобода объединить их обоих в один класс - как вы можете видеть в следующем примере:</p><pre class="brush: java noskimlinks noskimwords">class Car(val name: String, val plateNo: String) {    var new: Boolean = true    constructor(name: String, plateNo: String, new: Boolean) : this(name, plateNo) {        this.new = new    }}</pre><p>Обратите внимание, что мы не можем объявлять свойства внутри вторичного конструктора, как мы это делали для первичного конструктора. Если мы хотим сделать это, мы должны объявить это внутри тела класса, а затем инициализировать его во вторичном конструкторе. <br></p><p>В приведенном выше коде мы устанавливаем значение по умолчанию <code class="inline">new</code> свойства для класса <code class="inline">Car</code> (помните, что <code class="inline">new</code> не является ключевым словом в Kotlin) - тогда мы можем использовать вторичный конструктор, чтобы изменить его, если мы захотим. В Kotlin каждый вторичный конструктор должен вызывать первичный конструктор или вызывать другой вторичный конструктор, который вызывает первичный конструктор - для этого мы используем ключевое слово <code class="inline">this</code>. </p><p>Также обратите внимание, что внутри класса может быть несколько вторичных конструкторов. </p><pre class="brush: java noskimlinks noskimwords">class Car(val name: String, val plateNo: String) {    var new: Boolean? = null    var colour: String = ""    constructor(name: String, plateNo: String, new: Boolean) : this(name, plateNo) {        this.new = new    }    constructor(name: String, plateNo: String, new: Boolean, colour: String ) :            this(name, plateNo, new) {        this.colour = colour    }}</pre><p>Если класс расширяет <code class="inline">super</code>, то мы можем использовать ключевое слово super (аналогично Java) для вызова конструктора суперкласса (мы обсудим наследование в Kotlin в следующем посте). </p><pre class="brush: java noskimlinks noskimwords">// directly calls primary constructorval car1 = Car("Peugeot 504", "XYZ234")// directly calls 1st sec. constructorval car2 = Car("Peugeot 504", "XYZ234", false)// directly calls last sec. constructorval car3 = Car("Peugeot 504", "XYZ234", false, "grey") </pre><p>Как я уже говорил ранее, для того, чтобы мы явно включили модификатор видимости в конструктор в классе, мы должны включить ключевое слово <code class="inline">constructor</code> - по умолчанию конструкторы являются общедоступными. </p><pre class="brush: java noskimlinks noskimwords">class Car private constructor(val name: String, val plateNo: String) {//...</pre><p><span class="sectionnum">Здесь мы сделали конструктор закрытым</span> - это означает, что пользователи не могут создавать экземпляры объекта, используя его конструктор напрямую. Это может быть полезно, если вы хотите, чтобы пользователи вместо этого вызывали другой метод (фабричный метод) для косвенного создания объектов. </p><h2> <span class="sectionnum">2.</span> Любые и ничтожные типы</h2><p>В Kotlin самый верхний тип иерархии типов называется <code class="inline">Any</code>. Это эквивалентно типу <code class="inline">Object</code> Java. Это означает, что все классы в Kotlin явно наследуются от типа <code class="inline">Any</code>, включая <code class="inline">String</code>, <code class="inline">Int</code>, <code class="inline">Double</code> и так далее. Тип <code class="inline">Any</code> содержит три метода: <code class="inline">equals</code>, <code class="inline">toString</code> и <code class="inline">hashcode</code>. </p><p>Мы также можем использовать класс <code class="inline">Nothing</code> в Kotlin в функциях, которые всегда возвращают исключение, другими словами, для функций, которые не завершаются нормально. Когда функция возвращает <code class="inline">Nothing</code>, мы знаем, что она выдаст исключение. В Java не существует эквивалентного типа такого рода. </p><pre class="brush: java noskimlinks noskimwords">fun throwException(): Nothing {    throw Exception("Exception message)}</pre><p> Это может пригодиться при тестировании поведения обработки ошибок в модульных тестах. </p><h2> <span class="sectionnum">3.</span> Модификаторы видимости</h2><p> Модификаторы видимости помогают нам ограничить доступность нашего API для широкой публики. Мы можем предоставить различные модификаторы видимости для наших классов, интерфейсов, объектов, методов или свойств. Kotlin предоставляет нам четыре модификатора видимости:</p><h3>Public</h3><p> Это значение по умолчанию, и любой класс, функция, свойство, интерфейс или объект, которые имеют этот модификатор, могут быть доступны из любого места.<br></p><h3>Private </h3><p> Функция верхнего уровня, интерфейс или класс, объявленные как <code class="inline">private</code>, могут быть доступны только в одном файле. </p><p>Любая функция или свойство, которые объявлены <code class="inline">private</code> внутри класса, объекта или интерфейса, могут быть видны только другим членам этого же класса, объекта или интерфейса. </p><pre class="brush: java noskimlinks noskimwords">class Account {    private val amount: Double = 0.0}</pre><h3>Protected</h3><p><code class="inline">protected</code> модификатор можно применять только к свойствам или функциям внутри класса, объекта или интерфейса - его нельзя применять к функциям, классам или интерфейсам верхнего уровня. Свойства или функции с этим модификатором доступны только внутри определяющего его класса и любого подкласса. </p><h3>Internal </h3><p>В проекте, в котором есть модуль (модуль Gradle или Maven), класс, объект, интерфейс или функция, указанные с помощью <code class="inline">internal</code> модификатора, объявленного внутри этого модуля, доступны только из этого модуля. </p><pre class="brush: java noskimlinks noskimwords">internal class Account {    val amount: Double = 0.0}</pre><h2> <span class="sectionnum">4.</span> Smart Casting</h2><p>Приведение означает получение объекта другого типа и преобразование его в другой тип объекта. Например, в Java мы используем оператор <code class="inline">instanceof</code>, чтобы определить, принадлежит ли конкретный тип объекта другому типу, прежде чем мы затем приведем его.</p><pre class="brush: java noskimlinks noskimwords">/* Java */if (shape instanceof Circle) {    Circle circle = (Circle) shape;    circle.calCircumference(3.5); }</pre><p>Как вы можете видеть, мы проверили, является ли экземпляр <code class="inline">shape</code> <code class="inline">Circle</code>, и затем нам нужно явно привести ссылку на <code class="inline">shape</code> к типу <code class="inline">Circle</code>, чтобы мы могли вызывать методы типа <code class="inline">Circle</code>. </p><p>Еще одна потрясающая вещь о Kotlin - это умение его компилятора, когда дело доходит до кастинга. Теперь посмотрим версию в Котлине.</p><pre class="brush: java noskimlinks noskimwords">/* Kotlin */if (shape is Circle) {    shape.calCircumference(3.5)}</pre><p>Довольно аккуратно! Компилятору полезно знать, что блок <code class="inline">if</code> будет выполняться только в том случае, если объект <code class="inline">shape</code> является экземпляром <code class="inline">Circle</code>, поэтому механизм приведения сделан для нас под капотом.  Теперь мы можем легко вызвать свойства или функции типа <code class="inline">Circle</code> внутри блока <code class="inline">if</code>. </p><pre class="brush: java noskimlinks noskimwords">if (shape is Circle &amp;&amp; shape.hasRadius()) {    println("Circle radius is {shape.radius}")}</pre><p>Здесь последнее условие после <code class="inline">&amp;&amp;</code> в заголовке <code class="inline">if</code> будет вызываться, только если первое условие <code class="inline">true</code>. Если <code class="inline">shape</code> не является <code class="inline">Circle</code>, то последнее условие не будет оцениваться. </p><h2> <span class="sectionnum">5.</span> Explicit Casting</h2><p>Мы можем использовать оператор <code class="inline">as</code> (или <em>небезопасный </em>оператор литья) для явного указания ссылки типа на другой тип в Kotlin. </p><pre class="brush: java noskimlinks noskimwords">val circle = shape as Circlecircle.calCircumference(4)</pre><p>Если явная операция литья является незаконной, обратите внимание, что будет выбрано <code class="inline">ClassCastException</code>. Чтобы предотвратить исключение исключения при кастинге, мы можем использовать оператора <em>безопасного литья</em> (или оператор сбрасывания с нулевым значением) <code class="inline">as?</code>. </p><pre class="brush: java noskimlinks noskimwords">val circle: Circle? = shape as? Circle</pre><p><code class="inline">as?</code> оператор попытается применить к предполагаемому типу, и он возвращает значение <code class="inline">null</code>, если значение не может быть выбрано вместо исключения исключения. Помните, что аналогичный механизм обсуждался в разделе Nullability в столбцах <span>Nullability, Loops и Conditions в этой серии</span>. Прочитайте его для переподготовки.</p><ul class="roundup-block__contents posts--half-width roundup-block--list"><li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1499/posts/29366/preview_image/kotlin.jpg" alt="Котлин с нуля: классы и объекты..." title="Котлин с нуля: классы и объекты..." width="50" height="50"><div class="roundup-block__primary-category topic-code">Kotlin</div> <div class="roundup-block__content-title">Kotlin от Scratch: Nullability, Loops, и Conditions</div> <div class="roundup-block__author">Chike Mgbemena </div></span></li></ul><h2> <span class="sectionnum">6.</span> Объекты</h2><p>Объекты в Kotlin больше похожи на объекты JavaScript, чем объекты Java. Обратите внимание, что объект в Kotlin не является экземпляром определенного класса!</p><p>Объекты очень похожи на классы. Вот некоторые из характеристик объектов в Котлине:</p><ul><li>Они могут иметь свойства, методы и блок <code class="inline">init</code>.</li> <li>Эти свойства или методы могут иметь модификаторы видимости.</li> <li>У них не могут быть конструкторы (первичные или вторичные).</li> <li>Они могут расширять другие классы или реализовывать интерфейс.</li> </ul><p>Давайте теперь разберемся, как создать объект. </p><pre class="brush: java noskimlinks noskimwords">object Singleton {        fun myFunc(): Unit {        // do something    }}</pre><p>Мы помещаем ключевое слово <code class="inline">объекта</code> перед именем объекта, который хотим создать. На самом деле, мы создаем синглтоны, когда мы создаем объекты в Котлин, используя конструкцию <code class="inline">объекта</code>, потому что существует только один экземпляр объекта. Вы узнаете больше об этом, когда мы обсудим совместимость объектов с Java. </p><p>Singleton - это шаблон проектирования программного обеспечения, который гарантирует, что у класса есть только один экземпляр, и этот класс обеспечивает глобальную точку доступа к нему. В любое время, когда несколько классов или клиентов запрашивают класс, они получают один и тот же экземпляр класса. Вы можете проверить мое сообщение об одном шаблоне на Java, чтобы узнать больше об этом.</p><ul class="roundup-block__contents posts--half-width roundup-block--list"><li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1499/posts/29153/preview_image/gyt.png" alt="Котлин с нуля: классы и объекты..." title="Котлин с нуля: классы и объекты..." width="50" height="50"><div class="roundup-block__primary-category topic-code">Android SDK</div> <div class="roundup-block__content-title">Шаблоны дизайна Android: шаблон Singleton</div> <div class="roundup-block__author">Chike Mgbemena </div></span></li></ul><p>Вы можете получить доступ к объекту или синглтону в любом месте вашего проекта, если вы импортируете его пакет. </p><pre class="brush: java noskimlinks noskimwords">Singleton.myFunc()</pre><p>Если вы Java-кодер, так мы обычно создаем синглтоны:</p><pre class="brush: java noskimlinks noskimwords">public class Singleton  {     private static Singleton INSTANCE = null;     // other instance variables can be here         private Singleton() {};     public static synchronized Singleton getInstance() {        if (INSTANCE == null) {            INSTANCE = new Singleton();        }        return(INSTANCE);    }         // other instance methods can follow }</pre><p>Как вы можете видеть, использование конструкции <code class="inline">объекта</code> Kotlin делает его кратким и легким для создания одиночных чисел. </p><p>Объекты в Котлине могут также использоваться для создания констант. Обычно в Java мы создаем константы в классе, делая это публичное статическое конечное поле следующим образом:</p><pre class="brush: java noskimlinks noskimwords">public final class APIConstants {      public static final String baseUrl = "https://www.myapi.com/";   private APIConstants() {}}</pre><p>Этот код на Java можно более кратко преобразовать в Kotlin следующим образом:</p><pre class="brush: java noskimlinks noskimwords">package com.chike.kotlin.constantsobject APIConstants {    val baseUrl: String = "http://www.myapi.com/"}</pre><p>Здесь мы объявили константу <code class="inline">APIConstants</code> с базой свойств<code class="inline"> baseUrl</code> внутри пакета <code class="inline">com.chike.kotlin.constants</code>. Под капотом для нас создается приватный статический конечный элемент-член <code class="inline">baseUrl</code> для Java и инициализируется строковым URL-адресом. </p><p>Чтобы использовать эту константу в другом пакете в Котлине, просто импортируйте пакет.</p><pre class="brush: plain noskimlinks noskimwords">import com.chike.kotlin.constants.APIConstantsAPIConstants.baseUrl</pre><h3><span class="sectionnum">Совместимость с Java</span></h3><p><span class="sectionnum">Kotlin преобразует объект в конечный класс Java под капотом. Этот класс имеет личное статическое поле <code class="inline">INSTANCE</code>, которое содержит один экземпляр (одиночный элемент) класса. Следующий код показывает, как просто пользователи могут вызывать объект Kotlin из Java. </span></p><pre class="brush: java noskimlinks noskimwords">/* Java */Singleton.INSTANCE.myFunc()</pre><p><span class="sectionnum">Здесь класс Java, называемый <code class="inline">Singleton</code>, был сгенерирован с открытым статическим конечным членом <code class="inline">INSTANCE</code>, включая публичную конечную функцию <code class="inline">myFunc()</code>.</span></p><p>Чтобы функция или свойство объекта в Kotlin были статическим членом генерируемого класса Java, мы используем <code class="inline">@JvmStatic</code> аннотация. Вот как это использовать:</p><pre class="brush: java noskimlinks noskimwords">object Singleton {        @JvmStatic fun myFunc(): Unit {        // do something    }}</pre><p>Применяя <code class="inline">@JvmStatic</code> для <code class="inline">myFunc()</code>, компилятор превратил его в статическую функцию. </p><p> Теперь Java-вызовы могут вызывать его как обычный статический член-вызов. Обратите внимание, что использование статического поля <code class="inline">INSTANCE</code> для вызова участников будет по-прежнему работать.</p><pre class="brush: java noskimlinks noskimwords">/* Java */Singleton.myFunc()</pre><h2> <span class="sectionnum">7.</span> Сопутствующие объекты</h2><p>Теперь мы поняли, какие объекты находятся в Котлине, давайте погрузимся в объекты другого типа, называемые сопутствующими объектами. </p><p>Поскольку Kotlin не поддерживает статические классы, методы или свойства, подобные тем, которые у нас есть на Java, команда Kotlin предоставила нам более мощную альтернативу, называемую <em>сопутствующими объектами</em>. Сопутствующий объект - это в основном объект, принадлежащий классу, этот класс известен как сопутствующий класс объекта. Это также означает, что характеристики, о которых я упоминал для объектов, также относятся к сопутствующим объектам. </p><h3>Создание объекта-компаньона</h3><p>Подобно статическим методам в Java, объект-компаньон не связан с экземпляром класса, а скорее с самим классом - например, статическим методом, который выполняет задачу создания экземпляра класса. </p><pre class="brush: java noskimlinks noskimwords">class Person private constructor(var firstName: String, var lastName: String) {    companion object {        fun create(firstName: String, lastName: String): Person = Person(firstName, lastName)    }}</pre><p>Здесь мы создали конструктор <code class="inline">private</code> - это означает, что пользователи вне класса не могут создать экземпляр напрямую. Внутри нашего блока объектов-компаньонов у нас есть функция <code class="inline">create()</code>, которая создает объект <code class="inline">Person</code> и возвращает его. </p><h3>Вызов функции объекта Companion</h3><p><code class="inline">companion</code> экземпляр объекта ленив. Другими словами, он будет создан только в случае необходимости в первый раз Создание экземпляра объекта <code class="inline">companion</code> происходит, когда создается экземпляр класса <code class="inline">companion</code> или доступ к элементам <code class="inline">companion</code> объекта. </p><p>Давайте посмотрим, как вызвать функцию сопутствующего объекта в Kotlin.</p><pre class="brush: java noskimlinks noskimwords">val person = Person.create("Cersei", "Lannister")println(person.firstName) // prints "Cersei"</pre><p><span class="sectionnum">Как вы можете видеть, это похоже на вызов статического метода в Java как обычно. Другими словами, мы просто вызываем класс, а затем вызываем его. Обратите внимание: кроме функций мы можем также иметь свойства внутри нашего объекта-компаньона. </span></p><pre class="brush: java noskimlinks noskimwords">class Person private constructor(var firstName: String, var lastName: String) {    init {        count++    }        companion object {        var count: Int = 0        fun create(firstName: String, lastName: String): Person = Person(firstName, lastName)                init {            println("Person companion object created")        }    }}</pre><p>Также обратите внимание, что класс <code class="inline">companion</code> имеет неограниченный доступ ко всем свойствам и функциям, объявленным в его сопутствующем объекте, тогда как сопутствующий объект не может получить доступ к членам класса. У нас может быть блок кода <code class="inline">init</code> внутри объекта <code class="inline">companion</code> - он вызывается немедленно, когда создается объект-компаньон. </p><pre class="brush: java noskimlinks noskimwords">Person.create("Arya", "Stark")Person.create("Daenerys", "Targaryen")println(Person.count)</pre><p>Результат выполнения кода выше будет: </p><pre class="brush: plain noskimlinks noskimwords">Person companion object created2</pre><p>Помните, что может существовать только один экземпляр объекта <code class="inline">companion</code> класса. </p><p>Мы также можем предоставить объекту-компаньону имя. </p><pre class="brush: java noskimlinks noskimwords">// ...companion object Factory {    var count: Int = 0    fun create(firstName: String, lastName: String): Person = Person(firstName, lastName)}// ... </pre><p><span class="sectionnum">Здесь мы дали ему имя под названием <code class="inline">Factory</code>. Затем мы можем назвать это так в Kotlin:</span></p><pre class="brush: java noskimlinks noskimwords">Person.Factory.create("Petyr", "Baelish")</pre><p><span class="sectionnum">Этот стиль является многословным, поэтому придерживаться предыдущего способа является очень предпочтительным. Но это может пригодиться при вызове функции или свойства объекта-компаньона с Java.</span></p><p>Как я уже говорил ранее, подобные объекты, объекты-компаньоны могут также включать в себя свойства или функции, реализовывать интерфейсы и даже расширять класс. </p><pre class="brush: java noskimlinks noskimwords">interface PersonFactory {    fun create(firstName: String, lastName: String): Person}class Person private constructor(var firstName: String, var lastName: String) {        companion object : PersonFactory {        override fun create(firstName: String, lastName: String): Person {            return Person(firstName, lastName)        }    }}</pre><p>Здесь у нас есть интерфейс <code class="inline">PersonFactory</code> с единственной функцией <code class="inline">create()</code>. Рассматривая новый измененный объект <code class="inline">companion</code>, он теперь реализует этот интерфейс (вы узнаете о интерфейсах и наследовании в Kotlin в более позднем посте). </p><h3><span class="sectionnum">Совместимость с Java</span></h3><p>Под покрытием сопутствующие объекты компилируются аналогично тому, как компилируется объект Kotlin. В нашем собственном случае для нас создаются два класса: конечный класс <code class="inline">Person</code> и внутренний статический конечный класс <code class="inline">Person$Companion</code>. </p><p>Класс <code class="inline">Person</code> содержит последний статический член под названием <code class="inline">Companion</code> - это статическое поле является объектом внутреннего класса <code class="inline">Person$Companion</code>. Внутренний класс <code class="inline">Person$Companion</code> также имеет своих собственных членов, и одна из них является публичной конечной функцией с именем <code class="inline">create()</code>. </p><p>Обратите внимание, что мы не дали нашему объекту-компаньону имя, поэтому сгенерированный статический внутренний класс был <code class="inline">Companion</code>. Если бы мы дали ему имя, то сгенерированное имя было бы именем, которое мы дали ему в Kotlin. </p><pre class="brush: java noskimlinks noskimwords">/* Java */Person person = Person.Companion.create("Jon", "Snow");</pre><p>Здесь объект-компаньон в Kotlin не имеет имени, поэтому мы используем имя <code class="inline">Companion</code>, предоставленное компилятором для вызывающих Java-программ, для его вызова.</p><p>Аннотация <code class="inline">@JvmStatic</code>, применяемая к элементу объекта-компаньона, работает аналогично тому, как это работает для обычного объекта. </p><h3>Расширения сопутствующих объектов</h3><p>Аналогично тому, как функции расширения могут расширять функциональность класса, мы также можем расширять функциональность сопутствующего объекта. (Если вы хотите освежить в расширенных функциях в Kotlin, посетите руководство по <span>дополнительным функциям</span> в этой серии). </p><ul class="roundup-block__contents posts--half-width roundup-block--list"><li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1499/posts/29534/preview_image/kotlin.jpg" alt="Котлин с нуля: классы и объекты..." title="Котлин с нуля: классы и объекты..." width="50" height="50"><div class="roundup-block__primary-category topic-code">Kotlin</div> <div class="roundup-block__content-title">Kotlin от Scratch: расширенные функцию</div> <div class="roundup-block__author">Chike Mgbemena </div></span></li></ul><pre class="brush: java noskimlinks noskimwords">class ClassA {    companion object  {    }}fun ClassA.Companion.extFunc() {    // ... do implementation}ClassA.extFunc()</pre><p>Здесь мы определили функцию расширения <code class="inline">extFunc()</code> для сопутствующего объекта <code class="inline">ClassA.Companion</code>. Другими словами, <code class="inline">extfunc()</code> является расширением сопутствующего объекта. Затем мы можем вызвать расширение, как если бы оно было функцией(это не так!) объекта-компаньона. </p><p>За кулисами компилятор создаст статическую служебную функцию <code class="inline">extFunc()</code>. Объект-получатель в качестве аргумента этой служебной функции - <code class="inline">ClassA$Companion</code>. </p><h2>Заключение<br></h2><p>В этом уроке вы узнали об основных классах и объектах в Kotlin. Мы рассказали о классах:<br></p><ul><li>класс создания</li> <li>конструктор</li> <li>properties</li> <li>модификаторы видимости</li> <li>smart casting</li> <li>explicit casting </li> </ul><p>Кроме того, вы узнали о том, как объекты и сопутствующие объекты в Kotlin могут легко заменить ваши статические методы, константы и синглтоны, которые вы кодируете в Java. Но это еще не все! Можно узнать еще больше о Котлине. В следующем посте я покажу вам еще больше интересных возможностей, которые есть у Kotlin для объектно-ориентированного программирования. До скорой встречи!</p><p>Чтобы узнать больше о языке Kotlin, я рекомендую посетить <span>документацию Kotlin</span>. Или ознакомьтесь с некоторыми другими нашими статьями по разработке приложений для Android здесь, на Envato Tuts+!</p><ul class="roundup-block__contents posts--half-width roundup-block--list"><li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/369/posts/27846/preview_image/java-or-kotlin-for-android-dev.jpg" alt="Котлин с нуля: классы и объекты..." title="Котлин с нуля: классы и объекты..." width="50" height="50"><div class="roundup-block__primary-category topic-code">Android SDK</div> <div class="roundup-block__content-title">Java против Kotlin: стоит ли использовать Kotlin для разработки под Android?</div> <div class="roundup-block__author">Jessica Thornsby</div></span></li> <li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1308/posts/28749/preview_image/preview.jpg" alt="Котлин с нуля: классы и объекты..." title="Котлин с нуля: классы и объекты..." width="50" height="50"><div class="roundup-block__primary-category topic-code">Android SDK</div> <div class="roundup-block__content-title">Введение в компоненты архитектуры Android</div> <div class="roundup-block__author">Tin Megali</div></span></li> <li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/362/posts/29009/preview_image/preview.png" alt="Котлин с нуля: классы и объекты..." title="Котлин с нуля: классы и объекты..." width="50" height="50"><div class="roundup-block__primary-category topic-code">Android SDK</div> <div class="roundup-block__content-title">Как использовать API Google Cloud Vision в приложениях для Android</div> <div class="roundup-block__author">Ashraff Hathibelagal</div></span></li> <li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/769/posts/29283/preview_image/android-instant-apps.jpg" alt="Котлин с нуля: классы и объекты..." title="Котлин с нуля: классы и объекты..." width="50" height="50"><div class="roundup-block__primary-category topic-code">Android SDK</div> <div class="roundup-block__content-title">Что такое Android Instant Apps?</div> <div class="roundup-block__author">Jessica Thornsby</div></span></li> </ul>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824576-kotlin-s-nulya-klassy-i-obekty" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Kotlin" href="https://norma-studio.github.io/article/220824576-kotlin-s-nulya-klassy-i-obekty" class="tm-article-body__tags-item-link">Kotlin</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
31144</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
729</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

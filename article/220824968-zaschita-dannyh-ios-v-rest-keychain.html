
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Защита данных iOS в Rest: Keychain... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Защита данных iOS в Rest: Keychain... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Защита данных iOS в Rest: Keychain... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Защита данных iOS в Rest: Keychain... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Любое приложение, которое сохраняет данные пользователя, должно заботиться о безопасности и конфиденциальности этих данных. Как мы видели с недавними нарушениями данных, могут быть очень серьезные последствия для отказа от защиты хранимых данных ваших пользователей. В этом уроке вы узнаете некоторые рекомендации по защите данных своих пользователей...">
<meta property="og:description" content="Любое приложение, которое сохраняет данные пользователя, должно заботиться о безопасности и конфиденциальности этих данных. Как мы видели с недавними нарушениями данных, могут быть очень серьезные последствия для отказа от защиты хранимых данных ваших пользователей. В этом уроке вы узнаете некоторые рекомендации по защите данных своих пользователей...">
<meta name="twitter:description" content="Любое приложение, которое сохраняет данные пользователя, должно заботиться о безопасности и конфиденциальности этих данных. Как мы видели с недавними нарушениями данных, могут быть очень серьезные последствия для отказа от защиты хранимых данных ваших пользователей. В этом уроке вы узнаете некоторые рекомендации по защите данных своих пользователей...">
<meta property="aiturec:description" content="Любое приложение, которое сохраняет данные пользователя, должно заботиться о безопасности и конфиденциальности этих данных. Как мы видели с недавними нарушениями данных, могут быть очень серьезные последствия для отказа от защиты хранимых данных ваших пользователей. В этом уроке вы узнаете некоторые рекомендации по защите данных своих пользователей...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1638/posts/28529/preview_image/tutorialImage.png">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1638/posts/28529/preview_image/tutorialImage.png">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1638/posts/28529/preview_image/tutorialImage.png">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1638/posts/28529/preview_image/tutorialImage.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1638/posts/28529/preview_image/tutorialImage.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article/220824968-zaschita-dannyh-ios-v-rest-keychain.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article/220824968-zaschita-dannyh-ios-v-rest-keychain.html">
<link rel="canonical" href="https://norma-studio.github.io/article/220824968-zaschita-dannyh-ios-v-rest-keychain.html">
<meta property="og:url" content="https://norma-studio.github.io/article/220824968-zaschita-dannyh-ios-v-rest-keychain.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article/220824968-zaschita-dannyh-ios-v-rest-keychain.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article/220824968-zaschita-dannyh-ios-v-rest-keychain.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article/220824968-zaschita-dannyh-ios-v-rest-keychain.html" title="Защита данных iOS в Rest: Keychain... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Защита данных iOS в Rest: Keychain... | envatomarket.ru | norma-studio.github.io" title="Защита данных iOS в Rest: Keychain... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/636534636.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article/220824968-zaschita-dannyh-ios-v-rest-keychain.html" class="tm-user-info__username" title="
С. Новичков" aria-label="
С. Новичков">
С. Новичков</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Защита данных iOS в Rest: Keychain...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824968-zaschita-dannyh-ios-v-rest-keychain" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="iOS SDK" href="https://norma-studio.github.io/article/220824968-zaschita-dannyh-ios-v-rest-keychain" class="tm-article-snippet__hubs-item-link"><span>iOS SDK</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article/220824968-zaschita-dannyh-ios-v-rest-keychain.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1638/posts/28529/preview_image/tutorialImage.png">
    <meta itemprop="headline name" content="Защита данных iOS в Rest: Keychain... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Любое приложение, которое сохраняет данные пользователя, должно заботиться о безопасности и конфиденциальности этих данных. Как мы видели с недавними нарушениями данных, могут быть очень серьезные последствия для отказа от защиты хранимых данных ваших пользователей. В этом уроке вы узнаете некоторые рекомендации по защите данных своих пользователей...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Любое приложение, которое сохраняет данные пользователя, должно заботиться о безопасности и конфиденциальности этих данных. Как мы видели с недавними нарушениями данных, могут быть очень серьезные последствия для отказа от защиты хранимых данных ваших пользователей. В этом уроке вы узнаете некоторые рекомендации по защите данных своих пользователей...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Любое приложение, которое сохраняет данные пользователя, должно заботиться о безопасности и конфиденциальности этих данных. Как мы видели с недавними нарушениями данных, могут быть очень серьезные последствия для отказа от защиты хранимых данных ваших пользователей. В этом уроке вы узнаете некоторые рекомендации по защите данных своих пользователей.<br></p><p>В <span>предыдущей статье</span> вы узнали, как защитить файлы с помощью API защиты данных. Файловая защита - это мощная функция для безопасного хранения объемных данных. Но это так же может быть излишним для небольшого количества информации, такой как например ключ или пароль. Рекомендованное решение для этих типов элементов - это ключевое слово.</p><h2>Сервисы Keychain</h2><p>Keychain - отличное место для хранения небольших объемов информации, таких как конфиденциальные строки и идентификаторы, которые сохраняются даже тогда, когда пользователь удаляет приложение. Примером может быть токен устройства или сеанса, который ваш сервер возвращает в приложение при регистрации. Если вы называете это секретной строкой или уникальным токеном, связка ключей относится ко всем этим элементам как к <em>паролям</em>. </p><p>Есть несколько популярных сторонних библиотек для сервисов keychain, таких как <span>Strongbox</span> (Swift) и <span>SSKeychain</span> (Objective-C). Или, если вы хотите полностью контролировать свой собственный код, вы можете напрямую использовать API-интерфейс Keychain, который является C API. </p><p>Я кратко объясню, как работает Keychain. Можете рассматривать Keychain как типичную базу данных, где вы делаете запросы к таблице. Для функций API-интерфейса Keychain требуется объект <code class="inline">CFDictionary</code>, содержащий атрибуты запроса. </p><p>Каждая запись в цепочке ключей содержит имя службы. Имя службы - это идентификатор: <i>ключ</i> для любого <i>значения</i>, которое вы хотите сохранить или получить в цепочке ключей. Чтобы объект связки ключей сохранялся только для определенного пользователя, вы также можете указать имя учетной записи. </p><p>Поскольку каждая функция keychain принимает аналогичный словарь со многими из тех же параметров, что и запрос, вы можете избежать дублирования кода, создав вспомогательную функцию, которая возвращает этот словарь.</p><pre class="brush: objc noskimlinks noskimwords">import Security//...class func passwordQuery(service: String, account: String) -&gt; Dictionary&lt;String, Any&gt;{    let dictionary = [        kSecClass as String : kSecClassGenericPassword,        kSecAttrAccount as String : account,        kSecAttrService as String : service,        kSecAttrAccessible as String : kSecAttrAccessibleWhenUnlocked //If need access in background, might want to consider kSecAttrAccessibleAfterFirstUnlock    ] as [String : Any]        return dictionary}</pre><p>Этот код устанавливает запрос <code class="inline">Dictionary</code> с именами вашей учетной записи и службы и сообщает связке ключей, что мы будем хранить пароль. </p><p>Аналогично тому, как вы можете установить уровень защиты для отдельных файлов (как мы обсуждали в <span>предыдущей статье</span>), вы также можете установить уровни защиты для вашего объекта keychain с помощью <span>ключа</span> <code class="inline"><span>kSecAttrAccessible</span></code>. <br></p><h3>Добавление пароля<br></h3><p>Функция <code class="inline">SecItemAdd()</code> добавляет данные в цепочку ключей. Эта функция принимает объект <code class="inline">Data</code>, что делает ее универсальным для хранения многих объектов. Используя функцию запроса пароля, которую мы создали выше, давайте сохраним строку в связке ключей. Для этого нам просто нужно преобразовать <code class="inline">String</code> в <code class="inline">Data</code>.</p><pre class="brush: objc noskimlinks noskimwords">@discardableResult class func setPassword(_ password: String, service: String, account: String) -&gt; Bool{    var status : OSStatus = -1    if !(service.isEmpty) &amp;&amp; !(account.isEmpty)    {        deletePassword(service: service, account: account) //delete password if pass empty string. Could change to pass nil to delete password, etc                if !password.isEmpty        {            var dictionary = passwordQuery(service: service, account: account)            let dataFromString = password.data(using: String.Encoding.utf8, allowLossyConversion: false)            dictionary[kSecValueData as String] = dataFromString            status = SecItemAdd(dictionary as CFDictionary, nil)        }    }    return status == errSecSuccess}</pre><h3>Удаление пароля<br></h3><p>Чтобы предотвратить дублирование вставок, код выше сначала удаляет предыдущую запись, если она есть. Теперь напишем эту функцию. Это выполняется с помощью функции <code class="inline">SecItemDelete()</code>.</p><pre class="brush: objc noskimlinks noskimwords">@discardableResult class func deletePassword(service: String, account: String) -&gt; Bool{    var status : OSStatus = -1    if !(service.isEmpty) &amp;&amp; !(account.isEmpty)    {        let dictionary = passwordQuery(service: service, account: account)        status = SecItemDelete(dictionary as CFDictionary);    }    return status == errSecSuccess}</pre><h3>Получение пароля<br></h3><p>Затем, чтобы получить запись из связки ключей, используйте функцию <code class="inline">SecItemCopyMatching()</code>. Она вернет <code class="inline">AnyObject</code>, соответствующий вашему запросу.<br></p><pre class="brush: objc noskimlinks noskimwords">class func password(service: String, account: String) -&gt; String //return empty string if not found, could return an optional{    var status : OSStatus = -1    var resultString = ""    if !(service.isEmpty) &amp;&amp; !(account.isEmpty)    {        var passwordData : AnyObject?        var dictionary = passwordQuery(service: service, account: account)        dictionary[kSecReturnData as String] = kCFBooleanTrue        dictionary[kSecMatchLimit as String] = kSecMatchLimitOne        status = SecItemCopyMatching(dictionary as CFDictionary, &amp;passwordData)                if status == errSecSuccess        {            if let retrievedData = passwordData as? Data            {                resultString = String(data: retrievedData, encoding: String.Encoding.utf8)!            }        }    }    return resultString}</pre><p>В этом коде мы устанавливаем параметр <code class="inline">kSecReturnData</code> в <code class="inline">kCFBooleanTrue</code>. <code class="inline">KSecReturnData</code> означает, что фактические данные будут возвращены. Другой вариант - вернуть атрибуты (<code class="inline">kSecReturnAttributes</code>) элемента. Ключ принимает тип <code class="inline">CFBoolean</code>, который содержит константы <code class="inline">kCFBooleanTrue</code> или <code class="inline">kCFBooleanFalse</code>. Мы устанавливаем <code class="inline">kSecMatchLimit</code> в <code class="inline">kSecMatchLimitOne</code>, чтобы возвращался только первый элемент в цепочке ключей, а не неограниченное количество результатов.</p><h2>Открытые и закрытые ключи<br></h2><p>Связка ключей также является рекомендуемым местом для хранения объектов открытого и закрытого ключа, например, если ваше приложение работает и должно хранить объекты EC или RSA <code class="inline">SecKey</code>. </p><p>Основное различие заключается в том, что вместо того, чтобы сообщать связке ключей о сохранении пароля, мы можем сказать, что она хранит ключ. Фактически, мы можем получить конкретную информацию, задав типы хранимых ключей, например, публичные или частные. Все, что нужно сделать, - это адаптировать вспомогательную функцию запроса для работы с типом ключа, который вам нужен. </p><p>Ключи обычно идентифицируются с использованием тега обратного домена, такого как <strong>com.mydomain.mykey</strong>, а не именем службы и учетной записи (поскольку открытые ключи открываются совместно между различными компаниями или сущностями). Мы возьмем строки службы и аккаунт и преобразуем их в объект <code class="inline">Data</code>. Например, приведенный выше код, адаптированный для хранения RSA Private <code class="inline">SecKey</code>, будет выглядеть следующим образом:</p><pre class="brush: objc noskimlinks noskimwords">class func keyQuery(service: String, account: String) -&gt; Dictionary&lt;String, Any&gt;{    let tagString = "com.mydomain." + service + "." + account    let tag = tagString.data(using: .utf8)! //Store it as Data, not as a String    let dictionary = [        kSecClass as String : kSecClassKey,        kSecAttrKeyType as String : kSecAttrKeyTypeRSA,        kSecAttrKeyClass as String : kSecAttrKeyClassPrivate,        kSecAttrAccessible as String : kSecAttrAccessibleWhenUnlocked,        kSecAttrApplicationTag as String : tag        ] as [String : Any]        return dictionary}@discardableResult class func setKey(_ key: SecKey, service: String, account: String) -&gt; Bool{    var status : OSStatus = -1    if !(service.isEmpty) &amp;&amp; !(account.isEmpty)    {        deleteKey(service: service, account:account)        var dictionary = keyQuery(service: service, account: account)        dictionary[kSecValueRef as String] = key        status = SecItemAdd(dictionary as CFDictionary, nil);    }    return status == errSecSuccess}@discardableResult class func deleteKey(service: String, account: String) -&gt; Bool{    var status : OSStatus = -1    if !(service.isEmpty) &amp;&amp; !(account.isEmpty)    {        let dictionary = keyQuery(service: service, account: account)        status = SecItemDelete(dictionary as CFDictionary);    }    return status == errSecSuccess}class func key(service: String, account: String) -&gt; SecKey?{    var item: CFTypeRef?    if !(service.isEmpty) &amp;&amp; !(account.isEmpty)    {        var dictionary = keyQuery(service: service, account: account)        dictionary[kSecReturnRef as String] = kCFBooleanTrue        dictionary[kSecMatchLimit as String] = kSecMatchLimitOne        SecItemCopyMatching(dictionary as CFDictionary, &amp;item);    }    return item as! SecKey?}</pre><h2>Пароли приложений<br></h2><p>Элементы, защищенные флагом <code class="inline">kSecAttrAccessibleWhenUnlocked</code>, разблокируются только тогда, когда устройство будет разблокировано, но это еще и зависит от пользователя, у которого есть код доступа или сенсорный идентификатор, созданный в первую очередь. </p><p>Учетные данные <code class="inline">applicationPassword</code> позволяют связать элементы в связке ключей с помощью дополнительного пароля. Таким образом, если у пользователя нет кода доступа или сенсорного идентификатора, элементы будут по-прежнему безопасными и добавят дополнительный уровень безопасности, если у них есть набор паролей. </p><p>В качестве примера сценария, после того как ваше приложение будет аутентифицироваться на вашем сервере, ваш сервер может вернуть пароль через HTTPS, который требуется для разблокирования элемента keychain. Это предпочтительный способ предоставления дополнительного пароля. Жестко прописывать пароль в двоичном формате не рекомендуется.</p><p>Другим сценарием может быть получение дополнительного пароля с предоставленного пользователем пароля в вашем приложении; Однако для этого требуется больше работы (с использованием <span>PBKDF2</span>). В следующем учебнике мы рассмотрим безопасность паролей пользователей. </p><p>Другое использование пароля приложения - это хранение чувствительного ключа, например, который вы бы не хотели показывать только потому, что пользователь еще не установил пароль. </p><p><code class="inline">applicationPassword</code> доступно только для iOS 9 и выше, поэтому вам понадобится резерв, который не будет использовать <code class="inline">applicationPassword</code>, если вы нацеливаетесь на более низкие версии iOS. Чтобы использовать код, вам нужно добавить следующее в заголовок:</p><pre class="brush: objc noskimlinks noskimwords">#import &lt;LocalAuthentication/LocalAuthentication.h&gt;#import &lt;Security/SecAccessControl.h&gt;</pre><p>Следующий код устанавливает пароль для запроса <code class="inline">Dictionary</code>.<br></p><pre class="brush: objc noskimlinks noskimwords">if #available(iOS 9.0, *){    //Use this in place of kSecAttrAccessible for the query    var error: Unmanaged&lt;CFError&gt;?    let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault, kSecAttrAccessibleWhenUnlocked, SecAccessControlCreateFlags.applicationPassword, &amp;error)    if accessControl != nil    {        dictionary[kSecAttrAccessControl as String] = accessControl    }        let localAuthenticationContext = LAContext.init()    let theApplicationPassword = "passwordFromServer".data(using:String.Encoding.utf8)!    localAuthenticationContext.setCredential(theApplicationPassword, type: LACredentialType.applicationPassword)    dictionary[kSecUseAuthenticationContext as String] = localAuthenticationContext}</pre><p>Обратите внимание, что мы устанавливаем <code class="inline">kSecAttrAccessControl</code> в <code class="inline">Dictionary</code>. Это используется вместо <code class="inline">kSecAttrAccessible</code>, который ранее был установлен в нашем методе <code class="inline">passwordQuery</code>. Если вы попытаетесь использовать оба варианта, вы получите ошибку <code class="inline">OSStatus</code> <code class="inline">-50</code>.</p><h2>Аутентификация пользователя</h2><p>Начиная с iOS 8, вы можете хранить данные в связке ключей, доступ к которой возможен только после успешной аутентификации пользователя на устройстве с помощью Touch ID или кода доступа. Когда нужно аутентифицировать пользователя, Touch ID получит приоритет, если он настроен, в противном случае будет показан экран кода доступа. Сохранение в связке ключей не потребует аутентификации пользователя, а получение данных потребует. </p><p>Вы можете установить элемент keychain, требующий аутентификации пользователя, предоставив объект управления доступом, установленный на <code class="inline">.userPresence</code>. Если код доступа не установлен, любые запросы к связке ключей с <code class="inline">.userPresence</code> не будут выполнены. </p><pre class="brush: objc noskimlinks noskimwords">if #available(iOS 8.0, *){    let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault, kSecAttrAccessibleWhenUnlockedThisDeviceOnly, .userPresence, nil)    if accessControl != nil    {        dictionary[kSecAttrAccessControl as String] = accessControl    }} </pre><p>Эта функция хороша, если вы хотите убедиться, что ваше приложение используется подходящим человеком. Например, было бы важно, чтобы пользователь аутентифицировался до того, как смог войти в банковское приложение. Это защитит пользователей, которые оставили свое устройство незаблокированным, чтобы доступ к банку был невозможен. </p><p>Кроме того, если у вас нет серверного компонента для вашего приложения, вы можете использовать эту функцию для проверки подлинности на стороне устройства.</p><p>Для запроса загрузки вы можете указать, почему пользователь должен аутентифицироваться.</p><pre class="brush: objc noskimlinks noskimwords">dictionary[kSecUseOperationPrompt as String] = "Authenticate to retrieve x"</pre><p>При извлечении данных с помощью <code class="inline">SecItemCopyMatching()</code> функция покажет интерфейс аутентификации и дождется, пока пользователь будет использовать Touch ID или введет пароль. Поскольку SecItemCopyMatching () будет блокироваться до тех пор, пока пользователь не завершит проверку подлинности, вам нужно будет вызвать функцию из фонового потока, чтобы позволить основному потоку пользовательского интерфейса оставаться отзывчивым. </p><pre class="brush: objc noskimlinks noskimwords">DispatchQueue.global().async {    status = SecItemCopyMatching(dictionary as CFDictionary, &amp;passwordData)    if status == errSecSuccess    {        if let retrievedData = passwordData as? Data        {            DispatchQueue.main.async             {                //... do the rest of the work back on the main thread            }           }    }}</pre><p>Опять же, мы устанавливаем <code class="inline">kSecAttrAccessControl</code> в запросе <code class="inline">Dictionary</code>. Вам нужно будет удалить <code class="inline">kSecAttrAccessible</code>, который ранее был установлен в нашем методе <code class="inline">passwordQuery</code>. Использование обоих сразу приведет к ошибке <code class="inline">OSStatus</code> -50.</p><h2>Заключение</h2><p>В этой статье вы ознакомились с API-интерфейсом Keychain. Наряду с API защиты данных, который мы видели в <span>предыдущей статье</span>, использование этой библиотеки является частью лучших практик по обеспечению безопасности данных. </p><p>Однако, если у пользователя нет кода доступа или сенсорного идентификатора на устройстве, шифрование на одном из фреймворков не сработает. Поскольку API-интерфейсы Keychain и <span>Data Protection</span> обычно используются приложениями iOS, они иногда становятся целью злоумышленников, особенно на взломанных устройствах. Если ваше приложение не работает с высокочувствительной информацией, это может быть приемлемым риском. В то время как iOS постоянно обновляет безопасность фреймворков, мы по-прежнему находимся во власти пользователя, обновляющего ОС, используя стойкий пароль доступа, а не джейлбрейк своего устройства. </p><p>Связка ключей предназначена для небольших фрагментов данных, и у вас может быть больше данных для защиты, которые не зависят от аутентификации устройства. В то время как обновления iOS добавляют некоторые замечательные новые функции, такие как пароль приложения, вам все равно придется поддерживать более низкие версии iOS и по-прежнему иметь сильную безопасность. По некоторым из этих соображений вы можете вместо этого сами зашифровать данные. </p><p>Последняя статья в этой серии описывает шифрование данных с использованием AES-шифрования, и, хотя это более продвинутый подход, он позволяет вам полностью контролировать, как и когда ваши данные зашифровываются.</p><p>Так что следите за обновлениями. И тем временем, ознакомьтесь с некоторыми из наших других статей о разработке приложений для iOS!</p><ul class="roundup-block__contents posts--half-width roundup-block--list"><li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1638/posts/28529/preview_image/tutorialImage.png" alt="Защита данных iOS в Rest: Keychain..." title="Защита данных iOS в Rest: Keychain..." width="50" height="50"><div class="roundup-block__primary-category topic-code">SDK для iOS</div> <div class="roundup-block__content-title">Защита сообщений на iOS</div> <div class="roundup-block__author">Коллин Стюарт</div></span></li> <li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/769/posts/28154/preview_image/cloud%20services%20-%20mobile.jpg" alt="Защита данных iOS в Rest: Keychain..." title="Защита данных iOS в Rest: Keychain..." width="50" height="50"><div class="roundup-block__primary-category topic-code">Мобильная разработка</div> <div class="roundup-block__content-title">Back-End в качестве сервиса для мобильных приложений</div> <div class="roundup-block__author">Bala Durage Sandamal Siripathi</div></span></li> <li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1637/posts/28474/preview_image/Preview%20image.jpeg" alt="Защита данных iOS в Rest: Keychain..." title="Защита данных iOS в Rest: Keychain..." width="50" height="50"><div class="roundup-block__primary-category topic-code">SDK для iOS</div> <div class="roundup-block__content-title">Правильный способ совместного использования состояния между контроллерами представления Swift</div> <div class="roundup-block__author">Маттео Манфердини</div></span></li> <li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/41/posts/23138/preview_image/preview_image@2x.jpg" alt="Защита данных iOS в Rest: Keychain..." title="Защита данных iOS в Rest: Keychain..." width="50" height="50"><div class="roundup-block__primary-category topic-code">Swift</div> <div class="roundup-block__content-title">Изучаем Swift: Замыкания</div> <div class="roundup-block__author">Барт Джейкобс</div></span></li> </ul>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824968-zaschita-dannyh-ios-v-rest-keychain" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="iOS SDK" href="https://norma-studio.github.io/article/220824968-zaschita-dannyh-ios-v-rest-keychain" class="tm-article-body__tags-item-link">iOS SDK</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
30947</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
605</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>


<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Объектно ориентированный PHP для начинающих... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Объектно ориентированный PHP для начинающих... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Объектно ориентированный PHP для начинающих... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Объектно ориентированный PHP для начинающих... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Для многих программистов на PHP объектно-ориентированное программирование - пугающая концепция, полная сложного синтаксиса и других препятствий. Как подробно описано в моей книге Pro PHP и jQuery, вы узнаете концепции объектно-ориентированного программирования (ООП) - стиля кодирования, в котором связанные действия группируются в классы, чтобы обле...">
<meta property="og:description" content="Для многих программистов на PHP объектно-ориентированное программирование - пугающая концепция, полная сложного синтаксиса и других препятствий. Как подробно описано в моей книге Pro PHP и jQuery, вы узнаете концепции объектно-ориентированного программирования (ООП) - стиля кодирования, в котором связанные действия группируются в классы, чтобы обле...">
<meta name="twitter:description" content="Для многих программистов на PHP объектно-ориентированное программирование - пугающая концепция, полная сложного синтаксиса и других препятствий. Как подробно описано в моей книге Pro PHP и jQuery, вы узнаете концепции объектно-ориентированного программирования (ООП) - стиля кодирования, в котором связанные действия группируются в классы, чтобы обле...">
<meta property="aiturec:description" content="Для многих программистов на PHP объектно-ориентированное программирование - пугающая концепция, полная сложного синтаксиса и других препятствий. Как подробно описано в моей книге Pro PHP и jQuery, вы узнаете концепции объектно-ориентированного программирования (ООП) - стиля кодирования, в котором связанные действия группируются в классы, чтобы обле...">
<meta property="og:image" content="https://s3.amazonaws.com/nettuts/734_oop/images/blueprint-houses.jpg">
<meta property="aiturec:image" content="https://s3.amazonaws.com/nettuts/734_oop/images/blueprint-houses.jpg">
<meta name="twitter:image" content="https://s3.amazonaws.com/nettuts/734_oop/images/blueprint-houses.jpg">
<meta property="vk:image" content="https://s3.amazonaws.com/nettuts/734_oop/images/blueprint-houses.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://s3.amazonaws.com/nettuts/734_oop/images/blueprint-houses.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article/220824617-obektno-orientirovannyj-php-dlya-nachinayuschih.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article/220824617-obektno-orientirovannyj-php-dlya-nachinayuschih.html">
<link rel="canonical" href="https://norma-studio.github.io/article/220824617-obektno-orientirovannyj-php-dlya-nachinayuschih.html">
<meta property="og:url" content="https://norma-studio.github.io/article/220824617-obektno-orientirovannyj-php-dlya-nachinayuschih.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article/220824617-obektno-orientirovannyj-php-dlya-nachinayuschih.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article/220824617-obektno-orientirovannyj-php-dlya-nachinayuschih.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article/220824617-obektno-orientirovannyj-php-dlya-nachinayuschih.html" title="Объектно ориентированный PHP для начинающих... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Объектно ориентированный PHP для начинающих... | envatomarket.ru | norma-studio.github.io" title="Объектно ориентированный PHP для начинающих... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/ded38a8520cf75a955c11fc92a1a403e.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article/220824617-obektno-orientirovannyj-php-dlya-nachinayuschih.html" class="tm-user-info__username" title="
В. Самсонов" aria-label="
В. Самсонов">
В. Самсонов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Объектно ориентированный PHP для начинающих...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824617-obektno-orientirovannyj-php-dlya-nachinayuschih" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Back-End" href="https://norma-studio.github.io/article/220824617-obektno-orientirovannyj-php-dlya-nachinayuschih" class="tm-article-snippet__hubs-item-link"><span>Back-End</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article/220824617-obektno-orientirovannyj-php-dlya-nachinayuschih.html" />
    <link itemprop="image" href="https://s3.amazonaws.com/nettuts/734_oop/images/blueprint-houses.jpg">
    <meta itemprop="headline name" content="Объектно ориентированный PHP для начинающих... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Для многих программистов на PHP объектно-ориентированное программирование - пугающая концепция, полная сложного синтаксиса и других препятствий. Как подробно описано в моей книге Pro PHP и jQuery, вы узнаете концепции объектно-ориентированного программирования (ООП) - стиля кодирования, в котором связанные действия группируются в классы, чтобы обле...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Для многих программистов на PHP объектно-ориентированное программирование - пугающая концепция, полная сложного синтаксиса и других препятствий. Как подробно описано в моей книге Pro PHP и jQuery, вы узнаете концепции объектно-ориентированного программирования (ООП) - стиля кодирования, в котором связанные действия группируются в классы, чтобы обле...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Для многих программистов на PHP объектно-ориентированное программирование - пугающая концепция, полная сложного синтаксиса и других препятствий. Как подробно описано в моей книге <em><span>Pro PHP и jQuery</span></em>, вы узнаете концепции <strong>объектно-ориентированного программирования</strong> (ООП) - стиля кодирования, в котором связанные действия группируются в классы, чтобы облегчить создание более компактного и эффективного кода.</p> <h2>Понимание объектно ориентированного программирования</h2> <p> Объектно-ориентированное программирование - это стиль кодирования, который позволяет разработчикам группировать схожие задачи в <strong>классы</strong>. Это помогает сохранить код в соответствии с принципом <span>«не повторяйся» (DRY)</span> и простым в обслуживании.</p> <blockquote> <p>«Объектно-ориентированное программирование - это стиль кодирования, который позволяет разработчикам группировать схожие задачи в <strong>классы</strong>».</p> </blockquote> <p>Одним из основных преимуществ программирования по принципу DRY является то, что если в вашей программе изменяется часть информации, <strong>обычно требуется только одно изменение для обновления кода.</strong> Одним из самых больших кошмаров для разработчиков является поддержание кода, в котором данные объявляются снова и снова, а это означает, что любые изменения в программе становятся похожими на бесконечную игру <em>Where"s Waldo</em>? </p> <p>ООП пугает многих разработчиков, потому что он вводит новый синтаксис и, на первый взгляд, выглядит гораздо более сложным, чем простой процедурный или встроенный код. Однако при ближайшем рассмотрении ООП на самом деле является очень наглядным и, в конечном счете, более простым подходом к программированию.</p> <h2>Понимание объекты и классы</h2> <p>Прежде чем вы сможете проникнуть в тонкости ООП, необходимо базовое понимание различий между <strong>объектами</strong> и <strong>классами</strong>. В этом разделе будут рассмотрены строительные блоки классов, их различные возможности и некоторые виды их использования.</p> <h3>Узнаем различия между объектами и классами</h3> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://s3.amazonaws.com/nettuts/734_oop/images/blueprint-houses.jpg" class="lazy07" alt="Объектно ориентированный PHP для начинающих..." title="Объектно ориентированный PHP для начинающих..." width="50" height="50"><figcaption>Фотографии от <span>Instant Jefferson </span>и <span>John Wardell</span></figcaption></figure><blockquote> <p>Когда разработчики начинают говорить об объектах и классах, то они кажутся взаимозаменяемыми. Хотя на самом деле это не так.</p> </blockquote> <p>Сразу же у нас возникает путаница в ООП: опытные разработчики начинают говорить об объектах и классах, и они кажутся взаимозаменяемыми. Это не так, хотя разницу на первый взгляд и тяжело уловить.</p> <p>Класс, например, это <strong>как проект для дома</strong>. Он определяет форму дома на бумаге, при этом отношения между различными частями дома так же четко определены и спланированы, хотя дома еще не существует.</p> <p>Таким образом, объект подобен <strong>фактическому дому</strong>, построенному в соответствии с этим планом. Данные, хранящиеся в объекте, подобны дереву, проводам и бетону, которые составляют дом: не будучи собранными в соответствии с планом, это всего лишь куча материала. Однако, когда все это объединяется, это становится организованным и полезным домом.</p> <p><strong>Классы образуют структуру данных и действия, которые затем используют эту информацию для создания объектов.</strong> В один и тот же момент времени из одного и того же класса могут быть построены более одного объекта, каждый из которых не зависит от других. Продолжая нашу конструктивную аналогию, она похожа на то, как можно построить целое подразделение по одному и тому же проекту: 150 разных домов, которые все выглядят одинаково, но имеют разные<br> семьи и декорации внутри.</p> <h3>Структурирование классов</h3> <p>Синтаксис для создания класса довольно прост: объявить класс с помощью ключевого слова <code>class</code>, за которым следует имя класса и набор фигурных скобок (<code>{}</code>):</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  // Class properties and methods go here}?&gt;</pre> <p>После создания класса новый экземпляр может быть создан и сохранен в переменной с использованием ключевого слова <code>new</code>:</p> <pre class="brush: php noskimlinks noskimwords">$obj = new MyClass;</pre> <p>Чтобы увидеть содержимое класса, используйте <code>var_dump ():</code></p> <pre class="brush: php noskimlinks noskimwords">var_dump($obj);</pre> <p>Попробуйте выполнить этот процесс, разместив весь предыдущий код в новом файле <code>test.php</code> в [локальной] папке для тестирования:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  // Class properties and methods go here}$obj = new MyClass;var_dump($obj);?&gt;</pre> <p>Загрузите страницу в браузере по адресу <code>http: //localhost/test.php</code>, и на экране должно появиться следующее:</p> <pre class="brush: php noskimlinks noskimwords">object(MyClass)#1 (0) { }</pre> <p><strong>В своей простейшей форме вы только что завершили свой первый ООП-скрипт.</strong></p> <h2>Определение свойств класса</h2> <p>Для добавления данных в класс используются <strong>свойства</strong> или переменные класса. Они работают точно так же, как и обычные переменные, за исключением того, что они привязаны к объекту и поэтому могут быть доступны только с помощью объекта.</p> <p>Чтобы добавить свойство в <code>MyClass</code>, добавьте следующий код в свой скрипт:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";}$obj = new MyClass;var_dump($obj);?&gt;</pre> <p>Ключевое слово <code>public</code> определяет видимость свойства, о котором вы узнаете чуть позже в этой главе. Затем свойство присваивается с использованием стандартного синтаксиса переменных и присваивается значение (хотя свойствам классов не требуется начальное значение).</p> <p>Чтобы прочитать это свойство и вывести его в браузер, укажите объект, с которого следует читать, и свойство, которое нужно прочитать:</p> <pre class="brush: php noskimlinks noskimwords">echo $obj-&gt;prop1;</pre> <p>Поскольку могут существовать несколько экземпляров класса, если отдельный объект не ссылается, то сценарий не сможет определить, с какого объекта следует читать свойство. Использование стрелки (<code>-&gt;</code>) является конструкцией ООП, которая обращается к содержащимся в нем свойствам и методам данного объекта.</p> <p>Измените скрипт в <code>test.php</code>, чтобы считать свойство, вместо того, чтобы выводить весь класс, изменив код, как показано ниже:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";}$obj = new MyClass;echo $obj-&gt;prop1; // Output the property?&gt;</pre> <p>Теперь перезагрузка вашего браузера выводит следующее:</p> <pre class="brush: php noskimlinks noskimwords">I"m a class property!</pre> <h2>Определение методов класса</h2> <p><strong>Методы</strong> являются специфичными для класса функциями. Отдельные действия, которые объект сможет выполнить, определены внутри класса как методы.</p> <p>Например, чтобы создать методы, которые будут устанавливать и получать значение свойства класса <code>$prop1</code>, добавьте в свой код следующее:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . "&lt;br /&gt;";  }}$obj = new MyClass;echo $obj-&gt;prop1;?&gt;</pre> <p><strong>Примечание</strong>. ООП позволяет объектам ссылаться на себя, используя <code>$this</code>. При работе внутри метода используйте <code>$this</code> таким же образом, как вы использовали бы имя объекта вне класса.</p> <p>Чтобы использовать эти методы, вызовите их так же, как обычные функции, но сначала укажите ссылку на объект, к которому они принадлежат. Прочитайте свойство из <code>MyClass</code>, измените его значение и прочитайте его еще раз, внеся следующие изменения:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . "&lt;br /&gt;";  }}$obj = new MyClass;echo $obj-&gt;getProperty(); // Get the property value$obj-&gt;setProperty("I"m a new property value!"); // Set a new oneecho $obj-&gt;getProperty(); // Read it out again to show the change?&gt;</pre> <p>Перезагрузите браузер, и вы увидите следующее:</p> <pre class="brush: php noskimlinks noskimwords">I"m a class property!I"m a new property value!</pre> <blockquote> <p>"Сила ООП становится очевидной при использовании нескольких экземпляров<br> одного класса."</p> </blockquote> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . "&lt;br /&gt;";  }}// Create two objects$obj = new MyClass;$obj2 = new MyClass;// Get the value of $prop1 from both objectsecho $obj-&gt;getProperty();echo $obj2-&gt;getProperty();// Set new values for both objects$obj-&gt;setProperty("I"m a new property value!");$obj2-&gt;setProperty("I belong to the second instance!");// Output both objects" $prop1 valueecho $obj-&gt;getProperty();echo $obj2-&gt;getProperty();?&gt;</pre> <p>Когда вы загружаете результаты в свой браузер, они отобразят следующее:</p> <pre class="brush: php noskimlinks noskimwords">I"m a class property!I"m a class property!I"m a new property value!I belong to the second instance!</pre> <p>Как вы можете видеть, <strong>ООП хранит объекты как отдельные сущности</strong>, что позволяет легко разделять различные фрагменты кода на небольшие связанные пакеты.</p> <h2>Волшебные методы в ООП</h2> <p>Чтобы упростить использование объектов, PHP также предоставляет ряд <strong>магических методов</strong> или специальных методов, вызываемых, когда определенные общие действия происходят внутри объектов. Это позволяет разработчикам выполнять ряд полезных задач с относительной легкостью.</p> <h3>Использование конструкторов и деструкторов</h3> <p>Когда создается экземпляр объекта, часто желательно сразу же установить несколько вещей. Чтобы справиться с этим, PHP предоставляет магический метод <code>__construct()</code>, который вызывается автоматически всякий раз, когда новый объект<br> создается.</p> <p>В целях иллюстрации концепции конструкторов добавьте конструктор в <code>MyClass</code>, который будет выводить сообщение всякий раз, когда создается новый экземпляр класса:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";  public function __construct()  {      echo "The class "", __CLASS__, "" was initiated!&lt;br /&gt;";  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . "&lt;br /&gt;";  }}// Create a new object$obj = new MyClass;// Get the value of $prop1echo $obj-&gt;getProperty();// Output a message at the end of the fileecho "End of file.&lt;br /&gt;";?&gt;</pre> <p><strong>Примечание</strong>. <code>__CLASS__</code> возвращает имя класса, в котором оно вызывается; Это то, что известно как <span>волшебная константа</span>. Существует несколько доступных магических констант, о которых вы можете прочитать в руководстве по PHP.</p> <p>Перезагрузка файла в вашем браузере приведет к следующему результату:</p> <pre class="brush: php noskimlinks noskimwords">The class "MyClass" was initiated!I"m a class property!End of file.</pre> <p>Чтобы вызвать функцию, когда объект разрушен, доступен магический метод <code>__destruct()</code>. Это полезно для очистки класса (например, закрытие соединения с базой данных).</p> <p>Вывести сообщение, когда объект уничтожен, определяя магический метод<br><code>__destruct()</code> в <code>MyClass</code>:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";  public function __construct()  {      echo "The class "", __CLASS__, "" was initiated!&lt;br /&gt;";  }  public function __destruct()  {      echo "The class "", __CLASS__, "" was destroyed.&lt;br /&gt;";  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . "&lt;br /&gt;";  }}// Create a new object$obj = new MyClass;// Get the value of $prop1echo $obj-&gt;getProperty();// Output a message at the end of the fileecho "End of file.&lt;br /&gt;";?&gt;</pre> <p>При определенном деструкторе перезагрузка тестового файла приводит к следующему выводу:</p> <pre class="brush: php noskimlinks noskimwords">The class "MyClass" was initiated!I"m a class property!End of file.The class "MyClass" was destroyed.</pre> <blockquote> <p>«Когда достигнут конец файла, PHP автоматически освобождает все ресурсы».</p> </blockquote> <p>Чтобы явно вызвать деструктор, вы можете уничтожить объект, используя<br> функцию <code>unset()</code>:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";  public function __construct()  {      echo "The class "", __CLASS__, "" was initiated!&lt;br /&gt;";  }  public function __destruct()  {      echo "The class "", __CLASS__, "" was destroyed.&lt;br /&gt;";  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . "&lt;br /&gt;";  }}// Create a new object$obj = new MyClass;// Get the value of $prop1echo $obj-&gt;getProperty();// Destroy the objectunset($obj);// Output a message at the end of the fileecho "End of file.&lt;br /&gt;";?&gt;</pre> <p>Теперь при загрузке в вашем браузере результат будет выглядеть следующим образом:</p> <pre class="brush: php noskimlinks noskimwords">The class "MyClass" was initiated!I"m a class property!The class "MyClass" was destroyed.End of file.</pre> <h3>Преобразование в строку</h3> <p>Чтобы избежать ошибки, если скрипт пытается вывести <code>MyClass</code> в виде строки, используется другой магический метод, называемый <code>__toString()</code>.</p> <p>Без <code>__toString()</code> <em>попытка вывода объекта в виде строки приводит к фатальной ошибке</em>. Попытка использовать <code>echo</code> для вывода объекта без использования магического метода:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";  public function __construct()  {      echo "The class "", __CLASS__, "" was initiated!&lt;br /&gt;";  }  public function __destruct()  {      echo "The class "", __CLASS__, "" was destroyed.&lt;br /&gt;";  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . "&lt;br /&gt;";  }}// Create a new object$obj = new MyClass;// Output the object as a stringecho $obj;// Destroy the objectunset($obj);// Output a message at the end of the fileecho "End of file.&lt;br /&gt;";?&gt;</pre> <p>Это приводит к следующему результату:</p> <pre class="brush: php noskimlinks noskimwords">The class "MyClass" was initiated!Catchable fatal error: Object of class MyClass could not be converted to string in /Applications/XAMPP/xamppfiles/htdocs/testing/test.php on line 40</pre> <p>Чтобы избежать этой ошибки, добавим метод <code>__toString()</code>:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";  public function __construct()  {      echo "The class "", __CLASS__, "" was initiated!&lt;br /&gt;";  }  public function __destruct()  {      echo "The class "", __CLASS__, "" was destroyed.&lt;br /&gt;";  }  public function __toString()  {      echo "Using the toString method: ";      return $this-&gt;getProperty();  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . "&lt;br /&gt;";  }}// Create a new object$obj = new MyClass;// Output the object as a stringecho $obj;// Destroy the objectunset($obj);// Output a message at the end of the fileecho "End of file.&lt;br /&gt;";?&gt;</pre> <p>В этом случае попытка преобразовать объект в строку приведет к вызову метода <code>getProperty(</code>). Загрузите тестовый скрипт в свой браузер, чтобы увидеть результат:</p> <pre class="brush: php noskimlinks noskimwords">The class "MyClass" was initiated!Using the toString method: I"m a class property!The class "MyClass" was destroyed.End of file.</pre> <p><strong>Совет</strong>. В дополнение к магическим методам, обсуждаемым в этом разделе, доступно еще несколько других. Полный список магических методов приведен на странице <span>руководства PHP</span>.</p> <h2>Использование наследования</h2> <p><strong>Классы могут наследовать методы и свойства другого класса </strong>с помощью ключевого слова <code>extends</code>. Например, чтобы создать второй класс, который расширяет <code>MyClass</code> и добавить метод, вы должны добавить следующее в свой тестовый файл:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";  public function __construct()  {      echo "The class "", __CLASS__, "" was initiated!&lt;br /&gt;";  }  public function __destruct()  {      echo "The class "", __CLASS__, "" was destroyed.&lt;br /&gt;";  }  public function __toString()  {      echo "Using the toString method: ";      return $this-&gt;getProperty();  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . "&lt;br /&gt;";  }}class MyOtherClass extends MyClass{  public function newMethod()  {      echo "From a new method in " . __CLASS__ . ".&lt;br /&gt;";  }}// Create a new object$newobj = new MyOtherClass;// Output the object as a stringecho $newobj-&gt;newMethod();// Use a method from the parent classecho $newobj-&gt;getProperty();?&gt;</pre> <p>После перезагрузки тестового файла в вашем браузере выводится следующее:</p> <pre class="brush: php noskimlinks noskimwords">The class "MyClass" was initiated!From a new method in MyOtherClass.I"m a class property!The class "MyClass" was destroyed.</pre> <h3>Перезапись унаследованных свойств и методов</h3> <p>Чтобы изменить поведение существующего свойства или метода в новом классе, вы можете просто перезаписать его, объявив его снова в новом классе:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";  public function __construct()  {      echo "The class "", __CLASS__, "" was initiated!&lt;br /&gt;";  }  public function __destruct()  {      echo "The class "", __CLASS__, "" was destroyed.&lt;br /&gt;";  }  public function __toString()  {      echo "Using the toString method: ";      return $this-&gt;getProperty();  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . "&lt;br /&gt;";  }}class MyOtherClass extends MyClass{  public function __construct()  {      echo "A new constructor in " . __CLASS__ . ".&lt;br /&gt;";  }  public function newMethod()  {      echo "From a new method in " . __CLASS__ . ".&lt;br /&gt;";  }}// Create a new object$newobj = new MyOtherClass;// Output the object as a stringecho $newobj-&gt;newMethod();// Use a method from the parent classecho $newobj-&gt;getProperty();?&gt;</pre> <p>Это изменяет вывод в браузере на:</p> <pre class="brush: php noskimlinks noskimwords">A new constructor in MyOtherClass.From a new method in MyOtherClass.I"m a class property!The class "MyClass" was destroyed.</pre> <h3>Сохранение оригинальной функциональности метода при перезаписи методов</h3> <p>Чтобы добавить новые функции к унаследованному методу, сохранив исходный метод нетронутым, используйте ключевое слово <code>parent</code> с <strong>оператором разрешения области видимости</strong> (<code>::</code>):</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";  public function __construct()  {      echo "The class "", __CLASS__, "" was initiated!&lt;br /&gt;";  }  public function __destruct()  {      echo "The class "", __CLASS__, "" was destroyed.&lt;br /&gt;";  }  public function __toString()  {      echo "Using the toString method: ";      return $this-&gt;getProperty();  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  public function getProperty()  {      return $this-&gt;prop1 . "&lt;br /&gt;";  }}class MyOtherClass extends MyClass{  public function __construct()  {      parent::__construct(); // Call the parent class"s constructor      echo "A new constructor in " . __CLASS__ . ".&lt;br /&gt;";  }  public function newMethod()  {      echo "From a new method in " . __CLASS__ . ".&lt;br /&gt;";  }}// Create a new object$newobj = new MyOtherClass;// Output the object as a stringecho $newobj-&gt;newMethod();// Use a method from the parent classecho $newobj-&gt;getProperty();?&gt;</pre> <p>Это выведет результат как родительского конструктора, так и конструктора нового класса:</p> <pre class="brush: php noskimlinks noskimwords">The class "MyClass" was initiated!A new constructor in MyOtherClass.From a new method in MyOtherClass.I"m a class property!The class "MyClass" was destroyed.</pre> <h2>Указание видимости свойств и методов</h2> <p>Для дополнительного контроля над объектами методам и свойствам можно указать видимость. Это определяет, как и откуда можно получить доступ к свойствам и методам. Существует три ключевых слова: <code>public</code>, <code>protected</code> и <code>private</code>. В дополнение к своей видимости метод или свойство могут быть объявлены <code>static</code>, что позволяет им получать доступ без экземпляра класса.</p> <blockquote> <p>«Для дополнительного контроля над объектами методам и свойствам указывается их видимость."</p> </blockquote> <p><strong>Примечание</strong>. Видимость - новая функция в PHP, начиная с версии 5. Информацию<span> о совместимости ООП с PHP 4</span> смотрите на странице руководства PHP.</p> <h3>Публичные свойства и методы</h3> <p>Все методы и свойства, которые вы использовали до сих пор, были общедоступными. Это означает, что к ним можно получить доступ в любом месте, как внутри класса, так и извне.</p> <h3>Защищенные свойства и методы</h3> <p>Если свойство или метод объявлен как <code>protected</code>, <strong>доступ к нему можно получить только внутри самого класса или в классах-потомках</strong> (классы, которые расширяют класс, содержащий защищенный метод).</p> <p>Объявите метод <code>getProperty()</code> как защищенный в <code>MyClass</code> и попытайтесь получить к нему доступ непосредственно извне класса:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";  public function __construct()  {      echo "The class "", __CLASS__, "" was initiated!&lt;br /&gt;";  }  public function __destruct()  {      echo "The class "", __CLASS__, "" was destroyed.&lt;br /&gt;";  }  public function __toString()  {      echo "Using the toString method: ";      return $this-&gt;getProperty();  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  protected function getProperty()  {      return $this-&gt;prop1 . "&lt;br /&gt;";  }}class MyOtherClass extends MyClass{  public function __construct()  {      parent::__construct();echo "A new constructor in " . __CLASS__ . ".&lt;br /&gt;";  }  public function newMethod()  {      echo "From a new method in " . __CLASS__ . ".&lt;br /&gt;";  }}// Create a new object$newobj = new MyOtherClass;// Attempt to call a protected methodecho $newobj-&gt;getProperty();?&gt;</pre> <p>При попытке запустить этот сценарий появляется следующая ошибка:</p> <pre class="brush: php noskimlinks noskimwords">The class "MyClass" was initiated!A new constructor in MyOtherClass.Fatal error: Call to protected method MyClass::getProperty() from context "" in /Applications/XAMPP/xamppfiles/htdocs/testing/test.php on line 55</pre> <p>Теперь создайте новый метод в <code>MyOtherClass для вызова метода <code>getProperty()</code>:</code></p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";  public function __construct()  {      echo "The class "", __CLASS__, "" was initiated!&lt;br /&gt;";  }  public function __destruct()  {      echo "The class "", __CLASS__, "" was destroyed.&lt;br /&gt;";  }  public function __toString()  {      echo "Using the toString method: ";      return $this-&gt;getProperty();  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  protected function getProperty()  {      return $this-&gt;prop1 . "&lt;br /&gt;";  }}class MyOtherClass extends MyClass{  public function __construct()  {      parent::__construct();echo "A new constructor in " . __CLASS__ . ".&lt;br /&gt;";  }  public function newMethod()  {      echo "From a new method in " . __CLASS__ . ".&lt;br /&gt;";  }  public function callProtected()  {      return $this-&gt;getProperty();  }}// Create a new object$newobj = new MyOtherClass;// Call the protected method from within a public methodecho $newobj-&gt;callProtected();?&gt;</pre> <p>Это приведет к желаемому результату:</p> <pre class="brush: php noskimlinks noskimwords">The class "MyClass" was initiated!A new constructor in MyOtherClass.I"m a class property!The class "MyClass" was destroyed.</pre> <h3>Приватные свойства и методы</h3> <p>Свойства или методы, объявленные как <code>private</code>, доступны <strong>только внутри класса, который их определяет</strong>. Это означает, что <em>даже если новый класс расширяет класс, определяющий приватное свойство</em>, это свойство или метод не будут доступны в дочернем классе.</p> <p>Чтобы продемонстрировать это, объявите <code>getProperty()</code> как private в <code>MyClass</code> и попытайтесь вызвать<code> callProtected()</code> из<br><code>MyOtherClass</code>:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";  public function __construct()  {      echo "The class "", __CLASS__, "" was initiated!&lt;br /&gt;";  }  public function __destruct()  {      echo "The class "", __CLASS__, "" was destroyed.&lt;br /&gt;";  }  public function __toString()  {      echo "Using the toString method: ";      return $this-&gt;getProperty();  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  private function getProperty()  {      return $this-&gt;prop1 . "&lt;br /&gt;";  }}class MyOtherClass extends MyClass{  public function __construct()  {      parent::__construct();      echo "A new constructor in " . __CLASS__ . ".&lt;br /&gt;";  }  public function newMethod()  {      echo "From a new method in " . __CLASS__ . ".&lt;br /&gt;";  }  public function callProtected()  {      return $this-&gt;getProperty();  }}// Create a new object$newobj = new MyOtherClass;// Use a method from the parent classecho $newobj-&gt;callProtected();?&gt;</pre> <p>Перезагрузите браузер, и появится следующая ошибка:</p> <pre class="brush: php noskimlinks noskimwords">The class "MyClass" was initiated!A new constructor in MyOtherClass.Fatal error: Call to private method MyClass::getProperty() from context "MyOtherClass" in /Applications/XAMPP/xamppfiles/htdocs/testing/test.php on line 49</pre> <h3>Статические свойства и методы</h3> <p>Доступ к методу или свойству, объявленному <code>static</code>, возможен без создания экземпляра класса; Вы просто указываете имя класса, оператор разрешения области и имя свойства или метода.</p> <blockquote> <p>«Одним из основных преимуществ использования статических свойств является то, что они сохраняют свои значения в течение всего срока действия скрипта».</p> </blockquote> <p>Чтобы продемонстрировать это, добавьте статическое свойство <code>$count</code> и статический метод с именем <code>plusOne()</code> в <code>MyClass</code>. Затем установите цикл <code>do ... while</code> для вывода приращенного значения <code>$count</code>, пока значение меньше 10:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass{  public $prop1 = "I"m a class property!";  public static $count = 0;  public function __construct()  {      echo "The class "", __CLASS__, "" was initiated!&lt;br /&gt;";  }  public function __destruct()  {      echo "The class "", __CLASS__, "" was destroyed.&lt;br /&gt;";  }  public function __toString()  {      echo "Using the toString method: ";      return $this-&gt;getProperty();  }  public function setProperty($newval)  {      $this-&gt;prop1 = $newval;  }  private function getProperty()  {      return $this-&gt;prop1 . "&lt;br /&gt;";  }  public static function plusOne()  {      return "The count is " . ++self::$count . ".&lt;br /&gt;";  }}class MyOtherClass extends MyClass{  public function __construct()  {      parent::__construct();      echo "A new constructor in " . __CLASS__ . ".&lt;br /&gt;";  }  public function newMethod()  {      echo "From a new method in " . __CLASS__ . ".&lt;br /&gt;";  }  public function callProtected()  {      return $this-&gt;getProperty();  }}do{  // Call plusOne without instantiating MyClass  echo MyClass::plusOne();} while ( MyClass::$count &lt; 10 );?&gt;</pre> <p><strong>Примечание</strong>. При доступе к статическим свойствам знак доллара<br> (<code>$</code>) идет <em>после оператора разрешения области видимости</em>.</p> <p>Когда вы загружаете этот скрипт в своем браузере, выдается следующее:</p> <pre class="brush: php noskimlinks noskimwords">The count is 1.The count is 2.The count is 3.The count is 4.The count is 5.The count is 6.The count is 7.The count is 8.The count is 9.The count is 10.</pre> <h2>Комментирование с помощью DocBlocks</h2> <blockquote> <p>Стиль комментирования DocBlock является широко распространенным<br> методом документирования классов".</p> </blockquote> <p>Хотя это не официальная часть ООП, стиль комментирования <span>DocBlock</span> является широко распространенным методом документирования классов. Помимо предоставления стандарта для<br> разработчиков, используемым при написании кода, он также был принят многими из самых популярных наборов разработчика программного обеспечения (SDK), таких как <span>Eclipse</span> и <span>NetBeans</span>, и будет использоваться ими для генерации подсказок кода.</p> <p>DocBlock определяется с помощью комментария блока, который начинается с дополнительной звездочки:</p> <pre class="brush: php noskimlinks noskimwords">/** * This is a very basic DocBlock */</pre> <p>Реальная сила DocBlocks проявляется с возможностью использовать <strong>теги</strong>, которые начинаются с символа at (<code>@</code>), за которым сразу следует имя тега и значение тега. <strong>Теги DocBlock позволяют разработчикам определять авторов файла, лицензию на класс, информацию о свойствах или методах и другую полезную информацию.</strong></p> <p>Наиболее часто используемые теги:</p> <ul><li> <strong>@author</strong>: автор текущего элемента (который может быть классом, файлом, методом или любым битом кода) указан в этом теге. Несколько тегов автора могут использоваться в одном и том же DocBlock, если нужно указать несколько авторов. Формат имени автора - <code>John Doe john.doe@email.com</code>.</li> <li> <strong>@copyright</strong>: это означает год и имя хозяина авторских прав для текущего элемента. Формат такой: <code>2010 Copyright Holder</code>.</li> <li> <strong>@license</strong>: Ссылка на лицензию для текущего элемента. Формат информации о лицензии:<br><code>http://www.example.com/path/to/license.txt License Name</code>.</li> <li> <strong>@var</strong>: содержит тип и описание свойства переменной или класса. Формат: <code>type element description</code>.</li> <li> <strong>@param</strong>: Этот тег показывает тип и описание параметра функции или метода. Формат: <code>type $element_name element description</code>.</li> <li> <strong>@return</strong>: тип и описание возвращаемого значения функции или метода приведены в этом теге. Формат <code>type return element description</code>.</li> </ul><p>Пример класса, прокомментированного с помощью DocBlocks, может выглядеть так:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php/** * A simple class * * This is the long description for this class, * which can span as many lines as needed. It is * not required, whereas the short description is * necessary. * * It can also span multiple paragraphs if the * description merits that much verbiage. * * @author Jason Lengstorf &lt;jason.lengstorf@ennuidesign.com&gt; * @copyright 2010 Ennui Design * @license http://www.php.net/license/3_01.txt PHP License 3.01 */class SimpleClass{  /**   * A public variable   *   * @var string stores data for the class   */  public $foo;  /**   * Sets $foo to a new value upon class instantiation   *   * @param string $val a value required for the class   * @return void   */  public function __construct($val)  {      $this-&gt;foo = $val;  }  /**   * Multiplies two integers   *   * Accepts a pair of integers and returns the   * product of the two.   *   * @param int $bat a number to be multiplied   * @param int $baz a number to be multiplied   * @return int the product of the two parameters   */  public function bar($bat, $baz)  {      return $bat * $baz;  }}?&gt;</pre> <p>Когда вы просматриваете предыдущий класс, преимущества DocBlock становятся очевидны: все четко определено, так что следующий разработчик может использовать код и <em>никогда не задаваться вопросом, что делает фрагмент кода или что он должен содержать.</em></p> <h2>Сравнение объектно-ориентированного и процедурного кода</h2> <p>На самом деле нет правильного и неправильного способа написания кода. При этом <strong>в этом разделе излагается весомый аргумент в пользу применения объектно-ориентированного подхода при разработке программного обеспечения, особенно в крупных приложениях.</strong></p> <h2>Причина 1: Простота внедрения</h2> <blockquote> <p>«Хотя вначале это может быть непростой задачей, ООП действительно обеспечивает более простой подход к работе с данными».</p> </blockquote> <p>Хотя вначале это может быть непростой задачей, ООП действительно обеспечивает более простой подход к работе с данными. Поскольку объект может хранить данные внутри себя, нет необходимости передавать переменны от функции к функции для правильной работы.</p> <p>Кроме того, поскольку <em>одновременно могут существовать несколько экземпляров одного и того же класса</em>, работа с большими наборами данных становится гораздо проще. Например, представьте, что в файле есть информация двух людей. Нам нужны имена, профессии и возраст.</p> <h3>Процедурный подход</h3> <p>Вот процедурный подход к нашему примеру:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpfunction changeJob($person, $newjob){  $person["job"] = $newjob; // Change the person"s job  return $person;}function happyBirthday($person){  ++$person["age"]; // Add 1 to the person"s age  return $person;}$person1 = array(  "name" =&gt; "Tom",  "job" =&gt; "Button-Pusher",  "age" =&gt; 34);$person2 = array(  "name" =&gt; "John",  "job" =&gt; "Lever-Puller",  "age" =&gt; 41);// Output the starting values for the peopleecho "&lt;pre&gt;Person 1: ", print_r($person1, TRUE), "&lt;/pre&gt;";echo "&lt;pre&gt;Person 2: ", print_r($person2, TRUE), "&lt;/pre&gt;";// Tom got a promotion and had a birthday$person1 = changeJob($person1, "Box-Mover");$person1 = happyBirthday($person1);// John just had a birthday$person2 = happyBirthday($person2);// Output the new values for the peopleecho "&lt;pre&gt;Person 1: ", print_r($person1, TRUE), "&lt;/pre&gt;";echo "&lt;pre&gt;Person 2: ", print_r($person2, TRUE), "&lt;/pre&gt;";?&gt;</pre> <p>При выполнении код выводит следующее:</p> <pre class="brush: php noskimlinks noskimwords">Person 1: Array(  [name] =&gt; Tom  [job] =&gt; Button-Pusher  [age] =&gt; 34)Person 2: Array(  [name] =&gt; John  [job] =&gt; Lever-Puller  [age] =&gt; 41)Person 1: Array(  [name] =&gt; Tom  [job] =&gt; Box-Mover  [age] =&gt; 35)Person 2: Array(  [name] =&gt; John  [job] =&gt; Lever-Puller  [age] =&gt; 42)</pre> <p>Хотя этот код не обязательно плохой, в процессе кодирования нужно помнить о многом. <strong>Массив атрибутов измененного человека должен быть передан и возвращен из каждого вызова функции,</strong> что оставляет место для ошибок.</p> <p>Чтобы упростить этот пример, было бы желательно <strong>оставить как можно данных меньше разработчику.</strong> Необходимо передать только абсолютно необходимую информацию для текущей операции.</p> <p><strong>Вот как раз где ООП приходит и помогает нам очистить код.</strong></p> <h3>ООП подход</h3> <p>Вот подход ООП к нашему примеру:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass Person{  private $_name;  private $_job;  private $_age;  public function __construct($name, $job, $age)  {      $this-&gt;_name = $name;      $this-&gt;_job = $job;      $this-&gt;_age = $age;  }  public function changeJob($newjob)  {      $this-&gt;_job = $newjob;  }  public function happyBirthday()  {      ++$this-&gt;_age;  }}// Create two new people$person1 = new Person("Tom", "Button-Pusher", 34);$person2 = new Person("John", "Lever Puller", 41);// Output their starting pointecho "&lt;pre&gt;Person 1: ", print_r($person1, TRUE), "&lt;/pre&gt;";echo "&lt;pre&gt;Person 2: ", print_r($person2, TRUE), "&lt;/pre&gt;";// Give Tom a promotion and a birthday$person1-&gt;changeJob("Box-Mover");$person1-&gt;happyBirthday();// John just gets a year older$person2-&gt;happyBirthday();// Output the ending valuesecho "&lt;pre&gt;Person 1: ", print_r($person1, TRUE), "&lt;/pre&gt;";echo "&lt;pre&gt;Person 2: ", print_r($person2, TRUE), "&lt;/pre&gt;";?&gt;</pre> <p>В браузере выводится следующее:</p> <pre class="brush: php noskimlinks noskimwords">Person 1: Person Object(  [_name:private] =&gt; Tom  [_job:private] =&gt; Button-Pusher  [_age:private] =&gt; 34)Person 2: Person Object(  [_name:private] =&gt; John  [_job:private] =&gt; Lever Puller  [_age:private] =&gt; 41)Person 1: Person Object(  [_name:private] =&gt; Tom  [_job:private] =&gt; Box-Mover  [_age:private] =&gt; 35)Person 2: Person Object(  [_name:private] =&gt; John  [_job:private] =&gt; Lever Puller  [_age:private] =&gt; 42)</pre> <p>В этом коде можно еще кое-что улучишь, чтобы сделать код еще более объектно-ориентированным, но после того, как класс определен, создание и модификация людей - легкий процесс; <strong>Информация о человеке не нужно передавать или возвращать из методов, и наоборот, только абсолютно необходимая информация передается каждому методу.</strong></p> <blockquote> <p>«ООП подход значительно сократит вашу рабочую нагрузку, если он будет реализован должным образом».</p> </blockquote> <p>В небольших масштабах это различие может показаться не таким уж большим, но по мере роста размера ваших приложений ООП значительно снизит вашу рабочую нагрузку, если его реализовать должным образом.</p> <p><strong>Совет</strong>. <em>Не все должно быть объектно-ориентированным.</em> Быстрая функция, которая обрабатывает что-то маленькое в одном месте внутри приложения, необязательно должна быть обернута в класc. Используйте свои умения и знания при выборе между объектно-ориентированным и процедурным подходами.</p> <h2>Причина 2: лучшая организация</h2> <p>Еще одно преимущество ООП заключается в том, <strong>насколько хорошо он поддается быстрой упаковке и каталогизации.</strong> Каждый класс обычно может храниться в отдельном файле, и если используется общее соглашение об именах, доступ к классам чрезвычайно прост.</p> <p>Предположим, у вас есть приложение с 150 классами, которые динамически вызываются файлом контроллера в корневой области файловой системы приложения. Все 150 классов следуют классу соглашений об именах <code>class.classname.inc.php</code> и находятся в папке <code>inc</code> вашего приложения.</p> <p>Контроллер может реализовать функцию PHP <code>__autoload()</code> для динамического подтягивания только тех классов, которые ему нужны, как они вызываются, вместо того, чтобы включать все 150 в файл контроллера на всякий случай или придумать какой-нибудь умный способ включения файлов в свой собственный код :</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php  function __autoload($class_name)  {      include_once "inc/class." . $class_name . ".inc.php";  }?&gt;</pre> <p>Каждый класс в отдельном файле также делает код более переносимым и более удобным для повторного использования в новых приложениях без кучи копирования и вставки.</p> <h2>Причина 3: Простота в обслуживании</h2> <p>Из-за более компактной природы ООП, когда все сделано правильно, <strong>изменения в коде, как правило, намного легче обнаружить и сделать</strong>, чем в процедурной реализации длинного спагетти кода.</p> <p>Если конкретный массив информации приобретает новый атрибут, процедурная часть программного обеспечения может потребовать (в худшем случае) добавления нового атрибута в каждую функцию, использующую этот массив.</p> <p>Приложение ООП потенциально может быть обновлено так же легко, как добавление нового свойства, а затем добавление методов, которые имеют дело с указанным свойством.</p> <p>Многие преимущества, описанные в этом разделе, являются <strong>результатом применения ООП в сочетании с практикой DRY</strong>. Несомненно, можно создать простой в обслуживании процедурный код, который не вызывает трудностей, и в равной степени можно создать ужасный объектно-ориентированный код. В <em>[Pro PHP и jQuery]</em> продемонстрировано сочетание хороших привычек кодирования в сочетании с ООП для создания чистого кода, который легко читать и поддерживать.</p> <h2>Резюме</h2> <p>Теперь вы уже должны чувствовать себя комфортно в стиле объектно-ориентированного программирования. Изучение ООП - отличный способ перенести свое программирование на следующий уровень. При правильном внедрении ООП поможет вам создать легко читаемый и простой в обслуживании переносимый код, который сэкономит вам (и разработчикам, работающим с вами) часы дополнительной работы. Вы зациклились на чем-то, что не было рассмотрено в этой статье? Вы уже используете ООП и имеете несколько советов для новичков? Поделитесь ими в комментариях!</p> <p><strong>Примечание автора</strong>. Эта статья была отрывком из книги <span>Pro PHP и jQuery</span> (Apress, 2010).</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824617-obektno-orientirovannyj-php-dlya-nachinayuschih" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Back-End" href="https://norma-studio.github.io/article/220824617-obektno-orientirovannyj-php-dlya-nachinayuschih" class="tm-article-body__tags-item-link">Back-End</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
36444</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
523</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

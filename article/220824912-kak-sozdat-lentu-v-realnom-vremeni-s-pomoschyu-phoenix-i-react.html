
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Как создать ленту в реальном времени с помощью Phoenix и React
... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Как создать ленту в реальном времени с помощью Phoenix и React
... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Как создать ленту в реальном времени с помощью Phoenix и React
... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Как создать ленту в реальном времени с помощью Phoenix и React
... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="В этом уроке я покажу вам, как мы можем использовать силу React и Phoenix для создания приложения ленты, которое будет обновляться в режиме реального времени, когда мы добавим новые фиды в нашу базу данных....">
<meta property="og:description" content="В этом уроке я покажу вам, как мы можем использовать силу React и Phoenix для создания приложения ленты, которое будет обновляться в режиме реального времени, когда мы добавим новые фиды в нашу базу данных....">
<meta name="twitter:description" content="В этом уроке я покажу вам, как мы можем использовать силу React и Phoenix для создания приложения ленты, которое будет обновляться в режиме реального времени, когда мы добавим новые фиды в нашу базу данных....">
<meta property="aiturec:description" content="В этом уроке я покажу вам, как мы можем использовать силу React и Phoenix для создания приложения ленты, которое будет обновляться в режиме реального времени, когда мы добавим новые фиды в нашу базу данных....">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/1824/posts/29122/final_image/resize.jpg">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/1824/posts/29122/final_image/resize.jpg">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/1824/posts/29122/final_image/resize.jpg">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/1824/posts/29122/final_image/resize.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/1824/posts/29122/final_image/resize.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article/220824912-kak-sozdat-lentu-v-realnom-vremeni-s-pomoschyu-phoenix-i-react.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article/220824912-kak-sozdat-lentu-v-realnom-vremeni-s-pomoschyu-phoenix-i-react.html">
<link rel="canonical" href="https://norma-studio.github.io/article/220824912-kak-sozdat-lentu-v-realnom-vremeni-s-pomoschyu-phoenix-i-react.html">
<meta property="og:url" content="https://norma-studio.github.io/article/220824912-kak-sozdat-lentu-v-realnom-vremeni-s-pomoschyu-phoenix-i-react.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article/220824912-kak-sozdat-lentu-v-realnom-vremeni-s-pomoschyu-phoenix-i-react.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article/220824912-kak-sozdat-lentu-v-realnom-vremeni-s-pomoschyu-phoenix-i-react.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article/220824912-kak-sozdat-lentu-v-realnom-vremeni-s-pomoschyu-phoenix-i-react.html" title="Как создать ленту в реальном времени с помощью Phoenix и React
... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Как создать ленту в реальном времени с помощью Phoenix и React
... | envatomarket.ru | norma-studio.github.io" title="Как создать ленту в реальном времени с помощью Phoenix и React
... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/63456435436.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article/220824912-kak-sozdat-lentu-v-realnom-vremeni-s-pomoschyu-phoenix-i-react.html" class="tm-user-info__username" title="
М. Старостенко" aria-label="
М. Старостенко">
М. Старостенко</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Как создать ленту в реальном времени с помощью Phoenix и React
...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824912-kak-sozdat-lentu-v-realnom-vremeni-s-pomoschyu-phoenix-i-react" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="React" href="https://norma-studio.github.io/article/220824912-kak-sozdat-lentu-v-realnom-vremeni-s-pomoschyu-phoenix-i-react" class="tm-article-snippet__hubs-item-link"><span>React</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article/220824912-kak-sozdat-lentu-v-realnom-vremeni-s-pomoschyu-phoenix-i-react.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/1824/posts/29122/final_image/resize.jpg">
    <meta itemprop="headline name" content="Как создать ленту в реальном времени с помощью Phoenix и React
... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="В этом уроке я покажу вам, как мы можем использовать силу React и Phoenix для создания приложения ленты, которое будет обновляться в режиме реального времени, когда мы добавим новые фиды в нашу базу данных....">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">В этом уроке я покажу вам, как мы можем использовать силу React и Phoenix для создания приложения ленты, которое будет обновляться в режиме реального времени, когда мы добавим новые фиды в нашу базу данных....</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>В этом уроке я покажу вам, как мы можем использовать силу <span>React</span> и <span>Phoenix</span> для создания приложения ленты, которое будет обновляться в режиме реального времени, когда мы добавим новые фиды в нашу базу данных.</p><h2>Введение</h2><p>Elixir известен своей стабильностью и функциями реального времени, а Phoenix использует способность Erlang VM обрабатывать миллионы соединений наряду с красивым синтаксисом и производительным инструментарием Elixir. Это поможет нам в создании обновления данных в реальном времени через API, которые будут использоваться нашим приложением React для отображения данных в пользовательском интерфейсе.<br></p><h2>Начало</h2><p>У вас должны быть установлены Elixir, Erlang и Phoenix. Подробнее об этом можно узнать на <span>веб-сайте Phoenix</span>. Кроме того, мы будем использовать заготовку <span>React boilerplate</span>, поскольку она хорошо поддерживается и правильно документирована.</p><h2>Подготовка API</h2><p>В этом разделе мы загрузим наше приложение Phoenix API и добавим каналы для обновления API в режиме реального времени. Мы просто будем работать с фидом (он будет содержать заголовок и описание), и как только его значение будет изменено в базе данных, API отправит обновленное значение нашему фтонтенд приложению.</p><h3>Создание приложения</h3><p>Давайте сначала создадим приложение Phoenix.</p><p><code class="inline">mix phoenix.new realtime_feed_api --no-html --no-brunch</code></p><p>Это создаст скелет Phoenix приложения внутри папки с именем <strong>realtime_feed_api</strong>. Опция <code class="inline">--no-html</code> не будет создавать все статические файлы (что полезно, если вы создаете приложение только для API), а опция <code class="inline">--no-brunch</code> не будет включать сборщик статики Phoenix, <span>Brunch</span>. Убедитесь, что вы устанавливаете зависимости, когда это запрашивается.</p><p>Давайте зайдем в папку и создадим нашу базу данных.</p><p><code class="inline">cd realtime_feed_api</code><br></p><p>Нам нужно будет удалить поля <strong>username</strong> и <strong>password</strong> из нашего файла <strong>config/dev.exs</strong>, так как мы будем создавать нашу базу данных без какого-либо имени пользователя или пароля. Это для упрощения, чтобы все было просто для этого урока. Для вашего приложения, убедитесь, что вы  сначала создайте базу данных с именем пользователя и паролем.</p><p><code class="inline">mix ecto.create</code><br></p><p>Вышеупомянутая команда создаст нашу базу данных. Теперь мы можем запустить наш Phoenix-сервер и проверить, все ли в порядке.</p><p><code class="inline">mix phoenix.server</code><br></p><p>Вышеупомянутая команда запускает наш Phoenix-сервер, и мы можем перейти к <span>http://localhost:4000</span>, чтобы увидеть, как он работает. В настоящее время он будет бросать  ошибку <strong>no route found</strong>, поскольку мы еще не создали никаких маршрутов!</p><p>Не стесняйтесь проверять свои изменения с помощью моего <span>коммита</span>.</p><h3>Добавление модели фида</h3><p>На этом этапе мы добавим нашу модель <strong>Feed</strong> в наше приложение Phoenix. Модель Feeds будет состоять из <strong>title</strong> и <strong>description</strong>.</p><p><code class="inline">mix phoenix.gen.json Feed feeds title:string description:string</code><br></p><p>Вышеприведенная команда создаст нашу модель и контроллер <strong>Feed</strong>. Она также будет генерировать спецификации (которые мы не будем модифицировать в этом учебнике, просто для краткости).</p><p>Вам нужно добавить маршрут <code class="inline">/feeds</code> в файл <strong>web/router.ex</strong> внутри скоупа <strong>api</strong>:</p><p><code class="inline">resources "/feeds", FeedController, except: [:new, :edit]</code><br></p><p>Нам также необходимо выполнить миграцию, чтобы создать таблицу <strong>feeds</strong> в нашей базе данных:</p><p><code class="inline">mix ecto.migrate</code></p><p>Теперь, если мы перейдем на http<span>://localhost:4000/api/feeds</span>, мы увидим, что API отправляет нам пустой ответ, поскольку в нашей таблице <strong>feeds</strong> нет данных.</p><p>Вы можете проверить мой <span>коммит</span> для справки.</p><h3>Добавление канала фидов</h3><p>На этом этапе мы добавим канал <strong>Feed</strong> в наше приложение Phoenix. Каналы предоставляют средства для двунаправленной связи от клиентов, которые интегрируются со слоем <code class="inline">Phoenix.PubSub</code> для легкой функциональности в реальном времени.<br></p><p><code class="inline">mix phoenix.gen.channel feed</code><br></p><p>Вышеприведенная команда создаст файл <strong>feed_channel.ex</strong> внутри папки <strong>web/channels</strong>. Через этот файл наше приложение React будет обмениваться обновленными данными с базой данных с помощью сокетов.</p><p>Нам нужно добавить новый канал в наш файл <strong>web/channels/user_socket.ex</strong>:</p><p><code class="inline">channel "feeds", RealtimeFeedApi.FeedChannel</code><br></p><p>Поскольку мы не делаем аутентификацию для этого приложения, мы можем изменить наш файл <strong>web/channels/feed_channel.ex</strong>. Нам понадобится один метод <strong>join</strong> для нашего приложения React, чтобы присоединиться к нашему каналу фидов, один метод <b>handle_out</b>, чтобы отправлять полезную нагрузку через соединение сокета, и один метод <strong>broadcast_create</strong>, который будет транслировать полезную нагрузку всякий раз, когда в базе данных создается новый фид.</p><pre class="brush: erlang noskimlinks noskimwords">def join("feeds", payload, socket) do  {:ok, "Joined feeds", socket}end</pre><pre class="brush: erlang noskimlinks noskimwords">def handle_out(event, payload, socket) do  push socket, event, payload  {:noreply, socket}end</pre><pre class="brush: erlang noskimlinks noskimwords">def broadcast_create(feed) do  payload = %{    "id" =&gt; to_string(feed.id),    "title" =&gt; feed.title,    "description" =&gt; feed.description  }  RealtimeFeedApi.Endpoint.broadcast("feeds", "app/FeedsPage/HAS_NEW_FEEDS", payload)end</pre><p>Эти три метода определены выше. В методе <strong>broadcast_create</strong> мы используем <code class="inline">app/FeedsPage/HAS_NEW_FEEDS</code>, так как мы будем использовать это как константу для нашего контейнера состояний Redux, который будет отвечать за то, чтобы фронтенду было известно, что в базе данных есть новые фиды. Мы обсудим это, когда мы создадим наше фронтенд приложение.</p><p>В конце концов, нам нужно будет только вызвать метод <strong>broadcast_change</strong> через наш файл <strong>feed_controller.ex</strong> всякий раз, когда в наш метод <strong>create</strong> вставляются новые данные. Наш метод <strong>create</strong> будет выглядеть примерно так:</p><pre class="brush: erlang noskimlinks noskimwords">def create(conn, %{"feed" =&gt; feed_params}) do  changeset = Feed.changeset(%Feed{}, feed_params)  case Repo.insert(changeset) do    {:ok, feed} -&gt;      RealtimeFeedApi.FeedChannel.broadcast_create(feed)      conn      |&gt; put_status(:created)      |&gt; put_resp_header("location", feed_path(conn, :show, feed))      |&gt; render("show.json", feed: feed)    {:error, changeset} -&gt;      conn      |&gt; put_status(:unprocessable_entity)      |&gt; render(RealtimeFeedApi.ChangesetView, "error.json", changeset: changeset)  endend</pre><p>Метод <strong>create</strong> отвечает за вставку новых данных в базу данных. Вы можете проверить <span>мой</span> коммит для справки.</p><h3>Добавление поддержки CORS для API</h3><p>Нам нужно реализовать эту поддержку, поскольку в нашем случае API обслуживается с <span>http://localhost:4000</span>, но наше фронтенд приложение будет работать на <span>http://localhost:3000</span>. Добавление поддержки CORS очень просто. Нам просто нужно добавить <span>cors_plug</span> в наш файл <strong>mix.exs</strong>:</p><pre class="brush: erlang noskimlinks noskimwords">defp deps do  [   ...   {:cors_plug, "~&gt; 1.3"}  ]end</pre><p>Теперь мы останавливаем наш сервер Phoenix с помощью <strong>Control-C</strong> и выбираем зависимость, используя следующую команду:</p><p><code class="inline">mix deps.get</code><br></p><p>Нам нужно добавить следующую строку в наш файл <strong>lib/realtime_feed_api/endpoint.ex</strong>:</p><p><code class="inline">plug CORSPlug</code><br></p><p>Вы можете проверить мой <span>коммит</span>. Мы выполнили все наши текущие изменения. Давайте теперь сосредоточимся на фронтенд приложении.</p><h2>Обновление данных фронтенд в реальном времени</h2><p>Как упоминалось ранее, мы будем использовать <span>react-boilerplate</span>, чтобы начать работу с нашим фронтенд приложением. Мы будем использовать саму <span>Redux saga</span>, который будет слушать наши отправленные действия, и на основе этого пользовательский интерфейс будет обновлять данные. </p><p>Поскольку в шаблоне уже настроено все, нам не нужно его настраивать. Тем не менее, мы будем использовать <span>команды</span>, доступные в шаблоне, чтобы подкрасить наше приложение. Давайте сначала клонируем репозиторий:</p><p><code class="inline">git clone </code><span><code class="inline">https://github.com/react-boilerplate/react-boilerplate.git</code></span> realtime_feed_ui<br></p><h3>Создание приложения</h3><p>Теперь нам нужно зайти в папку <strong>realtime_feed_ui</strong> и установить зависимости.</p><p><code class="inline">cd realtime_feed_ui &amp;&amp; npm run setup</code></p><p>Это инициализирует новый проект с помощью этого шаблона, удаляет историю git <code class="inline">react-boilerplate</code>, устанавливает зависимости и инициализирует новый репозиторий.</p><p>Теперь давайте удалим пример приложения, который предоставляется шаблоном, и заменим его наименьшим количеством кода, необходимого для начала написания нашего приложения:</p><p><code class="inline">npm run clean</code></p><p>Теперь мы можем запустить наше приложение, используя <code class="inline">npm run start</code> и посмотреть, как он работает на <span>http://localhost:3000/</span>.</p><p>Вы можете ссылаться на мой <span>коммит</span>.</p><h3>Добавление необходимых контейнеров</h3><p>На этом этапе мы добавим два новых контейнера <strong>FeedsPage</strong> и <strong>AddFeedPage</strong> в наше приложение. Контейнер <strong>FeedsPage</strong> отобразит список фидов, а контейнер <strong>AddFeedPage</strong> позволит нам добавить новый фид в нашу базу данных. Для создания наших контейнеров мы будем использовать react-boilerplate.</p><p><code class="inline">npm run generate container</code><br></p><p>Вышеупомянутая команда используется для скаффолдинга в нашем приложении. После того, как вы наберете эту команду, он попросит имя компонента, которое в нашем случае будет <strong>FeedsPage</strong>, и мы будем использовать параметр <strong>Component</strong> на следующем шаге. Нам не понадобятся заголовки, но нам понадобятся <strong>actions/constants/selectors/reducer</strong>, а также <b>sages</b> для наших асинхронных потоков. Нам не нужны <strong>i18n messages</strong> для нашего приложения. Нам также необходимо будет придерживаться аналогичного подхода для создания нашего контейнера <b>AddFeedPage</b>.</p><p>Теперь у нас есть куча новых файлов для работы. Это экономит нам много времени. В противном случае нам придется создавать и настраивать все эти файлы самостоятельно. Кроме того, генератор создает тестовые файлы, которые очень полезны, но мы не будем писать тесты в этом уроке.</p><p>Давайте просто добавим наши контейнеры в наш файл <strong>routes.js</strong>:</p><pre class="brush: javascript noskimlinks noskimwords">{  path: "/feeds",  name: "feedsPage",  getComponent(nextState, cb) {    const importModules = Promise.all([      import("containers/FeedsPage/reducer"),      import("containers/FeedsPage/sagas"),      import("containers/FeedsPage"),    ]);    const renderRoute = loadModule(cb);    importModules.then(([reducer, sagas, component]) =&gt; {      injectReducer("feedsPage", reducer.default);      injectSagas(sagas.default);      renderRoute(component);    });    importModules.catch(errorLoading);  },}</pre><p>Это добавит наш контейнер <strong>FeedsPage</strong> в наш маршрут <code class="inline">/feeds</code>. Мы можем проверить это, посетив <span>http://localhost:3000/feeds</span>. В настоящее время он будет полностью пустым, поскольку в наших контейнерах ничего нет, но в консоли нашего браузера ошибок не будет.</p><p>Мы сделаем то же самое для нашего контейнера <strong>AddFeedPage</strong>.</p><p>Вы можете ссылаться на мой <span>коммит</span> для всех изменений.</p><h3>Создание листинговой страницы фидов</h3><p>На этом этапе мы создадим <strong>FeedsPage</strong>, в котором будут перечислены все наши фиды. Чтобы сохранить этот учебник небольшим, мы не будем здесь добавлять какие-либо стили, но в конце нашего приложения я сделаю отдельный коммит, который добавит некоторые декорации в наше приложение.</p><p>Начнем с добавления наших констант в наш файл <strong>app/container/FeedsPage/constants.js</strong>:</p><pre class="brush: javascript noskimlinks noskimwords">export const FETCH_FEEDS_REQUEST = "app/FeedsPage/FETCH_FEEDS_REQUEST";export const FETCH_FEEDS_SUCCESS = "app/FeedsPage/FETCH_FEEDS_SUCCESS";export const FETCH_FEEDS_ERROR = "app/FeedsPage/FETCH_FEEDS_ERROR";export const HAS_NEW_FEEDS = "app/FeedsPage/HAS_NEW_FEEDS";</pre><p>Нам понадобятся эти четыре константы:</p><ul><li>Константа <strong>FETCH_FEEDS_REQUEST</strong> будет использоваться для инициализации запроса на выборку.</li> <li>Константа <strong>FETCH_FEEDS_SUCCESS</strong> будет использоваться, когда запрос на выборку будет успешным.</li> <li>Константа <strong>FETCH_FEEDS_ERROR</strong> будет использоваться, когда запрос на выборку не будет выполнен.</li> <li>Константа <strong>HAS_NEW_FEEDS</strong> будет использоваться, если в нашей базе данных есть новый фид.</li> </ul><p>Давайте добавим наши действия в наш файл <strong>app/container/FeedsPage/actions.js</strong>:</p><pre class="brush: javascript noskimlinks noskimwords">export const fetchFeedsRequest = () =&gt; ({  type: FETCH_FEEDS_REQUEST,});export const fetchFeeds = (feeds) =&gt; ({  type: FETCH_FEEDS_SUCCESS,  feeds,});export const fetchFeedsError = (error) =&gt; ({  type: FETCH_FEEDS_ERROR,  error,});export const checkForNewFeeds = () =&gt; ({  type: HAS_NEW_FEEDS,});</pre><p>Все эти действия не требуют объяснений. Теперь мы структурируем <strong>initialState</strong> нашего приложения и добавим редюсер в наш файл <strong>app/container/FeedsPage/reducer.js</strong>:</p><pre class="brush: javascript noskimlinks noskimwords">const initialState = fromJS({  feeds: {    data: List(),    ui: {      loading: false,      error: false,    },  },  metadata: {    hasNewFeeds: false,  },});</pre><p>Это будет initialState нашего приложения (состояние перед загрузкой данных). Поскольку мы используем <span>ImmutableJS</span>, мы можем использовать его структуру данных <span>List</span> для хранения наших неизменных данных. Функция редюсера будет выглядеть примерно так:</p><pre class="brush: javascript noskimlinks noskimwords">function addFeedPageReducer(state = initialState, action) {  switch (action.type) {    case FETCH_FEEDS_REQUEST:      return state        .setIn(["feeds", "ui", "loading"], true)        .setIn(["feeds", "ui", "error"], false);    case FETCH_FEEDS_SUCCESS:      return state        .setIn(["feeds", "data"], action.feeds.data)        .setIn(["feeds", "ui", "loading"], false)        .setIn(["metadata", "hasNewFeeds"], false);    case FETCH_FEEDS_ERROR:      return state        .setIn(["feeds", "ui", "error"], action.error)        .setIn(["feeds", "ui", "loading"], false);    case HAS_NEW_FEEDS:      return state        .setIn(["metadata", "hasNewFeeds"], true);    default:      return state;  }}</pre><p>В принципе, то, что мы здесь делаем, меняет наше состояние на основе констант из наших действий. Таким образом, мы можем очень легко показать загрузчики и сообщения об ошибках. Это будет намного яснее, когда мы будем использовать это во фронтенде.</p><p>Пришло время создавать наши селекторы с помощью <span>reselect</span>, который является библиотекой селекторов для Redux. С помощью reselect мы можем легко извлекать значения сложного состояния. Давайте добавим следующие селекторs в наш <strong>app/containers/FeedsPage/selectors.js</strong>:</p><pre class="brush: javascript noskimlinks noskimwords">const feeds = () =&gt; createSelector(  selectFeedsPageDomain(),  (titleState) =&gt; titleState.get("feeds").get("data"));const error = () =&gt; createSelector(  selectFeedsPageDomain(),  (errorState) =&gt; errorState.get("feeds").get("ui").get("error"));const isLoading = () =&gt; createSelector(  selectFeedsPageDomain(),  (loadingState) =&gt; loadingState.get("feeds").get("ui").get("loading"));const hasNewFeeds = () =&gt; createSelector(  selectFeedsPageDomain(),  (newFeedsState) =&gt; newFeedsState.get("metadata").get("hasNewFeeds"));</pre><p>Как вы можете видеть здесь, мы используем структуру нашего <strong>initialState</strong> для извлечения данных из нашего состояния. Вам просто нужно запомнить синтаксис <span>reselect</span>.</p><p>Пришло время добавить наши sagas с использованием <span>redux-sage</span>. Здесь основная идея состоит в том, что нам нужно создать функцию для извлечения данных и другую функцию, чтобы наблюдать за начальной функцией, так что всякий раз, когда отправляется какое-либо конкретное действие, нам нужно вызвать начальную функцию. Давайте добавим функцию, которая будет извлекать наш список фидов из бекенд приложения в нашем файле <strong>app/container/FeedsPage/sagas.js</strong>:</p><pre class="brush: javascript noskimlinks noskimwords">function* getFeeds() {  const requestURL = "http://localhost:4000/api/feeds";  try {    // Call our request helper (see "utils/Request")    const feeds = yield call(request, requestURL);    yield put(fetchFeeds(feeds));  } catch (err) {    yield put(fetchFeedsError(err));  }}</pre><p>Здесь <strong>request</strong> - это просто функция-утилита, которая вызывает наш API бекенда. Весь файл доступен в <span>react-boilerplate</span>. Мы сделаем небольшое изменение в нем после заполнения нашего файла <strong>sagas.js</strong>.</p><p>Нам также нужно создать еще одну функцию для наблюдения функции <strong>getFeeds</strong>:</p><pre class="brush: javascript noskimlinks noskimwords">export function* watchGetFeeds() {  const watcher = yield takeLatest(FETCH_FEEDS_REQUEST, getFeeds);  // Suspend execution until location changes  yield take(LOCATION_CHANGE);  yield cancel(watcher);}</pre><p>Как мы видим здесь, функция <strong>getFeeds</strong> вызывается, когда мы вызываем действие, содержащее константу <strong>FETCH_FEEDS_REQUEST</strong>.</p><p>Теперь давайте скопируем файл <span>request.js</span> из react-boilerplate в наше приложение внутрь папки <strong>app/utils</strong>, а затем изменим функцию <strong>request</strong>:</p><pre class="brush: javascript noskimlinks noskimwords">export default function request(url, method = "GET", body) {  return fetch(url, {    headers: {      "Content-Type": "application/json",    },    method,    body: JSON.stringify(body),  })    .then(checkStatus)    .then(parseJSON);}</pre><p>Я только что добавил несколько значений по умолчанию, которые помогут нам сократить код позже, поскольку нам не нужно передавать метод и заголовки каждый раз. Теперь нам нужно создать другой файл util внутри папки <strong>app/utils</strong>. Мы назовем этот файл <strong>socketSagas.js</strong>. Он будет содержать четыре функции: <strong>connectToSocket</strong>, <b>joinChannel</b>, <b>createSocketChannel</b> и <strong>handleUpdatedData</strong>. </p><p>Функция <b>connectToSocket</b> будет отвечать за подключение к нашему бекенд API. Мы будем использовать npm пакет <strong>phoenix</strong> . Поэтому нам нужно будет установить его:</p><p><strong></strong><code class="inline">npm install phoenix --save</code></p><p>Это установит npm пакет <strong>phoenix</strong> и сохранит его в нашем файле <strong>package.json</strong>. Функция <strong>connectToSocket</strong> будет выглядеть примерно так:</p><pre class="brush: javascript noskimlinks noskimwords">export function* connectToSocket() {  const socket = new Socket("ws:localhost:4000/socket");  socket.connect();  return socket;}</pre><p>Затем мы определяем нашу функцию <strong>joinChannel</strong>, которая будет отвечать за присоединение определенного канала от бекенда. Функция <b>joinChannel</b> будет иметь следующее содержимое:</p><pre class="brush: javascript noskimlinks noskimwords">export function* joinChannel(socket, channelName) {  const channel = socket.channel(channelName, {});  channel.join()    .receive("ok", (resp) =&gt; {      console.log("Joined successfully", resp);    })    .receive("error", (resp) =&gt; {      console.log("Unable to join", resp);    });  return channel;}</pre><p>Если присоединение будет успешным, мы будем логировать "Joined successfully" только для тестирования. Если во время фазы соединения произошла ошибка, мы также будем регистрировать это только для целей отладки.</p><p><strong>CreateSocketChannel</strong> будет отвечать за создание канала событий из данного сокета.</p><pre class="brush: javascript noskimlinks noskimwords">export const createSocketChannel = (channel, constant, fn) =&gt;  // `eventChannel` takes a subscriber function  // the subscriber function takes an `emit` argument to put messages onto the channel  eventChannel((emit) =&gt; {    const newDataHandler = (event) =&gt; {      console.log(event);      emit(fn(event));    };    channel.on(constant, newDataHandler);    const unsubscribe = () =&gt; {      channel.off(constant, newDataHandler);    };    return unsubscribe;  });</pre><p>Эта функция также будет полезна, если мы хотим отказаться от подписки на конкретном канале.</p><p><strong>HandleUpdatedData</strong> будет просто вызывать действие, переданное ему в качестве аргумента.</p><pre class="brush: javascript noskimlinks noskimwords">export function* handleUpdatedData(action) {  yield put(action);}</pre><p>Теперь добавим остальные sags в наш файл <strong>app/container/FeedsPage/sagas.js</strong>. Здесь мы создадим еще две функции: <strong>connectWithFeedsSocketForNewFeeds</strong> и <b>watchConnectWithFeedsSocketForNewFeeds</b>. </p><p>Функция <strong>connectWithFeedsSocketForNewFeeds</strong> будет отвечать за подключение к бекенд сокету и проверку новых фидов. Если есть какие-либо новые фиды, он вызовет функцию <strong>createSocketChannel</strong> из файла <b>utils/socketSagas.js</b>, который создаст канал событий для данного сокета. Функция <strong>connectWithFeedsSocketForNewFeeds</strong> будет содержать следующее:</p><pre class="brush: javascript noskimlinks noskimwords">function* connectWithFeedsSocketForNewFeeds() {  const socket = yield call(connectToSocket);  const channel = yield call(joinChannel, socket, "feeds");  const socketChannel = yield call(createSocketChannel, channel, HAS_NEW_FEEDS, checkForNewFeeds);  while (true) {    const action = yield take(socketChannel);    yield fork(handleUpdatedData, action);  }}</pre><p>И <strong>watchConnectWithFeedsSocketForNewFeeds</strong> будет иметь следующее:</p><pre class="brush: javascript noskimlinks noskimwords">export function* watchConnectWithFeedsSocketForNewFeeds() {  const watcher = yield takeLatest(FETCH_FEEDS_SUCCESS, connectWithFeedsSocketForNewFeeds);  // Suspend execution until location changes  yield take(LOCATION_CHANGE);  yield cancel(watcher);}</pre><p>Теперь мы свяжем все с нашим файлом <strong>app/container/FeedsPage/index.js</strong>. Этот файл будет содержать все элементы пользовательского интерфейса. Начнем с вызова prop, который будет извлекать данные из бекенда нашего <strong>componentDidMount</strong>:</p><pre class="brush: javascript noskimlinks noskimwords">componentDidMount() {  this.props.fetchFeedsRequest();}</pre><p>Это приведет к загрузке всех фидов. Теперь нам нужно снова вызвать функцию <strong>fetchFeedsRequest</strong>, когда prop <strong>hasNewFeeds</strong> истен (вы можете обратиться к начальному состоянию нашего редюсера для структуры нашего приложения):</p><pre class="brush: javascript noskimlinks noskimwords">componentWillReceiveProps(nextProps) {    if (nextProps.hasNewFeeds) {      this.props.fetchFeedsRequest();    }  }</pre><p>После этого мы просто рендерим фиды в нашей функции render. Мы создадим функцию <strong>feedsNode</strong> со следующим содержимым:</p><pre class="brush: javascript noskimlinks noskimwords">feedsNode() {  return [...this.props.feeds].reverse().map((feed) =&gt; { // eslint-disable-line arrow-body-style    return (      &lt;div        className="col-12"        key={feed.id}      &gt;        &lt;div          className="card"          style={{ margin: "15px 0" }}        &gt;          &lt;div className="card-block"&gt;            &lt;h3 className="card-title"&gt;{ feed.title }&lt;/h3&gt;            &lt;p className="card-text"&gt;{ feed.description }&lt;/p&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    );  });}</pre><p>И тогда мы можем вызвать этот метод в нашем методе <strong>render</strong>:</p><pre class="brush: javascript noskimlinks noskimwords">render() {  if (this.props.loading) {    return (      &lt;div&gt;Loading...&lt;/div&gt;    );  }  return (    &lt;div className="row"&gt;      {this.feedsNode()}    &lt;/div&gt;  );}</pre><p>Если мы перейдем на <span>http://localhost:3000/feeds</span>, мы увидим, что на нашей консоли:</p><p><code class="inline">Присоединился успешно</code><br></p><p>Это означает, что наш API фидов работает отлично, и мы успешно подключили наш фронтенд к нашему бекенду. Теперь нам просто нужно создать форму, через которую мы можем ввести новый фид.</p><p>Не стесняйтесь ссылаться на мой <span>коммит</span>, потому что в нем выполнено многое!</p><h3>Создайте форму для добавления нового фида</h3><p>На этом этапе мы создадим форму, через которую мы можем добавить новый фид в нашу базу данных.</p><p>Начнем с добавления констант в <strong>app/containers/AddFeedPage/constants.js</strong>:</p><pre class="brush: javascript noskimlinks noskimwords">export const UPDATE_ATTRIBUTES = "app/AddFeedPage/UPDATE_ATTRIBUTES";export const SAVE_FEED_REQUEST = "app/AddFeedPage/SAVE_FEED_REQUEST";export const SAVE_FEED_SUCCESS = "app/AddFeedPage/SAVE_FEED_SUCCESS";export const SAVE_FEED_ERROR = "app/AddFeedPage/SAVE_FEED_ERROR";</pre><p>Константа <strong>UPDATE_ATTRIBUTES</strong> будет использоваться, когда мы добавим текст в поле ввода. Все остальные константы будут использоваться для сохранения заголовка и описания фида в нашей базе данных.</p><p>Контейнер <strong>AddFeedPage</strong> будет использовать четыре действия: <strong>updateAttributes</strong>, <b>saveFeedRequest</b>, <strong>saveFeed</strong> и <b>saveFeedError</b>. Функция <strong>updateAttributes</strong> обновит атрибуты нашего нового фида. Это означает, что всякий раз, когда мы вводим что-то в поле ввода заголовка и описания фида, функция <strong>updateAttributes</strong> обновляет наше состояние Redux. Эти четыре действия будут выглядеть примерно так:</p><pre class="brush: javascript noskimlinks noskimwords">export const updateAttributes = (attributes) =&gt; ({  type: UPDATE_ATTRIBUTES,  attributes,});export const saveFeedRequest = () =&gt; ({  type: SAVE_FEED_REQUEST,});export const saveFeed = () =&gt; ({  type: SAVE_FEED_SUCCESS,});export const saveFeedError = (error) =&gt; ({  type: SAVE_FEED_ERROR,  error,});</pre><p>Затем добавим функции редюсера в файл <strong>app/container/AddFeedPage/reducer.js</strong>. <strong>InitialState</strong> будет выглядеть следующим образом:</p><pre class="brush: javascript noskimlinks noskimwords">const initialState = fromJS({  feed: {    data: {      title: "",      description: "",    },    ui: {      saving: false,      error: null,    },  },});</pre><p>И функция редюсера будет выглядеть примерно так:</p><pre class="brush: javascript noskimlinks noskimwords">function addFeedPageReducer(state = initialState, action) {  switch (action.type) {    case UPDATE_ATTRIBUTES:      return state        .setIn(["feed", "data", "title"], action.attributes.title)        .setIn(["feed", "data", "description"], action.attributes.description);    case SAVE_FEED_REQUEST:      return state        .setIn(["feed", "ui", "saving"], true)        .setIn(["feed", "ui", "error"], false);    case SAVE_FEED_SUCCESS:      return state        .setIn(["feed", "data", "title"], "")        .setIn(["feed", "data", "description"], "")        .setIn(["feed", "ui", "saving"], false);    case SAVE_FEED_ERROR:      return state        .setIn(["feed", "ui", "error"], action.error)        .setIn(["feed", "ui", "saving"], false);    default:      return state;  }}</pre><p>Затем мы будем конфигурировать наш файл <strong>app/container/AddFeedPage/selectors.js</strong>. Он будет иметь четыре селектора: <strong>title</strong>, <b>description</b>, <strong>error</strong> и <b>saving</b>. Как следует из названия, эти селекторы извлекают эти состояния из состояния Redux и делают его доступным в нашем контейнере в качестве props.</p><p>Эти четыре функции будут выглядеть следующим образом:</p><pre class="brush: javascript noskimlinks noskimwords">const title = () =&gt; createSelector(  selectAddFeedPageDomain(),  (titleState) =&gt; titleState.get("feed").get("data").get("title"));const description = () =&gt; createSelector(  selectAddFeedPageDomain(),  (titleState) =&gt; titleState.get("feed").get("data").get("description"));const error = () =&gt; createSelector(  selectAddFeedPageDomain(),  (errorState) =&gt; errorState.get("feed").get("ui").get("error"));const saving = () =&gt; createSelector(  selectAddFeedPageDomain(),  (savingState) =&gt; savingState.get("feed").get("ui").get("saving"));</pre><p>Затем, давайте настроим наши sagas для контейнера <strong>AddFeedPage</strong>. Он будет иметь две функции: <strong>saveFeed</strong> и <b>watchSaveFeed</b>. Функция <strong>saveFeed</strong> будет отвечать за выполнение запроса <b>POST</b> на наш API, и она будет содержать следующее:</p><pre class="brush: javascript noskimlinks noskimwords">export function* saveFeed() {  const title = yield select(feedTitle());  const description = yield select(feedDescription());  const requestURL = "http://localhost:4000/api/feeds";  try {    // Call our request helper (see "utils/Request")    yield put(saveFeedDispatch());    yield call(request, requestURL, "POST",      {        feed: {          title,          description,        },      },    );  } catch (err) {    yield put(saveFeedError(err));  }}</pre><p>Функция <strong>watchSaveFeed</strong> будет похожа на наши предыдущие функции наблюдателей:</p><pre class="brush: javascript noskimlinks noskimwords">export function* watchSaveFeed() {  const watcher = yield takeLatest(SAVE_FEED_REQUEST, saveFeed);  // Suspend execution until location changes  yield take(LOCATION_CHANGE);  yield cancel(watcher);}</pre><p>Затем нам просто нужно отобразить форму в нашем контейнере. Чтобы сохранить модульность, давайте создадим подкомпонент для формы. Создайте новый файл <strong>form.js</strong> внутри нашей папки <strong>app/container/AddFeedPage/sub-components</strong> (папка <strong>sub-components</strong> - это новая папка, которую вам нужно будет создать). Он будет содержать форму с одним полем ввода для заголовка фида и одним текстовым полем для описания фида. Метод <strong>render</strong> будет иметь следующее содержимое:</p><pre class="brush: javascript noskimlinks noskimwords">render() {  return (    &lt;form style={{ margin: "15px 0" }}&gt;      &lt;div className="form-group"&gt;        &lt;label htmlFor="title"&gt;Title&lt;/label&gt;        &lt;input          type="text"          className="form-control"          id="title"          placeholder="Enter title"          onChange={this.handleChange}          name="title"          value={this.state.title}        /&gt;      &lt;/div&gt;      &lt;div className="form-group"&gt;        &lt;label htmlFor="description"&gt;Description&lt;/label&gt;        &lt;textarea          className="form-control"          id="description"          placeholder="Enter description"          onChange={this.handleChange}          name="description"          value={this.state.description}        /&gt;      &lt;/div&gt;      &lt;button        type="button"        className="btn btn-primary"        onClick={this.handleSubmit}        disabled={this.props.saving || !this.state.title || !this.state.description }      &gt;        {this.props.saving ? "Saving..." : "Save"}      &lt;/button&gt;    &lt;/form&gt;  );}</pre><p>Мы создадим еще две функции: <strong>handleChange</strong> и <b>handleSubmit</b>. Функция <strong>handleChange</strong> отвечает за обновление нашего состояния Redux всякий раз, когда мы добавляем некоторый текст, а функция <b>handleSubmit</b> вызывает наш API для сохранения данных в нашем состоянии Redux.</p><p>Функция <strong>handleChange</strong> содержит следующее:</p><pre class="brush: javascript noskimlinks noskimwords">handleChange(e) {  this.setState({    [e.target.name]: e.target.value,  });}</pre><p>И функция <b>handleSubmit</b> будет содержать следующее:</p><pre class="brush: javascript noskimlinks noskimwords">handleSubmit() {  // doing this will make the component faster  // since it doesn"t have to re-render on each state update  this.props.onChange({    title: this.state.title,    description: this.state.description,  });  this.props.onSave();  this.setState({    title: "",    description: "",  });}</pre><p>Здесь мы сохраняем данные и очищаем значения формы.</p><p>Теперь, вернемся к нашему файлу <strong>app/container/AddFeedPage/index.js</strong>, мы просто рендерим только что созданную форму.</p><pre class="brush: javascript noskimlinks noskimwords">render() {  return (    &lt;div&gt;      &lt;Form        onChange={(val) =&gt; this.props.updateAttributes(val)}        onSave={() =&gt; this.props.saveFeedRequest()}        saving={this.props.saving}      /&gt;    &lt;/div&gt;  );}</pre><p>Теперь весь наш кодинг завершен. Не стесняйтесь проверять мой <span>коммит</span>, если у вас есть какие-либо сомнения.</p><h2>Завершение</h2><p>Мы завершили строительство нашего приложения. Теперь мы можем посетить <span>http://localhost:3000/feeds/new</span> и добавить новые фиды, которые будут отображаться в реальном времени по адресу <span>http://localhost:3000/feeds</span>. Нам не нужно обновлять страницу, чтобы увидеть новые фиды. Вы также можете попробовать это, открыв <span>http://localhost:3000/feeds</span> на двух вкладках бок о бок и протестировать это!</p><h2>Заключение</h2><p>Это будет просто пример приложения, чтобы показать реальные возможности объединения Phoenix с React. В большинстве случаев мы используем данные в реальном времени, и это может помочь вам понять, как это происходит. Надеюсь, вы нашли этот учебник полезным.</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824912-kak-sozdat-lentu-v-realnom-vremeni-s-pomoschyu-phoenix-i-react" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="React" href="https://norma-studio.github.io/article/220824912-kak-sozdat-lentu-v-realnom-vremeni-s-pomoschyu-phoenix-i-react" class="tm-article-body__tags-item-link">React</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
34853</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
605</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

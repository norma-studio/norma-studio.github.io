
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Создание безупречной карусели. Часть 2... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Создание безупречной карусели. Часть 2... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Создание безупречной карусели. Часть 2... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Создание безупречной карусели. Часть 2... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Добро пожаловать в серии руководств ">
<meta property="og:description" content="Добро пожаловать в серии руководств ">
<meta name="twitter:description" content="Добро пожаловать в серии руководств ">
<meta property="aiturec:description" content="Добро пожаловать в серии руководств ">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/34/posts/29592/image/carousel-with-marking.png">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/34/posts/29592/image/carousel-with-marking.png">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/34/posts/29592/image/carousel-with-marking.png">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/34/posts/29592/image/carousel-with-marking.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/34/posts/29592/image/carousel-with-marking.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article/220824855-sozdanie-bezuprechnoi-karuseli-chast-2.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article/220824855-sozdanie-bezuprechnoi-karuseli-chast-2.html">
<link rel="canonical" href="https://norma-studio.github.io/article/220824855-sozdanie-bezuprechnoi-karuseli-chast-2.html">
<meta property="og:url" content="https://norma-studio.github.io/article/220824855-sozdanie-bezuprechnoi-karuseli-chast-2.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article/220824855-sozdanie-bezuprechnoi-karuseli-chast-2.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article/220824855-sozdanie-bezuprechnoi-karuseli-chast-2.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article/220824855-sozdanie-bezuprechnoi-karuseli-chast-2.html" title="Создание безупречной карусели. Часть 2... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Создание безупречной карусели. Часть 2... | envatomarket.ru | norma-studio.github.io" title="Создание безупречной карусели. Часть 2... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/636534636.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article/220824855-sozdanie-bezuprechnoi-karuseli-chast-2.html" class="tm-user-info__username" title="
С. Новичков" aria-label="
С. Новичков">
С. Новичков</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Создание безупречной карусели. Часть 2...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824855-sozdanie-bezuprechnoi-karuseli-chast-2" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Animation" href="https://norma-studio.github.io/article/220824855-sozdanie-bezuprechnoi-karuseli-chast-2" class="tm-article-snippet__hubs-item-link"><span>Animation</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article/220824855-sozdanie-bezuprechnoi-karuseli-chast-2.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/34/posts/29592/image/carousel-with-marking.png">
    <meta itemprop="headline name" content="Создание безупречной карусели. Часть 2... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Добро пожаловать в серии руководств ">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Добро пожаловать в серии руководств </span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Добро пожаловать в серии руководств "Создание безупречной карусели". Мы создаем удобную и очаровательную карусель при помощи возможностей Popmotion по симуляции физических явлений (* вроде скорости, ускорения, трения, усилия пружины. Здесь и далее примеч. пер.), JavaScript, твининга (* построение промежуточных отображений; плавный переход от одного значения к другому) и отслеживания действий пользователя.</p><p>В <span>1-й части</span> этой серии мы рассмотрели, как Amazon и Netflix реализовали их карусели, и оценили достоинства и недостатки их подходов. Используя полученные знания, мы выбрали стратегию создания нашей карусели и реализовали возможность прокрутки контента при помощи касаний за счет возможностей Popmotion по симуляции физических явлений.</p><p>Во второй части мы реализуем возможность прокрутки контента по горизонтали. Также мы рассмотрим некоторые обычные приемы реализации пагинации (* перехода по страницам/элементам) и воспользуемся одним. Наконец, мы подключим индикатор хода процесса, при помощи которого будет указываться, сколько контента карусели просмотрел пользователь.</p><p>Вы можете освежить в памяти, где мы остановились, посетив этот <span>Pen </span>(* фрагмент кода) на Codepen.<br></p><h2>Добавляем возможность прокрутки контента по горизонтали</h2><p>Редко бывает, чтобы в карусели, реализованной при помощи JavaScript, присутствовала возможность прокрутки контента по горизонтали. Это печально: для пользователей лэптопов и мышек с возможностью прокрутки контента по горизонтали, основанной на инерции (* инерциальная прокрутка), этот способ является наиболее быстрым способом просмотра элементов карусели. Это настолько же печально, как то, когда пользователей, имеющих возможность управления контентом при помощи касаний, принуждают просматривать элементы карусели при помощи кнопок, а не движений пальцами по экрану.</p><p>К счастью, этот способ можно реализовать при помощи нескольких строк кода. В конце функции <code class="inline">carousel</code> добавьте новый слушатель событий:</p><pre class="brush: javascript noskimlinks noskimwords">container.addEventListener("wheel", onWheel);</pre><p>Ниже вашего обработчика событий <code class="inline">startTouchScroll</code> добавьте заглушку (* небольшой фрагмент программного кода, который либо ничего не делает, либо печатает сообщение типа "FileOpenStub", либо подставляет необходимые для отладки данные и т. д.; вставляется в разрабатываемую программу вместо ещё не написанной функции (драйвера, модуля, подсистемы, ...)) под названием <code class="inline">onWheel</code>:</p><pre class="brush: javascript noskimlinks noskimwords">function onWheel(e) {  console.log(e.deltaX)}</pre><p>Теперь, если вы воспользуетесь колесиком прокрутки, находясь в карусели, и проверите свою консоль, то увидите там данные о расстоянии, на которое мы переместились по оси Х при помощи колесика.</p><p>Как и в случае с прокруткой контента при помощи касаний, если движение колесика осуществляется по вертикали, как это обычно происходит, то страница должна прокручиваться как обычно. Если движение колесика осуществляются по горизонтали, то нам необходимо собрать данные о движении колесика и применить их к карусели. Так что в <code class="inline">onWheel</code> замените <code class="inline">console.log</code> следующим кодом:</p><pre class="brush: javascript noskimlinks noskimwords">const angle = calc.angle({  x: e.deltaX,  y: e.deltaY});if (angleIsVertical(angle)) return;e.stopPropagation();e.preventDefault();</pre><p>При помощи этого блока кода прокрутка страницы остановится, если она происходит по горизонтали. Для обновления отступа нашей карусели по оси Х теперь всего лишь необходимо получить значение свойства <code class="inline">deltaX</code> объекта события и добавить его к текущему значению <code class="inline">sliderX</code>:</p><pre class="brush: javascript noskimlinks noskimwords">const newX = clampXOffset(  sliderX.get() + - e.deltaX);sliderX.set(newX);</pre><p>Мы повторно используем нашу ранее созданную функцию <code class="inline">clampXOffset</code> для обертывания этих вычислений и обеспечения того, чтобы карусель не прокручивалась за пределы ее рассчитанных границ.</p><h3>Отступление по поводу ограничения частоты генерации событий, возникающих при прокручивании</h3><p>В любом хорошем руководстве, в котором работают с событиями, возникающими при действиях со стороны пользователя, будет объяснена важность<span> ограничения частоты возникновения</span>  тех событий. Это так, поскольку события, возникающие при прокрутке, действиях с мышкой и действиях, выполняемых пользователем касаниями пальцев по экрану, все могут генерироваться быстрее частоты смены кадров (* скорость сканирования или вывода на экран видеокадров - дискретных изображений (30 кадр/с в стандарте NTSC и 25 кадр/с в стандарте PAL/SECAM)) устройства.</p><p>Вам не нужно, чтобы выполнялась лишняя ресурсоемкая работа вроде рендеринга (* в КГА – процесс визуализации – построения графической сцены или трёхмерного объекта по его описанию и последующего отображения результата в растровую цифровую форму. Во время рендеринга происходит наложение текстур, освещения, затенения, тумана и др.) карусели дважды за один фрейм, поскольку это пустая растрата ресурсов и прямая дорога к медленно реагирующему интерфейсу.</p><p>В этом руководстве не затрагивался этот вопрос, поскольку рендереры, предоставляемые Popmotion, используют <span>Framesync</span>, крошечный планировщик обработки заданий, синхронизированный с фреймами. Это означает, что вы могли бы вызвать <code class="inline">(v) =&gt; sliderRenderer.set("x", v)</code> множество раз подряд, а ресурсоемкий рендеринг был бы выполнен только однажды, в следующем фрейме.</p><h2>Пагинация</h2><p>На этом все с прокруткой. Теперь нам необходимо немного оживить навигационные кнопки, с которыми до сего времени не работали.</p><p>Теперь вот что: это руководство посвящено реализации возможности взаимодействия пользователя с интерфейсом, поэтому вы запросто можете изменить дизайн этих кнопок на тот, который вам необходим. Лично мне кажется, что указательные стрелки более интуитивно понятны (и полностью интернационализированы по умолчанию).</p><h3>Как должна работать пагинация?</h3><p>Имеется две явные стратегии, которыми мы могли бы воспользоваться для реализации возможности пагинации по элементам карусели: <strong>стратегия, согласно которой переход происходит постепенно по всем элементам</strong>, или <b>стратегия, согласно которой переход происходит по первым частично отображенным (* неотчётливым) элементам</b>. Только одна из них верна, однако поскольку я видел, как часто используется другая, то я подумал, что стоило бы объяснить, <em>почему</em> последняя неверна.</p><h3>1. Стратегия, согласно которой переход происходит постепенно по всем элементам</h3><figure></figure><p>Просто измерьте отступ по оси Х следующего элемента списка и переместите контейнер с элементами на то расстояние. Это очень простой алгоритм, который выбирают из-за его простоты, а не дружественности по отношению к пользователю.</p><p>Проблема заключается в том, что на большинстве экранов сможет отобразиться множество элементов одновременно, и люди бегло просмотрят их все перед тем, как попробовать перейти к следующему частично скрытому элементу.</p><p>При этом ваш интерфейс покажется пользователям медленно реагирующим, если не вовсе их огорчит. Единственная ситуация, когда этот вариант был бы удачным выбором, – та, когда вам <em>известно</em>, что элементы вашей карусели имеют тот же размер или немного меньше видимой области экрана.</p><p>Однако, если отображается множество элементов одновременно, то лучше использовать второй метод.</p><h3>2. Стратегия, согласно которой переход происходит по первым частично отображенным элементам</h3><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/34/posts/29592/image/carousel-with-marking.png" alt="Создание безупречной карусели. Часть 2..." title="Создание безупречной карусели. Часть 2..." width="50" height="50"></figure><p>При этом подходе происходит поиск <strong>первого частично отображенного элемента</strong> в направлении, в котором мы хотим перемещать карусель, получение его <strong>отступа по оси Х</strong> и прокручивание к нему.</p><p>За счет этого мы получаем максимальное число новых элементов, руководствуясь предположением, что пользователь уже видел все представленные на данный момент элементы.</p><p>Поскольку мы получаем больше элементов, то для перемещения по карусели требуется нажать навигационные кнопки меньшее число раз. В результате более быстрой навигации усилится вовлеченность пользователей и будет гарантировано, что они увидят большее число ваших продуктов.</p><h3>Слушатели событий</h3><p>Для начала давайте добавим слушатели событий, так чтобы мы могли начать работать над пагинацией.</p><p>Сперва нам необходимо выбрать наши кнопки для перехода к предыдущему и следующему элементам. <strong>Вверху</strong> функции <code class="inline">carousel</code> добавьте следующий код:</p><pre class="brush: javascript noskimlinks noskimwords">const nextButton = container.querySelector(".next");const prevButton = container.querySelector(".prev");</pre><p>Затем <strong>внизу</strong> функции <code class="inline">carousel</code> добавьте слушатели событий:</p><pre class="brush: javascript noskimlinks noskimwords">nextButton.addEventListener("click", gotoNext);prevButton.addEventListener("click", gotoPrev);</pre><p>Наконец, выше вашего блока со слушателями событий добавьте собственно функции:</p><pre class="brush: javascript noskimlinks noskimwords">function goto(delta) {}const gotoNext = () =&gt; goto(1);const gotoPrev = () =&gt; goto(-1);</pre><p><code class="inline">goto</code> – функция, в которой будет реализована вся логика для пагинации. Функция просто принимает число, которое представляет необходимое нам направление перемещения по карусели. <code class="inline">gotoNext</code> и <code class="inline">gotoPrev</code> просто вызывают эту функцию, передавая <code class="inline">1</code> или <code class="inline">-1</code> соответственно.</p><h3>Выбор «страницы»</h3><p>Пользователь может запросто прокрутить эту карусель, в ней имеется <code class="inline">n</code> элементов, и можно изменить размер карусели. Так что концепция традиционной страницы буквально здесь не подходит. Мы не будем подсчитывать количество страниц.</p><p>Вместо этого при вызове функции <code class="inline">goto</code> мы узнаем направление, указанное в <code class="inline">delta</code>, и получим первый частично отображенный элемент. Он станет первым элементом нашей следующей страницы.</p><p>На первом этапе нам необходимо получить текущий отступ по оси Х нашей карусели и воспользоваться им вместе с полной видимой шириной карусели для вычисления «идеального» отступа, на который мы бы хотели ее прокрутить. Идеальный отступ – тот, на который мы <em>бы</em> прокрутили карусель, если бы не были заинтересованы содержимым ее видимых элементов. Он предоставляет нам подходящее место для начала поиска нашего первого элемента.</p><pre class="brush: javascript noskimlinks noskimwords">const currentX = sliderX.get();let targetX = currentX + (- sliderVisibleWidth * delta);</pre><p>Мы можем выполнить здесь приблизительную оптимизацию. За счет передачи значения <code class="inline">targetX</code> в функцию <code class="inline">clampXOffset</code>, реализованную в предыдущем руководстве, мы можем проверить, отличается ли возвращаемое ею значение от того, что содержится в <code class="inline">targetX</code>. Если да, то это означает, что наше значение <code class="inline">targetX</code> находится за пределами значений границ нашей прокручиваемой области, так что нам не нужно определять ближайший частично отображенный элемент. Мы просто прокручиваем карусель до конца.</p><pre class="brush: javascript noskimlinks noskimwords">const clampedX = clampXOffset(targetX);targetX = (targetX === clampedX)  ? findClosestItemOffset(targetX, delta)  : clampedX;</pre><h3>Нахождение ближайшего частично отображенного элемента</h3><p>Необходимо отметить, что работа следующего кода основана на предположении, что <em>все элементы вашей карусели имеют одинаковый размер</em>. Это позволяет нам выполнить оптимизацию, которая заключается в том, что нам не нужно измерять размер каждого элемента. Если ваши элементы <em>имеют</em> различный размер, то нижеприведенное решение по-прежнему является хорошей отправной точкой. </p><p>Над функцией <code class="inline">goto</code> добавьте функцию <code class="inline">findClosestItemOffset</code>, упомянутую в последнем фрагменте кода:</p><pre class="brush: javascript noskimlinks noskimwords">function findClosestItem(targetX, delta) {}</pre><p>Для начала нам необходимо узнать ширину наших элементов и интервалов между ними. Метод <code class="inline">Element.getBoundingClientRect()</code> может предоставить нам эту информацию. Для определения ширины мы просто измеряем ширину первого элемента. Для того чтобы вычислить ширину интервала между элементами, мы можем измерить <code class="inline">right</code> (* правый) отступ первого элемента и <code class="inline">left</code> (* левый) отступ второго, а затем вычесть из последнего первый: </p><pre class="brush: javascript noskimlinks noskimwords">const { right, width } = items[0].getBoundingClientRect();const spacing = items[1].getBoundingClientRect().left - right;</pre><p>Теперь, при наличии значений переменных <code class="inline">targetX</code> и <code class="inline">delta</code>, переданных в функцию (* findClosestItem), у нас имеются все данные, необходимые для быстрого определения отступа, к которому нам необходимо прокрутить карусель.</p><p>Вычисление заключается в разделении абсолютного значения <code class="inline">targetX</code> на результат суммы <code class="inline">ширина элемента + ширина интервала</code>. В результате мы получим точное число элементов, которые можем уместить в пределах того расстояния.</p><pre class="brush: javascript noskimlinks noskimwords">const totalItems = Math.abs(targetX) / (width + spacing);</pre><p>Затем округляем с повышением числа или с понижением числа, в зависимости от направления пагинации (указанного в <code class="inline">delta</code>). В результате получится число <em>полных</em> элементов, которые мы можем уместить.</p><pre class="brush: javascript noskimlinks noskimwords">const totalCompleteItems = delta === 1  ? Math.floor(totalItems)  : Math.ceil(totalItems);</pre><p>Наконец, умножаем это число на сумму <code class="inline">ширина элемента + ширина интервала</code> для получения нового отступа, начинающегося с полностью отображенного элемента.</p><pre class="brush: javascript noskimlinks noskimwords">return 0 - totalCompleteItems * (width + spacing);</pre><h3>Анимация пагинации</h3><p>Теперь, когда у нас имеется значение <code class="inline">targetX</code>, мы можем санимировать карусель к нему. Для этого мы воспользуемся рабочей лошадкой веб-анимаций – <strong><span>твином</span></strong> (* от англ. tween).</p><p>Для тех, кто не в курсе, tween – сокращенное от <em>be</em>tween (* от англ. между). При помощи твина изменяются значения свойств в течение указанного периода времени. Если вы пользовались CSS-переходами, то знайте, что это одно и то же. </p><p>Имеется ряд преимуществ (и недостатков!) использования JavaScript вместо CSS для реализации твинов. Поскольку мы также анимируем <code class="inline">sliderX</code> при помощи возможностей Popmotion по симуляции физических явлений и на основании выполненных пользователем действий, то в этом случае нам будет легче придерживаться использования этой технологии (* JavaScript) и для реализации твинов.</p><p>Также за счет этого позднее мы можем подключить индикатор хода процесса, и он будет свободно работать со всеми нашими анимациями без дополнительных усилий с нашей стороны.</p><p>Для начала нам необходимо импортировать <code class="inline">tween</code> из Popmotion:</p><pre class="brush: javascript noskimlinks noskimwords">const { calc, css, easing, physics, pointer, transform, tween, value } = window.popmotion;</pre><p>В конце нашей функции <code class="inline">goto</code> мы можем добавить наш твин, при помощи которого значение изменяется от значения <code class="inline">currentX</code> к значению <code class="inline">targetX</code>:</p><pre class="brush: javascript noskimlinks noskimwords">tween({  from: currentX,  to: targetX,  onUpdate: sliderX}).start();</pre><p>По умолчанию в Popmotion в качестве значения <code class="inline">duration</code> задано <code class="inline">300</code> миллисекунд и <code class="inline">easing.easeOut</code> в качестве значения <code class="inline">ease</code> (* от англ. сглаживать; задавать вариант изменения анимации). Эти значения были выбраны специально для придания анимациям, возникающим при взаимодействии пользователя с интерфейсом, отзывчивого характера (* вроде ощущения замедления прокручивания карусели), однако вы запросто можете поэкспериментировать с этими значениями и посмотреть, получится ли у вас что-то более подходящее для вашего бренда.</p><h2>Индикатор хода процесса</h2><p>Пользователям полезно знать, какую часть карусели они уже просмотрели. Для этого мы можем подключить индикатор хода процесса.</p><p>Для вашего индикатора могло бы быть задано различное стилевое оформление. Для этого руководства я подготовил цветной элемент div высотой 5px, который располагается между кнопками для перехода к предыдущему и следующему элементам. В этом руководстве для нас важен и находится в центре нашего внимания именно способ, которым мы подключаем к нашему коду и анимируем индикатор.</p><p>Вы еще не видели индикатор, поскольку мы изначально задали для него правило <code class="inline">transform: scaleX(0)</code>. Мы используем трансформацию <code class="inline">scale</code> для подгонки ширины индикатора, поскольку, как мы разобрали в части 1, трансформации более эффективны, чем изменение значений свойств вроде <code class="inline">left</code> или, как в нашем случае, <code class="inline">width</code>.</p><p>Это также позволяет нам легко написать код, в котором размер задается в <em>процентах</em>: текущее значение <code class="inline">sliderX</code>, которое находится между значениями <code class="inline">minXOffset</code> и <code class="inline">maxXOffset</code>.</p><p>Давайте начнем с получения нашего индикатора <code class="inline">div.progress-bar</code> после селектора кнопки для перехода к предыдущему элементу (<code class="inline">prev</code>):</p><pre class="brush: javascript noskimlinks noskimwords">const progressBar = container.querySelector(".progress-bar");</pre><p>После определения <code class="inline">sliderRenderer</code> мы можем добавить рендерер (* аппаратный или программный продукт, выполняющий рендеринг изображения) для <code class="inline">progressBar</code>:</p><pre class="brush: javascript noskimlinks noskimwords">const progressBarRenderer = css(progressBar);</pre><p>Теперь давайте добавим функцию для обновления значения <code class="inline">scaleX</code> индикатора хода процесса.</p><p>Мы воспользуемся функцией объекта <code class="inline">calc</code> (* объект с методами для проведения различных вычислений) под названием <code class="inline">getProgressFromValue</code>. Она принимает диапазон, который в нашем случае задается значениями <code class="inline">minXOffset</code> и <code class="inline">maxXOffset</code>, и третье число. Эта функция возвращает информацию <strong>о положении</strong>, число между <code class="inline">0</code> и <code class="inline">1</code>, того третьего числа в пределах заданного диапазона.</p><pre class="brush: javascript noskimlinks noskimwords">function updateProgressBar(x) {  const progress = calc.getProgressFromValue(maxXOffset, minXOffset, x);  progressBarRenderer.set("scaleX", progress);}</pre><p>Мы указали диапазон здесь в виде <code class="inline">maxXOffset, minXOffset</code>, тогда как интуиция подсказывает, что эти значения должны были бы быть указаны в обратном порядке. Это так, поскольку значениями <code class="inline">x</code> и <code class="inline">maxXOffset</code> являются отрицательные числа, тогда как значением <code class="inline">minXOffset</code> является <code class="inline">0</code>. Формально <code class="inline">0</code> является большим из двух вышеуказанных чисел (* maxXOffset и minXOffset), однако меньшее значение собственно представляет максимальный отступ. Отрицательные значения, вы поняли?</p><p>Мы хотим, чтобы индикатор хода процесса обновлялся параллельно со значением <code class="inline">sliderX</code>, так что давайте изменим следующую строку:</p><pre class="brush: javascript noskimlinks noskimwords">const sliderX = value(0, (x) =&gt; sliderRenderer.set("x", x));</pre><p>На эту:</p><pre class="brush: javascript noskimlinks noskimwords">const sliderX = value(0, (x) =&gt; {  updateProgressBar(x);  sliderRenderer.set("x", x);});</pre><p>Теперь каждый раз при обновлении значения <code class="inline">sliderX</code> будет обновляться и значение индикатора хода процесса.</p><h2>Заключение</h2><p>На этом мы завершили с этой частью! Вы можете скачать самый последний код в этом <span>Pen </span>на Codepen. Мы успешно реализовали возможность прокрутку карусели по горизонтали при помощи колесика прокрутки, пагинации и индикатор хода процесса.</p><p>На данный момент карусель выглядит довольно хорошо! В последней части мы усовершенствуем ее. Мы добавим возможность полного управления каруселью при помощи клавиатуры, чтобы гарантировать то, что любой может ею пользоваться. </p><p>Также мы добавим несколько очаровательных эффектов при помощи дерганья, реализованного за счет эфекта усилия пружины, возникающего, когда пользователь пробует прокрутить карусель за ее пределы либо при помощи касаний вальцами, либо за счет пагинации. </p><p>Тогда и увидимся!</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824855-sozdanie-bezuprechnoi-karuseli-chast-2" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Animation" href="https://norma-studio.github.io/article/220824855-sozdanie-bezuprechnoi-karuseli-chast-2" class="tm-article-body__tags-item-link">Animation</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
42666</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
632</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

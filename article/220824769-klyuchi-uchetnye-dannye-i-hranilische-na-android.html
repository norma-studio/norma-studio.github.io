
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Ключи, учетные данные и хранилище на Android... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Ключи, учетные данные и хранилище на Android... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Ключи, учетные данные и хранилище на Android... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Ключи, учетные данные и хранилище на Android... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="В предыдущем материале о безопасности пользовательских данных Android мы рассмотрели шифрование данных с помощью предоставленного пользователем кода. В этом уроке перейдём к хранению учётных данных и ключей. Я начну с ознакомления с учётными данными и закончу примером защиты данных с помощью хранилища ключей KeyStore....">
<meta property="og:description" content="В предыдущем материале о безопасности пользовательских данных Android мы рассмотрели шифрование данных с помощью предоставленного пользователем кода. В этом уроке перейдём к хранению учётных данных и ключей. Я начну с ознакомления с учётными данными и закончу примером защиты данных с помощью хранилища ключей KeyStore....">
<meta name="twitter:description" content="В предыдущем материале о безопасности пользовательских данных Android мы рассмотрели шифрование данных с помощью предоставленного пользователем кода. В этом уроке перейдём к хранению учётных данных и ключей. Я начну с ознакомления с учётными данными и закончу примером защиты данных с помощью хранилища ключей KeyStore....">
<meta property="aiturec:description" content="В предыдущем материале о безопасности пользовательских данных Android мы рассмотрели шифрование данных с помощью предоставленного пользователем кода. В этом уроке перейдём к хранению учётных данных и ключей. Я начну с ознакомления с учётными данными и закончу примером защиты данных с помощью хранилища ключей KeyStore....">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1638/posts/30558/preview_image/AndroidStorage.png">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1638/posts/30558/preview_image/AndroidStorage.png">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1638/posts/30558/preview_image/AndroidStorage.png">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1638/posts/30558/preview_image/AndroidStorage.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1638/posts/30558/preview_image/AndroidStorage.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article/220824769-klyuchi-uchetnye-dannye-i-hranilische-na-android.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article/220824769-klyuchi-uchetnye-dannye-i-hranilische-na-android.html">
<link rel="canonical" href="https://norma-studio.github.io/article/220824769-klyuchi-uchetnye-dannye-i-hranilische-na-android.html">
<meta property="og:url" content="https://norma-studio.github.io/article/220824769-klyuchi-uchetnye-dannye-i-hranilische-na-android.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article/220824769-klyuchi-uchetnye-dannye-i-hranilische-na-android.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article/220824769-klyuchi-uchetnye-dannye-i-hranilische-na-android.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article/220824769-klyuchi-uchetnye-dannye-i-hranilische-na-android.html" title="Ключи, учетные данные и хранилище на Android... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Ключи, учетные данные и хранилище на Android... | envatomarket.ru | norma-studio.github.io" title="Ключи, учетные данные и хранилище на Android... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/64533gfdsgf.jpg" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article/220824769-klyuchi-uchetnye-dannye-i-hranilische-na-android.html" class="tm-user-info__username" title="
А. Лукичев" aria-label="
А. Лукичев">
А. Лукичев</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Ключи, учетные данные и хранилище на Android...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824769-klyuchi-uchetnye-dannye-i-hranilische-na-android" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Security" href="https://norma-studio.github.io/article/220824769-klyuchi-uchetnye-dannye-i-hranilische-na-android" class="tm-article-snippet__hubs-item-link"><span>Security</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article/220824769-klyuchi-uchetnye-dannye-i-hranilische-na-android.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1638/posts/30558/preview_image/AndroidStorage.png">
    <meta itemprop="headline name" content="Ключи, учетные данные и хранилище на Android... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="В предыдущем материале о безопасности пользовательских данных Android мы рассмотрели шифрование данных с помощью предоставленного пользователем кода. В этом уроке перейдём к хранению учётных данных и ключей. Я начну с ознакомления с учётными данными и закончу примером защиты данных с помощью хранилища ключей KeyStore....">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">В предыдущем материале о безопасности пользовательских данных Android мы рассмотрели шифрование данных с помощью предоставленного пользователем кода. В этом уроке перейдём к хранению учётных данных и ключей. Я начну с ознакомления с учётными данными и закончу примером защиты данных с помощью хранилища ключей KeyStore....</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>В предыдущем материале о безопасности пользовательских данных Android мы рассмотрели шифрование данных с помощью предоставленного пользователем кода. В этом уроке перейдём к хранению учётных данных и ключей. Я начну с ознакомления с учётными данными и закончу примером защиты данных с помощью хранилища ключей KeyStore.</p><ul class="roundup-block__contents posts--half-width roundup-block--list"><li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/1638/posts/30558/preview_image/AndroidStorage.png" alt="Ключи, учетные данные и хранилище на Android..." title="Ключи, учетные данные и хранилище на Android..." width="50" height="50"><div class="roundup-block__primary-category topic-code">Security</div> <div class="roundup-block__content-title">Безопасное хранение данных на Android</div> <div class="roundup-block__author">Collin Stuart</div></span></li> <li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/362/posts/26385/preview_image/picSec.png" alt="Ключи, учетные данные и хранилище на Android..." title="Ключи, учетные данные и хранилище на Android..." width="50" height="50"><div class="roundup-block__primary-category topic-code">Android</div> <div class="roundup-block__content-title">Как обезопасить Android приложение</div> <div class="roundup-block__author">Ashraff Hathibelagal</div></span></li> </ul><p>Часто, при работе со сторонней службой, требуется какая-то форма авторизации. Она может быть настолько простой, как <code class="inline">/login</code> на стороне пользователя, которая принимает имя пользователя и пароль. </p><p>Сначала может показаться, что простое решение — это собрать UI, который будет предлагать пользователю войти в систему, а затем записать и сохранить их данные для входа. Однако, это не лучший метод, так как нашему приложению не нужно знать данные для входа в сторонний аккаунт. Вместо этого, мы можем использовать Диспетчер учётных записей (Account Manager), который уполномочен отрабатывать эту конфиденциальную информацию для нас.<br></p><h2>Диспетчер учётных записей</h2> <p>Диспетчер учётных записей (Account Manager) — это централизованный помощник для работы с учётными данными пользователя, поэтому вашему приложению, иметь дело с паролями напрямую не нужно. Часто он предоставляет токен вместо реального имени пользователя и пароля, который можно использовать для выполнения аутентифицированных запросов к службе. Например, при запросе <span>токена OAuth2</span>. </p><p>Иногда, вся необходимая информация уже хранится на устройстве, а иногда Account Manager придётся обращаться к серверу за новым токеном. Вы, наверное, видели раздел <strong>Учётные записи</strong> в Настройках вашего устройства для разных приложений. И вот как, мы можем получить список доступных учётных записей:</p><pre class="brush: java noskimlinks noskimwords">AccountManager accountManager = AccountManager.get(this);Account[] accounts = accountManager.getAccounts();</pre> <p> Этому коду потребуется разрешение <code class="inline">android.permission.GET_ACCOUNTS</code>.  Если вы ищете определённую учётную запись, вы можете найти её вот так:</p><pre class="brush: java noskimlinks noskimwords">AccountManager accountManager = AccountManager.get(this);Account[] accounts = accountManager.getAccountsByType("com.google");</pre> <p> Как только найдёте учётную запись, её токен можно получить вызвав <span>метод <code class="inline">getAuthToken(Account, String, Bundle, Activity, AccountManagerCallback, Handler)</code></span>.  Затем, таки можно использовать как для авторизированных запросов API к сервису. Это может быть RESTful API, в котором вы передаёте параметр токена во время HTTPS-запроса без необходимости знать детали личной учётной записи пользователя.<br></p> <p> Так как, у каждой службы будет свой способ проверки подлинности и хранения личных учётных данных, Диспетчер учётных записей предоставляет модули проверки подлинности для реализации сторонней службой. Хотя Android может выполнять вход на многие популярные сервисы, для вашего приложения, вы можете написать свой собственный обработчик авторизации учётной записи и хранилища учётных данных. Это позволит убедиться, что учётные данные зашифрованы. Имейте также в виду, что учётные данные в Диспетчере учётных записей, которые используются другими службами, могут храниться в виде открытого текста, что делает их видимыми для любого, кто имеет рут-права на своё устройство.</p> <p> Временами вам нужно будет иметь дело с ключами или сертификатами для отдельного лица или сущности, вместо просто данных для входа. Например, когда стороннее приложение отправляет вам файл сертификата, который вам нужно сохранить. Самый распространённый сценарий — это когда приложению нужно авторизироваться на сервере частной организации. </p><p>В следующем уроке, мы рассмотрим использование сертификатов для аутентификации и безопасной связи, ну а пока, я всё же хочу рассмотреть, как хранить эти элементы. Изначально Keychain API был создан для очень конкретного использования — установка закрытого ключа или пары сертификатов из файла PKCS#12.</p><h2>Keychain — связка ключей</h2> <p> Представленный в Android 4.0 (API Level 14), Keychain API управлял ключами. В частности, это работает с объектами <code class="inline">PrivateKey</code> и <code class="inline">X509Certificate</code> и обеспечивает более безопасный контейнер, чем использование хранилища данных вашего приложения. Связано это с тем, что разрешения закрытых ключей открывают доступ к ключам только вашему приложению и только после авторизации пользователя. Это означает, что, прежде чем, вы сможете использовать хранилище учётных данных, на устройстве должен быть настроен экран блокировки. Кроме того, объекты в связке ключей можно объединить с защитой от оборудования, если доступно. </p><p>Код установки сертификата выглядит следующим образом:</p><pre class="brush: java noskimlinks noskimwords">Intent intent = KeyChain.createInstallIntent();byte[] p12Bytes = //... read from file, such as example.pfx or example.p12...intent.putExtra(KeyChain.EXTRA_PKCS12, p12Bytes);startActivity(intent);</pre><p>Пользователю будет предложено ввести пароль для доступа к закрытому ключу и указать имя сертификата. Для получения ключа, в следующем коде представлен пользовательский интерфейс, который позволяет пользователю выбирать ключ из списка установленных ключей.<br></p><pre class="brush: java noskimlinks noskimwords">KeyChain.choosePrivateKeyAlias(this, this, new String[]{"RSA"}, null, null, -1, null);</pre><p>Как только выбор сделан, возвращается строка с названием псевдонима <code class="inline">alias(final String alias)</code>, где вы можете напрямую получить доступ к закрытому ключу или цепочке сертификатов.</p><pre class="brush: java noskimlinks noskimwords">public class KeychainTest extends Activity implements ..., KeyChainAliasCallback{    //...        @Override    public void alias(final String alias)    {        Log.e("MyApp", "Alias is " + alias);        try        {            PrivateKey privateKey = KeyChain.getPrivateKey(this, alias);            X509Certificate[] certificateChain = KeyChain.getCertificateChain(this, alias);        }        catch ...    }        //...}</pre> <p> Вооружившись этими знаниями, теперь давайте посмотрим, как мы можем использовать хранилище учётных данных для сохранения конфиденциальных данных.</p><h2>KeyStore</h2> <p> В <span>предыдущем уроке</span>, мы рассмотрели защиту данных с помощью предоставляемого пользователем пароля. Такой вариант хорош, но требования к приложениям часто уводят от того, чтобы пользователи каждый раз входили в систему и запоминали дополнительный пароль. </p><p>Вот где можно использовать KeyStore API. Начиная с API 1, KeyStore используется системой для хранения учётных данных WiFi и VPN. Начиная с 4.3 (API 18), вы можете работать с <span>асимметричными</span> ключами конкретного приложения, а в Android M (API 23) можно хранить <span>симметричный</span> ключ AES. Таким образом, хотя API не позволяет хранить конфиденциальные строки напрямую, эти ключи можно сохранить, а затем использовать для шифрования строк. </p><p>Преимущество хранения ключа в хранилище ключей заключается в том, что он позволяет работать с ключами без раскрытия секретного содержимого этого ключа; данным ключа не место в приложении. Помните, что ключи защищаются разрешениями, так что только ваше приложение может получить к ним доступ, и они могут быть дополнительно защищены аппаратным обеспечением, если устройство поддерживает это. Создаётся контейнер, который усложняет извлечение ключей с устройства. </p><h3>Генерирование нового случайного ключа</h3><p>В этом примере вместо генерации ключа AES из предоставленного пользователем пароля мы можем автоматически сгенерировать случайный ключ, который будет защищён в хранилище ключей KeyStore. Мы можем сделать это, создав экземпляр <code class="inline">KeyGenerator</code>, настроенного на поставщика <code class="inline">"AndroidKeyStore"</code>.</p><pre class="brush: java noskimlinks noskimwords">//Generate a key and store it in the KeyStorefinal KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, "AndroidKeyStore");final KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder("MyKeyAlias",        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)        .setBlockModes(KeyProperties.BLOCK_MODE_GCM)        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)        //.setUserAuthenticationRequired(true) //requires lock screen, invalidated if lock screen is disabled        //.setUserAuthenticationValidityDurationSeconds(120) //only available x seconds from password authentication. -1 requires finger print - every time        .setRandomizedEncryptionRequired(true) //different ciphertext for same plaintext on each call        .build();keyGenerator.init(keyGenParameterSpec);keyGenerator.generateKey();</pre> <p> Здесь важно обратить внимание на спецификации <code class="inline">.setUserAuthenticationRequired(true)</code> и <code class="inline">.setUserAuthenticationValidityDurationSeconds(120)</code>. Для этого, обязательно должна быть включена блокировка экрана и ключ должен быть заблокирован, до тех пор, пока пользователь не аутентифицируется. </p><p>Изучив документацию <span><code class="inline">.setUserAuthenticationValidityDurationSeconds()</code></span>, вы увидите, что это означает, что ключ доступен только через определённое количество секунд после аутентификации по паролю, и что для передачи <code class="inline">-1</code> требуется идентификация по отпечатку пальца каждый раз, когда вы хотите получить доступ к ключу. Включение требования для аутентификации также приводит к отзыву ключа, когда пользователь удаляет или изменяет экран блокировки. </p><p>Поскольку хранение незащищённого ключа вместе с зашифрованными данными, это как прятать ключ от дома под половик, эти параметры пытаются защитить ключ в состоянии покоя в случае взлома устройства. Примером может служить автономный дамп данных устройства. Если пароль устройства не известен, эти данные, по сути, бесполезны.</p><p>Опция <code class="inline">.setRandomizedEncryptionRequired(true)</code> включает требование о наличии достаточного количества случайных чисел (каждый раз новый случайный ВИ [вектор инициализации]), чтобы при повторном шифровании одних и тех же данных, зашифрованный результат всё равно не повторялся. Это не позволяет злоумышленнику получить информацию о зашифрованном тексте на основе передачи тех же данных. </p><p>Ещё стоит отметить — <span><code class="inline">setUserAuthenticationValidWhileOnBody(boolean remainsValid)</code></span>, что блокирует ключ, как только устройство обнаружит, что он больше не принадлежит человеку.<br></p><h3>Шифрование данных</h3><p> Теперь, когда ключ хранится в хранилище KeyStore, мы можем создать метод, который зашифрует данные с использованием объекта <code class="inline">Cipher</code>, учитывая <code class="inline">SecretKey</code>. Это вернёт <code class="inline">HashMap</code>, содержащий зашифрованные данные и случайный ВИ, который понадобится для расшифровки данных. Зашифрованные данные вместе с ВИ могут быть сохранены в файл или в открытых настройках.<br></p><pre class="brush: java noskimlinks noskimwords">private HashMap&lt;String, byte[]&gt; encrypt(final byte[] decryptedBytes){    final HashMap&lt;String, byte[]&gt; map = new HashMap&lt;String, byte[]&gt;();    try    {        //Get the key        final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");        keyStore.load(null);        final KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry)keyStore.getEntry("MyKeyAlias", null);        final SecretKey secretKey = secretKeyEntry.getSecretKey();        //Encrypt data        final Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");        cipher.init(Cipher.ENCRYPT_MODE, secretKey);        final byte[] ivBytes = cipher.getIV();        final byte[] encryptedBytes = cipher.doFinal(decryptedBytes);        map.put("iv", ivBytes);        map.put("encrypted", encryptedBytes);    }    catch (Throwable e)    {        e.printStackTrace();    }    return map;}</pre> <h3>Расшифровка в массив байтов</h3><p>Для расшифровки применяется обратный ход. Объект <code class="inline">Cipher</code> инициализируется с использованием константы <code class="inline">DECRYPT_MODE</code>, и возвращается расшифрованный массив <code class="inline">byte[]</code>. <br></p><pre class="brush: java noskimlinks noskimwords">private byte[] decrypt(final HashMap&lt;String, byte[]&gt; map){    byte[] decryptedBytes = null;    try    {        //Get the key        final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");        keyStore.load(null);        final KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry)keyStore.getEntry("MyKeyAlias", null);        final SecretKey secretKey = secretKeyEntry.getSecretKey();        //Extract info from map        final byte[] encryptedBytes = map.get("encrypted");        final byte[] ivBytes = map.get("iv");        //Decrypt data        final Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");        final GCMParameterSpec spec = new GCMParameterSpec(128, ivBytes);        cipher.init(Cipher.DECRYPT_MODE, secretKey, spec);        decryptedBytes = cipher.doFinal(encryptedBytes);    }    catch (Throwable e)    {        e.printStackTrace();    }    return decryptedBytes;}</pre><h3>Смотрим на примере</h3><p>Теперь мы можем посмотреть на пример!</p><pre class="brush: java noskimlinks noskimwords">@TargetApi(Build.VERSION_CODES.M)private void testEncryption(){    try    {        //Generate a key and store it in the KeyStore        final KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, "AndroidKeyStore");        final KeyGenParameterSpec keyGenParameterSpec = new KeyGenParameterSpec.Builder("MyKeyAlias",                KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)                .setBlockModes(KeyProperties.BLOCK_MODE_GCM)                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)                //.setUserAuthenticationRequired(true) //requires lock screen, invalidated if lock screen is disabled                //.setUserAuthenticationValidityDurationSeconds(120) //only available x seconds from password authentication. -1 requires finger print - every time                .setRandomizedEncryptionRequired(true) //different ciphertext for same plaintext on each call                .build();        keyGenerator.init(keyGenParameterSpec);        keyGenerator.generateKey();        //Test        final HashMap&lt;String, byte[]&gt; map = encrypt("My very sensitive string!".getBytes("UTF-8"));        final byte[] decryptedBytes = decrypt(map);        final String decryptedString = new String(decryptedBytes, "UTF-8");        Log.e("MyApp", "The decrypted string is " + decryptedString);    }    catch (Throwable e)    {        e.printStackTrace();    }}</pre><h3>Использование асимметричных ключей RSA для старых устройств</h3><p>Это хорошее решение для хранения данных в версии M и выше, но что, если ваше приложение поддерживает более ранние версии? Хотя симметричные ключи AES не поддерживаются в M, поддерживаются асимметричные ключи RSA. Это означает, что для достижения того же результата, мы можем использовать RSA ключи и шифрование. </p><p>Основное отличие заключается в том, что асимметричная пара ключей содержит два ключа: закрытый и открытый ключ, где открытый ключ шифрует данные, а закрытый ключ расшифровывает их. <code class="inline">KeyPairGeneratorSpec</code> передаётся в <code class="inline">KeyPairGenerator</code>, который инициализируется с помощью <i><code class="inline">KEY_ALGORITHM_RSA</code></i> <i>и</i> поставщика <code class="inline">AndroidKeyStore</code>.</p><pre class="brush: java noskimlinks noskimwords">private void testPreMEncryption(){    try    {        //Generate a keypair and store it in the KeyStore        KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");        keyStore.load(null);        Calendar start = Calendar.getInstance();        Calendar end = Calendar.getInstance();        end.add(Calendar.YEAR, 10);        KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this)                .setAlias("MyKeyAlias")                .setSubject(new X500Principal("CN=MyKeyName, O=Android Authority"))                .setSerialNumber(new BigInteger(1024, new Random()))                .setStartDate(start.getTime())                .setEndDate(end.getTime())                .setEncryptionRequired() //on API level 18, encrypted at rest, requires lock screen to be set up, changing lock screen removes key                .build();        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_RSA, "AndroidKeyStore");        keyPairGenerator.initialize(spec);        keyPairGenerator.generateKeyPair();        //Encryption test        final byte[] encryptedBytes = rsaEncrypt("My secret string!".getBytes("UTF-8"));        final byte[] decryptedBytes = rsaDecrypt(encryptedBytes);        final String decryptedString = new String(decryptedBytes, "UTF-8");        Log.e("MyApp", "Decrypted string is " + decryptedString);    }    catch (Throwable e)    {        e.printStackTrace();    }}</pre><p>Для шифрования, из пары ключей мы получаем <code class="inline">RSAPublicKey</code> и используем его с объектом <code class="inline">Cipher</code>. </p><pre class="brush: java noskimlinks noskimwords">public byte[] rsaEncrypt(final byte[] decryptedBytes){    byte[] encryptedBytes = null;    try    {        final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");        keyStore.load(null);        final KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry("MyKeyAlias", null);        final RSAPublicKey publicKey = (RSAPublicKey)privateKeyEntry.getCertificate().getPublicKey();        final Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding", "AndroidOpenSSL");        cipher.init(Cipher.ENCRYPT_MODE, publicKey);        final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();        final CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, cipher);        cipherOutputStream.write(decryptedBytes);        cipherOutputStream.close();        encryptedBytes = outputStream.toByteArray();    }    catch (Throwable e)    {        e.printStackTrace();    }    return encryptedBytes;}</pre><p>Расшифровка выполняется с использованием объекта <code class="inline">RSAPrivateKey</code>.</p><pre class="brush: java noskimlinks noskimwords">public byte[] rsaDecrypt(final byte[] encryptedBytes){    byte[] decryptedBytes = null;    try    {        final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");        keyStore.load(null);        final KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry("MyKeyAlias", null);        final RSAPrivateKey privateKey = (RSAPrivateKey)privateKeyEntry.getPrivateKey();        final Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding", "AndroidOpenSSL");        cipher.init(Cipher.DECRYPT_MODE, privateKey);        final CipherInputStream cipherInputStream = new CipherInputStream(new ByteArrayInputStream(encryptedBytes), cipher);        final ArrayList&lt;Byte&gt; arrayList = new ArrayList&lt;&gt;();        int nextByte;        while ( (nextByte = cipherInputStream.read()) != -1 )        {            arrayList.add((byte)nextByte);        }        decryptedBytes = new byte[arrayList.size()];        for(int i = 0; i &lt; decryptedBytes.length; i++)        {            decryptedBytes[i] = arrayList.get(i);        }    }    catch (Throwable e)    {        e.printStackTrace();    }    return decryptedBytes;}</pre><p>Кое-что об RSA — шифрование медленнее, чем в AES. Для небольших объёмов информации, например, когда вы защищаете строки общих настроек, это не страшно. Если вы обнаружите проблему с производительностью при шифровании больших объёмов данных, то вместо этого вы можете использовать данный пример для шифрования и хранения только ключа AES. И тогда, для остальной части ваших данных, используйте более быстрое шифрование AES, которое обсуждалось в <span>предыдущем уроке</span>. Вы можете сгенерировать новый AES ключ и преобразовать его в массив <code class="inline">byte[]</code>, который совместим с этим примером.</p><pre class="brush: java noskimlinks noskimwords">KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");keyGenerator.init(256); //AES-256SecretKey secretKey = keyGenerator.generateKey();byte[] keyBytes = secretKey.getEncoded();</pre> <p> Чтобы получить ключ, сделайте вот так:</p><pre class="brush: java noskimlinks noskimwords">SecretKey key = new SecretKeySpec(keyBytes, 0, keyBytes.length, "AES");</pre> <p> Довольно много кода! Для простоты примеров, я пропустил обработку исключений. Но помните, что для итогового кода не рекомендуется просто перехватывать все случаи <code class="inline">Throwable</code> в одном операторе catch.</p> <h2>Заключение</h2><p> На этом урок по работе с учётными данными и ключами завершён. Большая часть неразберихи вокруг ключей и хранилища связана с эволюцией ОС Android, но вы можете выбрать, какое решение использовать, учитывая уровень API, поддерживаемый вашим приложением. </p><p>Теперь, когда мы рассмотрели лучшие примеры защиты данных в состоянии покоя, следующий урок будет сосредоточен на защите данных при передаче. </p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824769-klyuchi-uchetnye-dannye-i-hranilische-na-android" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Security" href="https://norma-studio.github.io/article/220824769-klyuchi-uchetnye-dannye-i-hranilische-na-android" class="tm-article-body__tags-item-link">Security</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
38427</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
498</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

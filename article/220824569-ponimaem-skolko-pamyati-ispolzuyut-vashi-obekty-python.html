
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Понимаем, сколько памяти используют ваши объекты Python... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Понимаем, сколько памяти используют ваши объекты Python... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Понимаем, сколько памяти используют ваши объекты Python... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Понимаем, сколько памяти используют ваши объекты Python... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Python - это фантастический язык программирования. Он также известен как довольно медленный, в основном из-за его огромной гибкости и динамических характеристик. Для многих приложений и областей это не проблема из-за их требований и различных методов оптимизации. Менее известно, что графы объектов Python (вложенные словари списков, кортежей и прими...">
<meta property="og:description" content="Python - это фантастический язык программирования. Он также известен как довольно медленный, в основном из-за его огромной гибкости и динамических характеристик. Для многих приложений и областей это не проблема из-за их требований и различных методов оптимизации. Менее известно, что графы объектов Python (вложенные словари списков, кортежей и прими...">
<meta name="twitter:description" content="Python - это фантастический язык программирования. Он также известен как довольно медленный, в основном из-за его огромной гибкости и динамических характеристик. Для многих приложений и областей это не проблема из-за их требований и различных методов оптимизации. Менее известно, что графы объектов Python (вложенные словари списков, кортежей и прими...">
<meta property="aiturec:description" content="Python - это фантастический язык программирования. Он также известен как довольно медленный, в основном из-за его огромной гибкости и динамических характеристик. Для многих приложений и областей это не проблема из-за их требований и различных методов оптимизации. Менее известно, что графы объектов Python (вложенные словари списков, кортежей и прими...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1199/profiles/19709/profileImage/gigi_kettlebell_400x400.jpg">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1199/profiles/19709/profileImage/gigi_kettlebell_400x400.jpg">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1199/profiles/19709/profileImage/gigi_kettlebell_400x400.jpg">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1199/profiles/19709/profileImage/gigi_kettlebell_400x400.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1199/profiles/19709/profileImage/gigi_kettlebell_400x400.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article/220824569-ponimaem-skolko-pamyati-ispolzuyut-vashi-obekty-python.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article/220824569-ponimaem-skolko-pamyati-ispolzuyut-vashi-obekty-python.html">
<link rel="canonical" href="https://norma-studio.github.io/article/220824569-ponimaem-skolko-pamyati-ispolzuyut-vashi-obekty-python.html">
<meta property="og:url" content="https://norma-studio.github.io/article/220824569-ponimaem-skolko-pamyati-ispolzuyut-vashi-obekty-python.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article/220824569-ponimaem-skolko-pamyati-ispolzuyut-vashi-obekty-python.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article/220824569-ponimaem-skolko-pamyati-ispolzuyut-vashi-obekty-python.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article/220824569-ponimaem-skolko-pamyati-ispolzuyut-vashi-obekty-python.html" title="Понимаем, сколько памяти используют ваши объекты Python... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Понимаем, сколько памяти используют ваши объекты Python... | envatomarket.ru | norma-studio.github.io" title="Понимаем, сколько памяти используют ваши объекты Python... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/64533jfgfsfxcv.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article/220824569-ponimaem-skolko-pamyati-ispolzuyut-vashi-obekty-python.html" class="tm-user-info__username" title="
О. Гуськов" aria-label="
О. Гуськов">
О. Гуськов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Понимаем, сколько памяти используют ваши объекты Python...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824569-ponimaem-skolko-pamyati-ispolzuyut-vashi-obekty-python" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Python" href="https://norma-studio.github.io/article/220824569-ponimaem-skolko-pamyati-ispolzuyut-vashi-obekty-python" class="tm-article-snippet__hubs-item-link"><span>Python</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article/220824569-ponimaem-skolko-pamyati-ispolzuyut-vashi-obekty-python.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1199/profiles/19709/profileImage/gigi_kettlebell_400x400.jpg">
    <meta itemprop="headline name" content="Понимаем, сколько памяти используют ваши объекты Python... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Python - это фантастический язык программирования. Он также известен как довольно медленный, в основном из-за его огромной гибкости и динамических характеристик. Для многих приложений и областей это не проблема из-за их требований и различных методов оптимизации. Менее известно, что графы объектов Python (вложенные словари списков, кортежей и прими...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Python - это фантастический язык программирования. Он также известен как довольно медленный, в основном из-за его огромной гибкости и динамических характеристик. Для многих приложений и областей это не проблема из-за их требований и различных методов оптимизации. Менее известно, что графы объектов Python (вложенные словари списков, кортежей и прими...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Python - это фантастический язык программирования. Он также известен как довольно медленный, в основном из-за его огромной гибкости и динамических характеристик. Для многих приложений и областей это не проблема из-за их требований и различных методов оптимизации. Менее известно, что графы объектов Python (вложенные словари списков, кортежей и примитивных типов) занимают значительный объем памяти. Это может быть гораздо более серьезным ограничивающим фактором из-за его влияния на кеширование, виртуальную память, многопользовательскую работу с другими программами и в целом более быстрое исчерпание доступной памяти, которая является дефицитным и дорогим ресурсом.</p><p>Оказывается, нетривиально выяснить, сколько памяти фактически потребляется. В этой статье я расскажу о тонкостях управления памятью объекта Python и покажу, как точно измерить потребляемую память.</p> <p>В этой статье я остановлюсь исключительно на <span>CPython</span> - основной реализации языка программирования Python. Эксперименты и выводы здесь не относятся к другим реализациям Python, таким как IronPython, Jython и PyPy.</p> <p>Также я запустил числа на 64-битном Python 2.7. В Python 3 числа иногда немного отличаются (особенно для строк, которые всегда являются Unicode), но концепции одинаковы.</p> <h2>Практическое исследование использования памяти Python</h2> <p>Во-первых, давайте немного разберемся и получим конкретное представление о фактическом использовании памяти объектами Python.</p> <h3>Встроенная функция sys.getsizeof()</h3> <p>Модуль sys стандартной библиотеки предоставляет функцию <span>getsizeof()</span>. Эта функция принимает объект (и необязательный параметр по умолчанию), вызывает метод <strong>sizeof()</strong> объекта и возвращает результат, поэтому вы также можете сделать ваши объекты инспектируемыми.</p> <h3>Измерение памяти объектов Python</h3> <p>Давайте начнем с некоторых числовых типов:</p> <pre class="brush: python noskimlinks noskimwords">import syssys.getsizeof(5)24</pre> <p>Интересно. Целое число занимает 24 байта.</p> <pre class="brush: python noskimlinks noskimwords">sys.getsizeof(5.3)24</pre> <p>Хм ... float также занимает 24 байта.</p> <pre class="brush: python noskimlinks noskimwords">from decimal import Decimalsys.getsizeof(Decimal(5.3))80</pre> <p>Вот это да. 80 байтов! Это действительно заставляет задуматься о том, хотите ли вы представлять большое количество вещественных чисел как числа с плавающей запятой или десятичные дроби.</p> <p>Давайте перейдем к строкам и коллекциям:</p> <pre class="brush: python noskimlinks noskimwords">sys.getsizeof("")37sys.getsizeof("1")38sys.getsizeof("1234")41sys.getsizeof(u"")50sys.getsizeof(u"1")52sys.getsizeof(u"1234")58</pre> <p>Хорошо. Пустая строка занимает 37 байтов, и каждый дополнительный символ добавляет еще один байт. Это многое говорит о компромиссе между сохранением нескольких коротких строк, когда вы будете платить 37 байтов за каждую, а не одну длинную строку, где вы платите только один раз.</p> <p>Строки Unicode ведут себя аналогично, за исключением того, что служебные данные составляют 50 байтов, и каждый дополнительный символ добавляет 2 байта. Это стоит учитывать, если вы используете библиотеки, которые возвращают строки Unicode, но ваш текст может быть представлен в виде простых строк.</p> <p>Кстати, в Python 3 строки всегда имеют Unicode, а служебные данные составляют 49 байт (они где-то сохранили байт). Объект <span>байтов</span> имеет служебную информацию только 33 байта. Если у вас есть программа, которая обрабатывает много коротких строк в памяти, и вы заботитесь о производительности, рассмотрите Python 3.</p> <pre class="brush: python noskimlinks noskimwords">sys.getsizeof([])72sys.getsizeof([1])88sys.getsizeof([1, 2, 3, 4])104sys.getsizeof(["a long longlong string"])</pre> <p>В чем дело? Пустой список занимает 72 байта, но каждый дополнительный int добавляет всего 8 байтов, где размер int составляет 24 байта. Список, который содержит длинную строку, занимает всего 80 байтов.</p> <p>Ответ прост. Список не содержит сами объекты int. Он просто содержит 8-байтовый (в 64-битных версиях CPython) указатель на фактический объект int. Это означает, что функция getsizeof() не возвращает фактическую память списка и всех объектов, которые он содержит, а только память списка и указатели на свои объекты. В следующем разделе я представлю функцию deep_getsizeof(), которая решает эту проблему.</p> <pre class="brush: python noskimlinks noskimwords">sys.getsizeof(())56sys.getsizeof((1,))64sys.getsizeof((1, 2, 3, 4))88sys.getsizeof(("a long longlong string",))64</pre> <p>История повторяется для кортежей. Накладные расходы пустого кортежа составляют 56 байтов против 72 списка. Опять же, эта разница в 16 байтов на последовательность - это низко висящий плод, если у вас есть структура данных с большим количеством небольших неизменяемых последовательностей.</p> <pre class="brush: python noskimlinks noskimwords">sys.getsizeof(set())232sys.getsizeof(set([1))232sys.getsizeof(set([1, 2, 3, 4]))232sys.getsizeof({})280sys.getsizeof(dict(a=1))280sys.getsizeof(dict(a=1, b=2, c=3))280</pre> <p>Наборы и словари якобы вообще не растут при добавлении элементов, но отмечают огромные накладные расходы.</p> <p>Суть в том, что у объектов Python огромные фиксированные накладные расходы. Если ваша структура данных состоит из большого количества объектов коллекций, таких как строки, списки и словари, которые содержат небольшое количество элементов каждый, вы много платите.</p> <h2>Функция deep_getsizeof()</h2> <p>Теперь, когда я напугал вас до полусмерти и продемонстрировал, что sys.getsizeof() может только сказать вам, сколько памяти занимает примитивный объект, давайте посмотрим на более адекватное решение. <span>Функция deep_getsizeof(</span>) рекурсивно выполняет детализацию и вычисляет фактическое использование памяти графом объектов Python.</p> <pre class="brush: python noskimlinks noskimwords">from collections import Mapping, Containerfrom sys import getsizeofdef deep_getsizeof(o, ids):    """Find the memory footprint of a Python object    This is a recursive function that drills down a Python object graph    like a dictionary holding nested dictionaries with lists of lists    and tuples and sets.    The sys.getsizeof function does a shallow size of only. It counts each    object inside a container as pointer only regardless of how big it    really is.    :param o: the object    :param ids:    :return:    """    d = deep_getsizeof    if id(o) in ids:        return 0    r = getsizeof(o)    ids.add(id(o))    if isinstance(o, str) or isinstance(0, unicode):        return r    if isinstance(o, Mapping):        return r + sum(d(k, ids) + d(v, ids) for k, v in o.iteritems())    if isinstance(o, Container):        return r + sum(d(x, ids) for x in o)    return r </pre> <p>У этой функции есть несколько интересных аспектов. Она учитывает объекты, на которые ссылаются несколько раз, и учитывает их только один раз, отслеживая идентификаторы объектов. Другая интересная особенность реализации заключается в том, что она в полной мере использует <span>абстрактные базовые классы</span> модуля коллекций. Это позволяет функции очень лаконично обрабатывать любую коллекцию, которая реализует базовые классы Mapping или Container, вместо непосредственного обращения к множеству типов коллекций, таких как: строка, Unicode, байты, список, кортеж, dict, frozendict, OrderedDict, set, frozenset и т.д. </p> <p>Давайте посмотрим на это в действии:</p> <pre class="brush: python noskimlinks noskimwords">x = "1234567"deep_getsizeof(x, set())44</pre> <p>Строка длиной 7 занимает 44 байта (37 служебных данных + 7 байтов для каждого символа).</p> <pre class="brush: python noskimlinks noskimwords">deep_getsizeof([], set())72</pre> <p>Пустой список занимает 72 байта (только накладные расходы).</p> <p><code class="inline">python deep_getsizeof ([x], set ()) 124 </code></p> <p>Список, содержащий строку x, занимает 124 байта (72 + 8 + 44).</p> <pre class="brush: python noskimlinks noskimwords">deep_getsizeof([x, x, x, x, x], set())156</pre> <p>Список, содержащий строку x 5 раз, занимает 156 байтов (72 + 5 * 8 + 44).</p> <p>Последний пример показывает, что deep_getsizeof() подсчитывает ссылки на один и тот же объект (строку x) только один раз, но подсчитывается указатель каждой ссылки.</p> <h2>Баг или фича</h2> <p>Оказывается, что у CPython есть несколько хитростей, поэтому числа, которые вы получаете от deep_getsizeof(), не полностью отражают использование памяти программой Python.</p> <h3>Подсчет ссылок</h3> <p>Python управляет памятью, используя семантику подсчета ссылок. Когда на объект больше не ссылаются, его память освобождается. Но пока есть ссылка, объект не будет освобожден. Такие вещи, как циклические ссылки, могут вас сильно укусить.</p> <h3>Маленькие объекты</h3> <p>CPython управляет небольшими объектами (менее 256 байтов) в специальных пулах на 8-байтовых границах. Есть пулы для 1-8 байтов, 9-16 байтов и вплоть до 249-256 байтов. Когда объект размером 10 выделяется, он выделяется из 16-байтового пула для объектов размером 9-16 байт. Таким образом, хотя он содержит только 10 байтов данных, он будет стоить 16 байтов памяти. Если вы выделяете 1 000 000 объектов размером 10, вы фактически используете 16 000 000 байтов, а не 10 000 000 байтов, как вы можете предположить. Эти 60% накладных расходов явно не тривиальны.</p> <h3>Целые числа</h3> <p>CPython хранит глобальный список всех целых чисел в диапазоне [-5, 256]. Эта стратегия оптимизации имеет смысл, потому что маленькие целые числа всплывают повсюду, и, учитывая, что каждое целое число занимает 24 байта, оно экономит много памяти для типичной программы.</p> <p>Это также означает, что CPython предварительно выделяет 266 * 24 = 6384 байта для всех этих целых чисел, даже если вы не используете большинство из них. Вы можете проверить это с помощью функции id(), которая дает указатель на фактический объект. Если вы называете id(x) несколько для любого x в диапазоне [-5, 256], вы будете каждый раз получать один и тот же результат (для одного и того же целого числа). Но если вы попробуете это для целых чисел за пределами этого диапазона, каждый из них будет отличаться (новый объект создается на лету каждый раз).</p> <p>Вот несколько примеров в этом диапазоне:</p> <pre class="brush: python noskimlinks noskimwords">id(-3)140251817361752id(-3)140251817361752id(-3)140251817361752id(201)140251817366736id(201)140251817366736id(201)140251817366736</pre> <p>Вот несколько примеров за пределами диапазона:</p> <pre class="brush: python noskimlinks noskimwords">id(301)140251846945800id(301)140251846945776id(-6)140251846946960id(-6)140251846946936</pre> <h3>Память Python против системной памяти</h3> <p>CPython является своего рода притяжательным. Во многих случаях, когда на объекты памяти в вашей программе больше не ссылаются, они <em>не</em> возвращаются в систему (например, маленькие объекты). Это хорошо для вашей программы, если вы выделяете и освобождаете много объектов (которые принадлежат одному и тому же 8-байтовому пулу), потому что Python не должен беспокоить систему, что относительно дорого. Но это не так здорово, если ваша программа обычно использует X байтов и при некоторых временных условиях она использует в 100 раз больше (например, анализирует и обрабатывает большой файл конфигурации только при запуске).</p> <p>Теперь эта память 100X может быть бесполезно захвачена в вашей программе, никогда больше не использоваться и лишать систему возможности выделять ее другим программам. Ирония заключается в том, что если вы используете модуль обработки для запуска нескольких экземпляров вашей программы, вы строго ограничите количество экземпляров, которые вы можете запустить на данном компьютере.</p> <h2>Профилировщик памяти</h2> <p>Чтобы измерить и измерить фактическое использование памяти вашей программой, вы можете использовать модуль <span>memory_profiler</span>. Я немного поиграл с этим, и я не уверен, что доверяю результатам. Он очень прост в использовании. Вы декорируете функцию (может быть главной (0 функция)) с помощью декоратора @profiler, и когда программа завершает работу, профилировщик памяти выводит на стандартный вывод удобный отчет, который показывает общее количество и изменения в памяти для каждой строки. Вот пример программы, которую я запускал под профилировщиком:</p> <pre class="brush: python noskimlinks noskimwords">from memory_profiler import profile@profiledef main():    a = []    b = []    c = []    for i in range(100000):        a.append(5)    for i in range(100000):        b.append(300)    for i in range(100000):        c.append("123456789012345678901234567890")    del a    del b    del c    print "Done!"if __name__ == "__main__":    main()</pre> <p>Вот вывод:</p> <pre class="noskimlinks noskimwords">Line #    Mem usage    Increment   Line Contents================================================     3     22.9 MiB      0.0 MiB   @profile     4                             def main():     5     22.9 MiB      0.0 MiB       a = []     6     22.9 MiB      0.0 MiB       b = []     7     22.9 MiB      0.0 MiB       c = []     8     27.1 MiB      4.2 MiB       for i in range(100000):     9     27.1 MiB      0.0 MiB           a.append(5)    10     27.5 MiB      0.4 MiB       for i in range(100000):    11     27.5 MiB      0.0 MiB           b.append(300)    12     28.3 MiB      0.8 MiB       for i in range(100000):    13     28.3 MiB      0.0 MiB           c.append("123456789012345678901234567890")    14     27.7 MiB     -0.6 MiB       del a    15     27.9 MiB      0.2 MiB       del b    16     27.3 MiB     -0.6 MiB       del c    17    18     27.3 MiB      0.0 MiB       print "Done!"</pre> <p>Как вы можете видеть, занято 22,9 МБ дополнительной памяти. Причина, по которой память не увеличивается при добавлении целых чисел как внутри, так и вне диапазона [-5, 256], а также при добавлении строки, заключается в том, что во всех случаях используется один объект. Непонятно, почему первый цикл диапазона (100000) в строке 8 добавляет 4,2 МБ, в то время как второй цикл в строке 10 добавляет всего 0,4 МБ, а третий цикл в строке 12 добавляет 0,8 МБ. Наконец, при удалении списков a, b и c освобождается -0.6MB для a и c, но для b добавляется 0.2MB. Я не могу понять эти странные результаты.</p> <h2>Заключение</h2> <p>CPython использует много памяти для своих объектов. Он использует различные приемы и оптимизации для управления памятью. Отслеживая использование памяти вашим объектом и зная модель управления памятью, вы можете значительно уменьшить объем памяти вашей программы.</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article/220824569-ponimaem-skolko-pamyati-ispolzuyut-vashi-obekty-python" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Python" href="https://norma-studio.github.io/article/220824569-ponimaem-skolko-pamyati-ispolzuyut-vashi-obekty-python" class="tm-article-body__tags-item-link">Python</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
30747</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
346</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

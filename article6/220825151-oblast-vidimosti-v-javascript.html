
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Область Видимости в JavaScript... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Область Видимости в JavaScript... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Область Видимости в JavaScript... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Область Видимости в JavaScript... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Область видимости (scope) - набор правил устанавливающий где ваша переменная-">
<meta property="og:description" content="Область видимости (scope) - набор правил устанавливающий где ваша переменная-">
<meta name="twitter:description" content="Область видимости (scope) - набор правил устанавливающий где ваша переменная-">
<meta property="aiturec:description" content="Область видимости (scope) - набор правил устанавливающий где ваша переменная-">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/71/courses/736/preview_image/ecma-1.png">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/71/courses/736/preview_image/ecma-1.png">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/71/courses/736/preview_image/ecma-1.png">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/71/courses/736/preview_image/ecma-1.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/71/courses/736/preview_image/ecma-1.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825151-oblast-vidimosti-v-javascript.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825151-oblast-vidimosti-v-javascript.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825151-oblast-vidimosti-v-javascript.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825151-oblast-vidimosti-v-javascript.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825151-oblast-vidimosti-v-javascript.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825151-oblast-vidimosti-v-javascript.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825151-oblast-vidimosti-v-javascript.html" title="Область Видимости в JavaScript... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Область Видимости в JavaScript... | envatomarket.ru | norma-studio.github.io" title="Область Видимости в JavaScript... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/65404fb3f3f8602d7f5b3bdc85cbef02.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825151-oblast-vidimosti-v-javascript.html" class="tm-user-info__username" title="
А. Крайнов" aria-label="
А. Крайнов">
А. Крайнов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Область Видимости в JavaScript...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825151-oblast-vidimosti-v-javascript" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="JavaScript" href="https://norma-studio.github.io/article5/220825151-oblast-vidimosti-v-javascript" class="tm-article-snippet__hubs-item-link"><span>JavaScript</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825151-oblast-vidimosti-v-javascript.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/71/courses/736/preview_image/ecma-1.png">
    <meta itemprop="headline name" content="Область Видимости в JavaScript... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Область видимости (scope) - набор правил устанавливающий где ваша переменная-">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Область видимости (scope) - набор правил устанавливающий где ваша переменная-</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Область видимости (scope) - набор правил устанавливающий где ваша переменная "живёт", одна из базовых концепций любого языка программирования. Настолько базовая, что по факту, очень легко забыть насколько тонкой может быть разница этих правил в зависимости от языка.</p><p>Понимание, как же движок JavaScript "<em>думает</em>" о области видимости предостережёт вас от известных ошибок, которые вызывает всплытие (hoisting), подготовит вас к работе с замыканиями (closures), и вероятнее всего вы не сделаете этих ошибок, после прочтения данной статьи.</p><p>... В любом случае, статья поможет вам понять всплытие и замыкания. </p><p>В ней мы рассмотрим:</p><ul><li>основы областей видимости в JavaScript</li> <li>как интерпретатор решает, какая переменная, какой области видимости пренадлежит</li> <li>как <em>на самом деле</em> работает всплытие</li> <li>как операторы ES6 - <code class="inline">let</code> и <code class="inline">const</code> влияют на эти правила</li> </ul><p>Давайте начнём.</p><p>Если вы хотите узнать больше о ES6 и как применять новый синтаксис и особенности спецификации, для улучшения и упрощения своего JavaScript кода, обратите внимание на следующие два курса:</p><ul class="roundup-block__contents posts--half-width roundup-block--list"><li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/71/courses/736/preview_image/ecma-1.png" alt="Область Видимости в JavaScript..." title="Область Видимости в JavaScript..." width="50" height="50"><div class="roundup-block__primary-category topic-code">JavaScript ES6</div> <div class="roundup-block__content-title">JavaScript ES6 Основы</div> <div class="roundup-block__author">Dan Wellman</div></span></li> <li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/71/courses/915/preview_image/refactor400.png" alt="Область Видимости в JavaScript..." title="Область Видимости в JavaScript..." width="50" height="50"><div class="roundup-block__primary-category topic-code">JavaScript</div> <div class="roundup-block__content-title">JavaScript Техники Рефакторинга</div> <div class="roundup-block__author">Pavan Podila</div></span></li> </ul><h2>Лексическая Область Видимости</h2><p>Если вам довелось написать хотя-бы строчку JavaScript кода, вам должно быть известно, что от того где вы <em>определили</em> свои переменные, зависит где вы сможете их использовать. Факт того, что видимость переменной зависит от структуры вашего кода, называется - лексической областью видимости (<em>lexical</em> scope).</p><p>Существует три способа задать область видимости в JavaScript:</p><ol><li> <strong>Создайте функцию</strong>. Переменные объявленные внутри функции, видны лишь внутри этой функции, включая вложенные функции.</li> <li> <b>Объявление переменной с помощью </b><code class="inline">let</code> или <code class="inline">const</code> <strong>внутри блока</strong>. Переменные объявленные таким образом будут видны только внутри блока.<strong></strong> </li> <li> <strong>Создайте</strong> <code class="inline">catch</code> <strong>блок</strong>. Верьте в это или нет, но это действительно <em>создает</em> новую область видимости!</li> </ol><pre class="brush: javascript noskimlinks noskimwords">"use strict";var mr_global = "Mr Global";function foo () {    var mrs_local = "Mrs Local";    console.log("I can see " + mr_global + " and " + mrs_local + ".");        function bar () {        console.log("I can also see " + mr_global + " and " + mrs_local + ".");    }}foo(); // Works as expectedtry {    console.log("But /I/ can"t see " + mrs_local + "."); } catch (err) {    console.log("You just got a " + err + ".");}{    let foo = "foo";    const bar = "bar";    console.log("I can use " + foo + bar + " in its block...");}try {    console.log("But not outside of it.");   } catch (err) {    console.log("You just got another " + err + ".");}// Throws ReferenceError!console.log("Note that " + err + " doesn"t exist outside of "catch"!") </pre><p>Кусок кода выше демонстрирует нам все три механизма создания области видимости. Вы можете запустить его при помощи Node или в Firefox, однако Chrome, на момент написания этой статьи, не поддерживает <code class="inline">let</code>.</p><p>Мы поговорим о каждом из этих механизмов в подробных деталях. Давайте узнаем, как JavaScript определяет какая переменная, какой области видимости принадлежит.</p><h2>Процесс Компиляции: С Высоты Птичьего Полёта</h2><p>Когда вы запускаете JavaScript код, происходят две вещи, которые заставляют его работать.</p><ol><li>Первое, ваш код компилируется.</li> <li>Затем скомпилированный код выполняется.</li> </ol><p>Во время <em>компиляции</em>, JavaScript движок:</p><ol><li>запоминает все имена ваших переменных</li> <li>регистрирует их согласно подходящим областям видимости</li> <li>сохраняет место для их значений</li> </ol><p>В действительности, только во время <em>выполнения</em>, движок JavaScript задаёт значения ссылкам переменных (variable references) равным присвоенному им значению. До этого они равны <code class="inline">undefined</code>. </p><h3>Шаг 1: Компиляция</h3><pre class="brush: javascript noskimlinks noskimwords">// I can use first_name anywhere in this program var first_name = "Peleke";function popup (first_name) {    // I can only use last_name inside of this function    var last_name = "Sengstacke";    alert(first_name + " " + last_name);}popup(first_name);</pre><p>Давайте посмотрим, что делает компилятор.</p><p>Сначала он прочитает строку <code class="inline">var first_name = "Peleke"</code>. Затем, он установит какой <em>области видимости</em> принадлежит эта переменная. Так как мы на верхнем уровне скрипта, он поймет, что мы в <em>глобальной области видимости</em>. Затем, он сохранит переменную <code class="inline">first_name</code> в глобальную область видимости и назначит ей значение <code class="inline">undefined</code>.</p><p>Затем компилятор прочитает строчку <code class="inline">function popup (first_name)</code>. Так как ключевое слово <em>function</em> идёт первым на этой строке, он создаст новую область видимости для функции, зарегистрирует объявление функции для глобальной области видимости и заглянет внутрь, чтобы найти объявление переменных.</p><p>Конечно, компилятор найдёт одно из них. Так как у нас есть <code class="inline">var last_name = "Sengstacke"</code> на первой строчке нашей функции, компилятор сохранит переменную <code class="inline">last_name</code> в область видимости <code class="inline">popup</code>—<em>не</em> глобальную область видимости—и задаст значение <code class="inline">undefined</code>. </p><p>Так как внутри функции больше нет объявлений переменных, компилятор вернётся в глобальную область видимости. <em>Там</em> нет объявлений переменных, на этом фаза компиляции закончится.</p><p>Обратите внимание, что мы ещё ничего не <em>запускали</em>. Работа компилятора на этом этапе - убедиться, что он знает все имена; ему не важно, <em>что</em> они делают. </p><p>К этому момента наша программа знает:</p><ol><li>Существует переменная <code class="inline">first_name</code> в глобальной области видимости.</li> <li>Существует функция <code class="inline">popup</code> в глобальной области видимости.</li> <li>Существует переменная <code class="inline">last_name</code> в области видимости <code class="inline">popup</code>.</li> <li>Значения <code class="inline">first_name</code> и <code class="inline">last_name</code> - <code class="inline">undefined</code>.</li> </ol><p>Не важно если мы задали значения этим переменным в другом месте нашего кода. Движок JavaScript позаботится об этом во время <em>выполнения</em>.</p><h3>Шаг 2: Выполнение</h3><p>Во время следующей фазы, движок будет читать наш кода снова, на этот раз, <em>выполняя</em> его. </p><p>Сначала, он прочитает строчку, <code class="inline">var first_name = "Peleke"</code>. Движок обратит внимание на переменную с названием <code class="inline">first_name</code>. Компилятор уже зарегистрировал переменную с таким именем, движок узнает об этом и задаст переменной значение <code class="inline">"Peleke"</code>.</p><p>Затем, он прочитает строку <code class="inline">function popup (first_name)</code>. Пока мы не <em>вызываем</em> функцию, движку она будет не интересна и он пропустит её.</p><p>Наконец, он прочитает строчку <code class="inline">popup(first_name)</code>. На этом месте идёт <em>вызов</em> функции, следовательно движок:</p><ol><li>будет искать значение <code class="inline">popup</code> </li> <li>будет искать значение <code class="inline">first_name</code> </li> <li>выполнит функцию <code class="inline">popup</code>, передавая значение <code class="inline">first_name</code>, как параметер</li> </ol><p>Когда он выполняет <code class="inline">popup</code>, повторится тот же самый процесс, на этот раз внутри функции <code class="inline">popup</code>. Движок будет:</p><ol><li>искать переменную <code class="inline">last_name</code> </li> <li>установит значение <code class="inline">last_name</code> равным <code class="inline">"Sengstacke"</code> </li> <li>будет искать <code class="inline">alert</code>, выполнит её, как функцию с параметром <code class="inline">"Peleke Sengstacke"</code></li> </ol><p>Оказывается под капотом JavaScript происходит гораздо больше, чем мы думали! </p><p>Теперь мы поняли, как JavaScript читает и выполняет, написанный вами код и мы готовы разобраться в том, как работает всплытие.</p><h2>Всплытие под Микроскопом</h2><p>Давайте начнём со следующего кода.</p><pre class="brush: javascript noskimlinks noskimwords">bar();function bar () {    if (!foo) {        alert(foo + "? This is strange...");    }    var foo = "bar";}broken(); // TypeError!var broken = function () {    alert("This alert won"t show up!");}</pre><p>Запустив этот код можно заметить следующее:</p><ol><li>Вы <em>можете</em> использовать <code class="inline">foo</code> до того, как присвоите значение, но значение будет <code class="inline">undefined</code>.</li> <li>Вы <em>можете</em> вызвать функцию <code class="inline">broken</code>, до того, как определили её, но получите ошибку <code class="inline">TypeError</code>.</li> <li>Вы <em>можете</em> вызвать <code class="inline">bar</code> до того как определили её и она будет работать как полагается.</li> </ol><p><strong>Всплытие</strong> означает тот факт, что JavaScript делает все наши объявленные имена переменных доступными <em>везде</em>, в их области видимости <em>до того</em>, как мы присвоим им значение. </p><p>Три случая в куске кода выше - это три случая, о которых вам стоит знать и быть внимательными, так что мы разберём каждый из них.</p><h3>Всплытие Объявления Переменной</h3><p>Помните, когда JavaScript компилятор читает строку вроде <code class="inline">var foo = "bar"</code>, он:</p><ol><li>регистрирует имя <code class="inline">foo</code> в ближайшей области видимости</li> <li>устанавливает значение <code class="inline">foo</code>, как undefined</li> </ol><p>Причина по которой мы можем использовать <code class="inline">foo</code> до того, как мы добавили к ней значения, это то что, движок знает о <em>существовании</em> имён переменных. Вот почему он не показывает <code class="inline">ReferenceError</code>. </p><p>Вместо этого мы видим значение <code class="inline">undefined</code> и движок пытается использовать его, в том случает если вы попросите его об этом. Обычно это вызывает ошибку.</p><p>Зная об этом, мы можем предстать, что JavaScript видит в нашей функции <code class="inline">bar</code> следующую картину:</p><pre class="brush: javascript noskimlinks noskimwords">function bar () {    var foo; // undefined    if (!foo) {        // !undefined is true, so alert        alert(foo + "? This is strange...");    }    foo = "bar";}</pre><p>Это <strong>Первое Правило Всплытия</strong>: Переменные доступны <em>в их области видимости</em>, но имеют значение <code class="inline">undefined</code> пока в коде им не будет присвоено значение.</p><p>Довольно популярная JavaScript идиома - писать все объявления <code class="inline">var</code> <span>на верху их области видимости</span>, вместо тех мест где вы их используете. Повторю слова Doug Crockford"а, ваш код <em>читается</em> также, как он <em>выполняется</em>.</p><p>Если подумать об этом, это имеет смысл. Сразу становится понятно почему <code class="inline">bar</code> ведёт себя так, когда мы пишем код также, как движок JavaScript читает его, неправд-ли? Так почему же не писать его так <em>всегда</em>? </p><h3>Всплытие Функционального Выражения (Function Expression)</h3><p>Тот факт, что мы видим <code class="inline">TypeError</code> ошибку когда пытаемся запустить <code class="inline">broken</code> до того, как она была определена, тоже относится к первому правилу всплытия.</p><p>Мы создали переменную <code class="inline">broken</code>, которую компилятор зарегистрировал в глобальной области видимости, равную <code class="inline">undefined</code>. Когда мы пытаемся её запустить, движок ищет значение <code class="inline">broken</code>, когда он его найдет, оно будет равно <code class="inline">undefined</code>, затем он пытается вызвать <code class="inline">undefined</code>, как функцию.</p><p>Очевидно, что <code class="inline">undefined</code> <em>не является</em> функцией—вот почему, в результате, мы получаем <code class="inline">TypeError</code>!</p><h3>Всплытие Объявления Функции (Function Declaration)</h3><p>Ну и наконец, зная это, мы можем вызвать <code class="inline">bar</code> до того, как мы определили данную функцию. Это связано со <strong>Вторым Правилом Всплытия</strong>: когда JavaScript компилятор находит объявление функции, имя <em>и</em> определение функции доступно сверху области видимости, которой она принадлежит. Давайте снова перепишем наш код:</p><pre class="brush: javascript noskimlinks noskimwords">function bar () {    if (!foo) {        alert(foo + "? This is strange...");    }    var foo = "bar";}var broken; // undefinedbar(); // bar is already defined, executes finebroken(); // Can"t execute undefined!broken = function () {    alert("This alert won"t show up!");}</pre><p> И опять же, не кажется-ли вам, что проще <em>писать</em> JavaScript код, так как <em>читает</em> его движок?</p><p>В итоге мы имеем:</p><ol><li>Имена объявлений переменных и выражения function (function expression) доступны в их области видимости, но их <em>значение</em> равно <code class="inline">undefined</code>, до тех пор пока оно не было назначено (значение).</li> <li>Имя <em>и</em> сама функция, функции объявления (function declaration) доступна внутри своей области видимости, даже до того, <em>как она была объявлена</em>. </li> </ol><p>Теперь давайте посмотрим на два новых инструмента, принцип работы, которых немного отличается: речь идёт о <code class="inline">let</code> и <code class="inline">const</code>.</p><h3> <code class="inline"><strong>let</strong></code>, <code class="inline">const</code> и временная мёртвая зона<strong></strong> </h3><p><strong></strong>В отличии от объявлений <code class="inline">var</code>, на переменные объявленные через <code class="inline">let</code> и <code class="inline">const</code>, <em>не распространяются</em> правила всплытия во время компиляции.</p><p>По крайней мере, не совсем так. </p><p>Помните мы могли вызвать <code class="inline">broken</code>, но в результате получили <code class="inline">TypeError</code>, потому что мы пытались вызывать <code class="inline">undefined</code>? Если мы вызовем <code class="inline">broken</code> объявленную через <code class="inline">let</code>, мы увидим <code class="inline">ReferenceError</code>:</p><pre class="brush: javascript noskimlinks noskimwords">"use strict"; // You have to "use strict" to try this in Nodebroken(); // ReferenceError!let broken = function () {    alert("This alert won"t show up!");}</pre><p>Не смотря на то что компилятор, при первом чтении кода, регистрирует переменные в их области видимости, <code class="inline">let</code> и <code class="inline">const</code> отличаются от <code class="inline">var</code>. <br></p><p>Когда он находит объявление <code class="inline">var</code>, мы регистрируем имя переменной в её области видимости и тут же присваиваем значение <code class="inline">undefined</code>.</p><p>Однако с <code class="inline">let</code>, компилятор <em>регистрирует</em> переменную в её области видимости, <em>но не инициализирует</em> при этом значение равное <code class="inline">undefined</code>. Вместо этого он оставляет переменную не инициализированной, <em>до тех пор</em> пока движок не начнёт выполнять выражения присваивания значений. Пытаясь получить значение не инициализированной переменной, даёт результат <code class="inline">ReferenceError</code>, что в свою очередь объясняет почему мы получили ошибку в коде выше, пытаясь его запустить.</p><p>Пространство между началом области видимости <code class="inline">let</code> и выражением присваивания значения, называется <em>временная мёртвая зона (Temporal Dead Zone)</em>. Это название связанно с тем фактом, что даже не смотря на то что движок <em>знает</em> о переменной <code class="inline">foo</code> на вершине области видимости <code class="inline">bar</code>, переменная "мертва", потому что у неё нет значения.</p><p>... А также переменная убьёт вашу программу если вы попытаетесь использовать её ранее.</p><p>Ключевое слово <code class="inline">const</code> работает примерно таким же образом, как и <code class="inline">let</code>, с двумя ключевыми отличиями:</p><ol><li>Вы <em>должны</em> сразу же присвоить значение, когда используете <code class="inline">const</code>.</li> <li>Вы <em>не можете</em> повторно присвоить значение переменной объявленной через <code class="inline">const</code>.</li> </ol><p>Тем самым у вас <em>всегда</em> будут гарантии, что у <code class="inline">const</code> будет значение, которое вы изначально присвоили.</p><pre class="brush: javascript noskimlinks noskimwords">// This is legalconst React = require("react");// This is totally not legalconst crypto;crypto = require("crypto");</pre><h3> <strong>Область Видимости Блока</strong><br></h3><p>У <code class="inline">let</code> и <code class="inline">const</code> есть и другое отличие от  <code class="inline">var</code>: размер области видимости.</p><p>Когда вы объявляете переменную через <code class="inline">var</code>, она видна на вершине цепочки областей видимости—обычно, на вершине ближайшего объявления функции, или глобальной области видимости, в том случае если объявление произошло на верхнем уровне. </p><p>Однако при объявлении переменных с <code class="inline">let</code> и <code class="inline">const</code>, они будут видны, более <em>локально</em>—только внутри ближайшего блока.</p><p><em>Блоком</em> считается пространство между фигурными скобками, которое можно видеть в <code class="inline">if</code>/<code class="inline">else</code> блоках, циклах <code class="inline">for</code>, и явно созданных "блочных" кусках кода, как в примере ниже. <br></p><pre class="brush: javascript noskimlinks noskimwords">"use strict";{  let foo = "foo";  if (foo) {      const bar = "bar";      var foobar = foo + bar;      console.log("I can see " + bar + " in this bloc.");  }    try {    console.log("I can see " + foo + " in this block, but not " + bar + ".");  } catch (err) {    console.log("You got a " + err + ".");  }}try {  console.log( foo + bar ); // Throws because of "foo", but both are undefined} catch (err) {  console.log( "You just got a " + err + ".");}console.log( foobar ); // Works fine</pre><p>Если вы объявляете переменную через <code class="inline">const</code> или <code class="inline">let</code> внутри блока, она будет видна <em>только</em> внутри этого блока и <em>только</em> после того, как вы присвоите значение.<br></p><p>Переменная объявленная через <code class="inline">var</code>, видна <em>гораздо дальше</em>—в нашем случае, в глобальной области видимости.</p><p>Если вас интересуют подробные детали <code class="inline">let</code> и <code class="inline">const</code>, обратите внимание, что Dr Rauschmayer говорит об этом в <span>Изучаем ES6: переменные и область видимости</span>, также посмотрите на <span>документацию на MDN</span>. </p><h3>Лексический <code class="inline"><strong>this</strong></code> и стрелочная функция</h3><p>На поверхности, не похоже что <code class="inline">this</code> каким-либо образом влияет на область видимости. По факту, правила области видимости JavaScript рассмотренные ранее <em>никак</em> не относятся к <code class="inline">this</code>.</p><p>По крайней мере не всегда. В JavaScript <em>не</em> важно где вы, в какой области видимости, использовали слово <code class="inline">this</code>:</p><pre class="brush: javascript noskimlinks noskimwords">var foo = {    name: "Foo",    languages: ["Spanish", "French", "Italian"],    speak : function speak () {        this.languages.forEach(function(language) {            console.log(this.name + " speaks " + language + ".");        })    }};foo.speak();</pre><p>Большинство из нас думают, что <code class="inline">this</code> будет равен <code class="inline">foo</code> внутри цикла <code class="inline">forEach</code>, так как this за границами forEach равен foo. Другими словами возможно многие думают, что JavaScript рассматривает <code class="inline">this</code> <em>лексически</em>.</p><p>Вы ошибаетесь.</p><p>Вместо этого создаётся <em>новый</em> <code class="inline">this</code> внутри каждой функции, которую вы определяете, движок рассматривает значение this в зависимости не от того <em>где</em> вы определили функцию, а от того <em>как</em> вы её вызвали.</p><p>Похожий случай когда вы переопределяете <em>любую</em> переменную во внутренней области видимости:</p><pre class="brush: javascript noskimlinks noskimwords">function foo () {    var bar = "bar";    function baz () {        // Reusing variable names like this is called "shadowing"         var bar = "BAR";        console.log(bar); // BAR    }    baz();}foo(); // BAR</pre><p>Замените <code class="inline">bar</code> на <code class="inline">this</code>, и всё немедленно отчистится!</p><p>Обычно, заставить <code class="inline">this</code> работать подобно лексической области видимости переменных, требует некоторых обходных путей:<br></p><pre class="brush: javascript noskimlinks noskimwords">var foo = {    name: "Foo",    languages: ["Spanish", "French", "Italian"],    speak_self : function speak_s () {        var self = this;        self.languages.forEach(function(language) {            console.log(self.name + " speaks " + language + ".");        })    },    speak_bound : function speak_b () {        this.languages.forEach(function(language) {            console.log(this.name + " speaks " + language + ".");        }.bind(foo)); // More commonly:.bind(this);    }};</pre><p>В <code class="inline">speak_self</code>, мы сохраняем значение <code class="inline">this</code> в переменную <code class="inline">self</code> и используем эту переменную в качестве ссылки. В <code class="inline">speak_bound</code>, мы используем <code class="inline"><span>bind</span></code> для того, чтобы привязать <code class="inline">this</code> к объекту, на постоянной основе.</p><p>В ES2015 появилась ещё одна альтернатива - стрелочные функции.</p><p>В отличии от обычной функции, стрелочная функция <em>не</em> скрывает значение <code class="inline">this</code> в родительской области видимости, устанавливая при этом новое значение. Вместо этого данные функции <em>лексически</em> привязаны к значению this. </p><p>Другими словами, используя <code class="inline">this</code> в стрелочной функции, JavaScript ищет значение наверху, как и в случае с обычными переменными.</p><p>В начале значение <code class="inline">this</code> ищется в локальной области видимости. Так как стрелочная функция не устанавливает значение this, там найдено ничего не будет. После этого значение <code class="inline">this</code> будет искаться в родительской области видимости. Если значение найдётся там, то оно и будет использоваться.</p><p>Тем самым мы можем переписать код выше:</p><pre class="brush: javascript noskimlinks noskimwords">var foo = {    name: "Foo",    languages: ["Spanish", "French", "Italian"],    speak : function speak () {        this.languages.forEach((language) =&gt; {            console.log(this.name + " speaks " + language + ".");        })    }};   </pre><p>Больше подробностей о стрелочных функциях рассказывает инструктор Envato Tuts+ <span>Dan Wellman</span> в курсе <span>Основы JavaScript ES6</span>, а также советую взглянуть на <span>документацию MDN по стрелочным функциям</span>.</p><h2>Заключение</h2><p>Мы разобрали многое c момента начала этой статьи! Мы узнали:</p><ul><li>Переменные регистрируются в их области видимости во время <em>компиляции</em>, значения переменным присваиваются во время <em>выполнения</em> кода.</li> <li>Использование переменных объявленных через <code class="inline">let</code> или <code class="inline">const</code>, перед присваиванием им значений, выдаст <code class="inline">ReferenceError</code> и эти переменные находятся в области видимости ближайшего блока.</li> <li>Стрелочные функции позволяют нам лексически привязывать <code class="inline">this</code>, тем самым обходя традиционное динамическое привязывание.</li> </ul><p>Мы также рассмотрели два правила всплытия:</p><ul><li><strong>Первое правило всплытия</strong>: функциональные выражения и объявления <code class="inline">var</code> доступны в области видимости в том месте где они были определены, но значение у них будет <code class="inline">undefined</code> то того момента, как произойдёт присваивание значения.</li> <li><strong>Второе правило всплытия</strong>: имена функций - объявлений <em>и</em> их тело доступны в их области видимости сразу, как только они были определены.</li> </ul><p>Полученные знания можно применить на практике при изучении замыканий JavaScript, в качестве следующего шага. Для этого советую вам ознакомиться со статьёй <span>Область видимости и Замыкания</span> Kyle Simpson"а.</p><p>Ну и наконец, в данной статье, я рассказал вам не всю информацию касательно <code class="inline">this</code>. Если это ключевое слово всё ещё кажется вам тёмной магией, взгляните на <span>this и прототипы объекта</span>, чтобы разобраться что к чему.</p><p>Со всеми новыми знаниями, начинайте писать код и конечно же ошибки!</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825151-oblast-vidimosti-v-javascript" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="JavaScript" href="https://norma-studio.github.io/article5/220825151-oblast-vidimosti-v-javascript" class="tm-article-body__tags-item-link">JavaScript</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
31023</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
531</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

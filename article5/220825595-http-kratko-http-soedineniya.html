
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>HTTP Кратко: HTTP-соединения... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="HTTP Кратко: HTTP-соединения... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="HTTP Кратко: HTTP-соединения... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="HTTP Кратко: HTTP-соединения... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="В последней статье мы рассмотрели HTTP-сообщения и увидели примеры текстовых команд и кодов, которые поступают от клиента на сервер и обратно в транзакцию HTTP. Но как информация в этих сообщениях перемещается по сети? Когда открыты сетевые подключения? Когда закрываются соединения? Вот такие некоторые вопросы, на которые ответит эта статья, как мы...">
<meta property="og:description" content="В последней статье мы рассмотрели HTTP-сообщения и увидели примеры текстовых команд и кодов, которые поступают от клиента на сервер и обратно в транзакцию HTTP. Но как информация в этих сообщениях перемещается по сети? Когда открыты сетевые подключения? Когда закрываются соединения? Вот такие некоторые вопросы, на которые ответит эта статья, как мы...">
<meta name="twitter:description" content="В последней статье мы рассмотрели HTTP-сообщения и увидели примеры текстовых команд и кодов, которые поступают от клиента на сервер и обратно в транзакцию HTTP. Но как информация в этих сообщениях перемещается по сети? Когда открыты сетевые подключения? Когда закрываются соединения? Вот такие некоторые вопросы, на которые ответит эта статья, как мы...">
<meta property="aiturec:description" content="В последней статье мы рассмотрели HTTP-сообщения и увидели примеры текстовых команд и кодов, которые поступают от клиента на сервер и обратно в транзакцию HTTP. Но как информация в этих сообщениях перемещается по сети? Когда открыты сетевые подключения? Когда закрываются соединения? Вот такие некоторые вопросы, на которые ответит эта статья, как мы...">
<meta property="og:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=680/net/uploads/2013/07/img004.png">
<meta property="aiturec:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=680/net/uploads/2013/07/img004.png">
<meta name="twitter:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=680/net/uploads/2013/07/img004.png">
<meta property="vk:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=680/net/uploads/2013/07/img004.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=680/net/uploads/2013/07/img004.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825595-http-kratko-http-soedineniya.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825595-http-kratko-http-soedineniya.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825595-http-kratko-http-soedineniya.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825595-http-kratko-http-soedineniya.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825595-http-kratko-http-soedineniya.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825595-http-kratko-http-soedineniya.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825595-http-kratko-http-soedineniya.html" title="HTTP Кратко: HTTP-соединения... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="HTTP Кратко: HTTP-соединения... | envatomarket.ru | norma-studio.github.io" title="HTTP Кратко: HTTP-соединения... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/64533ghhjgjj.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825595-http-kratko-http-soedineniya.html" class="tm-user-info__username" title="
С. Парфенов" aria-label="
С. Парфенов">
С. Парфенов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>HTTP Кратко: HTTP-соединения...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825595-http-kratko-http-soedineniya" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Web Development" href="https://norma-studio.github.io/article5/220825595-http-kratko-http-soedineniya" class="tm-article-snippet__hubs-item-link"><span>Web Development</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825595-http-kratko-http-soedineniya.html" />
    <link itemprop="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=680/net/uploads/2013/07/img004.png">
    <meta itemprop="headline name" content="HTTP Кратко: HTTP-соединения... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="В последней статье мы рассмотрели HTTP-сообщения и увидели примеры текстовых команд и кодов, которые поступают от клиента на сервер и обратно в транзакцию HTTP. Но как информация в этих сообщениях перемещается по сети? Когда открыты сетевые подключения? Когда закрываются соединения? Вот такие некоторые вопросы, на которые ответит эта статья, как мы...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">В последней статье мы рассмотрели HTTP-сообщения и увидели примеры текстовых команд и кодов, которые поступают от клиента на сервер и обратно в транзакцию HTTP. Но как информация в этих сообщениях перемещается по сети? Когда открыты сетевые подключения? Когда закрываются соединения? Вот такие некоторые вопросы, на которые ответит эта статья, как мы...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>В последней статье мы рассмотрели HTTP-сообщения и увидели примеры текстовых команд и кодов, которые поступают от клиента на сервер и обратно в транзакцию HTTP. Но как информация в этих сообщениях перемещается по сети? Когда открыты сетевые подключения? Когда закрываются соединения? Вот такие некоторые вопросы, на которые ответит эта статья, как мы смотрим на HTTP с точки зрения низкого уровня. Но сначала нам нужно понять некоторые абстракции ниже HTTP.</p> <p><!--more--></p> <hr><h2>Экскурс по сети</h2> <p>Чтобы понять HTTP соединения мы должны знать немного о том, что происходит в слоях под HTTP. Сетевая связь, как и многие приложения, состоит из слоев. Каждый уровень в <b>стеке связи</b> отвечает за определенное и ограниченное количество обязанностей.</p> <p>Например, HTTP - это то, что мы называем протоколом уровня приложения, поскольку он позволяет двум приложениям обмениваться данными по сети. Довольно часто одним из приложений является веб-браузер, а другое приложение - веб-сервер, например IIS или Apache. Мы видели, как сообщения HTTP позволяют браузеру запрашивать ресурсы с сервера. Но спецификации HTTP не говорят ничего о том, как сообщения действительно пересекают сеть и доходят до сервера, - это работа протоколов более низкого уровня. Сообщение от веб-браузера должно перемещаться по нескольким слоям, и когда он приходит на веб-сервер, он перемещается вверх через ряд слоев, чтобы достичь процесса веб-службы.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=680/net/uploads/2013/07/img004.png" alt="HTTP Кратко: HTTP-соединения..." title="HTTP Кратко: HTTP-соединения..." width="50" height="50"><figcaption>Слои протокола</figcaption></figure><p>Слой под HTTP — это <b>протокол уровня транспорта</b>. Почти весь HTTP-трафик проходит по <b>TCP </b>(короткий для протокола управления передачей), хотя HTTP не требуется. Когда пользователь вводит URL-адрес в браузер, браузер сначала извлекает имя хоста из URL-адреса (и номера порта, если есть), и открывает <b>разъем TCP</b>, указывая адрес сервера (полученный от имени хоста) и порта (который по умолчанию - 80).</p> <p>Когда приложение имеет открытый разъем, он может начать запись данных в разъем. Единственное, о чем нужно беспокоиться в браузере, это написать правильно отформатированное сообщение HTTP-запроса в сокет. Уровень TCP принимает данные и гарантирует, что сообщение будет доставлено на сервер без потери или дублирования. TCP автоматически отправит любую информацию, которая может быть потеряна при транзите, и именно поэтому TCP известен как <i>надежный протокол</i>. Помимо обнаружения ошибок TCP также обеспечивает управление потоком. Алгоритмы управления потоком в TCP гарантируют, что отправитель не будет отправлять данные слишком быстро, чтобы получатель обрабатывал данные. Управление потоком важно в этом мире разнообразных сетей и устройств.</p> <p>Короче говоря, TCP предоставляет службы, жизненно важные для успешной доставки HTTP-сообщений, но делает это прозрачным способом, поэтому большинству приложений не нужно беспокоиться о TCP. Как показано на предыдущем рисунке, TCP - это только первый уровень под HTTP. После того, как TCP на транспортном уровне идет IP как протокол сетевого уровня.</p> <p><strong>IP </strong>— короткий для <strong>Интернет-протокола</strong>. В то время как TCP отвечает за обнаружение ошибок, управление потоком и общую надежность, IP отвечает за сбор фрагментов информации и перемещение их через различные коммутаторы, маршрутизаторы, шлюзы, повторители и другие устройства, которые перемещают информацию из одной сети в другую во всем мире. IP пытается выполнить доставку данных в пункт назначения (но это не гарантирует доставку - это работа TCP). IP требует, чтобы компьютеры имели адрес (известный IP-адрес, пример - 208.192.32.40). IP также отвечает за разбиение данных на пакеты (часто называемые датаграммами), а иногда и на фрагментацию и сборку этих пакетов, поэтому они оптимизированы для определенного сегмента сети.</p> <p>Все, о чем мы говорили до сих пор, происходит внутри компьютера, но в конечном итоге эти IP-пакеты должны перемещаться по проводу, оптоволоконному кабелю, беспроводной сети или спутниковой линии. Это ответственность за уровень <strong>канала передачи данных</strong>. В настоящее время общий выбор технологии - <strong>Ethernet</strong>. На этом уровне пакеты данных становятся кадрами, а протоколы низкого уровня, такие как Ethernet, фокусируются на 1 с, 0 и электрические сигналы.</p> <p>В конце концов сигнал достигает сервера и поступает через сетевую карту, где процесс отменяется. Уровень канала передачи данных передает пакеты на уровень IP, который передает данные в TCP, который может собирать данные в исходное HTTP-сообщение, отправленное клиентом, и вставлять его в процесс веб-сервера. Это прекрасно спроектированная часть работы, сделанная по стандартам.</p> <hr><h2>Быстрый запрос HTTP с розетки и C#</h2> <p>Если вам интересно, как выглядит приложение, которое будет обрабатывать HTTP-запросы, то следующий код C # - это простой пример того, как выглядит код. Этот код не имеет обработки ошибок и пытается записать любой ответ сервера в окно консоли (так что вам нужно запросить текстовый ресурс), но он работает для простых запросов. Копия следующего примера кода доступна из <span>https://bitbucket.org/syncfusion/http-succinctly</span>. Имя образца - это сокеты-образец.</p> <pre class="brush: c-sharp noskimlinks noskimwords">using System;using System.Net;using System.Net.Sockets;using System.Text; public class GetSocket{    public static void Main(string[] args)    {        var host = "www.wikipedia.org";        var resource = "/";               Console.WriteLine("Connecting to {0}", host);         if(args.GetLength(0) &gt;= 2)        {            host = args[0];            resource = args[1];        }               var result = GetResource(host, resource);        Console.WriteLine(result);    }     private static string GetResource(string host, string resource)    {        var hostEntry = Dns.GetHostEntry(host);        var socket = CreateSocket(hostEntry);        SendRequest(socket, host, resource);        return GetResponse(socket);    }     private static Socket CreateSocket(IPHostEntry hostEntry)    {        const int httpPort = 80;        foreach (var address in hostEntry.AddressList)        {            var endPoint = new IPEndPoint(address, httpPort);            var socket = new Socket(                           endPoint.AddressFamily,                           SocketType.Stream,                           ProtocolType.Tcp);            socket.Connect(endPoint);            if (socket.Connected)            {                return socket;            }        }        return null;    }     private static void SendRequest(Socket socket, string host,                                    string resource)    {                       var requestMessage = String.Format(            "GET {0} HTTP/1.1\r\n" +            "Host: {1}\r\n" +            "\r\n",            resource, host        );         var requestBytes = Encoding.ASCII.GetBytes(requestMessage);        socket.Send(requestBytes);    }        private static string GetResponse(Socket socket)    {        int bytes = 0;        byte[] buffer = new byte[256];        var result = new StringBuilder();               do        {            bytes = socket.Receive(buffer);            result.Append(Encoding.ASCII.GetString(buffer, 0, bytes));        } while (bytes &gt; 0);         return result.ToString();    }}</pre> <p>Обратите внимание, как программа должна искать адрес сервера (используя <code>Dns.GetHostEntry</code>), и сформулировать правильное HTTP-сообщение с оператором <code>GET</code> и заголовком <code>Host</code>. Фактическая сетевая часть довольно проста, потому что реализация сокета и TCP заботятся о большей части работы. TCP понимает, например, как управлять несколькими подключениями к одному и тому же серверу (все они будут получать разные номера портов локально). Из-за этого два невыполненных запроса на один и тот же сервер не запутаются и не получат данные, предназначенные для другого.</p> <hr><h2>Сеть и Wireshark</h2> <p>Если вам нужна видимость TCP и IP, вы можете установить бесплатную программу, такую ​​как Wireshark (доступная для OSX и Windows с сайта <span>wirehark.org</span>). Wireshark - это сетевой анализатор, который может отображать каждый бит информации, проходящей через ваши сетевые интерфейсы. Используя Wireshark вы можете наблюдать TCP-сообщения, которые являются TCP-сообщениями, необходимыми для установления соединения между клиентом и сервером до того, как начнутся фактические HTTP-сообщения. Вы также можете видеть заголовки TCP и IP (по 20 байтов каждый) для каждого сообщения. На следующем рисунке показаны последние два шага рукопожатия, затем запрос <code>GET</code> и перенаправление <code>304</code>.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=635/net/uploads/2013/07/img005.png" alt="HTTP Кратко: HTTP-соединения..." title="HTTP Кратко: HTTP-соединения..." width="50" height="50"><figcaption>Использование Wireshark</figcaption></figure><p>С Wireshark вы можете видеть, когда HTTP-соединения установлены и закрыты. Важная часть, чтобы убрать все это, заключается не в том, как рукопожатия и TCP работают на самом низком уровне, но этот HTTP почти полностью связан с TCP, чтобы заботиться обо всей тяжелой работе, а TCP включает некоторые накладные расходы, например рукопожатия. Таким образом, характеристики производительности HTTP также зависят от характеристик производительности TCP, и это тема для следующего раздела.</p> <hr><h2>HTTP, TCP и Эволюция Интернета</h2> <p>В самые старые времена Интернета большинство ресурсов были текстовыми. Вы можете запросить документ с веб-сервера, выйти и прочитать в течение пяти минут, а затем запросить другой документ. Мир был прост.</p> <p>Для сегодняшней сети большинство веб-страниц требуют больше, чем одного ресурса для полного рендеринга. Каждая страница веб-приложения имеет одно или несколько изображений, один или несколько файлов JavaScript и один или несколько файлов CSS. Нередко исходный запрос для домашней страницы порождает 30 или 50 дополнительных запросов для извлечения всех других ресурсов, связанных со страницей.</p> <p>В старые времена для браузера также было просто установить соединение с сервером, отправить запрос, получить ответ и закрыть соединение. Если сегодняшние веб-браузеры открывали соединения по одному, и ожидали, что каждый ресурс будет полностью загружен до начала следующей загрузки, сеть будет очень медленной. Интернет полон задержек. Сигналы должны перемещаться на большие расстояния и прокладывать себе путь через разные аппаратные устройства. Также есть некоторые накладные расходы при установлении TCP-соединения. Как мы видели в скриншоте Wireshark, для завершения HTTP-транзакции может быть выполнено трехэтапное рукопожатие.</p> <p>Эволюция от простых документов до сложных страниц потребовала некоторой изобретательности в практическом использовании HTTP.</p> <hr><h2>Параллельные соединения</h2> <p>Большинство пользовательских агентов (ака веб-браузеров) не будут обрабатывать запросы по очереди один за другим. Вместо этого они открывают несколько <b>параллельных подключений</b> к серверу. Например, при загрузке HTML для страницы браузер может видеть две тега <code>&lt;img&gt;</code> на странице, поэтому браузер откроет два параллельных соединений, чтобы загрузить два изображения одновременно. Количество параллельных соединений зависит от пользовательского агента и конфигурации агента.</p> <p>Долгое время мы рассматривали два как максимальное количество параллельных соединений, которые создавал браузер. Мы считали два максимальных, потому что самый популярный браузер на протяжении многих лет - Internet Explorer (IE) 6 - допускал бы только два одновременных подключения к одному хосту. IE только подчинялся правилам, изложенным в спецификации HTTP 1.1, в которой говорится:</p> <div class="tip-shortcode"> <p>Однопользовательский клиент НЕ ДОЛЖЕН поддерживать более двух соединений с любым сервером или прокси.</p> </div> <p>Чтобы увеличить количество параллельных загрузок, многие веб-сайты используют некоторые трюки. Например, ограничение на два подключения для <i>каждого хоста</i>, то есть браузер, такой как IE 6, с радостью сделает два параллельных подключения к www.odetocode.com <i>и </i>два параллельных подключения к изображениям.odetocode.com. Путем размещения изображений на другом сервере веб-сайты могут увеличить количество параллельных загрузок и ускорить загрузку своих страниц (даже если записи DNS были настроены так, чтобы указать все четыре запроса на один и тот же сервер, поскольку ограничение на два подключения <i>для каждого хоста имя, а не IP-адрес</i>).</p> <p>На сегодня это разные вещи Большинство пользовательских агентов будут использовать другой набор эвристик при выборе количества параллельных подключений. Например, Internet Explorer 8 теперь откроет до шести одновременных подключений.</p> <p>Реальный вопрос: сколько соединений слишком много? Параллельные соединения будут подчиняться закону убывающих возвратов. Слишком много соединений может насыщать и поддерживать сеть, особенно когда задействованы мобильные устройства или ненадежные сети. Таким образом, слишком много соединений могут повредить производительность. Кроме того, сервер может принимать только конечное количество соединений, поэтому, если 100 000 браузеров одновременно создают 100 подключений к одному веб-серверу, то будет не очень хорошо. Тем не менее, использование более чем одного соединения для агента лучше, чем загрузка всего в серийном режиме.</p> <p>К счастью, параллельные соединения - это не единственная оптимизация производительности.</p> <hr><h2>Постоянные соединения</h2> <p>В первые дни Интернета пользовательский агент открывал и закрывал соединение для каждого отдельного запроса, отправленного на сервер. Эта реализация соответствовала идее HTTP о том, что она является полностью без государственным протоколом. По мере роста количества запросов на страницу также возникали накладные расходы, вызванные рукопожатиями TCP и структурами данных в памяти, необходимыми для установления каждого сокета TCP. Чтобы уменьшить эти накладные расходы и повысить производительность, спецификация HTTP 1.1 предполагает, что клиенты и серверы должны внедрять <b>постоянные соединения</b> и создавать постоянные соединения по умолчанию для типа соединения.</p> <p>Постоянное соединение остается открытым после завершения одной транзакции с запросом-ответом. Такое поведение оставляет пользовательский агент с уже открытым сокетом, который он может использовать, чтобы продолжать делать запросы на сервер без накладных расходов на открытие нового сокета. Персистентные соединения также избегают стратегии медленного запуска, которая является частью управления перегрузкой TCP, что делает постоянные соединения более эффективными с течением времени. Короче говоря, постоянные соединения сокращают использование памяти, уменьшают использование ЦП, уменьшают перегрузку сети, уменьшают задержку и обычно улучшают время отклика страницы. Но, как и все в жизни есть и обратная сторона.</p> <p>Как упоминалось ранее, сервер может поддерживать только конечное количество входящих соединений. Точный номер зависит от объема доступной памяти, конфигурации серверного программного обеспечения, производительности приложения и многих других переменных. Трудно дать точное число, но, вообще говоря, если вы говорите о поддержке тысяч одновременных подключений, вам нужно будет начать тестирование, чтобы проверить, поддерживает ли сервер нагрузку. Фактически, многие серверы настроены на ограничение количества параллельных подключений намного ниже точки, где сервер будет падать. Конфигурация - это мера безопасности, которая помогает предотвратить атаки на отказ в обслуживании. Для кого-то относительно легко создать программу, которая откроет тысячи постоянных подключений к серверу и не даст серверу отвечать реальным клиентам. Постоянными соединениями являются оптимизация производительности, а также уязвимость.</p> <p>Думая об уязвимости, нам также нужно задаться вопросом, как долго поддерживать постоянное соединение открытым. В мире бесконечной масштабируемости соединения могут оставаться открытыми до тех пор, пока запускается программа пользовательского агента. Но поскольку сервер поддерживает конечное число подключений, большинство серверов настроено на закрытие постоянного соединения, если он неактивен в течение некоторого периода времени (например, в Apache, например, пять секунд). Пользовательские агенты также могут закрывать соединения после периода простоя. Единственная видимость подключений закрывается через сетевой анализатор, такой как Wireshark.</p> <p>В дополнение к агрессивному закрытию постоянных соединений большинство веб-серверных программ можно настроить для отключения постоянных подключений. Это характерно для общих серверов. Совместные серверы жертвуют производительностью, позволяя максимально возможное количество подключений. Поскольку постоянные соединения - это стиль соединения по умолчанию с HTTP 1.1, сервер, который не разрешает постоянные подключения, должен включать заголовок <code>Connection</code> в каждом ответе HTTP. Примером может служить следующий код.</p> <pre class="brush: text noskimlinks noskimwords">HTTP/1.1 200 OKContent-Type: text/html; charset=utf-8Server: Microsoft-IIS/7.0X-AspNet-Version: 2.0.50727X-Powered-By: ASP.NETConnection: closeContent-Length: 17149</pre> <p>Заголовок <code>Connection: close</code> является сигналом для пользовательского агента, что соединение не будет постоянным и должно быть закрыто как можно скорее. Агенту не разрешается делать второй запрос по тому же соединению.</p> <hr><h2>Конвейерные соединения</h2> <p>Параллельные соединения и постоянные соединения широко используются и поддерживаются клиентами и серверами. Спецификация HTTP также позволяет <b>конвейерные соединения</b>, которые не так широко поддерживаются ни серверами, ни клиентами. В конвейерном соединении пользовательский агент может отправить несколько HTTP-запросов в соединение, прежде чем ждать первого ответа. Конвейеризация позволяет более эффективно упаковывать запросы в пакеты и может уменьшить задержку, но она не так широко поддерживается как параллельные и постоянные соединения.</p> <hr><h2>Где мы?</h2> <p>В этой главе мы рассмотрели HTTP-соединения и рассказали о некоторых оптимизациях производительности, которые стали доступны по спецификациям HTTP. Теперь, когда мы углубились в HTTP-сообщения и даже рассмотрели подключения и поддержку TCP под протоколом, мы сделаем шаг назад и рассмотрим Интернет с более широкой точки зрения.</p> 

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825595-http-kratko-http-soedineniya" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Web Development" href="https://norma-studio.github.io/article5/220825595-http-kratko-http-soedineniya" class="tm-article-body__tags-item-link">Web Development</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
30130</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
320</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>


<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Осваиваем HTML5: обход дерева... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Осваиваем HTML5: обход дерева... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Осваиваем HTML5: обход дерева... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Осваиваем HTML5: обход дерева... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Одна из наиболее важных концепций DOM – обход дерева (* процесс единоразового посещения (проверки и/или обновления) каждого узла дерева (структура данных). Здесь и далее примеч. пер.). Поскольку теория вычислительных машин и систем (* компьютерные науки; общее название для совокупности дисциплин, связанных с конструированием компьютеров и их исполь...">
<meta property="og:description" content="Одна из наиболее важных концепций DOM – обход дерева (* процесс единоразового посещения (проверки и/или обновления) каждого узла дерева (структура данных). Здесь и далее примеч. пер.). Поскольку теория вычислительных машин и систем (* компьютерные науки; общее название для совокупности дисциплин, связанных с конструированием компьютеров и их исполь...">
<meta name="twitter:description" content="Одна из наиболее важных концепций DOM – обход дерева (* процесс единоразового посещения (проверки и/или обновления) каждого узла дерева (структура данных). Здесь и далее примеч. пер.). Поскольку теория вычислительных машин и систем (* компьютерные науки; общее название для совокупности дисциплин, связанных с конструированием компьютеров и их исполь...">
<meta property="aiturec:description" content="Одна из наиболее важных концепций DOM – обход дерева (* процесс единоразового посещения (проверки и/или обновления) каждого узла дерева (структура данных). Здесь и далее примеч. пер.). Поскольку теория вычислительных машин и систем (* компьютерные науки; общее название для совокупности дисциплин, связанных с конструированием компьютеров и их исполь...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F48%2Fposts%2F24843%2Fimage-1444075147698.png">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F48%2Fposts%2F24843%2Fimage-1444075147698.png">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F48%2Fposts%2F24843%2Fimage-1444075147698.png">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F48%2Fposts%2F24843%2Fimage-1444075147698.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F48%2Fposts%2F24843%2Fimage-1444075147698.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825306-osvaivaem-html5-obhod-dereva.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825306-osvaivaem-html5-obhod-dereva.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825306-osvaivaem-html5-obhod-dereva.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825306-osvaivaem-html5-obhod-dereva.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825306-osvaivaem-html5-obhod-dereva.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825306-osvaivaem-html5-obhod-dereva.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825306-osvaivaem-html5-obhod-dereva.html" title="Осваиваем HTML5: обход дерева... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Осваиваем HTML5: обход дерева... | envatomarket.ru | norma-studio.github.io" title="Осваиваем HTML5: обход дерева... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/64533ghhjgjj.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825306-osvaivaem-html5-obhod-dereva.html" class="tm-user-info__username" title="
С. Парфенов" aria-label="
С. Парфенов">
С. Парфенов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Осваиваем HTML5: обход дерева...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825306-osvaivaem-html5-obhod-dereva" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="HTML5" href="https://norma-studio.github.io/article5/220825306-osvaivaem-html5-obhod-dereva" class="tm-article-snippet__hubs-item-link"><span>HTML5</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825306-osvaivaem-html5-obhod-dereva.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F48%2Fposts%2F24843%2Fimage-1444075147698.png">
    <meta itemprop="headline name" content="Осваиваем HTML5: обход дерева... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Одна из наиболее важных концепций DOM – обход дерева (* процесс единоразового посещения (проверки и/или обновления) каждого узла дерева (структура данных). Здесь и далее примеч. пер.). Поскольку теория вычислительных машин и систем (* компьютерные науки; общее название для совокупности дисциплин, связанных с конструированием компьютеров и их исполь...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Одна из наиболее важных концепций DOM – обход дерева (* процесс единоразового посещения (проверки и/или обновления) каждого узла дерева (структура данных). Здесь и далее примеч. пер.). Поскольку теория вычислительных машин и систем (* компьютерные науки; общее название для совокупности дисциплин, связанных с конструированием компьютеров и их исполь...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F48%2Fposts%2F24843%2Fimage-1444075147698.png" alt="Осваиваем HTML5: обход дерева..." title="Осваиваем HTML5: обход дерева..." width="50" height="50"></figure><p>Одна из наиболее важных концепций DOM – обход дерева (* процесс единоразового посещения (проверки и/или обновления) каждого узла дерева (структура данных). Здесь и далее примеч. пер.). Поскольку теория вычислительных машин и систем (* компьютерные науки; общее название для совокупности дисциплин, связанных с конструированием компьютеров и их использованием в обработке информации. Объединяет теоретические и практические аспекты многих наук, таких как электроника, программирование, математика, искусственный интеллект, человеко-машинное взаимодействие, конструирование и др.) сформировалась как самостоятельная область исследований, десятилетия были потрачены на разработку структур данных (* способ хранения и организации данных для более удобного доступа к ним и обработки; может представлять собой описание полей записи, таблицы, списка, массива, файла и т. п.) и алгоритмов (* математическая функция или конечный чёткий набор описаний логической последовательности действий, необходимых для того, чтобы компьютер или интеллектуальное устройство выполнили за конечное время некоторую задачу). Одной из наиболее часто используемых структур является дерево. Деревья представлены везде. Одной из простейших и в то же время полезной и часто используемой версией дерева является двоичное дерево (* структура данных, представляющая собой дерево, каждая вершина (узел) которого имеет не более двух потомков. Каждая вершина может также содержать ключ, идентифицирующий эту вершину и ассоциированный с некоторыми данными. Двоичные деревья используются в некоторых алгоритмах сортировки и поиска данных. У двоичных деревьев различают следующие части: корень (root), левая ветвь (left branch), правая ветвь (right branch) и листья (leaf node)). Спортивное соревнование можно представить в виде двоичного дерева. Однако дерево DOM не является двоичным. Это K-арное дерево (* дерево с корнем, в каждом узле которого имеется не более k дочерних узлов). Каждый узел может иметь от нуля до <em>N</em> подузлов, называемых <code class="inline">childNodes</code>.</p><p>В дереве DOM содержится большое разнообразие всевозможных типов узлов. Это могут быть <code class="inline">Text</code>, <code class="inline">Element</code>, <code class="inline">Comment </code>и другие дополнительные, например <code class="inline">ProcessingInstruction </code>или <code class="inline">DocumentType</code> помимо многих других. Большинство из них не будет содержать каких-либо <code class="inline">childNodes </code>(* дочерних элементов) по определению (* по своей природе). Они являются конечными точками (* термин "конечная точка" (endpoint) часто используется для описания отдельной функции API) и содержат только один тип информации. Например узел <code class="inline">Comment </code>содержит только указанную строку комментария. В узле <code class="inline">Text </code>может содержаться только строка с контентом.</p> <p>В узле <code class="inline">Element </code>содержатся другие узлы. Мы можем рекурсивно (* с повторным использованием процедуры, правила для достижения результата) спускаться к элементам для обхода всех доступных узлов дерева.</p> <h2>Наглядный пример</h2> <p>Примером, который также относится к предыдущей статье, в которой рассматривался элемент <code class="inline">&lt;template&gt;</code>, является заполнение поддерева. Поддерево – часть дерева, которая начинается с указанного элемента. Этот элемент называется корнем поддерева. Если бы мы взяли элемент <code class="inline">&lt;html&gt;</code> дерева в качестве корня поддерева, то поддерево было бы почти идентично дереву документа, которое начинается с <code class="inline">document</code>, то есть располагалось бы на один уровень ниже <code class="inline">documentElement</code>.</p> <p>Для того чтобы заполнить поддерево, нам необходимо выполнить итерацию для дочерних элементов корня поддерева. Для каждого узла нам необходимо уточнить его тип и затем продолжить соответствующим образом. Например каждый элемент необходимо снова принимать в качестве корня поддерева. Узлы с текстом, с другой стороны, нужно оценивать более тщательно. Возможно нам также хочется проверить узлы с комментариями на наличие специальных директив. Более того, также необходимо рассмотреть атрибуты элементов.</p> <p>В нашем примере мы используем метод под названием <code class="inline">applyModel </code>для заполнения строк, соответствующих определенному шаблону, значениями из модели. Метод выглядит, как показано ниже, и мог бы быть без проблем оптимизирован в дальнейшем. Однако для целей нашего руководства он несомненно подходит.</p> <pre class="brush: javascript noskimlinks noskimwords">function applyModel(model, data) {  var rx = new RegExp("\{\s*(.+?)\s*\}", "g");var group = rx.exec(data);while (group) {var name = group[1];var value = "";eval("with (model) { value = " + name + "; }");data = data.replace(group[0], value);group = rx.exec(data);}return data;}</pre> <p>Давайте рассмотрим реализацию вышеописанного сценария, в котором используется метод <code class="inline">applyModel </code>в различных ситуациях. Этот метод принимает образец элемента <code class="inline">template </code>и объект <code class="inline">model </code>для возвращения нового <code class="inline">DocumentFragment</code>. В новом фрагменте используются данные из модели для изменения всех значений <code class="inline">{X}</code> на результат вычисления выражения <code class="inline">X</code>, при котором использовался предоставленный объект.</p> <pre class="brush: javascript noskimlinks noskimwords">function iterateClassic (template, model) {var fragment = template.content.clone(true);var allNodes = findAllNodes(fragment);allNodes.forEach(changeNode);return fragment;}</pre> <p>В предыдущем коде используется функция <code class="inline">findAllNodes</code>, которая принимает узел и сохраняет все его дочерние элементы в массиве. Затем функция вызывается рекурсивно для каждого дочернего элемента. В конце все результаты помещаются в единственный массив для всего поддерева, то есть мы преобразуем дерево в одномерный массив.</p> <p>Ниже показан фрагмент кода для одного из вариантов реализации описанного выше алгоритма.</p> <pre class="brush: javascript noskimlinks noskimwords">function findAllNodes (childNodes) {var nodes = [];if (childNodes &amp;&amp; childNodes.length &gt; 0) {for (var i = 0, length = childNodes.length; i &lt; length; i++) {nodes.push(childNodes[i]);nodes = nodes.concat(findAllNodes(childNodes[i].childNodes));}}return nodes;}</pre> <p>Функция для изменения каждого узла массива показана ниже. Функция выполняет некоторые манипуляции в зависимости от типа узла. Нас интересуют только атрибуты элементов и текстовые узлы.</p> <pre class="brush: javascript noskimlinks noskimwords">function changeNode (node) {switch (node.nodeType) {case Node.TEXT_NODE:node.text.data = applyModel(model, node.text.data);break;case Node.ELEMENT_NODE:Array.prototype.forEach.call(node.attributes, function (attribute) {attribute.value = applyModel(model, attribute.value);});break;}}</pre> <p>Хотя вышеописанный код легко понять, в нем не все так гладко. У нас имеется довольно много проблем с производительностью, особенно из-за наличия как на зло необходимых операций с DOM. Наш сценарий можно реализовать более эффективно при помощи одного из вспомогательных интерфейсов дерева DOM. Обратите внимание, что метод <code class="inline">findAllNodes</code> возвращает массив со всеми узлами, а не только с образцами <code class="inline">Element </code>поддерева. Если мы заинтересованы в этом, то можем просто воспользоваться вызовом <code class="inline">querySelectorAll("*")</code>, при помощи которого выполняется итерация.</p> <h2>Итерирование (* процесс повторяющегося выполнения последовательности операторов или команд) для узлов</h2> <p>Сразу же находим решение проблемы – использование интерфейса <code class="inline">NodeIterator</code>. <code class="inline">NodeIterator </code>осуществляет итерацию для узлов. Он почти идеально подходит под наши требования. Мы можем создать новый <code class="inline">NodeIterator </code>при помощи метода <code class="inline">createNodeIterator </code>объекта <code class="inline">document</code>. Метод принимает три ключевых параметра:</p> <ol><li>Корневой узел поддерева, для которого необходимо выполнить итерацию.</li> <li>Фильтры для указания узлов, которые необходимо выбрать / для которых необходимо выполнить итерацию.</li> <li>Объект с методом <code class="inline">acceptNode </code>для фильтрации элементов на основании пользовательских настроек.</li> </ol><p>В то время как первый аргумент - лишь простой узел DOM, в качестве остальных двух используются специальные константы. Например: если необходимо, чтобы были показаны все узлы, то мы должны передать <code class="inline">-1</code> в качестве фильтра. Альтернативный вариант – можем использовать <code class="inline">NodeFilter.SHOW_ALL</code>. Мы могли бы скомбинировать несколько фильтров различными способами. Например для показа всех узлов с комментариями и элементами можно использовать <code class="inline">NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_ELEMENT</code>.</p> <p>Третий аргумент – объект, который может выглядеть настолько просто, как показанный ниже фрагмент кода. Хотя кажется, что объект, оборачивающий функцию, лишний, его необходимо указывать таким образом. Некоторые браузера, например Mozilla Firefox, предоставляют нам возможность сокращать объект до единственной функции.</p> <pre class="brush: javascript noskimlinks noskimwords">var acceptAllNodes = {acceptNode: function (node) { return NodeFilter.FILTER_ACCEPT;}};</pre> <p>Здесь мы принимаем любой узел, переданный в функцию. Также у нас имеется возможность отклонить узел (и его дочерние элементы) при помощи опции <code class="inline">FILTER_REJECT</code>. Если мы просто хотим пропустить узел, однако по-прежнему заинтересованы в его дочерних элементах, то можем воспользоваться константой <code class="inline">FILTER_SKIP</code>.</p> <p>Реализовать наш предыдущий пример при помощи <code class="inline">NodeIterator </code>довольно просто. Мы создаем новый итератор (* управляющая структура, определяющая порядок выполнения некоторых повторяющихся действий, устройство или программа организации циклов) при помощи конструктора <code class="inline">document</code>. Затем мы используем метод <code class="inline">nextNode </code>для выполнения итерации для всех узлов.</p> <p>Давайте взглянем на преобразованный пример.</p> <pre class="brush: javascript noskimlinks noskimwords">function iterateNodeIterator (template, model) {var currentNode;var fragment = template.content.clone(true);var iterator = document.createNodeIterator(    fragment,    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,    acceptAllNodes,    false);while ((currentNode = iterator.nextNode()))changeNode(currentNode);return fragment;}</pre> <p>Поиск по DOM полностью скрыт от нас. Это очень выгодно. Мы лишь запрашиваем необходимые нам узлы, остальное выполняется наиболее эффективным способом в движке браузера. Однако, с другой стороны нам по-прежнему необходимо написать код для выполнения итерации для узлов с атрибутами.</p> <p>Хотя для отбора атрибутов используется константа <code class="inline">SHOW_ATTRIBUTE</code>, они не связаны с узлами для элементов как дочерние узлы. Вместо этого они располагаются в коллекции <code class="inline">NamedNodeMap</code>, поиск по которой при помощи <code class="inline">NodeIterator </code>не будет происходить. Мы можем выполнить итерацию для атрибутов элементов только в том случае, если мы начинаем итерацию с атрибута элемента, при этом ограничивая наш выбор только атрибутами элементов.</p> <p>В предыдущем примере также могло бы быть внесено изменение в предоставленный фильтр. Однако, это не соответствует устоявшейся практике, поскольку мы могли бы захотеть использовать итератор и для других целей. Поэтому итератор должен представлять из себя решение  только для считывания, при использовании которого не меняется дерево.</p> <p>Изменение дерева также не поддерживается должным образом при использовании <code class="inline">NodeIterator</code>. Итератор можно представить в виде курсора в документе, расположенного между двумя (предыдущим и последующим) узлами. Поэтому <code class="inline">NodeIterator </code>не указывает ни на какой узел.</p> <h2>Обход дерева</h2> <p>Мы хотим выполнить итерацию для узлов в поддереве. Другой вариант для решения нашей проблемы, который можем придумать, – использование <code class="inline">TreeWalker</code>. При этом мы обходим дерево, как следует из имени интерфейса. Мы указываем корневой узел и элементы, которые необходимо принимать во внимание при обходе, и затем начинается обработка. Интересно то, что <code class="inline">TreeWalker </code>имеет много общего с <code class="inline">NodeIterator</code>. Это не только уже нами увиденные общие свойства, но и использование <code class="inline">NodeFilter </code>для установления ограничений.</p> <p>В большинстве случаев <code class="inline">TreeWalker </code>в действительности является лучшим выбором, чем <code class="inline">NodeIterator</code>. API <code class="inline">NodeIterator </code>чрезвычайно громоздкий для тех возможностей, которые он предоставляет. У <code class="inline">TreeWalker </code>имеется еще больше методов и настроек, но, во всяком случае, они находят применение.</p> <p>Главное различие между <code class="inline">TreeWalker </code>и <code class="inline">NodeIterator</code> заключается в том, что при использовании первого узлы поддерева представляются в виде дерева, а не списка, как в случае с итератором. В то время как <code class="inline">NodeIterator </code>позволяет нам перемещаться вперед или назад, <code class="inline">TreeWalker </code>предоставляет нам также возможность перемещения к родительскому элементу узла, к одному из дочерних элементов или к узлу-брату (* вершина дерева, имеющая того же "родителя").</p> <pre class="brush: javascript noskimlinks noskimwords">function iterateTreeWalker (template, model) {var fragment = template.content.clone(true);var walker = document.createTreeWalker(    fragment,    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,    acceptAllNodes,    false);while (walker.nextNode())changeNode(treeWalker.currentNode);return fragment;}</pre> <p>В отличие от <code class="inline">NodeIterator </code>TreeWalker указывает прямиком на указанный узел дерева. При перемещении узла <code class="inline">TreeWalker </code>будет следовать соответственно. Что более важно, – то, что при удалении из дерева узла, на который указывает TreeWalker, мы фактически окажемся за пределами дерева документа. Если мы последуем совету, данному при реализации примера за счет <code class="inline">NodeIterator</code>, и не будем изменять дерево при обходе, то получим тот же результат.</p> <p>Также похоже, что <code class="inline">TreeWalker </code>почти идентичен <code class="inline">NodeIterator </code>при достижении наших целей. Имеются причины, по которым последний не мог бы привлечь к себе значительное внимание. Тем не менее, <code class="inline">TreeWalker</code> также не пользуется особой популярностью. Возможно, что область его применения слишком ограничена, поскольку отсутствует возможность обхода узлов с атрибутами, – особенно при наличии третьего варианта для выполнения итерации для дерева DOM.</p> <h2>Выбор диапазона</h2> <p>Наконец, имеется третья конструкция, которая может пригодиться при некоторых обстоятельствах. Если мы хотим выбрать диапазон значений в одномерном массиве, то можем запросто реализовать это при помощи всего лишь двух индексов: <code class="inline">i</code> – для начальной (левой) границы и <code class="inline">f</code> – для конечной (правой) границы,<code class="inline"> [i, f]</code>.</p> <p>Если мы заменим массив связным списком (* список (структура данных), элементы которого не обязательно расположены в памяти последовательно. Доступ к следующему элементу (list element , node) осуществляется с помощью указателя, хранящегося в предыдущем элементе списка. У последнего элемента указатель имеет специальное значение (null pointer), по которому определяется конец списка. Список может быть однонаправленным (one-way list, single-linked list) и двунаправленным (double-linked list), когда каждый его элемент содержит ссылки как на следующий, так и на предшествующий элементы. Индексом элемента списка является порядковый номер элемента в списке), то два индекса также можно будет заменить двумя конкретными элементами, <code class="inline">[n_i, n_f]</code>. Преимущество при использовании этого варианта заключается в скрытом механизме обновления. Если мы добавляем в диапазон элементы, нам не нужно обновлять его границы. Также при удалении левой границы из связного списка мы получаем диапазон, увеличившийся в левую сторону, типа <code class="inline">[0, n_f]</code>.</p> <p>Что ж, у нас рассматриваемая тут проблема не связана с одномерным массивом, а с древовидной структурой. Выбор диапазона K-арного дерева не так просто осуществить. Мы могли бы придумать свой собственный алгоритм, однако в дереве DOM имеются свои «подводные камни». Например у нас имеются текстовые узлы, которые, возможно, также необходимо добавить в диапазон. В дереве DOM нашего примера диапазон состоит из четырех свойств. У нас имеется стартовый узел, конечный узел и смещение для обоих.</p> <p>Также имеются хелперы, например метод <code class="inline">selectNode </code>или <code class="inline">selectNodeContents</code>, при помощи которых выполняются необходимые вызовы <code class="inline">setStart </code>и <code class="inline">setEnd</code>. К примеру вызов <code class="inline">selectNodeContents(node) </code>эквивалентен следующему фрагменту кода:</p> <pre class="brush: javascript noskimlinks noskimwords">range.setStart(node, 0);range.setEnd(node, node.childNodes.length);</pre> <p>Выбор диапазонов выполняется не только нами в коде. Это происходит и при визуальном выборе в браузере. Метод <code class="inline">getSelection()</code> объекта <code class="inline">window </code>возвращает объект <code class="inline">Selection</code>, который может быть запросто преобразован в <code class="inline">Range </code>при помощи вызова метода <code class="inline">getRangeAt(0)</code>. Если ничего не выбрано, то при вычислении предыдущего выражения возвращается ошибка.</p> <p>Давайте рассмотрим простой пример выбора диапазона, результат которого выглядит следующим образом:</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/uploads%2Fusers%2F659%2Fposts%2F24843%2Fimage-1442220196802.png" class="lazy07" alt="Осваиваем HTML5: обход дерева..." title="Осваиваем HTML5: обход дерева..." width="50" height="50"></figure><p>Здесь диапазон начинается в текстовом узле первого элемента списка и заканчивается в конце текстового узла элемента strong. На следующем изображении показан рассматриваемый диапазон с точки зрения исходного кода:</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/uploads%2Fusers%2F659%2Fposts%2F24843%2Fimage-1442220196789.png" class="lazy07" alt="Осваиваем HTML5: обход дерева..." title="Осваиваем HTML5: обход дерева..." width="50" height="50"></figure><p>Также интересно взглянуть на дерево DOM для рассматриваемого образца <code class="inline">Range</code>. Мы видим, что при помощи подобного диапазона можно выбрать все разнообразие узлов без их родительских элементов или узла-брата.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=500/uploads%2Fusers%2F659%2Fposts%2F24843%2Fimage-1442220196827.png" alt="Осваиваем HTML5: обход дерева..." title="Осваиваем HTML5: обход дерева..." width="50" height="50"></figure><p>В результате извлечения выбранных узлов получаем <code class="inline">DocumentFragment</code>, который начинается с первого элемента списка и заканчивается после элемента strong.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=500/uploads%2Fusers%2F659%2Fposts%2F24843%2Fimage-1442220196815.png" alt="Осваиваем HTML5: обход дерева..." title="Осваиваем HTML5: обход дерева..." width="50" height="50"></figure><p>Извлечение – собственно внесение изменений в DOM, то есть при нем будет модифицировано существующее дерево. После манипуляций у нас остались следующие два элемента, точно так, как и ожидалось.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/uploads%2Fusers%2F659%2Fposts%2F24843%2Fimage-1442220196777.png" class="lazy07" alt="Осваиваем HTML5: обход дерева..." title="Осваиваем HTML5: обход дерева..." width="50" height="50"></figure><p>Поскольку в тексте могут содержаться элементы со всем их содержимым, то диапазон должен подходить и для этих случаев. На первый взгляд может показаться, что <code class="inline">Range</code> сконструирован странным образом, поскольку он должен уметь справляться как минимум с двумя вариантами узлов: текстовыми и нетекстовыми (большинство элементов). Однако, как мы видели, имеются веские основания для различения этих двух вариантов, поскольку в ином случае мы бы не смогли выбрать фрагменты текста.</p> <p>Объекту <code class="inline">Range </code>недостает возможности итерации, с которой мы ознакомились ранее. Вместо этого у него имеются усовершенствованные возможности сериализации (* преобразование параллельных данных в последовательные, например для передачи по последовательному каналу) и экспорта. Поэтому измененный код нашего ранее реализованного примера поначалу может показаться громоздким. Тем не менее, за счет добавления нескольких новых методов мы можем объединить гибкость <code class="inline">Range </code>с улучшенной итерацией.</p> <pre class="brush: javascript noskimlinks noskimwords">Range.prototype.current = function () {if (this.started)return this.startContainer.childNodes[this.startOffset];};Range.prototype.next = function (types) {var s = this.startContainer;var o = this.startOffset;var n = this.current();if (n) {if (n.childNodes.length) {s = n;o = 0;} else if (o + 1 &lt; s.childNodes.length) {o += 1;} else {do {n = s.parentNode;if (s == this.endContainer)return false;o = Array.prototype.indexOf.call(n.childNodes, s) + 1;s = n;} while (o === s.childNodes.length);}this.setStart(s, o);n = this.current();} else if (!this.started) {this.started = true;n = this.current();}if (n &amp;&amp; types &amp;&amp; Array.isArray(types) &amp;&amp; types.indexOf(n.nodeType) &lt; 0)return this.next();return !!n;};</pre> <p>Эти два метода позволяют нам пользоваться <code class="inline">Range </code>так же, как пользовались итератором ранее. Прямо сейчас мы можем лишь перемещаться в одном направлении; однако, мы могли бы запросто реализовать методы для пропуска дочерних элементов, перехода прямо к родительскому элементу или выполнения какого-либо еще перехода.</p> <pre class="brush: javascript noskimlinks noskimwords">function iterateRange (template, model) {var fragment = template.content.clone(true);var range = document.createRange();    range.selectNodeContents(fragment);while (range.nextNode([Node.TEXT_NODE, Node.ELEMENT_NODE]))changeNode(range.current());range.detach();return fragment;}</pre> <p>Несмотря на то что <code class="inline">Range </code>подвергается «сборке мусора» (* выполняемая во время исполнения программы операция удаления ненужных данных и переупорядочения (объединения в более крупные) блоков динамически распределяемой памяти, необходимой для дальнейшей работы. Эта операция может выполняться средствами , интерпретатора, приложения, аппаратуры - возможно, в разных их сочетаниях. Обычно запускается, когда объём свободной памяти становится меньше заранее определённого. Освобождённая память возвращается в пул свободной (доступной для распределения) памяти. Впервые сборка мусора была введена в Lisp в начале 1960-х годов), как и любой другой объект JavaScript, по-прежнему избавление от него при помощи функции <code class="inline">detach</code> считается устоявшейся практикой. Одна из причин – то, что все образцы <code class="inline">Range </code>в действительности сохраняются в <code class="inline">document</code>, где они обновляются при манипуляциях с DOM.</p> <p>Определение наших собственных методов для <code class="inline">Range </code>– удачная идея. Смещения автоматически обновляются, и у нас имеются дополнительные возможности, например клонирования текущего выбранного ряда элементов в качестве <code class="inline">DocumentFragment</code>, извлечения или удаления выбранных узлов. Также мы можем создать API для наших собственных нужд.</p> <h2>Заключение</h2> <p>Выполнение итерации для дерева DOM – интересная тема для всех, кто интересуется манипулированием DOM и эффективным получением узлов. Для большинства возможных сценариев уже имеется соответствующий API. Нам нужно просто выполнить итерацию? Мы хотим выбрать диапазон узлов? Нас интересует обход дерева? У каждого метода имеются свои недостатки и преимущества. Если мы знаем, что нам необходимо, то можем сделать правильный выбор.</p> <p>К сожалению, древовидные структуры не так просты, как одномерные массивы. Их можно превратить (* построить соответствие) в одномерные массивы, однако при этом учитываются те же алгоритмы, что и при выполнении итерации для их структуры. Если мы пользуемся одной из предоставленных нам структур, то получаем доступ к уже готовым методам, которые работают в соответствии с этими алгоритмами. Поэтому мы получаем удобный способ выполнения итерации для узлов в K-арном дереве. Также мы несколько улучшаем производительность за счет выполнения меньшего количества операций с DOM.</p> <h2>Ссылки</h2> <ul><li><span>MDN NodeIterator</span></li> <li><span>MDN TreeWalker</span></li> <li><span>MDN Range</span></li> <li><span>John Resig on the NodeIterator</span></li> <li><span>PPK"s Introduction to Range</span></li> </ul>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825306-osvaivaem-html5-obhod-dereva" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="HTML5" href="https://norma-studio.github.io/article5/220825306-osvaivaem-html5-obhod-dereva" class="tm-article-body__tags-item-link">HTML5</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
34496</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
390</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

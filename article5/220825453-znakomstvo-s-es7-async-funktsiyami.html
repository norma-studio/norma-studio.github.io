
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Знакомство с ES7 Async функциями... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Знакомство с ES7 Async функциями... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Знакомство с ES7 Async функциями... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Знакомство с ES7 Async функциями... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="В случае если вам довелось следить за событиями в мире JavaScript, вероятно вы знакомы с промисами (promises). Есть множество отличных туториалов онлайн, если есть необходимость узнать больше о промисах, я не буду объяснять их здесь, данная статья предполагает, что у вас есть рабочий опыт применения промисов. ...">
<meta property="og:description" content="В случае если вам довелось следить за событиями в мире JavaScript, вероятно вы знакомы с промисами (promises). Есть множество отличных туториалов онлайн, если есть необходимость узнать больше о промисах, я не буду объяснять их здесь, данная статья предполагает, что у вас есть рабочий опыт применения промисов. ...">
<meta name="twitter:description" content="В случае если вам довелось следить за событиями в мире JavaScript, вероятно вы знакомы с промисами (promises). Есть множество отличных туториалов онлайн, если есть необходимость узнать больше о промисах, я не буду объяснять их здесь, данная статья предполагает, что у вас есть рабочий опыт применения промисов. ...">
<meta property="aiturec:description" content="В случае если вам довелось следить за событиями в мире JavaScript, вероятно вы знакомы с промисами (promises). Есть множество отличных туториалов онлайн, если есть необходимость узнать больше о промисах, я не буду объяснять их здесь, данная статья предполагает, что у вас есть рабочий опыт применения промисов. ...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/418/profiles/2222/profileImage/DSC02496-400x.jpg">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/418/profiles/2222/profileImage/DSC02496-400x.jpg">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/418/profiles/2222/profileImage/DSC02496-400x.jpg">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/418/profiles/2222/profileImage/DSC02496-400x.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/418/profiles/2222/profileImage/DSC02496-400x.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825453-znakomstvo-s-es7-async-funktsiyami.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825453-znakomstvo-s-es7-async-funktsiyami.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825453-znakomstvo-s-es7-async-funktsiyami.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825453-znakomstvo-s-es7-async-funktsiyami.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825453-znakomstvo-s-es7-async-funktsiyami.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825453-znakomstvo-s-es7-async-funktsiyami.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825453-znakomstvo-s-es7-async-funktsiyami.html" title="Знакомство с ES7 Async функциями... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Знакомство с ES7 Async функциями... | envatomarket.ru | norma-studio.github.io" title="Знакомство с ES7 Async функциями... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/45343254534.jpg" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825453-znakomstvo-s-es7-async-funktsiyami.html" class="tm-user-info__username" title="
С. Баранов" aria-label="
С. Баранов">
С. Баранов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Знакомство с ES7 Async функциями...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825453-znakomstvo-s-es7-async-funktsiyami" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="JavaScript" href="https://norma-studio.github.io/article5/220825453-znakomstvo-s-es7-async-funktsiyami" class="tm-article-snippet__hubs-item-link"><span>JavaScript</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825453-znakomstvo-s-es7-async-funktsiyami.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/418/profiles/2222/profileImage/DSC02496-400x.jpg">
    <meta itemprop="headline name" content="Знакомство с ES7 Async функциями... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="В случае если вам довелось следить за событиями в мире JavaScript, вероятно вы знакомы с промисами (promises). Есть множество отличных туториалов онлайн, если есть необходимость узнать больше о промисах, я не буду объяснять их здесь, данная статья предполагает, что у вас есть рабочий опыт применения промисов. ...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">В случае если вам довелось следить за событиями в мире JavaScript, вероятно вы знакомы с промисами (promises). Есть множество отличных туториалов онлайн, если есть необходимость узнать больше о промисах, я не буду объяснять их здесь, данная статья предполагает, что у вас есть рабочий опыт применения промисов. ...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>В случае если вам довелось следить за событиями в мире JavaScript, вероятно вы знакомы с промисами (promises). Есть множество отличных туториалов онлайн, если есть необходимость <span>узнать больше о промисах</span>, я не буду объяснять их здесь, данная статья предполагает, что у вас есть рабочий опыт применения промисов. </p><p>Промисы преподносятся, как будущее асинхронного программирования в JavaScript. Промисы на самом деле замечательное нововведение, они помогают решить множество проблем, которые возникают во время написания кода для асинхронных программ, но это лишь отчасти правильно. В действительности промисы, являются некой <em>базой, фундаментом</em>, на котором будет выстраиваться будущее асинхронного программирования в JavaScript. В идеале, мы даже не будем замечать промисы, они будут оставаться за кулисами и мы сможем писать асинхронный код, точно также как код для программ работающих синхронно.</p><p>В ECMAScript7, это будет не просто мечта: всё это станет для нас реальностью, и я хочу познакомить вас с реальность - с функций async, прямо сейчас. Зачем мы об этом говорим? На данный момент ES6 даже не полностью утверждён, кто знает, сколько ещё придётся ждать, прежде чем мы увидим ES7. Правда в том, что уже сейчас можно использовать данную технологию и в конце этого поста я расскажу вам как.</p><h2>Нынешнее положение дел</h2><p>До того как я начну демонстрировать, как использовать функции async, я хочу показать несколько примеров с промисами (используя промисы ES6). Позже, я разберу данные примеры с использованием функций aysnc, чтобы вы могли понять разницу.</p><h3>Примеры</h3><p>Для первого примера, мы сделаем что-нибудь простое: вызовем асинхронную функцию, создадим лог возвращаемых значений.<br></p><pre class="brush: javascript noskimlinks noskimwords">function getValues() {    return Promise.resolve([1,2,3,4]);}getValues().then(function(values) {    console.log(values);});</pre><p>Теперь когда мы взглянули на простой пример, давайте займёмся чем-нибудь более сложным. Я буду использовать и модифицировать примеры из поста на моём личном блога, там можно найти описание некоторых <span>паттернов связанных с использованием промисов</span>, в различных ситуациях. Каждый из примеров асинхронно обрабатывает массив значений, выполняет асинхронные действия, которые изменяют каждое значение в массиве, логирует новые значения, и наконец возвращает массив с новыми значениями.<br></p><p>Сначала мы посмотрим на пример, параллельно запускающий множество асинхронных действий, после незамедлительно реагирует на них, после того, как каждая из них завершается, в не зависимости от порядка окончания работы функций. Функция <code class="inline">getValues</code> - точно такая же как в предыдущем примере.  Функция <code class="inline">asyncOperation</code>, также будет использована в примерах, которые мы рассмотрим позднее.</p><pre class="brush: javascript noskimlinks noskimwords">function asyncOperation(value) {    return Promise.resolve(value + 1);}function foo() {    return getValues().then(function(values) {        var operations = values.map(function(value) {            return asyncOperation(value).then(function(newValue) {                console.log(newValue);                return newValue;            });        });         return Promise.all(operations);    }).catch(function(err) {        console.log("We had an ", err);    });}</pre><p>Можно сделать тоже самое, но стоит убедиться, что логирование идёт в таком же порядке, в каком находятся элементы в массиве. Другими словами, следующий пример выполнит асинхронную работу параллельно, однако все синхронные операции будут последовательными:</p><pre class="brush: javascript noskimlinks noskimwords">function foo() {    return getValues().then(function(values) {        var operations = values.map(asyncOperation);               return Promise.all(operations).then(function(newValues) {            newValues.forEach(function(newValue) {                console.log(newValue);            });             return newValues;        });    }).catch(function(err) {        console.log("We had an ", err);    });}</pre><p>В последнем примере можно увидеть паттерн, где мы ждём завершения предыдущем асинхронной операции, перед там как начнём следующую. Ничего не запускается параллельно в данном примере, всё происходит последовательно.</p><pre class="brush: javascript noskimlinks noskimwords">function foo() {    var newValues = [];    return getValues().then(function(values) {        return values.reduce(function(previousOperation, value) {            return previousOperation.then(function() {                return asyncOperation(value);            }).then(function(newValue) {                console.log(newValue);                newValues.push(newValue);            });        }, Promise.resolve()).then(function() {        return newValues;        });    }).catch(function(err) {        console.log("We had an ", err);    });}</pre><p>Даже промисы не помогают уменьшить количество вложенных вызовов. Запуская неизвестное количество последовательных асинхронных вызовов, в итоге приведёт к беспорядку, что бы мы не делали. Особенно это можно увидеть, взглянув на огромное количество вложенных <code class="inline">return</code>. Если передать массив <code class="inline">newValues</code> промисам в коллбеке (callback) <code class="inline">reduce</code>, вместо того, чтобы делать его глобальным для всей функции <code class="inline">foo</code>, придётся переписать код, таким образом, что в нём будет ещё больше return, выглядит это так:</p><pre class="brush: javascript noskimlinks noskimwords">function foo() {    return getValues().then(function(values) {        return values.reduce(function(previousOperation, value) {            return previousOperation.then(function(newValues) {                return asyncOperation(value).then(function(newValue) {                    console.log(newValue);                    newValues.push(newValue);                    return newValues;                });            });        }, Promise.resolve([]));    }).catch(function(err) {        console.log("We had an ", err);    });}</pre><p>Не кажется ли вам, что следует это исправить? Давайте разберём решение данной проблемы.<br></p><h2>Функция Async приходит на помощь<br></h2><p>Даже имея под рукой промисы, асинхронное программирование не становится таким простым занятием, как хотелось бы. Синхронное программирование гораздо проще, код выглядит более понятным и его привычно читать. <span>Спецификация функций Async</span>, пытается найти средство (используя <span>генераторы ES6</span> под капотом) для написания кода, который похож на синхронный.<br></p><h3>Как их использовать?</h3><p>Первое что следует сделать, так это добавить ключевое слов <code class="inline">async</code> перед функцией. Без ключевого слова, мы не сможем применять очень важное ключевое слово <code class="inline">await</code>, внутри этой функции, скоро я дам объяснение, касательно этого. </p><p>Ключевое слово <code class="inline">async</code> не только позволяет использовать <code class="inline">await</code>, помимо этого функцией будет возвращён объект <code class="inline">Promise</code>. Внутри асинхронной функции, каждый раз когда возвращается значение, функция <em>вернёт</em> <code class="inline">Promise</code>, который будет ассоциирован с этим значением. Также есть возможность вернуть ошибку, в этом случае возвращаемое значение будет представлять из себя объект ошибки. Вот простой пример:</p><pre class="brush: javascript noskimlinks noskimwords">async function foo() {    if( Math.round(Math.random()) )        return "Success!";    else        throw "Failure!";}// Is equivalent to...function foo() {    if( Math.round(Math.random()) )        return Promise.resolve("Success!");    else        return Promise.reject("Failure!");}</pre><p>Мы ещё даже не добрались до самого интересного и уже сделали наш код, более похожим на синхронный, так как нам удалось не взаимодействовать на прямую с объектом <code class="inline">Promise</code>. Можно взять любую функцию и она будет возвращать объект <code class="inline">Promise</code>, лишь добавив перед ней ключевое слово <code class="inline">async</code>. </p><p>Пойдём дальше, сконвертируем <code class="inline">getValues</code> и функцию <code class="inline">asyncOperation</code>:</p><pre class="brush: javascript noskimlinks noskimwords">async function getValues() {    return [1,2,3,4];}async function asyncOperation(value) {    return value + 1;}</pre><p>Очень просто! Теперь разберёмся с самым интересным: ключевым словом <code class="inline">await</code>. Внутри асинхронной функции, каждый раз, когда выполняются действия возвращающие промис, вы можете добавить ключевое слово <code class="inline">await</code>, перед ним, тем самым функция не будет выполняться до того момента, как возвращаемый промис будет обработан, либо отклонён. На этом этапе, <code class="inline">await promisingOperation()</code> будет возвращать объект промис, либо объект с ошибкой. К примеру:</p><pre class="brush: javascript noskimlinks noskimwords">function promisingOperation() {    return new Promise(function(resolve, reject) {        setTimeout(function() {            if( Math.round(Math.random()) )                resolve("Success!");            else                reject("Failure!");        }, 1000);    }}async function foo() {    var message = await promisingOperation();    console.log(message);}</pre><p>Когда мы вызываем <code class="inline">foo</code>, она будет ждать результата <code class="inline">promisingOperation</code>, после чего будет выведен "Success!-" или <code class="inline">promisingOperation</code> вернёт ошибку, в таком случае foo сообщит об этом "Failure!". Так как <code class="inline">foo</code> ничего не возвращает, в результате мы получим <code class="inline">undefined</code>, предполагая , что <code class="inline">promisingOperation</code> успешно завершилась. <br></p><p>Остаётся лишь один вопрос, как нам стоит поступать с ошибками? Ответ на этот вопрос очень прост: всё что нам нужно сделать, так это обернуть блок в <code class="inline">try...catch</code>. Если одна из асинхронных операций, будет возвращать ошибку, мы можем обработать её с помощью <code class="inline">catch</code>:</p><pre class="brush: javascript noskimlinks noskimwords">async function foo() {    try {        var message = await promisingOperation();        console.log(message);    } catch (e) {        console.log("We failed:", e);    }}</pre><p>Теперь когда мы разобрались с основами, давайте вернёмся к предыдущему примеру и добавим функциями async.<br></p><h3>Примеры<br></h3><p>Первый пример выше создал <code class="inline">getValues</code> и мы его используем. Мы уже пересоздали <code class="inline">getValues</code>, поэтому остаётся лишь переписать код, чтобы можно было его применять. Есть одна оговорка, касательно async функций, которую мы можем наблюдать здесь: код <em>должен</em> находиться внутри функции. Предыдущий пример был реализован в глобальной области видимости (вы наверно уже это заметили), но нам следует обернуть код async в async функцию, чтобы он работал:</p><pre class="brush: javascript noskimlinks noskimwords">async function() {    console.log(await getValues());}(); // The extra "()" runs the function immediately</pre><p>Даже после того как мы обернули код в функцию, я всё  ещё утверждаю, что читается это гораздо понятнее и занимает меньше места (если убрать комментарий). Наш следующий пример, если вы помните, делает всё параллельно. Ситуация здесь не совсем очевидная, так как у нас есть внутренняя функция, которая должна вернуть промис. Если мы используем ключевое слово <code class="inline">await</code>, во внутренней функции, перед ней также должен идти <code class="inline">async</code>.</p><pre class="brush: javascript noskimlinks noskimwords">async function foo() {    try {    var values = await getValues();        var newValues = values.map(async function(value) {            var newValue = await asyncOperation(value);            console.log(newValue);            return newValue;        });               return await* newValues;    } catch (err) {        console.log("We had an ", err);    }}</pre><p>Вероятно вы заметили звёздочку перед последним ключевым словом <code class="inline">await</code>. По поводу этого ещё идут некоторые споры, тем не менее кажется, что <code class="inline">await*</code> в итоге автоматически будет оборачивать выражение в <code class="inline">Promise.all</code>. Однако на данный момент, инструмент, который мы разберём немного позже, не поддерживает <code class="inline">await*</code>, тем самым следует сконвертировать данный синтаксис в <code class="inline">Promise.all(newValues);</code> это видно в следующем примере.<br></p><p>В следующем примере <code class="inline">asyncOperation</code> вызываются параллельно, но в конечном итоге мы реорганизуем данный код и действия будут выполняться в последовательности.</p><pre class="brush: javascript noskimlinks noskimwords">async function foo() {    try {    var values = await getValues();        var newValues = await Promise.all(values.map(asyncOperation));        newValues.forEach(function(value) {            console.log(value);        });        return newValues;    } catch (err) {        console.log("We had an ", err);    }}</pre><p>Мне это правда нравится. Код выглядит чисто. Если убрать ключевые слова <code class="inline">await</code> и <code class="inline">async</code>, убрать обёртку <code class="inline">Promise.all</code>, затем сделать <code class="inline">getValues</code> и <code class="inline">asyncOperation</code> синхронными, скрипт будет работать точно также, только всё будет синхронно. Такого результат в конце концов мы и пытаемся добиться.<br></p><p>Последний пример, само собой, в нём всё будет работать синхронно. Не будет выполнено каких-либо асинхронных операций, до момента, пока следующая не завершиться.</p><pre class="brush: javascript noskimlinks noskimwords">async function foo() {    try {    var values = await getValues();        return await values.reduce(async function(values, value) {            values = await values;            value = await asyncOperation(value);            console.log(value);            values.push(value);            return values;        }, []);    } catch (err) {        console.log("We had an ", err);    }}</pre><p>Опять же, мы делаем внутреннюю <code class="inline">async</code> функцию. В данном коде встречается интересная странность. Я передал <code class="inline">reduce</code> - <code class="inline">[]</code>, в который будут записываться значения, однако затем использовал <code class="inline">await</code>. Значение справа от <code class="inline">await</code>, не обязательно должно быть промисом. Функция может принимать любые значения, в том случае если это не промис, функция не будет дожидаться, а запустится асинхронно. Тем не менее, после первого запуска коллбека, нам предстоит работать с промисом.<br></p><p>Данный пример выглядит схоже с первым примером, за исключением того, что мы используем <code class="inline">reduce</code> вместо <code class="inline">map</code>, таким образом мы можем дождаться <code class="inline">await</code> предыдущей операции, после чего, так как мы используем <code class="inline">reduce</code> для формирования массива (не совсем обычное явление, особенно если создаём массив такого же размера, как и оригинальный), нам необходимо создать массив внутри коллбека для <code class="inline">reduce</code>.<br></p><h2>Асинхронные функции сегодня<br></h2><p>Теперь, когда вам довелось взглянуть на простоту и эффективность asycn функций, возможно вам захотелось заплакать, такое же чувство первый раз посетило меня, когда я их увидел. Я не плакал от радости (может быть и плакал); нет, я плакал по причине, что ES7 не появится до тех пор пока я жив! По крайней мере, так я себя <em>чувствовал</em>. Потом я узнал о <span>Traceur</span>. <br></p><p>Traceur написан и поддерживается Google. Это транспайлер, который конвертирует код ES6 в ES5. Но это не поможет! Возможно, тем не менее, они также реализовали <span>поддержку async функций</span>. По сей день это является экспериментальной особенностью, это значит, что вам нужно явно сообщить компилятору, что данная особенность понадобится и вы будете её использовать, и что вы подробно протестируете код, убедившись, что с компиляцией не будет проблем.<br></p><p>Используя компилятор на подобии Traceur означает - клиенту придётся отправить немного громоздкий, некрасивый код, чего бы совсем не хотелось, но если прибегнуть к помощи source maps, вы сможете избежать большинства недостатков связанных с разработкой. Вы будете читать, писать и отлаживать чистый ES6/7 код, вместо чтения, отладки и написания беспорядочного кода, который пытается обойти ограничения языка. </p><p>Конечно, размер кода в любом случае будет больше, по сравнению с написанным от руки ES5 кодом (скорее всего), поэтому нужно найти некий баланс между хорошо поддерживаемым кодом и производительным кодом, но это тот самый баланс, который приходится искать, даже не работая с транспайлером.<br></p><h3>Используя Traceur<br></h3><p>Traceur - утлита для командной строки, которую можно установить с помощью NPM:</p><pre class="brush: bash noskimlinks noskimwords">npm install -g traceur</pre><p>В основном, Traceur довольно прост в использовании, но некоторые опции, могут запутать и потребуют некоторых экспериментов. Ознакомьтесь со <span>списком опций</span>. Больше всего нас интересует опция <code class="inline">--experimental</code>.<br></p><p>Эту опцию нужно использовать для включения экспериментальных особенностей, которые понадобятся для работы функций async. Как только у вас будет под рукой JavaScript файл (<code class="inline">main.js</code> в моём случае), содержащий код ES6 с async функциями, можно его скомпилировать следующим образом:</p><pre class="brush: bash noskimlinks noskimwords">traceur main.js --experimental --out compiled.js</pre><p>Также можно запустить код без <code class="inline">--out compiled.js</code>. Много вы не увидите, пока в коде нет <code class="inline">console.log</code> (или других опций для вывода в консоль), но по крайней мере, можно отладить ошибки. В любом случае скорее всего вы хотите запустить код в браузере. Если это ваш случай, придётся сделать ещё несколько дополнительных шагов.<br></p><ol><li>Скачайте скрипт <code class="inline">traceur-runtime.js</code>. Есть множество способов сделать это, самый простой с помощью NPM: <code class="inline">npm install traceur-runtime</code>. После чего файл будет доступен, как <code class="inline">index.js</code> в каталоге модулей.</li> <li>В вашем HTML файле, добавьте элемент <code class="inline">script</code>, который будет содержать исполняемый скрипт Traceur.</li> <li>Под скриптом Traceur, добавьте другой элемент <code class="inline">script</code>, содержащий <code class="inline">compiled.js</code>.<br></li> </ol><p>После этого код должен работать!<br></p><h3>Автоматизация компиляции Traceur<br></h3><p>Помимо применения Traceur в качестве инструмента командной строки, можно автоматизировать компиляцию, таким образом не придётся каждый раз возвращаться в консоль для повторного запуска компилятора. <span>Grunt</span> и <span>Gulp</span>, которые являются инструментами для автоматизации подобных задач, каждый из них имеет свои плагины, есть возможность всегда ими воспользоваться, они помогут в автоматизации компиляции Traceur: <span>grunt-traceur</span> и <span>gulp-traceur</span>.<br></p><p>Каждый из этих инструментов автоматизации может быть настроен таким образом - он будет отслеживать изменения в файлах и каждый раз компилировать код, как только будут сохранены изменения в JavaScript файлах. Ознакомиться с тем как использовать Grunt или Gulp, можно изучив документацию.<br></p><h2>Заключение</h2><p>Функции async из ES7 предоставляют разработчикам <em>способ</em> избавится от мешанины с коллбеками, так как не могут этого сделать промисы. Эта новая особенность позволяет писать асинхронный код, так что он будет максимально похож на синхронный, и даже не смотря на тот факт, что ES6 ещё не полностью доступен, мы уже можем воспользоваться функциями async, благодаря транспайлерам. Так чего же вы ждёте? Не упускайте возможность улучшить качество своего кода!</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825453-znakomstvo-s-es7-async-funktsiyami" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="JavaScript" href="https://norma-studio.github.io/article5/220825453-znakomstvo-s-es7-async-funktsiyami" class="tm-article-body__tags-item-link">JavaScript</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
37427</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
612</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>


<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Расширенная SDK для Android SDK: настройка камеры и датчика... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Расширенная SDK для Android SDK: настройка камеры и датчика... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Расширенная SDK для Android SDK: настройка камеры и датчика... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Расширенная SDK для Android SDK: настройка камеры и датчика... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Сегодня расширенная реальность (AR) является горячей темой в мобильных приложениях. Смартфоны и планшеты имеют мощь и аппаратное обеспечение, которое позволяет разработчикам создавать интересные интересные приложения, которые интересны для использования живых камер и видеопотоков, гиперточных данных датчиков и других пользовательских данных в реаль...">
<meta property="og:description" content="Сегодня расширенная реальность (AR) является горячей темой в мобильных приложениях. Смартфоны и планшеты имеют мощь и аппаратное обеспечение, которое позволяет разработчикам создавать интересные интересные приложения, которые интересны для использования живых камер и видеопотоков, гиперточных данных датчиков и других пользовательских данных в реаль...">
<meta name="twitter:description" content="Сегодня расширенная реальность (AR) является горячей темой в мобильных приложениях. Смартфоны и планшеты имеют мощь и аппаратное обеспечение, которое позволяет разработчикам создавать интересные интересные приложения, которые интересны для использования живых камер и видеопотоков, гиперточных данных датчиков и других пользовательских данных в реаль...">
<meta property="aiturec:description" content="Сегодня расширенная реальность (AR) является горячей темой в мобильных приложениях. Смартфоны и планшеты имеют мощь и аппаратное обеспечение, которое позволяет разработчикам создавать интересные интересные приложения, которые интересны для использования живых камер и видеопотоков, гиперточных данных датчиков и других пользовательских данных в реаль...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=841/legacy-premium-tutorials/posts/7403/images/7403_c1ac0306b7a783bec24c477eda431d6d.png">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=841/legacy-premium-tutorials/posts/7403/images/7403_c1ac0306b7a783bec24c477eda431d6d.png">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=841/legacy-premium-tutorials/posts/7403/images/7403_c1ac0306b7a783bec24c477eda431d6d.png">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=841/legacy-premium-tutorials/posts/7403/images/7403_c1ac0306b7a783bec24c477eda431d6d.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=841/legacy-premium-tutorials/posts/7403/images/7403_c1ac0306b7a783bec24c477eda431d6d.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825673-rasshirennaya-sdk-dlya-android-sdk-nastrojka-kamery-i-datchika.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825673-rasshirennaya-sdk-dlya-android-sdk-nastrojka-kamery-i-datchika.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825673-rasshirennaya-sdk-dlya-android-sdk-nastrojka-kamery-i-datchika.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825673-rasshirennaya-sdk-dlya-android-sdk-nastrojka-kamery-i-datchika.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825673-rasshirennaya-sdk-dlya-android-sdk-nastrojka-kamery-i-datchika.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825673-rasshirennaya-sdk-dlya-android-sdk-nastrojka-kamery-i-datchika.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825673-rasshirennaya-sdk-dlya-android-sdk-nastrojka-kamery-i-datchika.html" title="Расширенная SDK для Android SDK: настройка камеры и датчика... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Расширенная SDK для Android SDK: настройка камеры и датчика... | envatomarket.ru | norma-studio.github.io" title="Расширенная SDK для Android SDK: настройка камеры и датчика... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/64533jfgfsfxcv.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825673-rasshirennaya-sdk-dlya-android-sdk-nastrojka-kamery-i-datchika.html" class="tm-user-info__username" title="
О. Гуськов" aria-label="
О. Гуськов">
О. Гуськов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Расширенная SDK для Android SDK: настройка камеры и датчика...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825673-rasshirennaya-sdk-dlya-android-sdk-nastrojka-kamery-i-datchika" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Android SDK" href="https://norma-studio.github.io/article5/220825673-rasshirennaya-sdk-dlya-android-sdk-nastrojka-kamery-i-datchika" class="tm-article-snippet__hubs-item-link"><span>Android SDK</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825673-rasshirennaya-sdk-dlya-android-sdk-nastrojka-kamery-i-datchika.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=841/legacy-premium-tutorials/posts/7403/images/7403_c1ac0306b7a783bec24c477eda431d6d.png">
    <meta itemprop="headline name" content="Расширенная SDK для Android SDK: настройка камеры и датчика... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Сегодня расширенная реальность (AR) является горячей темой в мобильных приложениях. Смартфоны и планшеты имеют мощь и аппаратное обеспечение, которое позволяет разработчикам создавать интересные интересные приложения, которые интересны для использования живых камер и видеопотоков, гиперточных данных датчиков и других пользовательских данных в реаль...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Сегодня расширенная реальность (AR) является горячей темой в мобильных приложениях. Смартфоны и планшеты имеют мощь и аппаратное обеспечение, которое позволяет разработчикам создавать интересные интересные приложения, которые интересны для использования живых камер и видеопотоков, гиперточных данных датчиков и других пользовательских данных в реаль...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Сегодня расширенная реальность (AR) является горячей темой в мобильных приложениях. Смартфоны и планшеты имеют мощь и аппаратное обеспечение, которое позволяет разработчикам создавать интересные интересные приложения, которые интересны для использования живых камер и видеопотоков, гиперточных данных датчиков и других пользовательских данных в реальном времени.<!--more--> Сегодня мы начнем изучать мир дополненной реальности и то, что платформа Android может предложить разработчикам, которые хотят создавать AR-приложения и предоставлять своим пользователям глубокий и богатый опыт.</p> <hr><h3>Также доступны в этой серии:</h3> <ol><li>Расширенная SDK для Android SDK: настройка камеры и датчика</li> <li><span>Android SDK Augmented Reality: Местоположение и расстояние</span></li> </ol><hr><h2> <span>Шаг 0</span>: предварительные условия и начало работы</h2> <p> Этот урок движется довольно быстро. Таким образом, мы ожидаем, что читатели будут знать все основы создания и запуска проектов Android. Мы также ожидаем, что у читателей появится Android-устройство, достаточно мощное для запуска приложений AR (таких как Nexus S). Большинство тестов этого приложения необходимо будет сделать на реальном устройстве Android, так как приложение в значительной степени зависит от камеры, датчиков и данных местоположения, которые недоступны в эмуляторе.</p> <p>Мы предоставили пример приложения в сочетании с этим учебным пособием для загрузки. Этот проект будет усилен в ходе серии премиальных AR-обучающих программ, поэтому загрузите проект Android и следуйте за ним! </p> <hr><h2> <span>Часть 1</span>: Какое AR-приложение мы разрабатываем?</h2> <p> <br> Во-первых, нам нужно определить (в широком смысле), что будет делать это приложение. Мы хотим придерживаться типичных особенностей приложения AR и улучшать его с течением времени.</p> <p>Итак, какое приложение мы будем строить? Мы собираемся создать AR-приложение на основе местоположения. Эти типы приложений AR обычно показывают, где вещи находятся в реальном мире, указывая, где приложение считает, что они находятся над просмотром камеры, когда пользователь держит телефон и перемещает его.</p> <p>Другим типом приложения AR является тип, который распознает объект, используя алгоритмы компьютерного зрения, и может либо нарисовать информацию по камере, чтобы показать, что такое объект, как он ориентирован, либо, возможно, добавить или показать другие объекты в представлении. Хотя мы не будем создавать такое AR-приложение, многие из методов, которые мы преподаем здесь, могут применяться к любому типу приложения AR.</p> <p>Основная архитектура приложения на основе местоположения включает в себя представление камеры, местоположение пользователя, ориентацию телефона по сравнению с реальным миром и список мест для элементов, которые мы хотим показать на дисплее, - данные, с которыми мы увеличиваем видение камеры мира.</p> <figure><br><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=841/legacy-premium-tutorials/posts/7403/images/7403_c1ac0306b7a783bec24c477eda431d6d.png" alt="Расширенная SDK для Android SDK: настройка камеры и датчика..." title="Расширенная SDK для Android SDK: настройка камеры и датчика..." width="50" height="50"><br></figure><p>Эта первая часть нашей серии расскажет о камере и датчиках. В следующей части мы поговорим о данных о местоположении и математике, участвующих в создании приложения.</p> <hr><h2> <span>Требования к приложениям</span>: какие функции устройства Требуется ли наше приложение?</h2> <p>Для вашего типичного приложения AR требуется доступ к следующим функциям устройства:</p> <ul><li>Доступ к просмотру камеры</li> <li>Доступ к местоположению пользователя</li> <li>Доступ к другим датчикам устройства, особенно компас (акселерометр и гироскоп также могут быть полезны)</li> </ul><p>Приложению также могут потребоваться другие службы и разрешения, такие как доступ к сети, но они не являются центральными для AR-аспектов приложения.</p> <hr><h2> <span>Примечание по целевым устройствам</span>: Nexus S</h2> <p> <br> Не все устройства Android (или мобильные устройства в целом) имеют аппаратные спецификации для обработки требований AR-приложений. Для целей данного руководства мы ориентируемся на Nexus S, работающий под управлением Android 2.3.4, который удовлетворяет нашим специфическим требованиям к оборудованию. Поэтому наше приложение будет нацелено на очень специфическую версию Android SDK. Это упростит приложение. Однако требования SDK могут быть более гибкими, если манифест Android правильно идентифицирует любые требуемые аппаратные функции или вы реализуете альтернативные функции для менее мощных устройств.</p> <p>Хотя Nexus S более чем способен выполнять разумные задачи AR, многие другие устройства также способны, включая некоторые более старые устройства. Если вы создаете производственное приложение, использующее технологию AR, вы должны тщательно протестировать на своих целевых устройствах ответ, удобство и правильную функциональность.</p> <hr><h2> <span>Часть 2</span>: Настройка проекта</h2> <p> <br> Теперь мы готовы начать разработку! Сначала создадим проект AR. Это приложение настроено так же, как и любой другой проект приложения в Eclipse.</p> <hr><h2> <span>Шаг 1:</span> Создайте новый проект Eclipse</h2> <p> <br> Начните с создания нового проекта Android в Eclipse. Вот подробности проекта, которые мы использовали для образца проекта (доступны для загрузки):</p> <ul><li>Название проекта: ARTUT</li> <li>Уровень API мин/цель: 10</li> <li>Запуск действия класса: ArtutActivity</li> </ul><hr><h2> <span>Шаг 2:</span> Настройка файла манифеста</h2> <p> <br> Затем вы хотите настроить файл манифеста Android. Вы должны указать следующие настройки:</p> <p>На вкладке Манифест добавьте <uses-feature> настройки для следующего:</uses-feature></p> <ul><li>android.hardware.camera (обязательно = true)</li> <li>android.hardware.camera.autofocus (обязательно = false) </li> <li>android.hardware.location.gps (обязательно = true)</li> <li>android.hardware.sensor.compass (Required = true)</li> <li>android.hardware.sensor.gyroscope (обязательно = true)</li> <li>android.hardware.sensor.accelerometer (Required = true)</li> </ul><p>На вкладке Приложение:</p> <ul><li>Отладка должна быть установлена ​​в true</li> </ul><p>На вкладке разрешения добавить <uses-permission> настройки для:</uses-permission></p> <ul><li> android.permission.CAMERA</li> <li> android.permission.FINE_LOCATION</li> </ul><hr><h2> <span>Шаг 3:</span> Подключите целевое устройство</h2> <p> <br> Наконец, если вы еще этого не сделали, вам нужно настроить Android-устройство для тестирования и подключить его к компьютеру разработки через USB. Если вы этого еще не сделали, вам может потребоваться загрузить и установить драйверы перед использованием.</p> <p>Нет смысла создавать виртуальное устройство Android (AVD) для использования с этим проектом, так как эмулятор не имеет достаточных возможностей для тестирования приложений с живыми камерами или сенсорами с любой степенью эффективности. Мы сделаем все наши разработки и тестирование против реального оборудования. Помимо обеспечения лучшей тестовой среды при использовании датчиков, камеры и другого оборудования, мы также обнаруживаем, что тестирование на реальном оборудовании происходит намного быстрее из-за ограничений производительности и возможностей эмулятора.</p> <hr><h2> <span>Часть 2:</span> Работа с камерой</h2> <p> <br> Наш первый реальный шаг в разработке AR-приложения включает в себя получение содержимого камеры, отображаемого на экране. Мы делаем это, реализуя пользовательский SurfaceView, который отображается в макете действия.</p> <hr><h2> <span>Шаг 1:</span> Определение макета экрана App</h2> <p> <br> Во-первых, нам нужно определить ресурс макета, который будет использоваться для основного экрана AR. FrameLayout наиболее подходит для нашего экрана, так как позволяет расслоение видов в области отображения. Поэтому наш ресурс компоновки, /res/layout/main.xml, может быть довольно простым:</p> <pre class="brush: xml noskimlinks noskimwords"> &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;FrameLayout xmlns:android="https://schemas.android.com/apk/res/android"     android:id="@+id/ar_view_pane"       android:layout_width="fill_parent"     android:layout_height="fill_parent"&gt; &lt;/FrameLayout&gt;</pre> <hr><h2> <span>Шаг 2:</span> Определение пользовательского SurfaceView для хранения содержимого камеры.</h2> <p> <br> Затем вам нужно определить пользовательский элемент управления представлением для использования в вашем FrameLayout. Для этой цели можно использовать класс SurfaceView. Поэтому вы можете использовать этот класс для инкапсуляции рисунка вашей камеры.</p> <pre class="brush: java noskimlinks noskimwords"> public class ArDisplayView extends SurfaceView  {     public static final String DEBUG_TAG = "ArDisplayView Log";     Camera mCamera;     SurfaceHolder mHolder;     Activity mActivity;          public ArDisplayView(Context context, Activity activity) {          super(context);          mActivity = activity;         mHolder = getHolder();         mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);          mHolder.addCallback(this);       }</pre> <p>ArDisplayView класса начинается с конструктором. Мы добавили Activity как параметр конфигурации (подробнее об этом на следующем шаге). Конструктор должен инициализировать основной SurfaceHolder, который управляет рисунком на экране.</p> <p>(Обратите внимание, что хотя метод setType () устарел, и в документации Android SDK говорится, что он больше не нужен, мы обнаружили, что код камеры не будет функционировать без него, он просто не запускается, даже на самом новом устройства.)</p> <p>Мы добавили соответствующие переменные-члены для работы с камерой, и мы также поддерживаем активность, чтобы мы могли реагировать на изменения ориентации и любой другой удобный доступ к Контексту или Деятельности, которые могут нам понадобиться.</p> <hr><h2> <span>Шаг 3:</span> Реализация обратных вызовов SurfaceHolder</h2> <p> <br> Затем вам нужно будет реализовать обратные вызовы SurfaceHolder внутри класса. Обновите класс ArDisplayView, чтобы он реализовал интерфейс SurfaceHolder.Callback, например:</p> <pre class="brush: java noskimlinks noskimwords"> public class ArDisplayView extends SurfaceView implements SurfaceHolder.Callback {     //… }</pre> <p>Это потребует переопределения и реализации трех новых методов: surfaceCreated (), surfaceChanged () и surfaceDestroyed ().</p> <p>При работе с камерой предусмотрен ряд шагов, необходимых для запуска и выключения. Эти шаги четко описаны в документах <span>Android SDK для класса Camera</span>. Мы в основном отбрасываем эти шаги в соответствующие обратные вызовы SurfaceHolder.</p> <hr><h2> <span>Шаг 4:</span> Реализация обратного вызова surfaceCreated ()</h2> <p> <br> Начнем с метода обратного вызова surfaceCreated(). Здесь мы запрашиваем камеру, устанавливаем ориентацию дисплея камеры на основе текущей ориентации устройства (чтобы предварительный просмотр камеры всегда отображался справа вверх) и вызывал метод setPreviewDisplay (), чтобы связать предварительный просмотр камеры с нашим SurfaceHolder.</p> <pre class="brush: java noskimlinks noskimwords"> public void surfaceCreated(SurfaceHolder holder) {            mCamera = Camera.open();             CameraInfo info = new CameraInfo();         Camera.getCameraInfo(CameraInfo.CAMERA_FACING_BACK, info);              int rotation = mActivity.getWindowManager().getDefaultDisplay().getRotation();      int degrees = 0;        switch (rotation) {             case Surface.ROTATION_0: degrees = 0; break;                case Surface.ROTATION_90: degrees = 90; break;              case Surface.ROTATION_180: degrees = 180; break;               case Surface.ROTATION_270: degrees = 270; break;        }         cam.setDisplayOrientation((info.orientation - degrees + 360) % 360);             try {        mCamera.setPreviewDisplay(mHolder);    } catch (IOException e) {       Log.e(DEBUG_TAG, "surfaceCreated exception: ", e);        }   }</pre> <hr><h2> <span>Шаг 5:</span> Внедрение обратного вызова surfaceChanged()</h2> <p> <br> Большая часть интересного кода для предварительного просмотра камеры происходит в обратном вызове surfaceChanged (). Здесь мы запрашиваем параметры камеры и проверяем, какие поддерживаемые размеры предварительного просмотра. Нам нужно найти размер предварительного просмотра, который может быть размещен на поверхности, поэтому мы ищем ближайшее совпадение и используем его как наш размер предварительного просмотра. Затем мы устанавливаем формат предварительного просмотра камеры, фиксируем изменения параметров камеры и, наконец, вызываем метод startPreview (), чтобы начать отображение предварительного просмотра камеры на нашей поверхности.</p> <pre class="brush: java noskimlinks noskimwords"> public void surfaceChanged(SurfaceHolder holder, int format, int width, int height)  {            Camera.Parameters params = mCamera.getParameters();         List&lt;Size&gt; prevSizes = params.getSupportedPreviewSizes();    for (Size s : prevSizes)    {       if((s.height &lt;= height) &amp;&amp; (s.width &lt;= width))       {          params.setPreviewSize(s.width, s.height);          break;       }     }                mCamera.setParameters(params);    mCamera.startPreview(); }</pre> <hr><h2> <span>Шаг 6:</span> Внедрение обратного вызова surfaceDestroyed ()</h2> <p> <br> Мы заканчиваем методом обратного вызова surfaceDestroyed(). Здесь мы закрываем предварительный просмотр камеры и освобождаем ресурсы камеры.</p> <pre class="brush: java noskimlinks noskimwords"> public void surfaceDestroyed(SurfaceHolder holder) {        cam.stopPreview();    cam.release();   }</pre> <hr><h2> <span>Шаг 7:</span> Пользовательский просмотр камеры и основная активность</h2> <p>Теперь вам нужно добавить свои пользовательские представления в элемент управления FrameLayout. Для этого обновите метод onCreate() класса ArtutActivity, например:</p> <pre class="brush: java noskimlinks noskimwords"> public void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.main);             FrameLayout arViewPane = (FrameLayout) findViewById(R.id.ar_view_pane);             ArDisplayView arDisplay = new ArDisplayView(this);    arViewPane.addView(arDisplay); }</pre> <p>Это добавляет класс просмотра предварительного просмотра камеры, называемый ArDisplayView в FrameLayout. Если вы запустите приложение сейчас, действие запустится, и вы увидите предварительный просмотр камеры на экране.</p> <p>Заметка о цифрах: Захват экрана DDMS по умолчанию не фиксирует предварительный просмотр камеры. Запустите приложение самостоятельно, чтобы увидеть настоящую функциональность.</p> <hr><h2> <span>Часть 3:</span> Работа с датчиками устройства</h2> <p> <br> Наш следующий шаг в разработке приложения AR включает в себя доступ к данным датчика устройства. Нам также нужен способ наложения содержимого поверх предварительного просмотра камеры. Мы делаем это, реализуя настраиваемое представление, которое можно сложить поверх ArDisplayView, отображаемого в данный момент в элементе управления FrameLayout.</p> <hr><h2> <span>Шаг 1:</span> Отображение содержимого Overlay</h2> <p> <br> Во-первых, вам нужно определить настраиваемый элемент управления представлением для наложения содержимого наложения. Создайте новый класс OverlayView, который является производным от класса View. Этот класс начинается просто для этой части учебника. Мы просто хотим наложить некоторые данные датчиков сверху камеры (пока еще нет фантазии). Для этого мы создаем переменные-члены для хранения последних известных данных датчика для каждого интересующего нас датчика. Затем мы реализуем метод onDraw () нашего представления и наносим некоторый текст на холст.</p> <pre class="brush: java noskimlinks noskimwords">  public class OverlayView extends View {      public static final String DEBUG_TAG = "OverlayView Log";     String accelData = "Accelerometer Data";     String compassData = "Compass Data";     String gyroData = "Gyro Data";          public OverlayView(Context context) {         super(context);         }          @Override     protected void onDraw(Canvas canvas) {         super.onDraw(canvas);                     Paint contentPaint = new Paint(Paint.ANTI_ALIAS_FLAG);         contentPaint.setTextAlign(Align.CENTER);         contentPaint.setTextSize(20);         contentPaint.setColor(Color.RED);         canvas.drawText(accelData, canvas.getWidth()/2, canvas.getHeight()/4, contentPaint);         canvas.drawText(compassData, canvas.getWidth()/2, canvas.getHeight()/2, contentPaint);         canvas.drawText(gyroData, canvas.getWidth()/2, (canvas.getHeight()*3)/4, contentPaint);     } }</pre> <p>Метод onDraw() выполняет всю работу здесь. Мы настраиваем Paint с соответствующими текстовыми атрибутами, а затем рисуем текст на холсте с помощью метода drawText().</p> <p>Зачем использовать пользовательский вид вместо обычных элементов управления? В дальнейшем нам понадобится точность для размещения объектов AR в пределах камеры, которые являются репрезентативными для местоположений мест реального мира. Альтернативой этому методу является использование 3D-рендеринга для лучшего получения дескриптора глубины и расстояния. В AR-приложении местоположения это обычно менее важно, поскольку расстояния часто довольно обширны (километров, а не метров).</p> <hr><h2> <span>Шаг 2:</span> Реализация обратных вызовов SurfaceHolder</h2> <p> <br> Затем вам необходимо реализовать интерфейс SensorEventListener в классе. Обновите класс OverlayView, чтобы он реализовал интерфейс SensorEventListener, например:</p> <pre class="brush: java noskimlinks noskimwords"> public class OverlayView extends View implements SensorEventListener {</pre> <p>Это потребует переопределения и реализации двух новых методов: onAccuracyChanged() и onSensorChanged(). Для целей этого урока нас действительно интересует только метод onSensorChanged().</p> <hr><h2> <span>Шаг 3:</span> Регистрация для обновлений данных датчиков</h2> <p> <br> Прежде чем внедрять обратные вызовы SensorEventListener, мы хотим зарегистрироваться для соответствующих обновлений данных датчиков. Для этого обновите метод onCreate () класса OverlayView.</p> <p>Начните с запроса SensorManager и получения датчиков, которые вы хотите просмотреть. В этом случае мы будем смотреть акселерометр, компас и гироскоп. Затем зарегистрируйтесь для прослушивания событий на каждом из этих датчиков.</p> <pre class="brush: java noskimlinks noskimwords">         SensorManager sensors = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);         Sensor accelSensor = sensors.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);         Sensor compassSensor = sensors.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);         Sensor gyroSensor = sensors.getDefaultSensor(Sensor.TYPE_GYROSCOPE);          boolean isAccelAvailable = sensors.registerListener(this, accelSensor, SensorManager.SENSOR_DELAY_NORMAL);         boolean isCompassAvailable = sensors.registerListener(this, compassSensor, SensorManager.SENSOR_DELAY_NORMAL);               boolean isGyroAvailable = sensors.registerListener(this, gyroSensor, SensorManager.SENSOR_DELAY_NORMAL);</pre> <p>Теперь вы готовы реализовать обратный вызов датчика onSensorChanged (), чтобы реагировать на эти обновления датчиков.</p> <hr><h2> <span>Шаг 4:</span> Внедрение обратного вызова onSensorChanged()</h2> <p> <br> Большая часть интересного кода для обновлений датчиков происходит в обратном вызове onSensorChanged(). Здесь нам нужно, чтобы представление реагировало на изменения датчика. Мы зарегистрировались для нескольких различных типов изменений, поэтому этот метод можно вызвать для любого изменения сенсора. На данный момент мы просто хотим сэкономить данные датчика, которые изменились, а затем заставить просмотр обновить его содержимое. Мы можем сделать это, просто аннулируем представление и заставляя его перерисовывать.</p> <pre class="brush: java noskimlinks noskimwords"> public void onSensorChanged(SensorEvent event) {            StringBuilder msg = new StringBuilder(event.sensor.getName()).append(" ");    for(float value: event.values)    {       msg.append("[").append(value).append("]");    }             switch(event.sensor.getType())    {       case Sensor.TYPE_ACCELEROMETER:          accelData = msg.toString();          break;       case Sensor.TYPE_GYROSCOPE:          gyroData = msg.toString();          break;       case Sensor.TYPE_MAGNETIC_FIELD:          compassData = msg.toString();          break;                  }             this.invalidate();     }</pre> <hr><h2> <span>Шаг 5:</span> Пользовательский накладной и основная деятельность</h2> <p> <br> Теперь вам нужно добавить свой пользовательский вид в элемент управления FrameLayout. Для этого обновите метод onCreate() класса ArtutActivity. Добавьте следующий код чуть ниже вызова addView (), который добавляет ArDisplayView:</p> <pre class="brush: java noskimlinks noskimwords"> OverlayView arContent = new OverlayView(getApplicationContext()); arViewPane.addView(arContent);</pre> <p>Это складывает два вида: сначала класс просмотра предварительного просмотра камеры, называемый ArDisplayView, а затем накладывает OverlayView, который отображает данные датчика поверх него. Если вы запустите приложение сейчас, действие запустится, и вы увидите предварительный просмотр камеры на экране с данными датчиков, отображаемыми поверх него (помните, что вы не можете делать снимки экрана камеры, поэтому на следующем рисунке показано только содержимое наложения) ,</p> <figure><br><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=800/legacy-premium-tutorials/posts/7403/images/7403_96ffd1bec1e0a3bfc71d11e60b1d0a30.png" alt="Расширенная SDK для Android SDK: настройка камеры и датчика..." title="Расширенная SDK для Android SDK: настройка камеры и датчика..." width="50" height="50"><br></figure><p>Если вы используете приложение в данный момент, вы, вероятно, заметили, что данные датчиков обновляются очень быстро, несмотря на то, что они требуют достаточно медленной скорости, чтобы работать с изменениями ориентации. Эти датчики устройства имеют очень высокую степень чувствительности. В конечном итоге это приведет к шаткости в пользовательском интерфейсе. В конце концов, нам нужно будет реализовать некоторые алгоритмы сглаживания, чтобы удержать дрожи, когда мы начнем использовать данные датчиков в нашем приложении.</p> <p>Вам также может быть интересно, будем ли мы использовать все эти датчики и какие их устройства. Мы не обязательно будем использовать все датчики, но мы подумали, что мы покажем вам, как они выглядят, и как получить к ним доступ, если ваши конкретные интересы AR лежат на разных датчиках.</p> <ul><li>Числа акселерометра находятся в единицах СИ (м/с^2, т. е. В метрах в секунду, где гравитация Земли составляет 9,81 м/с^2). </li> <li>Магнитные датчики находятся в микро-Тесласе. Когда они входят в формы x, y и z, мы можем измерить вектор и сравнить с гравитацией, чтобы определить, где (магнитный) север по отношению к устройству.</li> <li>Гироскоп измеряет вращение вокруг каждой оси в радианах в секунду. Это также можно использовать для расчета относительной ориентации устройства. </li> </ul><hr><h2>Заключение</h2> <p> Это завершает первую часть нашего учебника AR. Расширенная реальность - захватывающий жанр для приложений на платформе Android. Android SDK предоставляет все необходимое для разработки гладких и интересных AR-приложений, но не все устройства могут удовлетворить требованиям к оборудованию, требуемым этими приложениями. К счастью, новейшее поколение Android-устройств является самым мощным, но многие из Android-устройств прекрасно способны работать с расширенными AR-приложениями.</p> <p>В следующей части этой серии мы перейдем к сбору данных о местоположении и размещению объектов AR на экране в определенном месте. Это будет включать в себя различные математические алгоритмы, но конечным результатом будет ... <i>увеличение</i>!</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825673-rasshirennaya-sdk-dlya-android-sdk-nastrojka-kamery-i-datchika" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Android SDK" href="https://norma-studio.github.io/article5/220825673-rasshirennaya-sdk-dlya-android-sdk-nastrojka-kamery-i-datchika" class="tm-article-body__tags-item-link">Android SDK</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
35215</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
657</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

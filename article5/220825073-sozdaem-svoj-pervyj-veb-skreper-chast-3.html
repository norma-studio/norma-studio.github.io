
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Создаем свой первый-веб-скрэпер, часть 3... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Создаем свой первый-веб-скрэпер, часть 3... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Создаем свой первый-веб-скрэпер, часть 3... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Создаем свой первый-веб-скрэпер, часть 3... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="С возвращением в серию статей по созданию веб-скрэпера. В этом уроке я рассмотрю пример сбора данных с моего подкаст-сайта. Я расскажу подробно о том, как извлекать данные, как вспомогательные и утилитные методы выполняют свою работу, и как все кусочки головоломки собираются вместе....">
<meta property="og:description" content="С возвращением в серию статей по созданию веб-скрэпера. В этом уроке я рассмотрю пример сбора данных с моего подкаст-сайта. Я расскажу подробно о том, как извлекать данные, как вспомогательные и утилитные методы выполняют свою работу, и как все кусочки головоломки собираются вместе....">
<meta name="twitter:description" content="С возвращением в серию статей по созданию веб-скрэпера. В этом уроке я рассмотрю пример сбора данных с моего подкаст-сайта. Я расскажу подробно о том, как извлекать данные, как вспомогательные и утилитные методы выполняют свою работу, и как все кусочки головоломки собираются вместе....">
<meta property="aiturec:description" content="С возвращением в серию статей по созданию веб-скрэпера. В этом уроке я рассмотрю пример сбора данных с моего подкаст-сайта. Я расскажу подробно о том, как извлекать данные, как вспомогательные и утилитные методы выполняют свою работу, и как все кусочки головоломки собираются вместе....">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/851/posts/27599/image/between-screens-old-01.png">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/851/posts/27599/image/between-screens-old-01.png">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/851/posts/27599/image/between-screens-old-01.png">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/851/posts/27599/image/between-screens-old-01.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/851/posts/27599/image/between-screens-old-01.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825073-sozdaem-svoj-pervyj-veb-skreper-chast-3.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825073-sozdaem-svoj-pervyj-veb-skreper-chast-3.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825073-sozdaem-svoj-pervyj-veb-skreper-chast-3.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825073-sozdaem-svoj-pervyj-veb-skreper-chast-3.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825073-sozdaem-svoj-pervyj-veb-skreper-chast-3.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825073-sozdaem-svoj-pervyj-veb-skreper-chast-3.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825073-sozdaem-svoj-pervyj-veb-skreper-chast-3.html" title="Создаем свой первый-веб-скрэпер, часть 3... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Создаем свой первый-веб-скрэпер, часть 3... | envatomarket.ru | norma-studio.github.io" title="Создаем свой первый-веб-скрэпер, часть 3... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/654345654.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825073-sozdaem-svoj-pervyj-veb-skreper-chast-3.html" class="tm-user-info__username" title="
А. Кузнецов" aria-label="
А. Кузнецов">
А. Кузнецов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Создаем свой первый-веб-скрэпер, часть 3...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825073-sozdaem-svoj-pervyj-veb-skreper-chast-3" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Ruby" href="https://norma-studio.github.io/article5/220825073-sozdaem-svoj-pervyj-veb-skreper-chast-3" class="tm-article-snippet__hubs-item-link"><span>Ruby</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825073-sozdaem-svoj-pervyj-veb-skreper-chast-3.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/851/posts/27599/image/between-screens-old-01.png">
    <meta itemprop="headline name" content="Создаем свой первый-веб-скрэпер, часть 3... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="С возвращением в серию статей по созданию веб-скрэпера. В этом уроке я рассмотрю пример сбора данных с моего подкаст-сайта. Я расскажу подробно о том, как извлекать данные, как вспомогательные и утилитные методы выполняют свою работу, и как все кусочки головоломки собираются вместе....">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">С возвращением в серию статей по созданию веб-скрэпера. В этом уроке я рассмотрю пример сбора данных с моего подкаст-сайта. Я расскажу подробно о том, как извлекать данные, как вспомогательные и утилитные методы выполняют свою работу, и как все кусочки головоломки собираются вместе....</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>С возвращением в серию статей по созданию веб-скрэпера. В этом уроке я рассмотрю пример сбора данных с моего подкаст-сайта. Я расскажу подробно о том, как извлекать данные, как вспомогательные и утилитные методы выполняют свою работу, и как все кусочки головоломки собираются вместе.<br></p><h2>Темы<br></h2><ul><li>Экстракция моего подкаста</li> <li>Pry</li> <li>Скрэпер</li> <li>Вспомогательные методы</li> <li>Пишем статьи</li> </ul><h2>Экстракция моего подкаста<br></h2><p>Теперь давайте попробуем на практике все что мы изучили. По некоторым причинам давно пора сменить дизайн моего сайта подкастов <span>Between | Screens</span>. Там было столько проблем, что я по утрам просыпался в холодном поту. Поэтому я решил создать новый статический сайт, построенный на Middleman, и разместить его GitHub Pages.</p><p>После настройки блога на Middleman под свои нужды, я потратил массу времени на новый дизайн. Все, что оставалось сделать, это импортировать содержимое базы данных из приложения на <span>Sinatra</span>, поэтому мне нужно было выбрать содержимое и перенести его на мой новый статический вебсайт.</p><p>Речи не шло о том, чтобы делать эту нудную работу вручную - без вариантов - так как я мог рассчитывать, что мои друзья Nokogiri и Mechanize сделают работу за меня. Что нас ждет впереди - это достаточно небольшая работа по экстракции данных, не слишком сложная, но предлагающая несколько интересных моментов, которые будут интересны новичкам скрэпинга.</p><p>Ниже вы найдете два скриншота с моего сайта. <br></p><h3>Скриншот старого сайта</h3><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/851/posts/27599/image/between-screens-old-01.png" alt="Создаем свой первый веб-скрэпер, часть 3..." title="Создаем свой первый веб-скрэпер, часть 3..." width="50" height="50"></figure><h3>Скриншот нового сайта</h3><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=850/uploads/users/851/posts/27599/image/between-screens-new-01.png" alt="Создаем свой первый веб-скрэпер, часть 3..." title="Создаем свой первый веб-скрэпер, часть 3..." width="50" height="50"></figure><p>Давайте разберем шаг за шагом, чего мы хотим достигнуть. Мы хотим извлечь следующие данные из 139 серии, которые размещены на  21 странице:</p><ul><li>заголовок</li> <li>собеседник</li> <li>подзаголовок со списком тем</li> <li>номер трека каждого эпизода на SoundCloud</li> <li>дата</li> <li>номер эпизода</li> <li>текст записок эпизода</li> <li>ссылки из записок эпизода</li> </ul><p>Мы будем переходить по страницам, а Mechanize будет кликать каждую ссылку эпизода. На следующей странице мы найдем всю необходимую нам информацию. Используя полученные данные, мы добавим их во <span>frontmatter (переменные конкретной страницы)</span> и body файлов разметки каждого эпизода.<br></p><p>Ниже вы можете найти предварительный вид файла разметки с добавленным содержанием эпизодов. Думаю, это дает преставление о том, что нас ждет впереди. Это последний шаг нашего небольшого скрипта. Не переживайте, мы рассмотрим его в деталях. </p><h3>def compose_markdown</h3><pre class="brush: ruby noskimlinks noskimwords">def compose_markdown(options={})&lt;&lt;-HEREDOC--- title: #{options[:interviewee]}interviewee: #{options[:interviewee]}topic_list: #{options[:title]}tags: #{options[:tags]}soundcloud_id: #{options[:sc_id]}date: #{options[:date]}episode_number: #{options[:episode_number]}---#{options[:text]}HEREDOCend</pre><p>Я также хотел бы добавить несколько трюков. Наличие индивидуальной, комплексной системы тэгов, было для меня крайне важным. Мне хотелось, чтобы у моих пользователей были широкие возможности. Поэтому мне нужны были как тэги для каждого собеседника, так и тэги для подзаголовков. Поскольку только в первом сезоне я создал 139 эпизодов, я должен был подготовить сайт для тех времен, когда количество контента вырастет до трудноразбираемых пределов. Так что развернутая система тэгов с грамотно подобранными рекомендациями, это то, что мне нужно. Это позволило мне создать облегченный и быстрый сайт.<br></p><p>Давайте взглянем на полный код экстракции содержимого вебсайта. Попробуйте вычислить общую картину происходящего. Поскольку я ожидаю, что читатели будут новичками в веб-скрэпинге, то я постарался держаться подальше от сложных абстракций, и придерживался полной ясности кода. Я сделал пару доработок, чтобы добавить ясности коду, а также оставил несколько заковырок, чтобы вам было с чем поэкспериментировать, после окончания работы с данным уроком. В конце концов, настоящее обучение начинается тогда, когда вы заканчиваете читать и начинаете эксперементировать с кодом.<br></p><p>Попутно, я настоятельно рекомендую вам начать думать о том, как улучшить данный код. Это будет вашим финальным заданием по окончании этой статьи. Небольшая подсказка: всегда проще разбить большие методы на более маленькие. Как только вы поймете, как работает код, вы сможете улучшать мои доработки в вводить свои. </p><p>Я уже начал добавлять некоторые методы в небольшие вспомогательные методы. Если вы читали мои предыдущие статьи <span>о коде с "запашком" и его рефакторинге</span>, вам легко будет применить, излагаемые там принципы, на практике. Но, не переживайте, если у вас до сих пор голова идет кругом, - мы все там были. Продолжайте изучать, и в какой-то момент все станет намного яснее.</p><h3>Полный код</h3><pre class="brush: ruby noskimlinks noskimwords">require "Mechanize"require "Pry"require "date"# Helper Methods# (Extraction Methods)def extract_interviewee(detail_page)  interviewee_selector = ".episode_sub_title span"  detail_page.search(interviewee_selector).text.stripenddef extract_title(detail_page)  title_selector = ".episode_title"  detail_page.search(title_selector).text.gsub(/[?#]/, "")enddef extract_soundcloud_id(detail_page)  sc = detail_page.iframes_with(href: /soundcloud.com/).to_s  sc.scan(/\d{3,}/).firstenddef extract_shownotes_text(detail_page)  shownote_selector = "#shownote_container &gt; p"  detail_page.search(shownote_selector)enddef extract_subtitle(detail_page)  subheader_selector = ".episode_sub_title"  detail_page.search(subheader_selector).textenddef extract_episode_number(episode_subtitle)  number = /[#]\d*/.match(episode_subtitle)  clean_episode_number(number)end# (Utility Methods)def clean_date(episode_subtitle)  string_date = /[^|]*([,])(.....)/.match(episode_subtitle).to_s  Date.parse(string_date)enddef build_tags(title, interviewee)  extracted_tags = strip_pipes(title)  "#{interviewee}"+ ", #{extracted_tags}"enddef strip_pipes(text)  tags = text.tr("|", ",")  tags = tags.gsub(/[@?#&amp;]/, "")  tags.gsub(/[w\/]{2}/, "with")enddef clean_episode_number(number)  number.to_s.tr("#", "")enddef dasherize(text)  text.lstrip.rstrip.tr(" ", "-")enddef extract_data(detail_page)  interviewee = extract_interviewee(detail_page)  title = extract_title(detail_page)  sc_id = extract_soundcloud_id(detail_page)  text = extract_shownotes_text(detail_page)  episode_subtitle = extract_subtitle(detail_page)  episode_number = extract_episode_number(episode_subtitle)  date = clean_date(episode_subtitle)  tags = build_tags(title, interviewee)  options = {    interviewee:    interviewee,    title:          title,    sc_id:          sc_id,    text:           text,    tags:           tags,    date:           date,    episode_number: episode_number  }enddef compose_markdown(options={})&lt;&lt;-HEREDOC--- title: #{options[:interviewee]}interviewee: #{options[:interviewee]}topic_list: #{options[:title]}tags: #{options[:tags]}soundcloud_id: #{options[:sc_id]}date: #{options[:date]}episode_number: #{options[:episode_number]}---#{options[:text]}HEREDOCenddef write_page(link)  detail_page = link.click  extracted_data = extract_data(detail_page)  markdown_text = compose_markdown(extracted_data)  date = extracted_data[:date]  interviewee = extracted_data[:interviewee]  episode_number = extracted_data[:episode_number]  File.open("#{date}-#{dasherize(interviewee)}-#{episode_number}.html.erb.md", "w") { |file| file.write(markdown_text) }enddef scrape  link_range = 1  agent ||= Mechanize.new  until link_range == 21    page = agent.get("https://between-screens.herokuapp.com/?page=#{link_range}")    link_range += 1    page.links[2..8].map do |link|      write_page(link)    end  endendscrape</pre><p>Зачем нам следующий код: <code class="inline">require "Nokogiri"</code>? Ведь Mechanize обеспечивает нас всеми необходимым для скрэпинга. Как мы рассказывали в предыдущей статье, Mechanize основывается на Nokogiri, что позволяет нам выбирать содержимое страниц. Но нам необходимо было описать этот пакет в первой статье, так вся наша последующая работа строиться на нем.</p><h2>Pry</h2><p>Первым делом о главном. Перед тем как перейти к коду, мне хотелось бы показать вам, как можно эффективно проверить, что ваш код работает как нужно на протяжении всего исполнения. Как вы могли заметить, я добавил еще один инструмент. Среди прочего, <code class="inline">Pry</code> очень полезен при отладке. </p><p>Если вы добавите код <code class="inline">Pry.start(binding)</code> в любой части кода, вы можете проинспектировать ваш код в том, месте где вы добавили данную строку. Вы можете добавлять pry в определенные части приложения. Pry помогает проводить отладку приложения шаг за шагом. Для примера, давайте добавим pry сразу после функции <code class="inline">write_page</code>, и посмотри действительно ли мы получаем <code class="inline">link</code>.<br></p><h3>Pry</h3><pre class="brush: ruby noskimlinks noskimwords">...def scrape  link_range = 1  agent ||= Mechanize.new  until link_range == 21    page = agent.get("https://between-screens.herokuapp.com/?page=#{link_range}")    link_range += 1    page.links[2..8].map do |link|      write_page(link)      Pry.start(binding)    end  endend...</pre><p>Если вы выполните этот скрипт, то получите что-то вроде этого.<br></p><h3>Результат</h3><pre class="brush: plain noskimlinks noskimwords">»$ ruby noko_scraper.rb    321: def scrape    322:     link_range = 1    323:     agent ||= Mechanize.new    324:     326:   until link_range == 21    327:     page = agent.get("https://between-screens.herokuapp.com/?page=#{link_range}")    328:     link_range += 1    329:     330:     page.links[2..8].map do |link|    331:       write_page(link) =&gt; 332:     Pry.start(binding)    333:     end    334:   end    335: end[1] pry(main)&gt;</pre><p>Запрашивая <code class="inline">link</code>, мы можем проверить, что мы на правильном пути, перед тем, как идти дальше.</p><h3>Терминал</h3><pre class="brush: bash noskimlinks noskimwords">[2] pry(main)&gt; link=&gt; #&lt;Mechanize::Page::Link "Masters @ Work | Subvisual | Deadlines | Design personality | Design problems | Team | Pushing envelopes | Delightful experiences | Perfecting details | Company values" "/episodes/139"&gt;</pre><p>Похоже то, что нам нужно. Отлично, можно продолжать дальше. Очень важно пройти шаг за шагом по всему приложению, это гарантирует, что вы не потеряетесь в коде и всегда будете знать как что работает. Я не буду здесь погружаться в детали Pry, так как это может занять целую статью. Могу только порекомендовать вам использовать Pry как альтернативу IRB shell (командной оболочке Ruby). Вернемся к нашему основному заданию.<br></p><h2>Скрэпер<br></h2><p>Теперь когда вы ознакомились со всеми кусочками головоломки, предлагаю пройтись по каждому из них, и разобрать некоторые интересные моменты. Давайте начнем с ключевых частей.<br></p><h3>podcast_scraper.rb</h3><pre class="brush: ruby noskimlinks noskimwords">...def write_page(link)  detail_page = link.click    extracted_data = extract_data(detail_page)  markdown_text = compose_markdown(extracted_data)  date = extracted_data[:date]  interviewee = extracted_data[:interviewee]  episode_number = extracted_data[:episode_number]  file_name = "#{date}-#{dasherize(interviewee)}-#{episode_number}.html.erb.md"   File.open(file_name, "w") { |file| file.write(markdown_text) }enddef scrape  link_range = 1  agent ||= Mechanize.new  until link_range == 21    page = agent.get("https://between-screens.herokuapp.com/?page=#{link_range}")    link_range += 1    page.links[2..8].map do |link|      write_page(link)    end  endend...</pre><p>Что происходит в методе <code class="inline">scrape</code>? Во-первых, я пройду по индексной странице старого подкаста. Я использую старую ссылку на приложение на Heroku, так как новый сайт уже расположен на <span>betweenscreens.fm</span>. Мне надо было пройти по 20 эпизодам. </p><p>Я разбил цикл по переменной <code class="inline">link_range</code>, и обновлял его на каждом повторе. А переход по страницам был очень прост, я всего лишь добавлял эту переменную в URL каждой страницы. Просто и эффективно<br></p><h3>Метод def scrape</h3><pre class="brush: ruby noskimlinks noskimwords">page = agent.get("https://between-screens.herokuapp.com/?page=#{link_range}")</pre><p>Затем, на каждой новой странице с 8 эпизодами, я использовал <code class="inline">page.links</code> для обозначения ссылок, на которые нужно кликать, чтобы перейти на страницу отдельного эпизода. Я решил использовать диапазон <code class="inline">links[2..8]</code>, так как он оставался неизменным. Это также самый простой способ определить необходимые ссылки с каждой страницы. Нет необходимости перебирать CSS-селекторы.<br></p><p>Затем мы передаем эту ссылку методу <code class="inline">write_page</code> для извлечения всей страницы. Большая часть работы делается здесь. Берем ссылку, кликаем на нее, и переходим на страницу с полной информацией, где мы можем начать экстракцию содержимого. На этой странице мы найдем всю информацию, которая нам понадобится для создания структуры эпизодов на моем новом сайте. <br></p><h3>метод def write_page</h3><pre class="brush: ruby noskimlinks noskimwords">extracted_data = extract_data(detail_page)</pre><h3>метод def extract_data</h3><pre class="brush: ruby noskimlinks noskimwords">def extract_data(detail_page)  interviewee = extract_interviewee(detail_page)  title = extract_title(detail_page)  sc_id = extract_soundcloud_id(detail_page)  text = extract_shownotes_text(detail_page)  episode_subtitle = extract_subtitle(detail_page)  episode_number = extract_episode_number(episode_subtitle)  date = clean_date(episode_subtitle)  tags = build_tags(title, interviewee)  options = {    interviewee:    interviewee,    title:          title,    sc_id:          sc_id,    text:           text,    tags:           tags,    date:           date,    episode_number: episode_number  }end</pre><p>Как вы можете видеть выше, мы берем параметр <code class="inline">detail_page</code>, и применяем к нему кучу методов извлечения. Мы извлекаем следующие параметры, <code class="inline">interviewee</code>, <code class="inline">title</code>, <code class="inline">sc_id</code>, <code class="inline">text</code>, <code class="inline">episode_title</code>, и <code class="inline">episode_number</code>. Я переделал много целевых вспомогательные методов, которые отвечают за функции извлечения. Давайте их рассмотрим:<br></p><h2>Вспомогательные методы <br></h2><h3>Методы экстракции<br></h3><p>Я отделил эти вспомогательные методы, так как они позволяют мне сократить общее количество всех методов. Инкапсуляция этих методов также полезна. И код намного проще читать. Большинство из них принимает <code class="inline">detail_page</code> как аргумент, и извлекают данные, необходимые для наших записей на сайте на Middleman.</p><pre class="brush: ruby noskimlinks noskimwords">def extract_interviewee(detail_page)  interviewee_selector = ".episode_sub_title span"  detail_page.search(interviewee_selector).text.stripend</pre><p>Мы ищем определенный селектор на странице и получаем текст без лишних пробелов.</p><pre class="brush: ruby noskimlinks noskimwords">def extract_title(detail_page)  title_selector = ".episode_title"  detail_page.search(title_selector).text.gsub(/[?#]/, "")end</pre><p>Удаляем из заголовка <code class="inline">?</code> и <code class="inline">#</code>, так как они не особо сочетаются с переменными front matter эпизодов. Больше о переменных front matter далее. </p><pre class="brush: ruby noskimlinks noskimwords">def extract_soundcloud_id(detail_page)  sc = detail_page.iframes_with(href: /soundcloud.com/).to_s  sc.scan(/\d{3,}/).firstend</pre><p>Здесь нам придется немного потрудиться, чтобы извлечь идентификаторы SoundCloud для всех треков. Сначала нам нужно получить iframe с атрибутом <code class="inline">href</code> для <code class="inline">soundcloud.com</code> и затем конвертировать его в строку для сканирования.</p><pre class="brush: bash noskimlinks noskimwords">"[#&lt;Mechanize::Page::Frame\n nil\n \"https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/221003494&amp;amp;auto_play=false&amp;amp;hide_related=false&amp;amp;show_comments=false&amp;amp;show_user=true&amp;amp;show_reposts=false&amp;amp;visual=true\"&gt;\n]"</pre><p>Затем сопоставить регулярные выражения с идентификаторами трека - <code class="inline">soundcloud_id</code> и <code class="inline">"221003494"</code>.</p><pre class="brush: ruby noskimlinks noskimwords">def extract_shownotes_text(detail_page)  shownote_selector = "#shownote_container &gt; p"  detail_page.search(shownote_selector)end</pre><p>Экстракция заметок шоу проходит довольно таки просто. Нам нужно только выбрать параграфы заметок из страниц с отдельными эпизодами. Здесь никаких сюрпризов. </p><pre class="brush: ruby noskimlinks noskimwords">def extract_subtitle(detail_page)  subheader_selector = ".episode_sub_title"  detail_page.search(subheader_selector).textend</pre><p>То же самое касается и субтитров, за исключением того, что это только подготовка к аккуратному извлечению нумерации эпизодов.</p><pre class="brush: ruby noskimlinks noskimwords">def extract_episode_number(episode_subtitle)  number = /[#]\d*/.match(episode_subtitle)  clean_episode_number(number)end</pre><p>Здесь нам понадобиться еще несколько регулярных выражений. Давайте посмотрим, что у нас есть до и после применения регулярных выражений.<br></p><h3>episode_subtitle</h3><pre class="brush: bash noskimlinks noskimwords">" João Ferreira  | 12  Minutes |  Aug 26, 2015 | Episode #139  "</pre><h4>number (номер эпизода)</h4><pre class="brush: bash noskimlinks noskimwords">"#139"</pre><p>Еще один шаг до получения номера.</p><pre class="brush: ruby noskimlinks noskimwords">def clean_episode_number(number)  number.to_s.tr("#", "")end</pre><p>Просто удалим знак нумерации (<code class="inline">#</code>). Вуаля, у нас есть первый номер эпизода - <code class="inline">139</code>. Предлагаю взглянуть на другие утилитные методы, прежде чем мы соберем все это вместе.<br></p><h3>Утилитные методы<br></h3><p>Нам нужно  будет кое что подчистить после экстракции. Мы уже можем начинать готовить данные к разметке. Например, я еще больше разбил <code class="inline">episode_subtitle</code>, чтобы получить дату и создать <code class="inline">tags</code> с помощью метода <code class="inline">build_tags</code>. <br></p><h3>метод def clean_date</h3><pre class="brush: ruby noskimlinks noskimwords">def clean_date(episode_subtitle)  string_date = /[^|]*([,])(.....)/.match(episode_subtitle).to_s  Date.parse(string_date)end</pre><p>Запустим еще одно регулярное выражение, чтобы выделить даты, которые выглядят вот так <code class="inline">" Aug 26, 2015"</code>. Как видите, пока не особенно практично. Из атрибута <code class="inline">string_date</code> субититров нам нужно создать объект <code class="inline">Date</code>. Иначе он будет бесполезен для создания записей Middleman.<br></p><h3>string_date</h3><pre class="brush: bash noskimlinks noskimwords">"  Aug 26, 2015"</pre><p>Таким образом берем строку и пропускаем ее через метод <code class="inline">Date.parse</code>. Результат выглядит намного более перспективным.<br></p><h3>Date (дата)</h3><pre class="brush: bash noskimlinks noskimwords">2015-08-26</pre><h3>метод def build_tags</h3><pre class="brush: ruby noskimlinks noskimwords">def build_tags(title, interviewee)  extracted_tags = strip_pipes(title)  "#{interviewee}"+ ", #{extracted_tags}"end</pre><p>Здесь метод принимает две переменные: <code class="inline">title</code> и <code class="inline">interviewee</code>, которые мы создали в методе <code class="inline">extract_data</code>, и удаляет все символы пайп (вертикальная черта). Мы заменим все символы пайп запятыми, а символы <code class="inline">@</code>, <code class="inline">?</code>, <code class="inline">#</code>  и <code class="inline">&amp;</code> пробелами; и, наконец, позаботимся о сокращениях для атрибута <code class="inline">with</code>.<br></p><h3>Метод def strip_pipes</h3><pre class="brush: ruby noskimlinks noskimwords">def strip_pipes(text)  tags = text.tr("|", ",")  tags = tags.gsub(/[@?#&amp;]/, "")  tags.gsub(/[w\/]{2}/, "with")end</pre><p>В конце мы добавим имя собеседника в список тэгов, и разделим тэги запятыми.<br></p><h3>До</h3><pre class="brush: bash noskimlinks noskimwords">"Masters @ Work | Subvisual | Deadlines | Design personality | Design problems | Team | Pushing envelopes | Delightful experiences | Perfecting details | Company values"</pre><h3>После</h3><pre class="brush: bash noskimlinks noskimwords">"João Ferreira, Masters  Work , Subvisual , Deadlines , Design personality , Design problems , Team , Pushing envelopes , Delightful experiences , Perfecting details , Company values"</pre><p>Каждый из этих тегов, в конечном итоге, будет ссылкой на посты на определенную тему. Все это происходит в методе <code class="inline">extract_data</code>. Давайте еще раз посмотрим, где мы находимся:<br></p><h3>Метод def extract_data</h3><pre class="brush: ruby noskimlinks noskimwords">def extract_data(detail_page)  interviewee = extract_interviewee(detail_page)  title = extract_title(detail_page)  sc_id = extract_soundcloud_id(detail_page)  text = extract_shownotes_text(detail_page)  episode_subtitle = extract_subtitle(detail_page)  episode_number = extract_episode_number(episode_subtitle)  date = clean_date(episode_subtitle)  tags = build_tags(title, interviewee)  options = {    interviewee:    interviewee,    title:          title,    sc_id:          sc_id,    text:           text,    tags:           tags,    date:           date,    episode_number: episode_number  }end</pre><p>Все, что нам осталось сделать - это вернуть хэш параметров с данными, которые мы выбрали. Мы можем послать хеш в метод <code class="inline">compose_markdown</code>, который получает наши, уже готовые к записи, данные в виде файла, который нужен для моего нового сайта.<br></p><h2>Пишем посты<br></h2><h3>Метод def compose_markdown</h3><pre class="brush: ruby noskimlinks noskimwords">def compose_markdown(options={})&lt;&lt;-HEREDOC--- title: #{options[:interviewee]}interviewee: #{options[:interviewee]}topic_list: #{options[:title]}tags: #{options[:tags]}soundcloud_id: #{options[:sc_id]}date: #{options[:date]}episode_number: #{options[:episode_number]}---#{options[:text]}HEREDOCend</pre><p>Для публикации подкастов на сайте Middleman, я решил перепрофилировать систему блога. Вместо того, чтобы создавать исключительно блог посты, я создал заметки шоу для эпизодов, которые отображают эпизоды с SoundCloud через iframe. На индексных сайтах, я отображаю только iframe плюс заголовок, и прочее. <br></p><p>Формат, необходимый для этой работы состоит из переменных, названных front matter. По сути это параметры ключ/значение для моего статического сайта. Это замена базы данных моего старого сайта на Sinatra. </p><p>Такие данные, как имя собеседника, дата, код трека на SoundCloud, номер эпизода и т. п. находятся между тремя знаками тире (<code class="inline">---</code>) над файлом эпизода. Ниже идет контент каждого эпизода - вопросы, ссылки, спонсоры и т. д.<br></p><h3>Front Matter</h3><pre class="brush: plain noskimlinks noskimwords">---key: valuekey: valuekey: valuekey: value---Episode content goes here.</pre><p>В методе <code class="inline">compose_markdown</code>, я использую <code class="inline">HERODOC</code> для создания файла с атрибутами (frontmatter: в Middleman переменные конкретной страницы - прим. переводчика) для каждого эпизода. Мы передаем параметры в этот метод из хэша параметров - извлекаем все данные, которые мы получили через вспомогательный метод <code class="inline">extract_data</code>.<br></p><h3>Метод def compose_markdown</h3><pre class="brush: ruby noskimlinks noskimwords">...&lt;&lt;-HEREDOC--- title: #{options[:interviewee]}interviewee: #{options[:interviewee]}topic_list: #{options[:title]}tags: #{options[:tags]}soundcloud_id: #{options[:sc_id]}date: #{options[:date]}episode_number: #{options[:episode_number]}---#{options[:text]}HEREDOC...</pre><p>Вот шаблон нового эпизода подкаста. Как раз за этим мы и пришли. Возможно, вы задаетесь вопросом о данном конкретном синтаксисе: <code class="inline">#{options[:interviewee]}</code>. Я, как обычно, интерполировал строку, но так как мы уже находимся внутри <code class="inline">&lt;&lt;-heredoc</code>, можно не использовать двойные кавычки.<br></p><p>Для нашей ориентации, мы все еще находимся в цикле, внутри функции <code class="inline">write_page</code>, где каждая щелкнутая ссылка ведет на страницу записей каждого отдельно эпизода. Далее идет подготовка записи этого шаблона в файловую систему. Другими словами, мы создаем реальный эпизод с помощью имени файла и готового <code class="inline">markdown_text</code>. <br></p><p>Для этого последнего шага, нам нужно подготовить следующие ингредиенты: дату, имя собеседника, и число эпизодов. Ну и, конечно, <code class="inline">markdown_text</code>, который мы получили из метода <code class="inline">compose_markdown</code>.<br></p><h3>Метод def write_page</h3><pre class="brush: ruby noskimlinks noskimwords">...markdown_text = compose_markdown(extracted_data)date = extracted_data[:date]interviewee = extracted_data[:interviewee]episode_number = extracted_data[:episode_number]file_name = "#{date}-#{dasherize(interviewee)}-#{episode_number}.html.erb.md" ...</pre><p>Затем нам только нужно взять параметры <code class="inline">file_name</code> и <code class="inline">markdown_text</code> и создать файл.<br></p><h3>Метод def write_page</h3><pre class="brush: ruby noskimlinks noskimwords">...File.open(file_name, "w") { |file| file.write(markdown_text) }...</pre><p>Давайте разобьем его на части. Для каждого поста мне нужен определенный формат: что-то вроде <code class="inline">2016-10-25-Avdi-Grimm-120</code>. Я хочу, чтобы имя файлов начиналось с даты, и также включало имя собеседника и номер эпизода.<br></p><p>Чтобы отвечать требованиям для новых постов Middleman, мне нужно пропустить имя собеседника через вспомогательный метод <code class="inline">dasherize</code>, чтобы <code class="inline">Avdi Grimm</code> из получилось <code class="inline">Avdi-Grimm</code>. Ничего волшебного, но взглянуть стоит:<br></p><h3>Метод def dasherize</h3><pre class="brush: ruby noskimlinks noskimwords">def dasherize(text)  text.lstrip.rstrip.tr(" ", "-")end</pre><p>Этот метод удаляет пробелы в имени собеседника, и заменяет пробел между Avdi и Grimm тире. Остальное имя файла также разделено тире: <code class="inline">"date-interviewee-name-episodenumber"</code>.<br></p><h3>Метод def write_page</h3><pre class="brush: ruby noskimlinks noskimwords">..."#{date}-#{dasherize(interviewee)}-#{episode_number}.html.erb.md"...</pre><p>Так как мы получаем содержимое экстракции прямо из HTML сайта, я не могу сразу использовать <code class="inline">.md</code> или <code class="inline">.markdown</code> в качестве расширения файла. Я решил использовать <code class="inline">.html.erb.md</code>. Для будущих эпизодов, которые я буду создавать без экстракции, можно будет убрать <code class="inline">.html.erb</code>, и использовать только <code class="inline">.md</code>.<br></p><p>После этих шагов, цикл в функции <code class="inline">scrape</code> остановится, и у нас будет один эпизод, который выглядит примерно так:<br></p><h3>2014-12-01-Avdi-Grimm-1.html.erb.md</h3><pre class="brush: html noskimlinks noskimwords">--- title: Avdi Grimminterviewee: Avdi Grimmtopic_list: What is Rake | Origins | Jim Weirich | Common use cases | Advantages of Raketags: Avdi Grimm, What is Rake , Origins , Jim Weirich , Common use cases , Advantages of Rakesoundcloud_id: 179619755date: 2014-12-01episode_number: 1---Questions:- What is Rake?- What can you tell us about the origins of Rake?- What can you tell us about Jim Weihrich?- What are the most common use cases for Rake?- What are the most notable advantages of Rake?Links:In"&gt;http://www.youtube.com/watch?v=2ZHJSrF52bc"&gt;In memory of the great Jim WeirichRake"&gt;https://github.com/jimweirich/rake"&gt;Rake on GitHubJim"&gt;https://github.com/jimweirich"&gt;Jim Weirich on GitHubBasic"&gt;http://www.youtube.com/watch?v=AFPWDzHWjEY"&gt;Basic Rake talk by Jim WeirichPower"&gt;http://www.youtube.com/watch?v=KaEqZtulOus"&gt;Power Rake talk by Jim WeirichLearn"&gt;http://devblog.avdi.org/2014/04/30/learn-advanced-rake-in-7-episodes/"&gt;Learn advanced Rake in 7 episodes - from Avdi Grimm ( free )Avdi"&gt;http://about.avdi.org/"&gt;Avdi GrimmAvdi Grimm’s screencasts: Ruby"&gt;http://www.rubytapas.com/"&gt;Ruby TapasRuby"&gt;http://devchat.tv/ruby-rogues/"&gt;Ruby Rogues podcast with Avdi GrimmGreat ebook: Rake"&gt;http://www.amazon.com/Rake-Management-Essentials-Andrey-Koleshko/dp/1783280778"&gt;Rake Task Management Essentials fromhttps://twitter.com/ka8725"&gt; Andrey Koleshko</pre><p>Наш скрэпер начнет свою работу с последнего эпизода, и будет переходит по эпизодам до первого. А для демонстрационных целей нам подойдет и первый эпизод. Вверху вы можете видеть front matter вместе извлеченными данными. </p><p>Все эти данные раньше содержались в базе данных моего приложения на Sinatra - номер эпизода, дата, имя собеседника, и т.п. А теперь они готовы для моего статического сайта на Middleman. Все что ниже двойных трех тире (<code class="inline">---</code>) - это текст из заметок шоу: по большей части вопросы и ссылки.<br></p><h2>Заключительные мысли<br></h2><p>Вот мы и закончили. Мой новый подкаст уже готов и работает. Я очень рад, что я нашел время переделать сайт с нуля.  Сейчас намного круче публиковать новые эпизоды. И для пользователей стало намного проще находить эпизоды. </p><p>Как я говорил раньше, теперь настало время вам поэкспериментировать с кодом. Переделайте код немного. Попробуйте упростить его. У вас много возможностей для рефакторинга кода.<br></p><p>В целом, я надеюсь, я показал, чего можно добиться с новыми пакетами веб скрэпинга. Конечно, вы можете решать гораздо более сложные проблемы - я даже уверен, что есть много возможностей для организации бизнеса на основе этих навыков. </p><p>Ну и, как обычно, ступайте шаг за шагом, и не слишком разочаровывайтесь, если что-то не получается сразу. Это не просто нормально для большинства, но и само собой разумеется. Это часть пути. Хорошего скрэпинга!</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825073-sozdaem-svoj-pervyj-veb-skreper-chast-3" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Ruby" href="https://norma-studio.github.io/article5/220825073-sozdaem-svoj-pervyj-veb-skreper-chast-3" class="tm-article-body__tags-item-link">Ruby</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
44815</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
398</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

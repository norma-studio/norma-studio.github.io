
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Все о моках в PHPUnit
... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Все о моках в PHPUnit
... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Все о моках в PHPUnit
... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Все о моках в PHPUnit
... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Существует два стиля тестирования: стили «черного ящика» и «белого ящика». Тестирование черного ящика фокусируется на состоянии объекта; тогда как тестирование белого ящика фокусируется на поведении. Эти два стиля дополняют друг друга и могут быть объединены для тщательного тестирования кода. Mocking позволяет нам тестировать поведение, и этот учеб...">
<meta property="og:description" content="Существует два стиля тестирования: стили «черного ящика» и «белого ящика». Тестирование черного ящика фокусируется на состоянии объекта; тогда как тестирование белого ящика фокусируется на поведении. Эти два стиля дополняют друг друга и могут быть объединены для тщательного тестирования кода. Mocking позволяет нам тестировать поведение, и этот учеб...">
<meta name="twitter:description" content="Существует два стиля тестирования: стили «черного ящика» и «белого ящика». Тестирование черного ящика фокусируется на состоянии объекта; тогда как тестирование белого ящика фокусируется на поведении. Эти два стиля дополняют друг друга и могут быть объединены для тщательного тестирования кода. Mocking позволяет нам тестировать поведение, и этот учеб...">
<meta property="aiturec:description" content="Существует два стиля тестирования: стили «черного ящика» и «белого ящика». Тестирование черного ящика фокусируется на состоянии объекта; тогда как тестирование белого ящика фокусируется на поведении. Эти два стиля дополняют друг друга и могут быть объединены для тщательного тестирования кода. Mocking позволяет нам тестировать поведение, и этот учеб...">
<meta property="og:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/2126_mockingphp/app_schema.png">
<meta property="aiturec:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/2126_mockingphp/app_schema.png">
<meta name="twitter:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/2126_mockingphp/app_schema.png">
<meta property="vk:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/2126_mockingphp/app_schema.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/2126_mockingphp/app_schema.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825621-vse-o-mokah-v-phpunit.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825621-vse-o-mokah-v-phpunit.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825621-vse-o-mokah-v-phpunit.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825621-vse-o-mokah-v-phpunit.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825621-vse-o-mokah-v-phpunit.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825621-vse-o-mokah-v-phpunit.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825621-vse-o-mokah-v-phpunit.html" title="Все о моках в PHPUnit
... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Все о моках в PHPUnit
... | envatomarket.ru | norma-studio.github.io" title="Все о моках в PHPUnit
... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/63456435436.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825621-vse-o-mokah-v-phpunit.html" class="tm-user-info__username" title="
М. Старостенко" aria-label="
М. Старостенко">
М. Старостенко</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Все о моках в PHPUnit
...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825621-vse-o-mokah-v-phpunit" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="PHP" href="https://norma-studio.github.io/article5/220825621-vse-o-mokah-v-phpunit" class="tm-article-snippet__hubs-item-link"><span>PHP</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825621-vse-o-mokah-v-phpunit.html" />
    <link itemprop="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/2126_mockingphp/app_schema.png">
    <meta itemprop="headline name" content="Все о моках в PHPUnit
... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Существует два стиля тестирования: стили «черного ящика» и «белого ящика». Тестирование черного ящика фокусируется на состоянии объекта; тогда как тестирование белого ящика фокусируется на поведении. Эти два стиля дополняют друг друга и могут быть объединены для тщательного тестирования кода. Mocking позволяет нам тестировать поведение, и этот учеб...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Существует два стиля тестирования: стили «черного ящика» и «белого ящика». Тестирование черного ящика фокусируется на состоянии объекта; тогда как тестирование белого ящика фокусируется на поведении. Эти два стиля дополняют друг друга и могут быть объединены для тщательного тестирования кода. Mocking позволяет нам тестировать поведение, и этот учеб...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



 <p>Существует два стиля тестирования: стили «черного ящика» и «белого ящика». Тестирование черного ящика фокусируется на состоянии объекта; тогда как тестирование белого ящика фокусируется на поведении. Эти два стиля дополняют друг друга и могут быть объединены для тщательного тестирования кода. <b>Mocking</b> позволяет нам тестировать поведение, и этот учебник сочетает концепцию моков с TDD, чтобы создать класс примера, который использует несколько других компонентов для своей работы.</p> <p><!--more--></p> <hr><h2> <span>Шаг 1:</span> Введение в тестирование поведения</h2> <p>Объекты - это сущности, которые отправляют сообщения друг другу. Каждый объект распознает набор сообщений, на которые он в свою очередь отвечает. Это <em>public</em> методы объекта. <em>Private</em> методы - это полная противоположность. Они полностью внутренне относятся к объекту и не могут связываться с чем-либо вне объекта. Если публичные методы сродни сообщениям, частные методы похожи на мысли.</p> <p>Общее количество всех методов, public и private, доступных через публичные методы, представляет собой поведение объекта. Например, указание <em>move</em> объекту, заставляет  этот объект не только взаимодействовать со своими внутренними методами, но и с другими объектами. С точки зрения пользователя объект имеет только одно простое поведение: он <em>moves</em>.</p> <blockquote><p>Однако с точки зрения программиста объект должен сделать много мелочей для достижения движения.</p></blockquote> <p>Например, представьте, что наш объект - это автомобиль. Чтобы он мог <em>move</em>, он должен иметь ходовой двигатель, находиться на первой передаче (или наоборот), а колеса должны вращаться. Это поведение, которое нам необходимо проверить и использовать для разработки и написания нашего итогового кода.</p> <hr><h2> <span>Шаг 2:</span> Игрушечная машинка с дистанционным управлением</h2> <blockquote class="pullquote"><p>Наш тестируемый класс никогда не использует эти фиктивные объекты.</p></blockquote> <p>Представим себе, что мы создаем программу для дистанционного управления игрушечной машиной. Все команды нашего класса проходят через пульт дистанционного управления. Мы должны создать класс, который <em>понимает</em>, что пульт дистанционного управления отправляет и выдает <em>команды</em> машине.</p> <p>Это будет упражнение, и мы предполагаем, что другие классы, контролирующие различные части автомобиля, уже написаны. Мы знаем точную сигнатуру всех этих классов, но, к сожалению, производитель автомобилей не смог отправить нам прототип - даже нет исходного кода. Все, что мы знаем, это имена классов, методы, которые у них есть, и какое поведение каждый метод инкапсулирует. Также указываются возвращаемые значения.</p> <hr><h2> <span>Шаг 3:</span> Схема приложения</h2> <p>Вот полная схема приложения. На данный момент нет никаких объяснений; просто имейте это в виду для последующего использования.</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/2126_mockingphp/app_schema.png" alt="Все о моках в PHPUnit..." title="Все о моках в PHPUnit..." width="50" height="50"></div> <hr><h2> <span>Шаг 4:</span> Тестовые дубликаты</h2> <blockquote class="pullquote"><p>Тест-stub (заглушка) является объектом контроля косвенного ввода тестируемого кода.</p></blockquote> <p>Mocking - это стиль тестирования, для которого требуется собственный набор инструментов, набор специальных объектов, представляющих разные уровни фальсификации поведения объекта. Вот они:</p> <ul><li>фиктивные объекты</li> <li>тестовые заглушки</li> <li>тестовые шпионы</li> <li>тестовые моки</li> <li>пробные подделки</li> </ul><p>Каждый из этих объектов имеет свою собственную зону ответственности и поведение. В PHPUnit они создаются с помощью метода <code>$this-&gt;getMock()</code>. Разница заключается в том, как и по каким причинам используются объекты.</p> <p>Чтобы лучше понять эти объекты, я буду реализовывать «игрушечный контроллер автомобиля» шаг за шагом, используя типы объектов, в таком порядке, как было указано выше. Каждый объект в списке более сложный, чем предыдущий объект. Это приводит к реализации, которая радикально отличается от реального мира. Кроме того, будучи воображаемым приложением, я буду использовать некоторые сценарии, которые могут быть даже невозможны в реальной игрушечной машине. Но, эй, давайте представим, что нам нужно, чтобы понять большую картину.</p> <hr><h2> <span>Шаг 5:</span> Dummy-объект</h2> <p>Объекты «пустышки» - это объекты, от которых зависит системный тест (SUT), но они на самом деле никогда не используются. Фиктивный объект может быть аргументом, переданным другому объекту, или он может быть возвращен вторым объектом и затем передан третьему объекту. Дело в том, что наш тестируемый класс никогда не использовал эти фиктивные объекты. В то же время объект должен напоминать реальный объект; в противном случае получатель может отказаться от него.</p> <p>Лучший способ продемонстрировать это - представить себе сценарий; схема которого представлена ниже:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/2126_mockingphp/dummy_object.png" alt="Все о моках в PHPUnit..." title="Все о моках в PHPUnit..." width="50" height="50"></div> <p>Оранжевым объектом является <code>RemoteControlTranslator</code>. Основная цель - получать сигналы с пульта дистанционного управления и переводить их в сообщения для наших классов. В какой-то момент пользователь выполнит действие «<em>Ready to Go</em>» на пульте дистанционного управления. Переводчик получит сообщение и создаст классы, необходимые для того, чтобы автомобиль был готов к работе.</p> <blockquote> <p>Изготовитель сказал, что «<em>Ready to Go</em>» означает, что двигатель запущен, коробка передач находится в нейтральном положении, а индикаторы установлены в положение «включено» или «выключено» в соответствии с запросом пользователя.</p> </blockquote> <p>Это означает, что пользователь может заранее определить состояние огней перед тем, как быть готовым к работе, и они включится или выключится на основе этого предопределенного значения при активации. Затем <code>RemoteControlTranslator</code> отправляет всю необходимую информацию в класс <code>CarControl</code> «<code>getRightToGo($engine, $gearbox, $electronics, $lights)</code>. Я знаю, что это далеко не идеальный дизайн и нарушает несколько принципов и шаблонов, но это очень хорошо для этого примера.</p> <p>Начните наш проект с этой исходной файловой структуры:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cdn.tutsplus.com/net/uploads/legacy/2126_mockingphp/initial_file_structure.png" class="lazy07" alt="Все о моках в PHPUnit..." title="Все о моках в PHPUnit..." width="50" height="50"></div> <p>Помните, что все классы в папке <em>CarInterface</em> предоставлены производителем автомобиля; мы не знаем их реализации. Все, что мы знаем, это сигнатуры классов, но на данный момент нас это не волнует.</p> <p>Наша основная цель - реализовать класс <code>CarController</code>. Чтобы протестировать этот класс, нам нужно представить, как мы хотим его использовать. Другими словами, мы ставим себя на место <code>RemoteControlTranslator</code> и / или любого другого будущего класса, который может использовать <code>CarController</code>. Начнем с создания кейса для нашего класса.</p> <pre class="brush: php noskimlinks noskimwords">class CarControllerTest extends PHPUnit_Framework_TestCase {}</pre> <p>Затем добавьте тестовый метод.</p> <pre class="brush: php noskimlinks noskimwords">  function testItCanGetReadyTheCar() {}</pre> <p>Теперь подумайте над тем, что нам нужно передать методу <code>getReadyToGo()</code>: движок, коробку передач, контроллер электроники и данные по огням. Ради этого примера мы замокаем только огни:</p> <pre class="brush: php noskimlinks noskimwords">require_once "../CarController.php";include "../autoloadCarInterfaces.php";class CarControllerTest extends PHPUnit_Framework_TestCase {function testItCanGetReadyTheCar() {$carController = new CarController();$engine = new Engine();$gearbox = new Gearbox();$electornics = new Electronics();$dummyLights = $this-&gt;getMock("Lights");$this-&gt;assertTrue($carController-&gt;getReadyToGo($engine, $gearbox, $electornics, $dummyLights));}}</pre> <p>Это, очевидно, не сработает:</p> <pre class="brush: text noskimlinks noskimwords">PHP Fatal error:  Call to undefined method CarController::getReadyToGo()</pre> <p>Несмотря на неудачу, этот тест дал нам отправную точку для нашей реализации <code>CarController</code>. Я подключил файл с именем <em>autoloadCarInterfaces.php</em>, который не был в исходном списке. Я понял, что мне нужно что-то, что загрузит все классы, и я написал очень простое решение. Мы всегда можем переписать его, когда появятся реальные классы, но это уже совершенно другая история. На данный момент мы придерживаемся простого решения:</p> <pre class="brush: php noskimlinks noskimwords">foreach (scandir(dirname(__FILE__) . "/CarInterface") as $filename) {$path = dirname(__FILE__) . "/CarInterface/" . $filename;if (is_file($path)) {require_once $path;}}</pre> <p>Я предполагаю, что этот загрузчик классов очевиден для всех; поэтому давайте обсудим тестовый код.</p> <p>Сначала мы создаем экземпляр <code>CarController</code>, класс, который мы хотим протоестировать. Затем мы создаем экземпляры всех других классов, которые нам интересны: двигатель, коробка передач и электроника.</p> <p>Затем мы создаем dummy-объект <code>Lights</code>, вызывая метод <code>getMock()</code> PHPUnit и передавая имя класса <code>Lights</code>. Это возвращает экземпляр <code>Lights</code>, но каждый метод возвращает <code>null</code> - фиктивный объект. Этот фиктивный объект ничего не может сделать, но он дает нашему коду интерфейс, необходимый для работы со объектами <code>Light</code>.</p> <blockquote><p>Очень важно отметить, что <code>$dummyLights</code> - это объект <code>Lights</code>, и любой пользователь, ожидающий объект <code>Light</code>, может использовать фиктивный объект, не зная, что он не является реальным объектом <code>Lights</code>.</p></blockquote> <p>Чтобы избежать путаницы, я рекомендую указать тип параметра при определении функции. Это заставляет среду выполнения PHP проверять аргументы, переданные функции. Без указания типа данных вы можете передать любой объект любому параметру, что может привести к сбою вашего кода. Имея это в виду, давайте рассмотрим класс <code>Electronics</code>:</p> <pre class="brush: php noskimlinks noskimwords">require_once "Lights.php";class Electronics {function turnOn(Lights $lights) {}}</pre> <p>Давайте проведем тест:</p> <pre class="brush: php noskimlinks noskimwords">class CarController {function getReadyToGo(Engine $engine, Gearbox $gearbox, Electronics $electronics, Lights $lights) {$engine-&gt;start();$gearbox-&gt;shift("N");$electronics-&gt;turnOn($lights);return true;}}</pre> <p>Как вы можете видеть, функция <code>getReadyToGo()</code> использовала объект <code>$lights</code> только с целью отправки его методу <code>turnOn()</code> объекта <code>$electronics</code>. Это идеальное решение для такой ситуации? Наверное, нет, но вы можете четко наблюдать, как объект-пустышка, без какой-либо связи с функцией <code>getReadyToGo()</code>, передается вместе с одним объектом, который действительно нуждается в нем.</p> <p><em>Обратите внимание, что все классы, содержащиеся в </em>каталоге CarInterface, <em>при инициализации предоставляют фиктивные объекты</em>. Также предположим, что для этого упражнения мы ожидаем, что производитель предоставит настоящие классы в будущем. Мы не можем полагаться на их нынешнюю нехватку функциональности; поэтому мы должны обеспечить, чтобы наши тесты успешно проходили.</p> <hr><h2> <span>Шаг 6:</span> «Заглушить» статус и двигаться вперёд</h2> <p>Тест-заглушка является объектом контроля косвенного ввода тестируемого кода. Но что такое косвенный ввод? Это источник информации, который нельзя напрямую указать.</p> <blockquote><p>Наиболее распространенным примером тестового заглушки является то, что объект запрашивает другой объект для информации, а затем делает что-то с этими данными.</p></blockquote> <blockquote class="pullquote"><p>Шпионы, по определению, являются более способными заглушками.</p></blockquote> <p>Данные могут быть получены только путем запроса их у определенного объекта, и во многих случаях эти объекты используются для определенной цели внутри тестируемого класса. Мы не хотим создавать (<code>new SomeClass()</code>) класс внутри другого класса для целей тестирования. Поэтому нам нужно ввести экземпляр класса, который действует как <code>SomeClass</code>, при этом не вводя фактический объект <code>SomeClass</code>.</p> <p>Нам нужен класс заглушки, который затем приводит к <em>инъекции зависимостей</em>. Инъекция зависимостей (DI) - это техника, который вводит один объект в другой объект, заставляя его использовать введенный объект. DI распространен в TDD, и это абсолютно необходимо практически в любом проекте. Он обеспечивает простой способ заставить объект использовать подготовленный тестовый класс вместо реального класса, используемого в рабочей среде.</p> <p>Давайте заставим нашу игрушечную машину двигаться вперед.</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/2126_mockingphp/test_stub.png" alt="Все о моках в PHPUnit..." title="Все о моках в PHPUnit..." width="50" height="50"></div> <p>Мы хотим реализовать метод <code>moveForward()</code>. Этот метод сначала запрашивает объект <code>StatusPanel</code> для состояния топлива и двигателя. Если автомобиль готов к работе, то метод инструктирует электронику ускоряться.</p> <p>Чтобы лучше понять, как работает заглушка, я сначала напишу код проверки состояния и ускорения:</p> <pre class="brush: php noskimlinks noskimwords">function goForward(Electronics $electronics) {$statusPanel = new StatusPanel();if($statusPanel-&gt;engineIsRunning() &amp;&amp; $statusPanel-&gt;thereIsEnoughFuel())$electronics-&gt;accelerate ();}</pre> <p>Этот код довольно прост, но у нас нет реального двигателя или топлива, чтобы проверить нашу реализацию <code>goForward()</code>. Наш код даже не будет входить в оператор <code>if</code>, потому что у нас нет класса <code>StatusPanel</code>. Но если мы продолжим тестирование, появится логическое решение:</p> <pre class="brush: php noskimlinks noskimwords">function testItCanAccelerate() {$carController = new CarController();$electronics = new Electronics();$stubStatusPanel = $this-&gt;getMock("StatusPanel");$stubStatusPanel-&gt;expects($this-&gt;any())-&gt;method("thereIsEnoughFuel")-&gt;will($this-&gt;returnValue(TRUE));$stubStatusPanel-&gt;expects($this-&gt;any())-&gt;method("engineIsRunning")-&gt;will($this-&gt;returnValue(TRUE));$carController-&gt;goForward($electronics, $stubStatusPanel);}</pre> <p>Построчное объяснение:</p> <blockquote class="pullquote"> <p>Мне нравится рекурсия; всегда легче протестировать рекурсию, чем циклы.</p> </blockquote> <ul><li>создать новый <code>CarController</code> </li> <li>создать зависимый объект <code>Electronics</code></li> <li>создать мок для <code>StatusPanel</code> </li> <li>ожидать, что будет вызван метод <code>thereIsEnoughFuel()</code> ноль или более раз и вернуть <code>true</code> </li> <li>ожидание вызова <code>engineIsRunning()</code> ноль или более раз и вернуть <code>true</code> </li> <li>вызов <code>goForward()</code> с <code>Elelctronics</code> и <code>StubbedStatusPanel</code></li> </ul><p>Это тест, который мы хотим написать, но он не будет работать с нашей текущей версией <code>goForward()</code>. Мы должны изменить его:</p> <pre class="brush: php noskimlinks noskimwords">function goForward(Electronics $electronics, StatusPanel $statusPanel = null) {$statusPanel = $statusPanel ? : new StatusPanel();if($statusPanel-&gt;engineIsRunning() &amp;&amp; $statusPanel-&gt;thereIsEnoughFuel())$electronics-&gt;accelerate ();}</pre> <p>В нашей модификации используется <em>инъекция зависимостей</em> путем добавления второго необязательного параметра типа <code>StatusPanel</code>. Мы определяем, имеет ли этот параметр значение и создаем новый <code>StatusPanel</code>, если <code>$statusPanel</code> имеет значение NULL. Это гарантирует, что новый объект <code>StatusPanel</code> будет создан в процессе работы, все еще позволяя нам протестировать метод.</p> <p>Важно указать тип параметра <code>$statusPanel</code>. Это гарантирует, что к методу может быть передан только объект <code>StatusPanel</code> (или объект наследуемого класса). Но даже с этой модификацией наш тест все еще не завершен.</p> <hr><h2> <span>Шаг 7:</span> Завершите тест с помощью мока</h2> <p>Мы должны протестировать объект <code>Electronics</code>, чтобы гарантировать, что наш метод из шага 6 вызывает метод <code>accelerate()</code>. Мы не можем использовать настоящий класс <code>Electronics</code> по нескольким причинам:</p> <ul><li>У нас нет этого класса. </li> <li>Мы не можем проверить его поведение. </li> <li>Даже если бы мы могли его вызвать, мы должны тестировать его изолированно.</li> </ul><p>Тестовый мок - это объект, который способен контролировать как косвенный ввод так и вывод, и у него есть механизм автоматического утверждения ожиданий и результатов. Это определение может показаться немного запутанным, но реализовать его довольно просто:</p> <pre class="brush: php noskimlinks noskimwords">function testItCanAccelerate() {$carController = new CarController();$electronics = $this-&gt;getMock("Electronics");$electronics-&gt;expects($this-&gt;once())-&gt;method("accelerate");$stubStatusPanel = $this-&gt;getMock("StatusPanel");$stubStatusPanel-&gt;expects($this-&gt;any())-&gt;method("thereIsEnoughFuel")-&gt;will($this-&gt;returnValue(TRUE));$stubStatusPanel-&gt;expects($this-&gt;any())-&gt;method("engineIsRunning")-&gt;will($this-&gt;returnValue(TRUE));$carController-&gt;goForward($electronics, $stubStatusPanel);}</pre> <p>Мы просто изменили переменную <code>$electronics</code>. Вместо создания реального объекта <code>Electronics</code> мы просто делаем его мок.</p> <p>На следующей строке мы определяем ожидание для объекта <code>$electronics</code>. Точнее, мы ожидаем, что метод <code>accelerate()</code> вызывается только один раз (<code>$this-&gt;once()</code>). Тест теперь проходит!</p> <p>Не стесняйтесь поиграть с этим тестом. Попробуйте изменить <code>$this-&gt;once()</code> на <code>$this-&gt;exactly(2)</code> и посмотрите, какое приятное сообщение об ошибке PHPUnit выдаст вам:</p> <pre class="brush: text noskimlinks noskimwords">1) CarControllerTest::testItCanAccelerateExpectation failed for method name is equal to &lt;string:accelerate&gt;; when invoked 2 time(s).Method was expected to be called 2 times, actually called 1 times.</pre> <hr><h2> <span>Шаг 8:</span> Использование тестового шпиона</h2> <p>Тестовый шпион - это объект, способный фиксировать косвенный вывод и при необходимости обеспечивать косвенный ввод.</p> <p>Косвенный вывод - это то, что мы не можем наблюдать напрямую. Например: когда тестируемый класс вычисляет значение, а затем использует его в качестве аргумента для метода другого объекта. Единственный способ наблюдать этот вывод - спросить вызываемый объект о переменной, используемой для доступа к его методу.</p> <p>Это определение делает шпиона чем-то очень ложным.</p> <blockquote> <p>Основное различие между моком и шпионом заключается в том, что мок объекты имеют встроенные утверждения и ожидания.</p> </blockquote> <p>В этом случае, как мы можем создать тестовый шпион, используя <code>getMock()</code> PHPUnit? Мы не можем (ну, мы не можем создать чистого шпиона), но мы можем создавать моки, способные шпионить за другими объектами.</p> <p>Давайте реализуем тормозную систему, чтобы мы могли остановить машину. Торможение довольно простое; пульт дистанционного управления будет ощущать интенсивность торможения от пользователя и отправлять его на контроллер. Пульт дистанционного управления также обеспечивает кнопку «аварийная остановка!». Это должно немедленно задействовать тормоза с максимальной мощностью.</p> <p>Тормозная мощность измеряется в значениях от 0 до 100, при этом 0 ничего не означает и 100 означает максимальную мощность тормоза. Команда «Аварийная остановка!» будет приниматься как отдельный вызов.</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/2126_mockingphp/test_spy.png" alt="Все о моках в PHPUnit..." title="Все о моках в PHPUnit..." width="50" height="50"></div> <p><code>CarController</code> выдаст сообщение объекту <code>Electronics</code> для активации тормозной системы. Контроллер автомобиля также может запросить <code>StatusPanel</code> для получения информации о скорости, полученной с помощью датчиков на автомобиле.</p> <h3>Реализация с использованием чистого тестового шпиона</h3> <p>Давайте сначала реализуем чистый объект-шпион, не используя инфраструктуру моков PHPUnit. Это даст вам лучшее представление о концепции тестового шпиона. Начнем с проверки сигнатуры объекта <code>Electronics</code>.</p> <pre class="brush: php noskimlinks noskimwords">class Electronics {function turnOn(Lights $lights) {}function accelerate(){}function pushBrakes($brakingPower){}}</pre> <p>Нам интересен метод <code>pushBrakes()</code>. Я не назвал его <code>brake()</code>, чтобы избежать путаницы с ключевым словом <code>break</code> в PHP.</p> <p>Чтобы создать настоящего шпиона, мы расширим <code>Electronics</code> и переопределим метод <code>pushBrakes()</code>. Этот переопределенный метод не будет тормозить; вместо этого он регистрирует только тормозную мощность.</p> <pre class="brush: php noskimlinks noskimwords">class SpyingElectronics extends Electronics {private $brakingPower;function pushBrakes($brakingPower) {$this-&gt;brakingPower = $brakingPower;}function getBrakingPower() {return $this-&gt;brakingPower;}}</pre> <p>Метод <code>getBrakingPower()</code> дает нам возможность проверить мощность торможения в нашем тесте. Этот метод не будет использоваться в рабочем коде.</p> <p>Теперь мы можем написать тест, способный проверить мощность торможения. Следуя принципам TDD, мы начнем с самого простого теста и обеспечим самую основную реализацию:</p> <pre class="brush: php noskimlinks noskimwords">function testItCanStop() {$halfBrakingPower = 50;$electronicsSpy = new SpyingElectronics();$carController = new CarController();$carController-&gt;pushBrakes($halfBrakingPower, $electronicsSpy);$this-&gt;assertEquals($halfBrakingPower, $electronicsSpy-&gt;getBrakingPower());}</pre> <p>Этот тест завершился неудачно, потому что у нас еще нет метода <code>pushBrakes()</code> в <code>CarController</code>. Давайте исправим это и напишем:</p> <pre class="brush: php noskimlinks noskimwords">function pushBrakes($brakingPower, Electronics $electronics) {$electronics-&gt;pushBrakes($brakingPower);}</pre> <p>Тест теперь проходит, эффективно тестируя метод <code>pushBrakes()</code>.</p> <p>Мы также можем отслеживать вызовы методов. Тестирование класса <code>StatusPanel</code> является следующим логическим шагом. Он предоставляет пользователю различные сведения о дистанционно управляемом автомобиле. Давайте напишем тест, который проверяет, запрашивается ли объект <code>StatusPanel</code> о скорости автомобиля. Мы создадим для этого шпиона:</p> <pre class="brush: php noskimlinks noskimwords">class SpyingStatusPanel extends StatusPanel {private $speedWasRequested = false;function getSpeed() {$this-&gt;speedWasRequested = true;}function speedWasRequested() {return $this-&gt;speedWasRequested;}}</pre> <p>Затем мы модифицируем наш тест для использования шпиона:</p> <pre class="brush: php noskimlinks noskimwords">function testItCanStop() {$halfBrakingPower = 50;$electronicsSpy = new SpyingElectronics();$statusPanelSpy = new SpyingStatusPanel();$carController = new CarController();$carController-&gt;pushBrakes($halfBrakingPower, $electronicsSpy, $statusPanelSpy);$this-&gt;assertEquals($halfBrakingPower, $electronicsSpy-&gt;getBrakingPower());$this-&gt;assertTrue($statusPanelSpy-&gt;speedWasRequested());}</pre> <p>Обратите внимание, что я не написал отдельный тест.</p> <blockquote><p>Рекомендация «одно утверждение за тест» хороша, но если ваш тест описывает действие, требующее нескольких шагов или состояний, допустимо использование нескольких утверждений в одном тесте.</p></blockquote> <p>Более того, это сохраняет все ваши утверждения об одной концепции в одном месте. Это помогает устранить дублирующий код, не требуя от вас повторной настройки тех же условий для вашего SUT.</p> <p>И теперь сама реализация:</p> <pre class="brush: php noskimlinks noskimwords">function pushBrakes($brakingPower, Electronics $electronics, StatusPanel $statusPanel = null) {$statusPanel = $statusPanel ? : new StatusPanel();$electronics-&gt;pushBrakes($brakingPower);$statusPanel-&gt;getSpeed();}</pre> <p>Там всего лишь маленькая крошечная вещь, которая меня беспокоит: имя этого теста - <code>testItCanStop()</code>. Это явно означает, что мы нажимаем тормоза до тех пор, пока автомобиль не остановится. Мы, однако, называем метод <code>pushBrakes()</code>, что не совсем корректно. Время для рефакторинга:</p> <pre class="brush: php noskimlinks noskimwords">function stop($brakingPower, Electronics $electronics, StatusPanel $statusPanel = null) {$statusPanel = $statusPanel ? : new StatusPanel();$electronics-&gt;pushBrakes($brakingPower);$statusPanel-&gt;getSpeed();}</pre> <p>Не забудьте также изменить вызов метода в тесте.</p> <pre class="brush: php noskimlinks noskimwords">$carController-&gt;stop($halfBrakingPower, $electronicsSpy, $statusPanelSpy);</pre> <blockquote class="pullquote"><p>Косвенный вывод - это то, что мы не можем наблюдать напрямую.</p></blockquote> <p>На этом этапе нам нужно подумать о нашей тормозной системе и о том, как она работает. Существует несколько возможностей, но для этого примера предположим, что поставщик игрушечного автомобиля указал, что торможение происходит сдержанно. Вызов метода <code>pushBreakes()</code> объекта <code>Electronics</code> заставляет тормозить в течение некоторого времени, а затем отпускает его. Временной интервал для нас неважен, но давайте представим, что это часть секунды. С таким небольшим интервалом времени мы должны непрерывно посылать команды <code>pushBrakes()</code>, пока скорость не станет равной нулю.</p> <p>Шпионы по определению являются более способными заглушками, и при необходимости они могут также управлять косвенным вводом. Давайте сделаем наш шпион для <code>StatusPanel</code> более способным и предложим определенное значение для скорости. Я думаю, что первый вызов должен обеспечить положительную скорость - допустим, значение <code>1</code>. Второй вызов обеспечит скорость <code>0</code>.</p> <pre class="brush: php noskimlinks noskimwords">class SpyingStatusPanel extends StatusPanel {private $speedWasRequested = false;private $currentSpeed = 1;function getSpeed() {if ($this-&gt;speedWasRequested) $this-&gt;currentSpeed = 0;$this-&gt;speedWasRequested = true;return $this-&gt;currentSpeed;}function speedWasRequested() {return $this-&gt;speedWasRequested;}function spyOnSpeed() {return $this-&gt;currentSpeed;}}</pre> <p>Переопределенный метод <code>getSpeed()</code> возвращает соответствующее значение скорости с помощью метода <code>spyOnSpeed()</code>. Добавим третье утверждение к нашему тесту:</p> <pre class="brush: php noskimlinks noskimwords">function testItCanStop() {$halfBrakingPower = 50;$electronicsSpy = new SpyingElectronics();$statusPanelSpy = new SpyingStatusPanel();$carController = new CarController();$carController-&gt;stop($halfBrakingPower, $electronicsSpy, $statusPanelSpy);$this-&gt;assertEquals($halfBrakingPower, $electronicsSpy-&gt;getBrakingPower());$this-&gt;assertTrue($statusPanelSpy-&gt;speedWasRequested());$this-&gt;assertEquals(0, $statusPanelSpy-&gt;spyOnSpeed());}</pre> <p>Согласно последнему утверждению, скорость должна иметь значение <code>0</code> по завершению метода <code>stop()</code>. Выполнение этого теста приводит к сбою с загадочным сообщением:</p> <pre class="brush: text noskimlinks noskimwords">1) CarControllerTest::testItCanStopFailed asserting that 1 matches expected 0.</pre> <p>Давайте добавим наше собственное сообщение об утверждении:</p> <pre class="brush: php noskimlinks noskimwords">$this-&gt;assertEquals(0, $statusPanelSpy-&gt;spyOnSpeed(),"Expected speed to be 0 (zero) after stopping but it actually was " . $statusPanelSpy-&gt;spyOnSpeed());</pre> <p>Это дает гораздо более читаемое сообщение об ошибке:</p> <pre class="brush: text noskimlinks noskimwords">1) CarControllerTest::testItCanStopExpected speed to be 0 (zero) after stopping but it actually was 1Failed asserting that 1 matches expected 0.</pre> <p>Хватит уже ошибок! Давайте сделаем это.</p> <pre class="brush: php noskimlinks noskimwords">function stop($brakingPower, Electronics $electronics, StatusPanel $statusPanel = null) {$statusPanel = $statusPanel ? : new StatusPanel();$electronics-&gt;pushBrakes($brakingPower);if ($statusPanel-&gt;getSpeed()) $this-&gt;stop($brakingPower, $electronics, $statusPanel);}</pre> <p>Мне нравится рекурсия; всегда легче протестировать рекурсию, чем циклы. Более простое тестирование означает более простой код, который, в свою очередь, означает лучший алгоритм. Ознакомьтесь с <span>Помещением приоритета трансформации</span> для получения дополнительной информации по этому вопросу.</p> <h3>Возвращение к PHPUnit Mocking Framework</h3> <p>Хватит дополнительных классов. Давайте перепишем это с помощью мок фреймворка PHPUnit и исключим этих чистых шпионов. Зачем?</p> <blockquote><p>Поскольку PHPUnit предлагает лучший и простой мок-синтаксис, меньше кода и некоторые хорошие предопределенные методы.</p></blockquote> <p>Обычно я создаю чистых шпионов и заглушки только тогда, когда мокать их с помощью <code>getMock()</code> будет еще более сложным. Если ваши классы настолько сложные, что <code>getMock()</code> не может их обработать, тогда у вас есть проблема с вашим рабочим кодом - а не с вашими тестами.</p> <pre class="brush: php noskimlinks noskimwords">function testItCanStop() {$halfBrakingPower = 50;$electronicsSpy = $this-&gt;getMock("Electronics");$electronicsSpy-&gt;expects($this-&gt;exactly(2))-&gt;method("pushBrakes")-&gt;with($halfBrakingPower);$statusPanelSpy = $this-&gt;getMock("StatusPanel");$statusPanelSpy-&gt;expects($this-&gt;at(0))-&gt;method("getSpeed")-&gt;will($this-&gt;returnValue(1));$statusPanelSpy-&gt;expects($this-&gt;at(1))-&gt;method("getSpeed")-&gt;will($this-&gt;returnValue(0));$carController = new CarController();$carController-&gt;stop($halfBrakingPower, $electronicsSpy, $statusPanelSpy);}</pre> <blockquote class="pullquote"><p>Общее количество всех методов, public и private, доступных через публичные методы, представляет собой поведение объекта.</p></blockquote> <p>Построчное объяснение приведенного выше кода:</p> <ul><li>установить половину мощности торможения = 50</li> <li>создать мок для <code>Electronics</code></li> <li>ожидание вызова метода <code>pushBrakes()</code> ровно два раза с указанной выше тормозной силой</li> <li>создать мок <code>StatusPanel</code></li> <li>вернуть <code>1</code> при первом вызове <code>getSpeed()</code></li> <li>вернуть <code>0</code> при втором выполнении <code>getSpeed()</code></li> <li>вызвать проверенный метод <code>stop()</code> на реальном объекте <code>CarController</code></li> </ul><p>Вероятно, самое интересное в этом коде - метод <code>$this-&gt;at($someValue)</code>. PHPUnit подсчитывает количество вызовов этого мока. Подсчет происходит на уровне мока; поэтому вызов нескольких методов в <code>$statusPanelSpy</code> увеличит счетчик. Поначалу это может показаться немного интуитивным; поэтому давайте посмотрим на пример.</p> <p>Предположим, мы хотим проверить уровень топлива на каждом вызове <code>stop()</code>. Код будет выглядеть так:</p> <pre class="brush: php noskimlinks noskimwords">function stop($brakingPower, Electronics $electronics, StatusPanel $statusPanel = null) {$statusPanel = $statusPanel ? : new StatusPanel();$electronics-&gt;pushBrakes($brakingPower);$statusPanel-&gt;thereIsEnoughFuel();if ($statusPanel-&gt;getSpeed()) $this-&gt;stop($brakingPower, $electronics, $statusPanel);}</pre> <p>Это сломает наш тест. Сперва может быть непонятно почему, но вы получите следующее сообщение:</p> <pre class="brush: text noskimlinks noskimwords">1) CarControllerTest::testItCanStopExpectation failed for method name is equal to &lt;string:pushBrakes&gt; when invoked 2 time(s).Method was expected to be called 2 times, actually called 1 times.</pre> <p>Совершенно очевидно, что <code>pushBrakes()</code> следует вызывать два раза. Почему же мы получаем это сообщение? Из-за ожидания <code>$this-&gt;at($someValue)</code>. Счетчик увеличивается следующим образом:</p> <ul><li>первый вызов <code>stop()</code> -&gt; первый вызов <code>thereIsEnougFuel()</code> =&gt; внутренний счетчик на <code>0</code> </li> <li>первый вызов <code>stop()</code> -&gt; первый вызов <code>getSpeed()</code> =&gt; внутренний счетчик в 1 <strong>и</strong> возвращает <code>0</code> </li> <li>второй вызов <code>stop()</code> никогда не произойдет =&gt; второй вызов <code>getSpeed()</code> никогда не происходит</li> </ul><p>Каждый вызов <strong>любого</strong> замоканного метода на <code>$statusPanelSpy</code> увеличивает внутренний счетчик PHPUnit.</p> <hr><h2> <span>Шаг 9:</span> Тестовый фейк</h2> <blockquote class="pullquote"><p>Если публичные методы сродни сообщениям, приватные методы похожи на мысли.</p></blockquote> <p>Тестовая подделка - это более простая реализация производственного кода. Это очень похожее определение тестовых заглушек. В действительности, Fakes и Stubs очень похожи по внешнему поведению. Оба являются объектами, имитирующими поведение некоторых других реальных объектов, и оба реализуют метод управления косвенным вводом. Разница в том, что подделки гораздо ближе к реальному объекту, чем к фиктивному объекту.</p> <p>Стаб - это, в основном, фиктивный объект, методы которого возвращают предопределенные значения. Подделка, однако, выполняет полную реализацию реального объекта но более простым способом. Вероятно, наиболее распространенным примером является <code>InMemoryDatabase</code>, чтобы идеально имитировать реальный класс базы данных, фактически не записывая в хранилище данных. Таким образом, тестирование становится быстрее.</p> <p>Тестовые подделки не должны реализовывать какие-либо методы прямого управления входными данными или возвращать наблюдаемое состояние. Они не используются для вопросов; они используются для получения данных. Наиболее распространенные случаи использования подделок - это когда реальный зависимый компонент (DOC) еще не написан, он слишком медленный (например, база данных) или реальный DOC недоступен в тестовой среде.</p> <hr><h2> <span>Шаг 10:</span> Выводы</h2> <p>Наиболее важной функциональностью является управление DOC. Это также обеспечивает отличный способ управления косвенным вводом-выводом с помощью техники инъекции зависимостей.</p> <p>Есть два основных мнения насчет моков:</p> <blockquote class="pullquote"><p>Некоторые говорят, что моки это плохо ...</p></blockquote> <ul><li>Некоторые говорят, что <strong>мокать нельзя</strong>, и они правы. Mocking делает что-то тонкое и уродливое: он связывает слишком много тестов с реализацией. Когда это возможно, тест должен быть как можно более независимым от реализации. Тестирование черного ящика всегда предпочтительнее для тестирования белых ящиков. Всегда проверяйте состояние, если можете; не мокайте поведение. Отказ от моков поощряет восходящую разработку и дизайн. Это означает, что сначала создаются небольшие составные части системы, а затем они объединяются в гармоничную структуру.</li> <li>Некоторые говорят, что <strong>мокать можно</strong>, и они правы. Mocking делает что-то тонкое и красивое; он определяет поведение. Это заставляет нас думать гораздо больше с точки зрения пользователя. Обычно при этом используют подход «сверху вниз» для внедрения и проектирования. Мы начинаем с самого верхнего класса в системе и записываем свой первый тест, мокая другие воображаемые DOC, которые еще не реализованы. Компоненты системы появляются и развиваются в зависимости от того, какие моки создаются на один уровень выше.</li> </ul><blockquote><p>Куда двигаться - все зависит от вас.</p></blockquote> <p>Некоторые предпочитают использовать моки, в то время как другие предпочитают тестирование состояния. Каждый подход имеет свои плюсы и минусы. Система с моками предлагает дополнительную поведенческую информацию в тестах. Система с состояниями предлагает более подробную информацию о компонентах, но может также скрывать некоторые действия.</p> <hr><h2>Дополнительные ссылки и книги</h2> <ul><li><span>Официальная документация PHPUnit по мокам</span></li> <li><span>Mocks Are not Stubs - сообщение в блоге от Martin Fowler</span></li> <li><span>Приоритет трансформации - пост в блоге Роберта К. Мартина</span></li> <li><span>xUnit Test Patterns: Рефакторинг тестового кода книга Джерарда Мезароса</span></li> <li><span>Работаем эффективно с устаревшим кодом, книга Майкла Пера</span></li> </ul>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825621-vse-o-mokah-v-phpunit" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="PHP" href="https://norma-studio.github.io/article5/220825621-vse-o-mokah-v-phpunit" class="tm-article-body__tags-item-link">PHP</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
43886</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
419</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

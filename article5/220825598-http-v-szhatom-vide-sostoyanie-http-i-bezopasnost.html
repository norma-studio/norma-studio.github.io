
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>HTTP в сжатом виде: состояние HTTP и безопасность... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="HTTP в сжатом виде: состояние HTTP и безопасность... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="HTTP в сжатом виде: состояние HTTP и безопасность... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="HTTP в сжатом виде: состояние HTTP и безопасность... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="В этой последней главе мы рассмотрим аспекты безопасности HTTP, в том числе, как определить пользователей, как работает проверка подлинности HTTP и почему для некоторых сценариев требуется HTTPS (защищенный HTTP). По пути мы также немного узнаем, как управлять состоянием с помощью HTTP....">
<meta property="og:description" content="В этой последней главе мы рассмотрим аспекты безопасности HTTP, в том числе, как определить пользователей, как работает проверка подлинности HTTP и почему для некоторых сценариев требуется HTTPS (защищенный HTTP). По пути мы также немного узнаем, как управлять состоянием с помощью HTTP....">
<meta name="twitter:description" content="В этой последней главе мы рассмотрим аспекты безопасности HTTP, в том числе, как определить пользователей, как работает проверка подлинности HTTP и почему для некоторых сценариев требуется HTTPS (защищенный HTTP). По пути мы также немного узнаем, как управлять состоянием с помощью HTTP....">
<meta property="aiturec:description" content="В этой последней главе мы рассмотрим аспекты безопасности HTTP, в том числе, как определить пользователей, как работает проверка подлинности HTTP и почему для некоторых сценариев требуется HTTPS (защищенный HTTP). По пути мы также немного узнаем, как управлять состоянием с помощью HTTP....">
<meta property="og:image" content="https://cdn.tutsplus.com/net/uploads/2013/07/img008.png">
<meta property="aiturec:image" content="https://cdn.tutsplus.com/net/uploads/2013/07/img008.png">
<meta name="twitter:image" content="https://cdn.tutsplus.com/net/uploads/2013/07/img008.png">
<meta property="vk:image" content="https://cdn.tutsplus.com/net/uploads/2013/07/img008.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cdn.tutsplus.com/net/uploads/2013/07/img008.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825598-http-v-szhatom-vide-sostoyanie-http-i-bezopasnost.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825598-http-v-szhatom-vide-sostoyanie-http-i-bezopasnost.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825598-http-v-szhatom-vide-sostoyanie-http-i-bezopasnost.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825598-http-v-szhatom-vide-sostoyanie-http-i-bezopasnost.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825598-http-v-szhatom-vide-sostoyanie-http-i-bezopasnost.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825598-http-v-szhatom-vide-sostoyanie-http-i-bezopasnost.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825598-http-v-szhatom-vide-sostoyanie-http-i-bezopasnost.html" title="HTTP в сжатом виде: состояние HTTP и безопасность... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="HTTP в сжатом виде: состояние HTTP и безопасность... | envatomarket.ru | norma-studio.github.io" title="HTTP в сжатом виде: состояние HTTP и безопасность... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/45343254534.jpg" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825598-http-v-szhatom-vide-sostoyanie-http-i-bezopasnost.html" class="tm-user-info__username" title="
С. Баранов" aria-label="
С. Баранов">
С. Баранов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>HTTP в сжатом виде: состояние HTTP и безопасность...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825598-http-v-szhatom-vide-sostoyanie-http-i-bezopasnost" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Web Development" href="https://norma-studio.github.io/article5/220825598-http-v-szhatom-vide-sostoyanie-http-i-bezopasnost" class="tm-article-snippet__hubs-item-link"><span>Web Development</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825598-http-v-szhatom-vide-sostoyanie-http-i-bezopasnost.html" />
    <link itemprop="image" href="https://cdn.tutsplus.com/net/uploads/2013/07/img008.png">
    <meta itemprop="headline name" content="HTTP в сжатом виде: состояние HTTP и безопасность... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="В этой последней главе мы рассмотрим аспекты безопасности HTTP, в том числе, как определить пользователей, как работает проверка подлинности HTTP и почему для некоторых сценариев требуется HTTPS (защищенный HTTP). По пути мы также немного узнаем, как управлять состоянием с помощью HTTP....">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">В этой последней главе мы рассмотрим аспекты безопасности HTTP, в том числе, как определить пользователей, как работает проверка подлинности HTTP и почему для некоторых сценариев требуется HTTPS (защищенный HTTP). По пути мы также немного узнаем, как управлять состоянием с помощью HTTP....</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>В этой последней главе мы рассмотрим аспекты безопасности HTTP, в том числе, как определить пользователей, как работает проверка подлинности HTTP и почему для некоторых сценариев требуется HTTPS (защищенный HTTP). По пути мы также немного узнаем, как управлять состоянием с помощью HTTP.</p> <p><!--more--></p> <hr><h2>Веб без гражданства (еще с отслеживанием состояния)</h2> <p>HTTP - это протокол без учета состояния, то есть каждая транзакция запроса-ответа не зависит от какой-либо предыдущей или будущей транзакции. В HTTP-протоколе ничего не требуется, чтобы сервер сохранял информацию о HTTP-запросе. Все, что требуется серверу, это генерировать ответ для каждого запроса. Каждый запрос будет содержать всю информацию, необходимую серверу для создания ответа.</p> <p>Характер HTTP-состояния без гражданства является одним из движущих факторов успеха сети. Многоуровневые службы, которые мы рассмотрели в предыдущей главе, такие сервисы, как кэширование, становятся возможными (или, по крайней мере, проще), потому что каждое сообщение содержит всю информацию, необходимую для обработки сообщения. Прокси-серверы и веб-серверы могут проверять, преобразовывать и кэшировать сообщения. Без кэширования сеть не могла масштабироваться для удовлетворения потребностей Интернета.</p> <p>Однако большинство веб-приложений и сервисов, которые мы создаем поверх HTTP, отличаются высокой степенью готовности.</p> <p>Банковское приложение хочет, чтобы пользователь входил в систему, прежде чем позволить пользователю просматривать свои ресурсы, связанные с учетной записью. Поскольку каждый запрос без гражданства поступает на частный ресурс, приложение хочет убедиться, что пользователь уже прошел аутентификацию. Другим примером является то, когда пользователь хочет открыть учетную запись и заполнить формы в трехстраничном мастере. Приложение захочет убедиться, что первая страница мастера завершена, прежде чем разрешить пользователю отправлять вторую страницу.</p> <p>К счастью, существует много вариантов сохранения состояния в веб-приложении. Один из подходов состоит в том, чтобы внедрить состояние в ресурсы, передаваемые клиенту, чтобы все состояние, требуемое приложением, вернется к следующему запросу. Этот подход обычно требует некоторых скрытых полей ввода и лучше всего подходит для состояния короткого замыкания (например, состояния, необходимого для перемещения через трехстраничный мастер). Состояние вложения в ресурс сохраняет все состояние внутри HTTP-сообщений, поэтому это очень масштабируемый подход, но он может усложнить программирование приложений.</p> <p>Другой вариант - сохранить состояние на сервере (или за сервером). Этот параметр требуется для состояния, которое должно быть около долгого времени. Допустим, пользователь отправляет форму для изменения своего адреса электронной почты. Адрес электронной почты всегда должен быть связан с пользователем, поэтому приложение может принимать новый адрес, проверять адрес и хранить адрес в базе данных, файле или вызывать веб-службу, чтобы кто-то другой позаботился о сохранении адреса ,</p> <p>Для серверного хранилища многие веб-разработки, такие как ASP.NET, также обеспечивают доступ к «сеансу пользователя». Сеанс может работать в памяти или в базе данных, но разработчик может хранить информацию в сеансе и получать информацию о каждом последующем запросе. Данные, хранящиеся в сеансе, привязаны к отдельному пользователю (фактически, к сеансу просмотра пользователей) и не используются несколькими пользователями.</p> <p>Хранилище сеансов имеет легкую модель программирования и подходит только для краткосрочного состояния, поскольку в конечном итоге сервер должен предположить, что пользователь покинул сайт или закрыл браузер, и сервер отменит сеанс. Хранилище сеансов, если оно хранится в памяти, может отрицательно влиять на масштабируемость, поскольку последующие запросы должны поступать на тот же сервер, на котором хранятся данные сеанса. Некоторые балансировки нагрузки помогают поддерживать этот сценарий, реализуя «липкие сеансы».</p> <p>Возможно, вам интересно, как сервер может отслеживать пользователя для реализации состояния сеанса. Если на сервер поступают два запроса, как сервер знает, являются ли эти два запроса от одного и того же пользователя, или есть два разных пользователя, каждый из которых делает один запрос?</p> <p>В первые дни работы веб-сервера серверное программное обеспечение может иметь дифференцированных пользователей, просматривая IP-адрес сообщения запроса. Однако в наши дни многие пользователи живут за устройствами, использующими Network Address Translation, и по этой и другим причинам вы можете эффективно использовать несколько пользователей на одном IP-адресе. IP-адрес не является надежным методом для дифференциации пользователей.</p> <p>К счастью, есть более надежные методы.</p> <hr><h2>Идентификация и файлы cookie</h2> <p>Веб-сайты, которые хотят отслеживать пользователей, часто обращаются к файлам <b>cookie</b>. Файлы cookie определяются RFC6265 (<span>http://tools.ietf.org/html/rfc6265</span>), и этот RFC метко называется «HTTP State Management Mechanism». Когда пользователь впервые посещает веб-сайт, сайт может предоставить браузеру пользователя cookie с использованием HTTP-заголовка. Затем браузер знает, как отправить cookie в заголовки каждого дополнительного запроса, который он отправляет на сайт. Предполагая, что веб-сайт поместил какой-то уникальный идентификатор в файл cookie, сайт теперь может отслеживать пользователя, когда он или она делает запросы, и дифференцировать одного пользователя от другого.</p> <p>Прежде чем мы углубимся в подробности того, как выглядят куки и как они себя ведут, стоит отметить пару ограничений. Во-первых, файлы cookie могут идентифицировать пользователей в том смысле, что ваш файл cookie отличается от моего файла cookie, но файлы cookie не аутентифицируют пользователей. Аутентифицированный пользователь обычно подтвердил свою личность, предоставив учетные данные, такие как имя пользователя и пароль. Сookies , о которых мы говорим, пока дают нам уникальный идентификатор, чтобы отличать одного пользователя от другого и отслеживать пользователя, когда запросы отправляются на сайт.</p> <p>Во-вторых, поскольку файлы cookie могут отслеживать, что делает пользователь, они поднимают проблемы конфиденциальности в некоторых кругах. Некоторые пользователи будут отключать файлы cookie в своих браузерах, то есть браузер отклонит любые файлы cookie, отправленные сервером в ответ. Отключенные файлы cookie представляют проблему для сайтов, которые должны отслеживать пользователей, конечно, и альтернативы являются беспорядочными. Например, один подход к «cookieless session» заключается в том, чтобы поместить идентификатор пользователя в URL-адрес. Сеансы cookieless требуют, чтобы каждый URL-адрес, который сайт предоставляет пользователю, содержит правильный идентификатор, а URL-адреса становятся намного большими (именно поэтому этот метод часто называют методом «толстого URL»).</p> <hr><h2>Настройка файлов cookie</h2> <p>Когда веб-сайт хочет предоставить пользователю cookie, он использует заголовок <code>Set-Cookie</code> в ответе HTTP.</p> <pre class="brush: text noskimlinks noskimwords">HTTP/1.1 200 OKContent-Type: text/html; charset=utf-8Set-Cookie: fname=Scott$lname=Allen;    domain=.mywebsite.com; path=/...</pre> <p>В файле cookie, показанном в этом примере, есть три области информации. Три области разделены точкой с запятой (;). Во-первых, есть одна или несколько пар имя-значение. Эти пары имя-значение разделены знаком доллара ($) и выглядят очень похожими на то, как параметры запроса форматируются в URL. В примере cookie сервер хотел сохранить имя и фамилию пользователя в файле cookie. Вторая и третья области - это домен и путь, соответственно. Мы вернемся позже, чтобы поговорить о домене и пути.</p> <p>Веб-сайт может помещать любую информацию, которая ему нравится, в файл cookie, хотя существует ограничение по размеру в 4 КБ. Тем не менее, многие веб-сайты только помещают уникальный идентификатор для пользователя, возможно, GUID. Сервер никогда не может доверять чему-либо, хранящемуся на клиенте, если он не защищен криптографически. Да, можно хранить зашифрованные данные в файле cookie, но обычно проще хранить идентификатор.</p> <pre class="brush: text noskimlinks noskimwords">HTTP/1.1 200 OKSet-Cookie: GUID=00a48b7f6a4946a8adf593373e53347c;    domain=.msn.com; path=/</pre> <p>Предполагая, что браузер настроен на прием файлов cookie, браузер будет отправлять cookie на сервер в каждом последующем HTTP-запросе.</p> <pre class="brush: text noskimlinks noskimwords">GET ... HTTP/1.1Cookie: GUID=00a48b7f6a4946a8adf593373e53347c;...</pre> <p>Когда ID прибывает, серверное программное обеспечение может быстро искать любые связанные данные пользователя из структуры данных, базы данных или распределенного кеша в памяти. Вы можете настроить большинство фреймворков веб-приложений для управления файлами cookie и автоматического поиска состояния сеанса. Например, в ASP.NET объект <code>Session</code> предоставляет простой API для чтения и записи состояния сеанса пользователя. В качестве разработчиков нам не нужно беспокоиться о отправке заголовка <code>Set-Cookie</code> или чтении входящих файлов cookie для поиска связанного состояния сеанса. За кулисами ASP.NET будет управлять cookie сеанса.</p> <pre class="brush: js noskimlinks noskimwords">Session["firstName"]  = "Scott";     // writing session state...var lastName = Session["lastName"];  // reading session state</pre> <p>Опять же, стоит отметить, что данные <code>firstName</code> и <code>lastName</code>, хранящиеся в объекте сеанса, <b>не попадают в файл cookie</b>. Файл cookie содержит только идентификатор сеанса. Значения, связанные с идентификатором сеанса, безопасны на сервере. По умолчанию данные сеанса передаются в структуру данных в памяти и остаются живыми в течение 20 минут. Когда cookie сеанса поступает в запрос, ASP.NET свяжет правильные данные сеанса с объектом <code>Session</code> после поиска данных пользователя, используя идентификатор, хранящийся в файле cookie. Если нет входящего файла cookie с идентификатором сеанса, ASP.NET создаст его с заголовком <code>Set-Cookie</code>.</p> <p>Одна из проблем безопасности, связанных с идентификаторами сеансов, заключается в том, как они могут открыть возможность кого-то захватить другой сеанс пользователя. Например, если я использую такой инструмент, как Fiddler для трассировки HTTP-трафика, я могу увидеть, что заголовок <code>Set-Cookie</code> поступает с сервера с <code>SessionID=12</code> внутри. Я мог догадаться, что у какого-то другого пользователя уже есть <code>SessionID</code> 11, и создайте HTTP-запрос с этим идентификатором, чтобы увидеть, могу ли я украсть или просмотреть HTML, предназначенный для другого пользователя. Для борьбы с этой проблемой большинство веб-приложений будут использовать большие случайные числа в качестве идентификаторов (ASP.NET использует 120 бит случайности). Идентификатор сеанса ASP.NET выглядит следующим образом, что затрудняет определение того, как будет выглядеть идентификатор сеанса другого пользователя.</p> <pre class="brush: text noskimlinks noskimwords">Set-Cookie: ASP.NET_SessionId=en5yl2yopwkdamv2ur5c3z45;    path=/; HttpOnly</pre> <hr><h2>Файлы cookie HttpOnly</h2> <p>Еще одна проблема безопасности, связанная с куки-файлами, заключается в том, насколько уязвимы они к межсайтовой скриптовой атаке (XSS). При атаке XSS злоумышленник вводит злоумышленный код JavaScript на чужой сайт. Если другой веб-сайт отправляет вредоносный скрипт своим пользователям, вредоносный скрипт может модифицировать или проверять и красть информацию cookie (что может привести к захвату сеанса или, что еще хуже).</p> <p>Для борьбы с этой уязвимостью Microsoft представила флаг<code><b> HttpOnly</b></code> (см. Последний пример <code>Set-Cookie</code>). Флаг <code>HttpOnly</code> сообщает агенту пользователя, чтобы он не разрешал коду сценария получать доступ к файлу cookie. Файл cookie существует только для «HTTP only» -т.e. для перемещения в заголовке каждого сообщения HTTP-запроса. Браузеры, которые реализуют HttpOnly не позволит JavaScript для чтения или записи файлов cookie на клиенте.</p> <hr><h2>Типы файлов cookie</h2> <p>Сookies, которые мы видели до сих пор, - это файлы <b>cookie сеанса</b>. Файлы сеансов cookie существуют для сеанса одного пользователя и уничтожаются, когда пользователь закрывает браузер. <b>Стойкие файлы cookie</b> могут пережить один сеанс просмотра, а пользовательский агент будет хранить файлы cookie на диске. Вы можете выключить компьютер и вернуться через неделю, перейти на ваш любимый веб-сайт, и постоянный файл cookie будет по-прежнему доступен для первого запроса.</p> <p>Единственное различие между ними состоит в том, что постоянному файлу cookie требуется значение <code>Expires</code>.</p> <pre class="brush: text noskimlinks noskimwords">Set-Cookie: name=value; expires=Monday, 09-July-2012 21:12:00 GMT</pre> <p>Сookie -файлы сеанса могут явно добавлять атрибут <code>Discard</code> в файл cookie, но без значения <code>Expires</code>, пользовательский агент должен в любом случае отказаться от файла cookie.</p> <hr><h2>Пути файлов cookie и домены</h2> <p>До сих пор мы говорили, что после того, как cookie будет установлен на веб-сайте, cookie отправится на сайт с каждым последующим запросом (при условии, что cookie не истек). Однако не все файлы cookie отправляются на каждый веб-сайт. Единственными файлами cookie, которые должен отправить пользовательский агент на сайт, являются файлы cookie, указанные агенту пользователя одним и тем же сайтом. Не было бы смысла использовать файлы cookie с amazon.com в HTTP-запросе на google.com. Этот тип поведения может только открыть дополнительные проблемы безопасности и конфиденциальности. Если вы установите cookie в ответ на запрос на www.server.com, полученный файл cookie будет перемещаться только по запросам на www.server.com.</p> <p>Веб-приложение также может изменить область действия cookie, чтобы ограничить куки-файл определенным хостом или доменом и даже определенным контентом ресурса. Веб-приложение контролирует область действия с использованием атрибутов <code><b>domain</b></code> и <code><b>path</b></code> .</p> <pre class="brush: text noskimlinks noskimwords">HTTP/1.1 200 OKSet-Cookie: name=value; domain=.server.com; path=/stuff...</pre> <p>Атрибут <code>domain</code> позволяет куки-файлу распространять субдомены. Другими словами, если вы установили cookie с сайта www.server.com, пользовательский агент отправит cookie только на www.server.com. Домен в предыдущем примере также позволяет cookie перемещаться по любому URL-адресу в домене server.com, включая images.server.com, help.server.com и просто на сервере server.com. Вы не можете использовать атрибут домена для охвата доменов, поэтому настройка домена на .microsoft.com в ответе на .server.com не является законной, и пользовательский агент должен отклонить файл cookie.</p> <p>Атрибут <code>path</code> может ограничивать cookie определенным контуром ресурса. В предыдущем примере cookie будет перемещаться только на сайт server.com, когда URL-адрес запроса указывает на <code>/stuff</code>, или местоположение под<code> /stuff</code>, например <code>/stuff/images</code>. Параметры пути могут помочь организовать куки, когда несколько команд создают веб-приложения по разным путям.</p> <hr><h2>Недостатки Cookie </h2> <p>Cookies файлы позволяют веб-сайтам хранить информацию в клиенте, и информация будет отправляться обратно на сайты в последующих запросах. Преимущества для веб-разработки огромны, потому что файлы cookie позволяют нам отслеживать, какой запрос принадлежит пользователю. Но у куки есть некоторые проблемы, которые мы уже коснулись.</p> <p>Cookies файлы были уязвимы для атак XSS, как мы упоминали ранее, а также получают плохую рекламу, когда сайты (особенно рекламные сайты) используют <b>сторонние файлы cookie</b> для отслеживания пользователей через Интернет. Сторонние файлы cookie - это файлы cookie, которые устанавливаются из другого домена, чем домен в адресной строке браузера. Сторонние файлы cookie имеют такую ​​возможность, потому что многие веб-сайты при отправке ресурса страницы обратно клиенту будут включать ссылки на скрипты или изображения из других URL-адресов. Запросы, поступающие на другие URL-адреса, позволяют другим сайтам устанавливать файлы cookie.</p> <p>Например, могут включать Домашняя страница на server.com <code>&lt;script&gt;</code> Это позволяет bigadvertising.com доставлять cookie, пока пользователь просматривает контент с сервера.com. Печенье может вернуться только на сайт bigadvertising.com, но если достаточно сайтов используют bigadvertising.com, тогда Big Advertising может начать профилировать отдельных пользователей и сайты, которые они посещают. Большинство веб-браузеров позволят вам отключить сторонние файлы cookie (но они включены по умолчанию).</p> <p>Однако два из самых больших недостатков для файлов cookie - это то, как они мешают кешированию и как они передают данные с каждым запросом. Любой ответ с заголовком <code>Set-Cookie</code> не должен кэшироваться, по крайней мере, не в заголовках, поскольку это может помешать идентификации пользователя и создавать проблемы безопасности. Кроме того, имейте в виду, что все, что хранится в файле cookie, видно, когда оно перемещается по сети (и в случае постоянного файла cookie, поскольку он находится на файловой системе). Поскольку мы знаем, что есть много устройств, которые могут слушать и интерпретировать HTTP-трафик, cookie никогда не должен хранить конфиденциальную информацию. Даже идентификаторы сеанса являются рискованными, поскольку, если кто-то может перехватить идентификатор другого пользователя, он может украсть данные сеанса с сервера.</p> <p>Даже со всеми этими минусами cookies не уходят. Иногда нам нужно состояние, чтобы путешествовать по HTTP, и куки предлагают эту возможность в простой, в основном прозрачной манере. Другая возможность, которую нам иногда нужна, - это возможность аутентификации пользователя. Ниже мы обсудим функции проверки подлинности.</p> <hr><h2>Проверка подлинности</h2> <p>Процесс аутентификации заставляет пользователя подтвердить свою личность, введя имя пользователя и пароль, адрес электронной почты и PIN-код или некоторые другие типы учетных данных.</p> <p>На сетевом уровне аутентификация обычно соответствует формату «запрос / ответ». Клиент будет запрашивать защищенный ресурс, и сервер будет подвергать клиенту проверку подлинности. Затем клиенту необходимо отправить другой запрос и включить учетные данные для проверки подлинности сервера. Если учетные данные являются хорошими, запрос будет успешным.</p> <p>Расширяемость HTTP позволяет HTTP поддерживать различные протоколы аутентификации. В этом разделе мы кратко рассмотрим верхние 5: основные, дайджест, Windows, формы и OpenID. Из этих пяти только два являются «официальными» в спецификации HTTP - базовые и дайджест-протоколы аутентификации. Сначала мы рассмотрим эти два.</p> <hr><h2>Обычная проверка подлинности</h2> <p>При базовой аутентификации клиент сначала запросит ресурс с обычным HTTP-сообщением.</p> <pre class="brush: text noskimlinks noskimwords">GET http://localhost/html5/ HTTP/1.1Host: localhost</pre> <p>Веб-серверы позволят вам настроить доступ к определенным файлам и каталогам. Вы можете разрешить доступ ко всем анонимным пользователям или ограничить доступ, чтобы только определенные пользователи или группы могли обращаться к файлу или каталогу. Для предыдущего запроса предположим, что сервер настроен только для того, чтобы определенные пользователи могли просматривать <code>/html5/</code> resource. В этом случае сервер выдаст запрос проверки подлинности.</p> <pre class="brush: text noskimlinks noskimwords">HTTP/1.1 401 UnauthorizedWWW-Authenticate: Basic realm="localhost"</pre> <p>Код состояния <code>401</code> сообщает клиенту, что запрос несанкционирован. Заголовок <code>WWW-Authenticate</code> сообщает клиенту собирать учетные данные пользователя и повторять попытку. Атрибут <code>realm</code> предоставляет пользовательскому агенту строку, которую он может использовать в качестве описания для защищенной области. Что происходит дальше, зависит от пользовательского агента, но большинство браузеров могут отображать пользовательский интерфейс для ввода учетных данных.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" data-src="https://cdn.tutsplus.com/net/uploads/2013/07/img008.png" class="lazy07" alt="HTTP в сжатом виде: состояние HTTP и безопасность..." title="HTTP в сжатом виде: состояние HTTP и безопасность..." width="50" height="50"><figcaption>Диалог аутентификации</figcaption></figure><p>Имея учетные данные, браузер может отправить другой запрос на сервер. Этот запрос будет включать заголовок<code> Authorization</code>.</p> <pre class="brush: text noskimlinks noskimwords">GET http://localhost/html5/ HTTP/1.1Authorization: Basic bm86aXdvdWxkbnRkb3RoYXQh</pre> <p>Значение заголовка авторизации - это имя пользователя и пароль клиента в кодировке base 64. <b>Обычная проверка подлинности по умолчанию небезопасна</b>, поскольку любой, у кого есть базовый 64-декодер, который может просматривать сообщение, может украсть пароль пользователя. По этой причине базовая аутентификация редко используется без использования защищенного HTTP, о чем мы поговорим позже.</p> <p>Сервер должен расшифровать заголовок авторизации и проверить имя пользователя и пароль в операционной системе или на любой другой системе управления учетными данными на сервере. Если учетные данные совпадают, сервер может сделать обычный ответ. Если учетные данные не совпадают, сервер должен снова ответить на статус <code>401</code>.</p> <hr><h2>Дайджест-проверка подлинности</h2> <p>Дайджест-аутентификация - это улучшение по сравнению с базовой аутентификацией, поскольку она не передает пароли пользователей с использованием кодировки base 64 (которая по сути передает пароль в виде простого текста). Вместо этого клиент должен отправить <b>дайджест </b>пароля. Клиент вычисляет дайджест с использованием алгоритма хеширования MD5 с помощью nonce, который сервер предоставляет во время проверки подлинности (nonce - это криптографический номер, используемый для предотвращения повторных атак).</p> <p>Ответ на вызов дайджест похож на основной запрос проверки подлинности, но с дополнительными значениями, поступающими с сервера в заголовке <code>WWW-Authenticate</code> для использования в криптографических функциях.</p> <pre class="brush: text noskimlinks noskimwords">HTTP/1.0 401 UnauthorizedWWW-Authenticate: Digest realm="localhost",    qop="auth,auth-int",    nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",    opaque="5ccc069c403ebaf9f0171e9517f40e41"</pre> <p>Дайджест-аутентификация лучше базовой проверки подлинности, когда защищенный HTTP недоступен, но он еще далек от совершенства. Дайджест-аутентификация по-прежнему уязвима для атак типа «человек-в-середине», когда кто-то обнюхивает сетевой трафик.</p> <hr><h2>Проверка подлинности Windows</h2> <p>Windows Integrated Authentication не является стандартным протоколом проверки подлинности, но она популярна среди продуктов и серверов Microsoft. Хотя аутентификация Windows поддерживается многими современными браузерами (не только Internet Explorer), она не работает хорошо через Интернет или где находятся прокси-серверы. Вы найдете, что это распространено на внутренних и интрасети, где существует сервер Microsoft Active Directory.</p> <p>Аутентификация Windows зависит от базовых протоколов проверки подлинности, поддерживаемых Windows, включая NTLM и Kerberos. Шаги проверки / ответа Windows Authentication очень похожи на то, что мы уже видели, но сервер укажет <code>NTLM</code> или <code>Negotiate</code> в заголовке <code>WWW-Authenticate</code> (<code>Negotiate</code> - это протокол, который позволяет клиенту выбирать Kerberos или HTML).</p> <pre class="brush: text noskimlinks noskimwords">HTTP/1.1 401 UnauthorizedWWW-Authenticate: Negotiate</pre> <p>Аутентификация Windows имеет то преимущество, что она безопасна даже без использования защищенного HTTP, и быть ненавязчивой для пользователей Internet Explorer. IE автоматически аутентифицирует пользователя при вызове сервера и будет делать это, используя учетные данные пользователя, которые он или она использовали для входа в операционную систему Windows.</p> <hr><h2>Проверка подлинности на основе форм</h2> <p>Аутентификация форм - это самый популярный подход к аутентификации пользователей через Интернет. Аутентификация на основе форм не является стандартным протоколом проверки подлинности и не использует заголовки <code>WWW-Authenticate</code> или <code>Authorization</code>. Тем не менее, многие рамки веб-приложений предоставляют некоторую поддержку для проверки подлинности на основе форм.</p> <p>При аутентификации на основе форм приложение будет отвечать на запрос для защищенного ресурса анонимным пользователем, перенаправляя пользователя на страницу входа. Переадресация - это временное перенаправление HTTP 302. Как правило, URL-адрес, запрашиваемый пользователем, может быть включен в строку запроса местоположения перенаправления, чтобы после того, как пользователь завершил вход в систему, приложение может перенаправить пользователя на защищенный ресурс, который он или она пытался достичь.</p> <pre class="brush: text noskimlinks noskimwords">HTTP/1.1 302 FoundLocation: /Login.aspx?ReturnUrl=/Admin.aspx</pre> <p>Страница входа в систему для проверки подлинности на основе форм - это HTML-форма со входами для ввода учетных данных. Когда пользователь нажимает кнопку отправки, значения формы будут отправляться в <code>POST</code>, где приложение должно принимать учетные данные и проверять их на основе записи базы данных или операционной системы.</p> <pre class="brush: html noskimlinks noskimwords">&lt;form method="post"&gt;    ...    &lt;input type="text" name="username" /&gt;    &lt;input type="password" name="password" /&gt;    &lt;input type="submit" value="Login" /&gt;&lt;/form&gt;</pre> <p>Обратите внимание, что проверка подлинности на основе форм будет передавать учетные данные пользователя в виде простого текста, поэтому, как и обычная проверка подлинности, проверка подлинности на основе форм небезопасна, если вы не используете безопасный HTTP. В ответ на сообщение <code>POST</code> с учетными данными (при условии, что учетные данные являются хорошими) приложение обычно перенаправляет пользователя обратно на защищенный ресурс, а также устанавливает cookie, указывающий, что пользователь теперь аутентифицирован.</p> <pre class="brush: text noskimlinks noskimwords">HTTP/1.1 302 FoundLocation: /admin.aspxSet-Cookie: .ASPXAUTH=9694BAB... path=/; HttpOnly</pre> <p>Для ASP.NET билет проверки подлинности (значение cookie .<code>ASPXAUTH</code>) зашифрован и хэширован для предотвращения несанкционированного доступа. Однако без безопасного HTTP cookie уязвим для перехвата, поэтому захват сеанса по-прежнему является потенциальной проблемой. Тем не менее, аутентификация форм остается популярной, поскольку она позволяет приложениям полностью контролировать процесс входа в систему и проверку учетных данных.</p> <hr><h2>OpenID</h2> <p>Хотя проверка подлинности на основе форм дает пользователю полный контроль над аутентификацией пользователей, многие приложения не хотят этого уровня контроля. В частности, приложения не хотят управлять и проверять имена пользователей и пароли (и пользователи не хотят иметь другое имя пользователя и пароль для каждого веб-сайта). OpenID является открытым стандартом для децентрализованной аутентификации. С OpenID пользователь регистрируется с провайдером идентификации OpenID, а поставщик удостоверений - это единственный сайт, который должен хранить и проверять учетные данные пользователя. Существует множество поставщиков OpenID, включая Google, Yahoo и Verisign.</p> <p>Когда приложение должно аутентифицировать пользователя, оно работает с пользователем и поставщиком идентификации пользователя. Пользователь должен в конечном счете проверить свое имя пользователя и пароль у поставщика удостоверений, но приложение будет знать, успешна ли аутентификация благодаря наличию криптографических токенов и секретов. Google просматривает этот процесс на своей веб-странице «Зарегистрированный пользователь для пользователей учетных записей Google» (<span>https://developers.google.com/accounts/docs/OpenID</span>).</p> <p>Хотя OpenID предлагает множество потенциальных преимуществ по сравнению с проверкой подлинности форм, он столкнулся с отсутствием усыновления из-за сложности в реализации, отладке и поддержке танца входа в OpenID. Мы должны надеяться, что инструментарий и каркасы продолжают развиваться, чтобы упростить подход OpenID к аутентификации.</p> <hr><h2>Безопасный HTTP</h2> <p>Ранее мы упоминали, как самоописательные текстовые HTTP-сообщения являются одной из сильных сторон сети. Любой может прочитать сообщение и понять, что внутри. Но есть много сообщений, которые мы отправляем по сети, которые мы не хотим, чтобы кто-либо еще видел. Мы обсудили некоторые из этих сценариев в этой книге. Мы не хотим, чтобы кто-либо еще в сети видел наши пароли, например, но мы также не хотим, чтобы они видели наши номера кредитных карт или номера банковских счетов. Secure HTTP решает эту проблему, шифруя сообщения, прежде чем сообщения начнут перемещаться по сети.</p> <p>Безопасный HTTP также известен как HTTPS (поскольку он использует схему <code>https</code> в URL вместо обычной схемы <code>http</code>). Порт по умолчанию для HTTP - порт 80, а порт по умолчанию для HTTPS - порт 443. Браузер подключится к соответствующему порту в зависимости от схемы (если только он не должен использовать явный порт, который присутствует в URL-адресе). HTTPS работает с использованием дополнительного уровня безопасности в стеке сетевых протоколов. Уровень безопасности существует между уровнями HTTP и TCP и включает использование протокола безопасности транспортного уровня (TLS) или предшественника TLS, известного как Secure Sockets Layer (SSL).</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=672/net/uploads/2013/07/img009.png" alt="HTTP в сжатом виде: состояние HTTP и безопасность..." title="HTTP в сжатом виде: состояние HTTP и безопасность..." width="50" height="50"><figcaption>Защищенные уровни протокола HTTP</figcaption></figure><p>HTTPS требует, чтобы сервер имел криптографический сертификат. Сертификат отправляется клиенту во время настройки связи HTTPS. Сертификат включает имя хоста сервера, и пользовательский агент может использовать сертификат для проверки того, что он действительно разговаривает с сервером, на котором, по его мнению, он разговаривает. Валидация становится возможной благодаря криптографии с открытым ключом и наличию органов сертификации, таких как Verisign, которые будут подписываться и ручаться за целостность сертификата. Администраторы должны приобретать и устанавливать сертификаты из органов сертификации.</p> <p>Есть много криптографических данных, которые мы могли бы охватить, но с точки зрения разработчика наиболее важные вещи, которые нужно знать о HTTPS:</p> <ul><li> <b>Весь трафик через HTTPS зашифровывается в запросе и ответе</b>, включая заголовки HTTP и тело сообщения, а также все после имени узла в URL-адресе. Это означает, что данные строки пути и строки запроса зашифрованы, а также все файлы cookie. HTTPS предотвращает захват сеанса, потому что никакие подслушивающие устройства не могут проверить сообщение и украсть файл cookie.</li> <li> <b>Сервер аутентифицирован клиенту благодаря сертификату сервера.</b> Если вы разговариваете с mybigbank.com через HTTPS, вы можете быть уверены, что ваши сообщения действительно отправятся на mybigbank.com, а не на тех, кто запустил прокси-сервер в сети, чтобы перехватывать запросы и трафик отмахивания от mybigbank.com</li> <li> <b>HTTPS не аутентифицирует клиента.</b> Приложениям по-прежнему необходимо реализовать проверку подлинности форм или один из других ранее упомянутых протоколов проверки подлинности, если им необходимо знать идентификатор пользователя. HTTPS делает проверку подлинности на основе форм и базовую аутентификацию более безопасной, поскольку все данные зашифрованы. Существует возможность использования клиентских сертификатов с HTTPS, а сертификаты на стороне клиента могут аутентифицировать клиента наиболее безопасным образом. Тем не менее, сертификаты на стороне клиента обычно не используются в открытом Интернете, поскольку не многие пользователи приобретут и установят личный сертификат. Корпорации могут требовать, чтобы клиентские сертификаты для сотрудников обращались к корпоративным серверам, но в этом случае корпорация может выступать в качестве центра сертификации и выдавать сертификаты сотрудников, которые они создают и управляют.</li> </ul><p>У HTTPS есть некоторые недостатки, и большинство из них связано с производительностью. HTTPS является дорогостоящим вычислительным процессом, а на крупных сайтах часто используется специализированное оборудование (ускорители SSL) для загрузки криптографических вычислений с веб-серверов. Трафик HTTPS также невозможно кэшировать в общедоступном кеше, но пользовательские агенты могут хранить ответы HTTPS в своем личном кэше. Наконец, HTTPS-соединения дороги для настройки и требуют дополнительного рукопожатия между клиентом и сервером для обмена криптографическими ключами и обеспечения того, чтобы все общались с надлежащим безопасным протоколом. Постоянное подключение может помочь амортизировать эту стоимость.</p> <p>В конце концов, если вам нужна безопасная связь, вы будете охотно платить штрафы за производительность.</p> <hr><h2>Где мы?</h2> <p>В этой статье мы рассмотрели файлы cookie, аутентификацию и защищенный HTTP. Если вы завершили весь этот сеанс, я надеюсь, что вы нашли ценную информацию, которая поможет вам при написании, обслуживании и отладке веб-приложений.</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825598-http-v-szhatom-vide-sostoyanie-http-i-bezopasnost" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Web Development" href="https://norma-studio.github.io/article5/220825598-http-v-szhatom-vide-sostoyanie-http-i-bezopasnost" class="tm-article-body__tags-item-link">Web Development</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
39422</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
617</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

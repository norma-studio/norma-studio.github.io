
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Решение проблем колбэков с помощью Async
... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Решение проблем колбэков с помощью Async
... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Решение проблем колбэков с помощью Async
... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Решение проблем колбэков с помощью Async
... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Когда мы начинаем программировать, мы узнаем, что блок кода выполняется сверху вниз. Это синхронное программирование: каждая операция завершается до начала следующей. Это здорово, когда вы делаете много вещей, которые практически не требуют времени для завершения работы компьютера, например, сложение чисел, манипулирование строкой или назначения пе...">
<meta property="og:description" content="Когда мы начинаем программировать, мы узнаем, что блок кода выполняется сверху вниз. Это синхронное программирование: каждая операция завершается до начала следующей. Это здорово, когда вы делаете много вещей, которые практически не требуют времени для завершения работы компьютера, например, сложение чисел, манипулирование строкой или назначения пе...">
<meta name="twitter:description" content="Когда мы начинаем программировать, мы узнаем, что блок кода выполняется сверху вниз. Это синхронное программирование: каждая операция завершается до начала следующей. Это здорово, когда вы делаете много вещей, которые практически не требуют времени для завершения работы компьютера, например, сложение чисел, манипулирование строкой или назначения пе...">
<meta property="aiturec:description" content="Когда мы начинаем программировать, мы узнаем, что блок кода выполняется сверху вниз. Это синхронное программирование: каждая операция завершается до начала следующей. Это здорово, когда вы делаете много вещей, которые практически не требуют времени для завершения работы компьютера, например, сложение чисел, манипулирование строкой или назначения пе...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=849/uploads/users/1197/posts/26591/image/g4694.png">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=849/uploads/users/1197/posts/26591/image/g4694.png">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=849/uploads/users/1197/posts/26591/image/g4694.png">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=849/uploads/users/1197/posts/26591/image/g4694.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=849/uploads/users/1197/posts/26591/image/g4694.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825125-reshenie-problem-kolbekov-s-pomoschyu-async.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825125-reshenie-problem-kolbekov-s-pomoschyu-async.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825125-reshenie-problem-kolbekov-s-pomoschyu-async.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825125-reshenie-problem-kolbekov-s-pomoschyu-async.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825125-reshenie-problem-kolbekov-s-pomoschyu-async.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825125-reshenie-problem-kolbekov-s-pomoschyu-async.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825125-reshenie-problem-kolbekov-s-pomoschyu-async.html" title="Решение проблем колбэков с помощью Async
... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Решение проблем колбэков с помощью Async
... | envatomarket.ru | norma-studio.github.io" title="Решение проблем колбэков с помощью Async
... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/64535356345.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825125-reshenie-problem-kolbekov-s-pomoschyu-async.html" class="tm-user-info__username" title="
В. Чендылов" aria-label="
В. Чендылов">
В. Чендылов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Решение проблем колбэков с помощью Async
...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825125-reshenie-problem-kolbekov-s-pomoschyu-async" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Node.js" href="https://norma-studio.github.io/article5/220825125-reshenie-problem-kolbekov-s-pomoschyu-async" class="tm-article-snippet__hubs-item-link"><span>Node.js</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825125-reshenie-problem-kolbekov-s-pomoschyu-async.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=849/uploads/users/1197/posts/26591/image/g4694.png">
    <meta itemprop="headline name" content="Решение проблем колбэков с помощью Async
... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Когда мы начинаем программировать, мы узнаем, что блок кода выполняется сверху вниз. Это синхронное программирование: каждая операция завершается до начала следующей. Это здорово, когда вы делаете много вещей, которые практически не требуют времени для завершения работы компьютера, например, сложение чисел, манипулирование строкой или назначения пе...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Когда мы начинаем программировать, мы узнаем, что блок кода выполняется сверху вниз. Это синхронное программирование: каждая операция завершается до начала следующей. Это здорово, когда вы делаете много вещей, которые практически не требуют времени для завершения работы компьютера, например, сложение чисел, манипулирование строкой или назначения пе...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Когда мы начинаем программировать, мы узнаем, что блок кода выполняется сверху вниз. Это синхронное программирование: каждая операция завершается до начала следующей. Это здорово, когда вы делаете много вещей, которые практически не требуют времени для завершения работы компьютера, например, сложение чисел, манипулирование строкой или назначения переменных. </p><p>Что происходит, когда вы хотите сделать что-то, что занимает относительно много времени, например, доступ к файлу на диске, отправка сетевого запроса или ожидание истечения таймера? При синхронном программировании ваш скрипт ничего не может сделать, пока он ждет. </p><p>Это может быть хорошо для чего-то простого или в ситуации, когда у вас будет несколько экземпляров вашего скрипта, но для многих серверных приложений это кошмар. <br></p><p>Встречайте асинхронное программирование. В асинхронном скрипте ваш код продолжает выполняться, ожидая чего-то, но может вернуться, когда что-то произошло. </p><p>Возьмем, например, сетевой запрос. Если вы выполняете сетевой запрос на медленный сервер, на который требуется ответить в течение трех секунд, ваш скрипт может активно делать другие вещи, пока этот медленный сервер отвечает. В этом случае три секунды для человека могут ничего не значить, но сервер может отвечать на тысячи других запросов во время ожидания. Итак, как вы обрабатываете асинхронность в Node.js? <br></p><p>Самый простой способ - обратный вызов. Обратный вызов - это просто функция, вызываемая при завершении асинхронной операции. По соглашению, функции обратного вызова Node.js имеют как минимум один аргумент, <code class="inline">err</code>. В обратных вызовах может быть больше аргументов (которые обычно представляют данные, возвращенные для обратного вызова), но первый из них будет <code class="inline">err</code>. Как вы, возможно, догадались, <code class="inline">err</code> содержит объект ошибки (если ошибка имела место быть - подробнее об этом позже).<br></p><p>Давайте рассмотрим очень простой пример. Мы будем использовать встроенный модуль файловой системы Node.js (<code class="inline">fs</code>). В этом скрипте мы прочитаем содержимое текстового файла. Последней строкой файла является <code class="inline">console.log</code>, который ставит вопрос: если вы запустите этот скрипт, вы думаете, что увидите лог до того, как мы увидим содержимое текстового файла?</p><pre class="brush: javascript noskimlinks noskimwords">var  fs  = require("fs");fs.readFile(  "a-text-file.txt",      //the filename of a text file that says "Hello!"  "utf8",                 //the encoding of the file, in this case, utf-8  function(err,text) {    //the callback    console.log("Error:",err);    //Errors, if any    console.log("Text:",text);    //the contents of the file  });//Will this be before or after the Error / Text?console.log("Does this get logged before or after the contents of the text file?"); </pre><p>Поскольку это асинхронно, мы фактически увидим последний <code class="inline">console.log</code> <i>перед</i> содержимым текстового файла. Если у вас есть файл с именем <em>a-text-file.txt</em> в том же каталоге, в котором выполняется ваш скрипт node, вы увидите, что значение <code class="inline">err</code> равно <code class="inline">null</code>, а значение <code class="inline">text</code> заполнено содержимым текстового файла. </p><p>Если у вас нет файла с именем <em>a-text-file.txt</em>, <code class="inline">err</code> возвратит объект Error, а значение <code class="inline">text</code> будет <code class="inline">undefined</code>. Это приводит к важному аспекту обратных вызовов: вы всегда должны обрабатывать свои ошибки. Чтобы обрабатывать ошибки, вам нужно проверить значение в переменной <code class="inline">err</code>; если значение присутствует, то произошла ошибка. По соглашению аргументы <code class="inline">err</code> обычно не возвращают <code class="inline">false</code>, поэтому вы можете проверить только на true.</p><pre class="brush: javascript noskimlinks noskimwords">var  fs  = require("fs");fs.readFile(  "a-text-file.txt",      //the filename of a text file that says "Hello!"  "utf8",                 //the encoding of the file, in this case, utf-8  function(err,text) {    //the callback    if (err) {      console.error(err);           //display an error to the console    } else {      console.log("Text:",text);    //no error, so display the contents of the file    }  });</pre><p>Предположим, вы хотите отобразить содержимое двух файлов в определенном порядке. Вы получите что-то вроде этого:</p><pre class="brush: javascript noskimlinks noskimwords">var  fs  = require("fs");fs.readFile(  "a-text-file.txt",      //the filename of a text file that says "Hello!"  "utf8",                 //the encoding of the file, in this case, utf-8  function(err,text) {    //the callback    if (err) {      console.error(err);           //display an error to the console    } else {      console.log("First text file:",text);    //no error, so display the contents of the file      fs.readFile(        "another-text-file.txt",  //the filename of a text file that says "Hello!"        "utf8",                   //the encoding of the file, in this case, utf-8        function(err,text) {      //the callback          if (err) {            console.error(err);                       //display an error to the console          } else {            console.log("Second text file:",text);    //no error, so display the contents of the file          }        }      );    }  });</pre><p>Код выглядит довольно неприятно и имеет ряд проблем:</p><ol><li> <p>Вы загружаете файлы последовательно; было бы более эффективно, если бы вы могли одновременно загрузить их оба и вернуть значения, когда оба загрузились полностью.</p> </li> <li> <p> </p> <p>Синтаксически это правильно, но трудно читать. Обратите внимание на количество вложенных функций и увеличивающихся вкладок. Вы могли бы сделать некоторые трюки, чтобы они выглядели немного лучше, но в итоге вы можете пожертвовать читабельностью другими способами.</p> </li> <li> <p> </p> <p>Это не очень общая цель. Это отлично работает для двух файлов, но что, если у вас было девять файлов иногда и в других случаях 22 или только один? То, как это написано в настоящее время, очень тяжело воспринимать.</p> </li> </ol><p>Не беспокойтесь, мы можем решить все эти проблемы (и многое другое) с помощью <span>async.js</span>.</p><h2>Обратные вызовы с <span>Async.js</span> </h2><p>Во-первых, давайте начнем с установки модуля async.js.</p><pre class="brush: bash noskimlinks noskimwords">npm install async —-save</pre><p>Async.js можно использовать для склеивания массивов функций либо последовательно, либо параллельно. Перепишем наш пример:</p><pre class="brush: javascript noskimlinks noskimwords">var  async = require("async"),     //async.js module  fs    = require("fs");async.series(                     //execute the functions in the first argument one after another  [                               //The first argument is an array of functions    function(cb) {                //`cb` is shorthand for "callback"      fs.readFile(        "a-text-file.txt",         "utf8",        cb      );    },    function(cb) {      fs.readFile(        "another-text-file.txt",         "utf8",        cb      );    }  ],  function(err,values) {          //The "done" callback that is ran after the functions in the array have completed    if (err) {                    //If any errors occurred when functions in the array executed, they will be sent as the err.      console.error(err);    } else {                      //If err is falsy then everything is good      console.log("First text file:",values[0]);      console.log("Second text file:",values[1]);    }  });</pre><p>Это работает почти так же, как в предыдущем примере, последовательно загружая каждый файл и отличается только тем, что читает каждый файл и не отображает результат до его завершения. Код более короткий и более чистый, чем предыдущий пример (а позже мы сделаем его еще лучше). <code class="inline">async.series</code> принимает массив функций и выполняет их одну за другой. </p><p>Каждая функция должна иметь только один аргумент, обратный вызов (или <code class="inline">cb</code> в нашем коде). <code class="inline">cb</code> должен выполняться с тем же типом аргументов, что и любой другой обратный вызов, поэтому мы можем поместить его прямо в наши аргументы <code class="inline">fs.readFile</code>. </p><p>Наконец, результаты отправляются на окончательный обратный вызов, второй аргумент - в <code class="inline">async.series</code>. Результаты сохраняются в массиве со значениями, коррелирующими с порядком функций в первом аргументе <code class="inline">async.series</code>.</p><p>С помощью async.js обработка ошибок упрощается, поскольку, если она встречает ошибку, она возвращает ошибку в аргумент окончательного обратного вызова и не будет выполнять никаких дополнительных асинхронных функций. </p><h2>А теперь все вместе</h2><p>Похожая функция <code class="inline">async.parallel</code>; она имеет те же аргументы, что и <code class="inline">async.series</code>, поэтому вы можете менять их между собой, не изменяя остальную часть вашего синтаксиса. Это хороший момент чтобы поговорить о параллелизме и одновременном выполнении. </p><p>JavaScript - это в основном однопоточный язык, то есть он может делать только одно действие за раз. Он способен выполнять некоторые задачи в отдельном потоке (например, большинство функций ввода-вывода), и именно здесь асинхронное программирование входит в игру с JS. Не путайте параллелизм с <i>concurrency</i>. </p><p>Когда вы выполняете две задачи с помощью <code class="inline">async.parallel</code>, вы не заставляете его открывать другой поток для разбора JavaScript или выполнения двух действий одновременно - вы действительно контролируете то, когда он проходит между функциями в первом аргументе <code class="inline">async.parallel</code>. Таким образом, вы ничего не получаете, просто добавив синхронный код в async.parallel. </p><p>Это лучше всего поясняется визуально:</p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=849/uploads/users/1197/posts/26591/image/g4694.png" alt="Решение проблем колбэков с помощью Async..." title="Решение проблем колбэков с помощью Async..." width="50" height="50"></figure><p>Вот наш предыдущий пример, написанный как параллельный. Единственное отличие состоит в том, что мы используем <code class="inline">async.parallel</code>, а не <code class="inline">async.series</code>.</p><pre class="brush: javascript noskimlinks noskimwords">var  async = require("async"),       //async.js module  fs    = require("fs");async.parallel(                   //execute the functions in the first argument, but don"t wait for the first function to finish to start the second  [                               //The first argument is an array of functions    function(cb) {                //`cb` is shorthand for "callback"      fs.readFile(        "a-text-file.txt",         "utf8",        cb      );    },    function(cb) {      fs.readFile(        "another-text-file.txt",         "utf8",        cb      );    }  ],  function(err,values) {          //The "done" callback that is ran after the functions in the array have completed    if (err) {                    //If any errors occurred when functions in the array executed, they will be sent as the err.      console.error(err);    } else {                      //If err is falsy then everything is good      console.log("First text file:",values[0]);      console.log("Second text file:",values[1]);    }  });</pre><h2>Вновь и вновь</h2><p>В наших предыдущих примерах выполнено фиксированное количество операций, но что произойдет, если вам потребуется переменное число асинхронных операций? Это быстро становится беспорядочным, если вы просто полагаетесь на обратные вызовы и правильную конструкцию языка, полагаясь на неуклюжие счетчики или проверки условий, которые скрывают реальный смысл вашего кода. Давайте рассмотрим приблизительный эквивалент цикла for с async.js.</p><p>В этом примере мы будем писать в десять файлов в текущий каталог с последовательными именами файлов и небольшим количеством содержимого. Вы можете изменить число, изменив значение первого аргумента <code class="inline">async.times</code>. В этом примере обратный вызов для <code class="inline">fs.writeFile</code> создает только аргумент <code class="inline">err</code>, но функция <code class="inline">async.times</code> также может поддерживать возвращаемое значение. Подобно async.series, оно передается done обратному вызову во втором аргументе в виде массива.</p><pre class="brush: javascript noskimlinks noskimwords">var  async = require("async"),  fs    = require("fs");async.times(  10,                                   // number of times to run the function   function(runCount,callback) {    fs.writeFile(      "file-"+runCount+".txt",          //the new file name      "This is file number "+runCount,  //the contents of the new file      callback    );  },  function(err) {    if (err) {      console.error(err);    } else {      console.log("Wrote files.");    }  });</pre><p>Пришло время сказать, что большинство функций async.js по умолчанию работают параллельно, а не сериями. Таким образом, в приведенном выше примере он начнет создавать файлы и сообщит, когда все они будут полностью созданы и записаны. </p><p>Те функции, которые работают по умолчанию параллельно, имеют функцию двойника для серийного выполнения, обозначенную именем, заканчивающимся, как вы догадались, «Series». Поэтому, если вы хотите запустить этот пример последовательно, а не параллельно, вы должны изменить <code class="inline">async.times</code> на <code class="inline">async.timesSeries</code>.<br></p><p>В следующем примере цикла мы рассмотрим функцию async.until. <code class="inline">async.until</code> выполняет асинхронную функцию (последовательно) до тех пор, пока не будет выполнено определенное условие. Эта функция принимает три функции в качестве аргументов. </p><p>Первая функция - это тест, в котором вы возвращаете либо true (если вы хотите остановить цикл), либо false (если вы хотите его продолжить). Второй аргумент - асинхронная функция, а последний - обратный вызов done. Взгляните на этот пример:</p><pre class="brush: javascript noskimlinks noskimwords">var  async     = require("async"),  fs        = require("fs"),  startTime = new Date().getTime(),   //the unix timestamp in milliseconds  runCount  = 0;async.until(  function () {    //return true if 4 milliseconds have elapsed, otherwise false (and continue running the script)    return new Date().getTime() &gt; (startTime + 5);  },  function(callback) {    runCount += 1;    fs.writeFile(      "timed-file-"+runCount+".txt",    //the new file name      "This is file number "+runCount,  //the contents of the new file      callback    );  },  function(err) {    if (err) {      console.error(err);    } else {      console.log("Wrote files.");    }  });</pre><p>Этот скрипт создаст новые текстовые файлы за пять миллисекунд. В начале скрипта мы получаем время начала в миллисекундах unix-эпохи, а затем в тестовой функции мы получаем текущее время и тест, чтобы увидеть, если оно на пять миллисекунд больше, чем время начала плюс пять. Если вы запускаете этот сценарий несколько раз, вы можете получить разные результаты. </p><p>На моей машине я создавал от 6 до 20 файлов за пять миллисекунд. Интересно, что если вы попытаетесь добавить <code class="inline">console.log</code> в тестовую функцию или асинхронную функцию, вы получите очень разные результаты, потому что требуется время для записи на консоль. Это просто показывает вам, что в программном обеспечении все имеет стоимость исполнения!</p><p>Цикл for - удобная структура - она позволяет вам что-то делать для каждого элемента массива. В async.js это будет функция <code class="inline">async.each</code>. Эта функция принимает три аргумента: коллекцию или массив, асинхронную функцию для каждого элемента и обратный вызов done. </p><p>В приведенном ниже примере мы берем массив строк (в данном случае типов пород собак) и создаем файл для каждой строки. Когда все файлы были созданы, выполняется обратный вызов done. Как и следовало ожидать, ошибки обрабатываются через объект <code class="inline">err</code> в обратном вызове done. <code class="inline">async.each</code> запускается параллельно, но если вы хотите запустить его последовательно, вы можете следовать ранее упомянутому шаблону и использовать <code class="inline">async.eachSeries</code> вместо <code class="inline">async.each</code>.</p><pre class="brush: javascript noskimlinks noskimwords">var  async     = require("async"),  fs        = require("fs");async.each(  //an array of sighthound dog breeds  ["greyhound","saluki","borzoi","galga","podenco","whippet","lurcher","italian-greyhound"],  function(dogBreed, callback) {    fs.writeFile(      dogBreed+".txt",                         //the new file name      "file for dogs of the breed "+dogBreed,  //the contents of the new file      callback    );  },  function(err) {    if (err) {      console.error(err);    } else {      console.log("Done writing files about dogs.");    }  });</pre><p>Кузеном <code class="inline">async.each</code> является функция <code class="inline">async.map</code>; разница в том, что вы можете передать значения обратно на ваш обратный вызов. С помощью функции <code class="inline">async.map</code> вы передаете массив или коллекцию в качестве первого аргумента, а затем асинхронная функция будет выполняться для каждого элемента массива или коллекции. Последний аргумент - это обратный вызов done. </p><p>В приведенном ниже примере представлен массив пород собак и каждый элемент используется для создания имени файла. Затем имя файла передается в <code class="inline">fs.readFile</code>, где он считывается, а значения передаются функцией обратного вызова. В итоге вы получите массив содержимого файла в аргументах завершенного обратного вызова.</p><pre class="brush: javascript noskimlinks noskimwords">var  async     = require("async"),  fs        = require("fs");async.map(  ["greyhound","saluki","borzoi","galga","podenco","whippet","lurcher","italian-greyhound"],  function(dogBreed, callback) {    fs.readFile(      dogBreed+".txt",    //the new file name      "utf8",      callback    );  },  function(err, dogBreedFileContents) {    if (err) {      console.error(err);    } else {      console.log("dog breeds");      console.log(dogBreedFileContents);    }  });</pre><p><code class="inline">async.filter</code> также очень похож на синтаксис <code class="inline">async.each</code> и <code class="inline">async.map</code>, но с фильтром вы отправляете логическое значение в обратный вызов элемента, а не в значение файла. В обратном вызове done вы получаете новый массив с только теми элементами, для которых вы передали <code class="inline">true</code> или <span>truthy</span> значение в обратном вызове для элемента. </p><pre class="brush: javascript noskimlinks noskimwords">var  async     = require("async"),  fs        = require("fs");async.filter(  ["greyhound","saluki","borzoi","galga","podenco","whippet","lurcher","italian-greyhound"],  function(dogBreed, callback) {    fs.readFile(      dogBreed+".txt",    //the new file name      "utf8",      function(err,fileContents) {        if (err) { callback(err); } else {          callback(            err,                                //this will be falsy since we checked it above            fileContents.match(/greyhound/gi)   //use RegExp to check for the string "greyhound" in the contents of the file          );        }      }    );  },  function(err, dogBreedFileContents) {    if (err) {      console.error(err);    } else {      console.log("greyhound breeds:");      console.log(dogBreedFileContents);    }  });</pre><p>В этом примере мы делаем еще несколько вещей. Обратите внимание, как мы добавляем дополнительный вызов функции и обрабатываем нашу собственную ошибку. Шаблон <code class="inline">if</code> <code class="inline">err</code> и <code class="inline">callback(err) </code>очень полезен, если вам нужно манипулировать результатами асинхронной функции, но вы все равно хотите, чтобы async.js обрабатывали ошибки. </p><p>Кроме того, вы заметите, что мы используем переменную err как первый аргумент функции обратного вызова. Сначала кажется, что это выглядит не совсем правильно. Но поскольку мы уже проверяли правдивость ошибки, мы знаем, что она <span>ложна</span> и можно безопасно переходить к обратному вызову. </p><h2>Над краем скалы</h2><p>До сих пор мы изучили ряд полезных строительных блоков, которые имеют грубые следствия в синхронном программировании. Давайте погрузиться прямо в <code class="inline">async.waterfall</code>, который не имеет эквивалента в синхронном мире. </p><p>Концепция с водопадом состоит в том, что результаты одной асинхронной функции последовательно поступают в аргументы другой асинхронной функции. Это очень мощная концепция, особенно когда вы пытаетесь объединить несколько асинхронных функций, которые полагаются друг на друга. С <code class="inline">async.waterfall</code> первым аргументом является массив функций, а второй аргумент - ваш обратный вызов. </p><p>В вашем массиве функций первая функция всегда будет начинаться с одного аргумента, обратного вызова. Каждая последующая функция должна соответствовать аргументам non-err предыдущей функции без функции err и с добавлением нового обратного вызова.</p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=849/uploads/users/1197/posts/26591/image/path5052.png" alt="Решение проблем колбэков с помощью Async..." title="Решение проблем колбэков с помощью Async..." width="50" height="50"></figure><p>В следующем примере мы начнем комбинировать некоторые концепции, используя водопад в качестве <em>клея</em>. В массиве, который является первым аргументом, мы имеем три функции: первая загружает список каталогов из текущего каталога, вторая берет список каталогов и использует <code class="inline">async.map</code> для выполнения <code class="inline">fs.stat</code> для каждого файла, а третья функция принимает список каталогов из результат работы первой функции и получает содержимое для каждого файла (<code class="inline">fs.readFile</code>).</p><p><code class="inline">async.waterfall</code> запускает каждую функцию последовательно, поэтому всегда будет запускать все функции <code class="inline">fs.stat</code> перед запуском любого <code class="inline">fs.readFile</code>. В этом первом примере вторая и третья функции не зависят друг от друга, поэтому их можно обернуть в <code class="inline">async.parallel</code>, чтобы сократить общее время выполнения, но мы снова изменим эту структуру для следующего примера.</p><p><em><strong>Примечание</strong></em>. Запустите этот пример в небольшом каталоге текстовых файлов, иначе вы долго будете получать мусор в окне терминала.</p><pre class="brush: javascript noskimlinks noskimwords">var  async     = require("async"),  fs        = require("fs");async.waterfall([    function(callback) {      fs.readdir(".",callback);               //read the current directory, pass it along to the next function.    },    function(fileNames,callback) {            //`fileNames` is the directory listing from the previous function      async.map(                                     fileNames,                             //The directory listing is just an array of filenames,        fs.stat,                               //so we can use async.map to run fs.stat for each filename        function(err,stats) {          if (err) { callback(err); } else {            callback(err,fileNames,stats);    //pass along the error, the directory listing and the stat collection to the next item in the waterfall          }        }      );    },    function(fileNames,stats,callback) {      //the directory listing, `fileNames` is joined by the collection of fs.stat objects in  `stats`      async.map(        fileNames,        function(aFileName,readCallback) {    //This time we"re taking the filenames with map and passing them along to fs.readFile to get the contents          fs.readFile(aFileName,"utf8",readCallback);        },        function(err,contents) {          if (err) { callback(err); } else {  //Now our callback will have three arguments, the original directory listing (`fileNames`), the fs.stats collection and an array of with the contents of each file            callback(err,fileNames,stats,contents);          }        }      );    }  ],  function(err, fileNames,stats,contents) {    if (err) {      console.error(err);    } else {      console.log(fileNames);      console.log(stats);      console.log(contents);    }  });</pre><p>Предположим, мы хотим получить результаты только файлов размером более 500 байт. Мы могли бы использовать вышеуказанный код, но вы бы получили размер и содержимое каждого файла, независимо от того, нужны они вам или нет. Как бы нам получить статистику по файлам и только содержимое тех файлов, которые соответствуют требованиям размера? </p><p>Во-первых, мы можем вывести все анонимные функции в именованные. Это личное предпочтение, но оно делает код немного чище и понятнее (можно использовать повторно для загрузки). Как вы можете себе представить, вам нужно получить размеры, оценить эти размеры и получить только содержимое файлов, превышающее требования к размеру. Это можно легко выполнить с помощью <code class="inline">Array.filter</code>, но это синхронная функция, и async.waterfall ожидает функции асинхронного стиля. Async.js имеет вспомогательную функцию, которая может обертывать синхронные функции в асинхронные функции, и она называется <code class="inline">async.asyncify</code>.</p><p>Нам нужно сделать три вещи, каждую из которых мы будем обертывать <code class="inline">async.asyncify</code>. Во-первых, мы возьмем файлы и массивы stat из функции <code class="inline">arrayFsStat</code>, и объединим их с помощью <code class="inline">map</code>. Затем мы отфильтровываем любые элементы, размер которых меньше 300. Наконец, мы возьмем объединенное имя файла и объект stat и снова используем <code class="inline">map</code>, чтобы просто получить имя файла. </p><p>После того, как мы получим имена файлов размером менее 300, мы будем использовать <code class="inline">async.map</code> и <code class="inline">fs.readFile</code> для получения содержимого. Существует много способов взломать это яйцо, но в нашем случае оно было разбито, чтобы показать максимальную гибкость и повторное использование кода. Подобное использование <code class="inline">async.waterfall</code> иллюстрирует, как вы можете смешивать и сопоставлять синхронный и асинхронный код.</p><pre class="brush: javascript noskimlinks noskimwords">var  async     = require("async"),  fs        = require("fs");//Our anonymous refactored into named functions function directoryListing(callback) {  fs.readdir(".",callback);}function arrayFsStat(fileNames,callback) {  async.map(    fileNames,    fs.stat,    function(err,stats) {      if (err) { callback(err); } else {        callback(err,fileNames,stats);      }    }  );}function arrayFsReadFile(fileNames,callback) {  async.map(    fileNames,    function(aFileName,readCallback) {       fs.readFile(aFileName,"utf8",readCallback);    },    function(err,contents) {      if (err) { callback(err); } else {        callback(err,contents);      }    }  );}//These functions are synchronous function mergeFilenameAndStat(fileNames,stats) {  return stats.map(function(aStatObj,index) {    aStatObj.fileName = fileNames[index];    return aStatObj;  });}function above300(combinedFilenamesAndStats) {  return combinedFilenamesAndStats    .filter(function(aStatObj) {      return aStatObj.size &gt;= 300;    });}function justFilenames(combinedFilenamesAndStats) {  return combinedFilenamesAndStats    .map(function(aCombinedFileNameAndStatObj) {      return aCombinedFileNameAndStatObj.fileName;    });}    async.waterfall([    directoryListing,    arrayFsStat,    async.asyncify(mergeFilenameAndStat),   //asyncify wraps synchronous functions in a err-first callback    async.asyncify(above300),    async.asyncify(justFilenames),    arrayFsReadFile  ],  function(err,contents) {    if (err) {      console.error(err);    } else {      console.log(contents);    }  });</pre><p>Сделав еще один шаг, давайте еще немного изменим нашу функцию. Предположим, мы хотим написать функцию, которая работает точно так же, как указано выше, но с гибкостью для поиска по любому пути. Близким кузеном к async.waterfall является <code class="inline">async.seq</code>. В то время как <code class="inline">async.waterfall</code> просто выполняет водопад функций,<code class="inline"> async.seq</code> возвращает функцию, которая выполняет водопад других функций. В дополнение к созданию функции вы можете передать значения, которые пойдут в первую асинхронную функцию. </p><p>Преобразование в <code class="inline">async.seq</code> требует лишь нескольких изменений. Во-первых, мы изменим <code class="inline">directoryListing</code>, чтобы была возможность принимать аргумент - это будет путь. Во-вторых, мы добавим переменную для хранения нашей новой функции (<code class="inline">directoryAbove300</code>). В-третьих, мы возьмем аргумент массива из <code class="inline">async.waterfall</code> и переведем его в аргументы <code class="inline">async.seq</code>. Наш обратный вызов для водопада теперь используется в качестве обратного вызова done при запуске <code class="inline">directoryAbove300</code>.<br></p><pre class="brush: javascript noskimlinks noskimwords">var  async     = require("async"),  fs        = require("fs"),  directoryAbove300;function directoryListing(initialPath,callback) { //we can pass a variable into the first function used in async.seq - the resulting function can accept arguments and pass them this first function  fs.readdir(initialPath,callback);}function arrayFsStat(fileNames,callback) {  async.map(    fileNames,    fs.stat,    function(err,stats) {      if (err) { callback(err); } else {        callback(err,fileNames,stats);      }    }  );}function arrayFsReadFile(fileNames,callback) {  async.map(    fileNames,    function(aFileName,readCallback) {       fs.readFile(aFileName,"utf8",readCallback);    },    function(err,contents) {      if (err) { callback(err); } else {        callback(err,contents);      }    }  );}function mergeFilenameAndStat(fileNames,stats) {  return stats.map(function(aStatObj,index) {    aStatObj.fileName = fileNames[index];    return aStatObj;  });}function above300(combinedFilenamesAndStats) {  return combinedFilenamesAndStats    .filter(function(aStatObj) {      return aStatObj.size &gt;= 300;    });}function justFilenames(combinedFilenamesAndStats) {  return combinedFilenamesAndStats    .map(function(aCombinedFileNameAndStatObj) {      return aCombinedFileNameAndStatObj.fileName;    })}//async.seq will produce a new function that you can use over and overdirectoryAbove300 = async.seq(  directoryListing,  arrayFsStat,  async.asyncify(mergeFilenameAndStat),  async.asyncify(above300),  async.asyncify(justFilenames),  arrayFsReadFile);directoryAbove300(  ".",  function(err, fileNames,stats,contents) {    if (err) {      console.error(err);    } else {      console.log(fileNames);    }  });</pre><h2>Замечание об обещаниях и асинхронных функциях</h2><p>Возможно, вам интересно, почему я не упомянул о <span>обещаниях</span>. У меня нет ничего против них - они очень удобны и, возможно, более элегантное решение, чем обратные вызовы, - но это другой способ взглянуть на асинхронное кодирование. </p><p>Встроенные модули Node.js используют <code class="inline">err</code>-обратные вызовы, а тысячи других модулей используют этот шаблон. Фактически, поэтому в этом руководстве используется <code class="inline">fs</code> в примерах - что-то такое же фундаментальное, как доступ к файловой системе в Node.js, использует обратные вызовы, поэтому обратного вызова без обещаний являются важной частью программирования Node.js. </p><p>Можно использовать что-то вроде <span>Bluebird</span> для переноса ошибочных обратных вызовов в функции на основе <span>Promise</span>. Async.js предоставляет множество абстракций, которые делают асинхронный код читаемым и управляемым.</p><h2>Принятие асинхронности</h2><p>JavaScript стал одним из де-факто языков работы в Интернете. Здесь есть много все, что нужно изучить, а также множество фреймворков и библиотек. Если вы ищете дополнительные ресурсы для изучения или использования в своей работе, посмотрите, что у нас есть на <span>рынке Envato</span>.<br></p><p>Но изучение асинхронности - это нечто совсем другое, и, надеюсь, этот урок показал вам, насколько она полезна.</p><p>Асинхронность - это ключ к написанию JavaScript на стороне сервера, но если она не воссоздана должным образом, ваш код может стать неуправляемым зверьком обратных вызовов. Используя библиотеку async.js, которая предоставляет ряд абстракций, вы можете обнаружить, что писать асинхронный код - только в радость.</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825125-reshenie-problem-kolbekov-s-pomoschyu-async" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Node.js" href="https://norma-studio.github.io/article5/220825125-reshenie-problem-kolbekov-s-pomoschyu-async" class="tm-article-body__tags-item-link">Node.js</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
41756</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
630</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>


<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Core Data и Swift: Управляемые объекты и fetch-запросы... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Core Data и Swift: Управляемые объекты и fetch-запросы... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Core Data и Swift: Управляемые объекты и fetch-запросы... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Core Data и Swift: Управляемые объекты и fetch-запросы... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Пока все, что мы узнали о модели данных Core Data, еще не успело забыться, самое время поработать непосредственно с Core Data. В этой статье мы познакомимся с NSManagedObject, классом, с который вы будете взаимодействовать наиболее часто-при работе с Core Data. Вы узнаете, как создавать, читать, обновлять и удалять записи....">
<meta property="og:description" content="Пока все, что мы узнали о модели данных Core Data, еще не успело забыться, самое время поработать непосредственно с Core Data. В этой статье мы познакомимся с NSManagedObject, классом, с который вы будете взаимодействовать наиболее часто-при работе с Core Data. Вы узнаете, как создавать, читать, обновлять и удалять записи....">
<meta name="twitter:description" content="Пока все, что мы узнали о модели данных Core Data, еще не успело забыться, самое время поработать непосредственно с Core Data. В этой статье мы познакомимся с NSManagedObject, классом, с который вы будете взаимодействовать наиболее часто-при работе с Core Data. Вы узнаете, как создавать, читать, обновлять и удалять записи....">
<meta property="aiturec:description" content="Пока все, что мы узнали о модели данных Core Data, еще не успело забыться, самое время поработать непосредственно с Core Data. В этой статье мы познакомимся с NSManagedObject, классом, с который вы будете взаимодействовать наиболее часто-при работе с Core Data. Вы узнаете, как создавать, читать, обновлять и удалять записи....">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/41/posts/25068/image/figure-database-contents-1.jpg">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/41/posts/25068/image/figure-database-contents-1.jpg">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/41/posts/25068/image/figure-database-contents-1.jpg">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/41/posts/25068/image/figure-database-contents-1.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/41/posts/25068/image/figure-database-contents-1.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825323-core-data-i-swift-upravlyaemye-obekty-i-fetch-zaprosy.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825323-core-data-i-swift-upravlyaemye-obekty-i-fetch-zaprosy.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825323-core-data-i-swift-upravlyaemye-obekty-i-fetch-zaprosy.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825323-core-data-i-swift-upravlyaemye-obekty-i-fetch-zaprosy.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825323-core-data-i-swift-upravlyaemye-obekty-i-fetch-zaprosy.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825323-core-data-i-swift-upravlyaemye-obekty-i-fetch-zaprosy.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825323-core-data-i-swift-upravlyaemye-obekty-i-fetch-zaprosy.html" title="Core Data и Swift: Управляемые объекты и fetch-запросы... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Core Data и Swift: Управляемые объекты и fetch-запросы... | envatomarket.ru | norma-studio.github.io" title="Core Data и Swift: Управляемые объекты и fetch-запросы... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/54332343.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825323-core-data-i-swift-upravlyaemye-obekty-i-fetch-zaprosy.html" class="tm-user-info__username" title="
В. Бухтеев" aria-label="
В. Бухтеев">
В. Бухтеев</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Core Data и Swift: Управляемые объекты и fetch-запросы...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825323-core-data-i-swift-upravlyaemye-obekty-i-fetch-zaprosy" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Core Data" href="https://norma-studio.github.io/article5/220825323-core-data-i-swift-upravlyaemye-obekty-i-fetch-zaprosy" class="tm-article-snippet__hubs-item-link"><span>Core Data</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825323-core-data-i-swift-upravlyaemye-obekty-i-fetch-zaprosy.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/41/posts/25068/image/figure-database-contents-1.jpg">
    <meta itemprop="headline name" content="Core Data и Swift: Управляемые объекты и fetch-запросы... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Пока все, что мы узнали о модели данных Core Data, еще не успело забыться, самое время поработать непосредственно с Core Data. В этой статье мы познакомимся с NSManagedObject, классом, с который вы будете взаимодействовать наиболее часто-при работе с Core Data. Вы узнаете, как создавать, читать, обновлять и удалять записи....">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Пока все, что мы узнали о модели данных Core Data, еще не успело забыться, самое время поработать непосредственно с Core Data. В этой статье мы познакомимся с NSManagedObject, классом, с который вы будете взаимодействовать наиболее часто-при работе с Core Data. Вы узнаете, как создавать, читать, обновлять и удалять записи....</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Пока все, что мы узнали о модели данных Core Data, <span>еще не успело забыться</span>, самое время поработать непосредственно с Core Data. В этой статье мы познакомимся с <code class="inline">NSManagedObject</code>, классом, с который вы будете взаимодействовать наиболее часто при работе с Core Data. Вы узнаете, как создавать, читать, обновлять и удалять записи.</p><p>Вы также узнаете несколько других классов Core Data, таких как <code class="inline">NSFetchRequest</code> и <code class="inline">NSEntityDescription</code>. Позвольте мне начать с введения о <code class="inline">NSManagedObject</code>, вашего нового лучшего друга.</p><h2>Необходимые условия</h2><p>То, что я расскажу в этой серии про Core Data применимо к iOS 7+ и OS X 10.10+, но основное внимание будет уделяться iOS. В этой серии статей я буду работать с Xcode 7.1 и Swift 2.1. Если вы предпочитаете Objective-C, то я рекомендую прочитать <span>мои предыдущие статьи о Core Data</span>.</p><h2> <span class="sectionnum">1.</span> Управляемые объекты</h2><p>Экземпляр <code class="inline">NSManagedObject</code> представляет собой запись резервного хранилища Core Data. Запомните, не имеет значения, как выглядит это резервное хранилище. Однако, возвращаясь к аналогии с базой данных, экземпляр <code class="inline">NSManagedObject</code> содержит информацию строки в таблице базы данных.</p><p>Причина, по которой Core Data использует <code class="inline">NSManagedObject</code> вместо <code class="inline">NSObject</code>, как свой базовый класс для моделирования записей, будет понятна немного позже. Прежде чем мы начнем работать с <code class="inline">NSManagedObject</code>, нам необходимо знать несколько вещей об этом классе.</p><h3><code class="inline">NSEntityDescription</code></h3><p>Каждый экземпляр <code class="inline">NSManagedObject</code> связан с экземпляром <code class="inline">NSEntityDescription</code>. Описание сущности включает в себя сведения об управляемых объектах, так <b>сущность</b> управляемых объектов включает в себя также его <b>атрибуты</b> и <b>отношения</b>.</p><h3> <code class="inline">NSManagedObjectContext</code><br></h3><p>Управляемый объект также связан с экземпляром <code class="inline">NSManagedObjectContext</code>. Контекст управляемого объекта, к которому относится управляемый объект, следит за изменениями этого управляемого объекта.</p><h2> <span class="sectionnum">2.</span> Создание записи</h2><p>С учетом вышесказанного, создание управляемого объекта делается довольно незамысловато. Чтобы убедиться в том, что управляемый объект настроен должным образом, рекомендуется использовать специальный инициализатор для создания новых экземпляров <code class="inline">NSManagedObject</code>. Давайте посмотрим, как происходит создание нового объекта person.</p><p>Откройте проект из <span>предыдущей статьи</span> или клонируйте репозиторий с <span>GitHub</span>. Так как мы не делаем полнофункционального приложения в этой статье, будем делать большую часть нашей работы в классе делегата приложения, <code class="inline">AppDelegate</code>. Откройте <b>AppDelegate.swift</b> и обновите реализацию <code class="inline">application(_:didFinishLaunchingWithOptions:)</code>, как показано ниже.</p><pre class="brush: javascript noskimlinks noskimwords">func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {    // Create Managed Object    let entityDescription = NSEntityDescription.entityForName("Person", inManagedObjectContext: self.managedObjectContext)    let newPerson = NSManagedObject(entity: entityDescription!, insertIntoManagedObjectContext: self.managedObjectContext)        return true}</pre><p>Первое, что мы делаем, - создаем экземпляр класса <code class="inline">NSEntityDescription</code> путем вызова <code class="inline">entityForName(_:inManagedObjectContext:)</code>. Мы передаем имя сущности для которой хотим создать управляемый объект - <code class="inline">"Person"</code> и экземпляр <code class="inline">NSManagedObjectContext</code>.</p><p>Почему нам нужно передавать еще и объект <code class="inline">NSManagedObjectContext</code>? Мы указываем имя для управляемого объекта, который мы хотим создать, но мы также должны сказать Core Data, где можно найти модель данных для этой сущности. Помните, что контекст управляемого объекта прочно связан с координатором постоянного хранилища, который хранит ссылку на модель данных. Когда мы передаем контекст управляемого объекта, Core Data запрашивает у координатора постоянного хранилища модель данных, чтобы найти сущность, которая нам нужна.</p><p>На втором шаге мы вызываем назначенный инициализатор класса <code class="inline">NSManagedObject</code>, <code class="inline">init(entity:insertIntoManagedObjectContext:)</code>. Мы передаем описание сущности и экземпляр <code class="inline">NSManagedObjectContext</code>. Что? Почему мы должны снова передавать экземпляр <code class="inline">NSManagedObjectContext</code>? Вспомните, что я писал ранее. Управляемый объект связан с описанием сущности <i>и</i> она живет в контексте управляемого объекта, именно поэтому мы сообщаем Core Data с каким контекстом управляемого объекта должны быть связан новый управляемый объект.</p><p>Это не слишком сложно. Да? Теперь мы создали новый объект person. Как нам изменить его атрибуты или установить взаимосвязь? Это делается с помощью метода ключ-значение (key-value). Чтобы изменить имя [first] нового объекта person, который мы только что создали, мы сделаем следующее:</p><pre class="brush: javascript noskimlinks noskimwords">// Configure New PersonnewPerson.setValue("Bart", forKey: "first")newPerson.setValue("Jacobs", forKey: "last")</pre><p>Если вы знакомы с методом ключ-значение, то это должно выглядеть очень похоже. Поскольку класс <code class="inline">NSManagedObject</code> соответствует протоколу <code class="inline">NSKeyValueCoding</code>, мы устанавливаем атрибут, вызывая <code class="inline">setValue(_:forKey:)</code>. Это так просто.</p><p>Одним из недостатков этого подхода является то, что вы легко можете ошибиться, написав неправильно имя атрибута или взаимосвязи. Кроме того, имена атрибутов Xcode не автодополняет, как, например, имена свойств. Эту проблему легко решить, мы поговорим об этом позже, в следующих статьях этой серии.</p><p>Прежде чем мы продолжим наше изучение <code class="inline">NSManagedObject</code>, давайте установить атрибуту <strong>age</strong>  объекта <code class="inline">newPerson</code> значение <strong>44</strong>.</p><pre class="brush: javascript noskimlinks noskimwords">newPerson.setValue(44, forKey: "age")</pre><h2> <span class="sectionnum">3.</span> Сохранение записи</h2><p>Несмотря на то, что у нас теперь есть новый экземпляр person, Core Data еще не сохранила этот объект в свое резервное хранилище. На данный момент управляемый объект, который мы создали, живет только в контексте управляемого объекта, куда он был добавлен. Чтобы сохранить объект person в резервное хранилище, нам нужно сохранить изменения контекста управляемого объекта путем вызова <code class="inline">save()</code> у него.</p><p>Метод <code class="inline">save()</code> - это throw-метод (то есть, он может генерировать исключение), который возвращает логическое значение для указания результата операции сохранения. Взгляните на следующий блок кода, чтобы лучше понять.</p><pre class="brush: javascript noskimlinks noskimwords">do {    try newPerson.managedObjectContext?.save()} catch {    print(error)}</pre><p>Постройте и запустите приложение, чтобы увидеть, что все работает так, как ожидалось. У вас тоже аварийное завершение? Что вам говорит консоль вывода? Это похоже на результат, что ниже?</p><pre class="brush: bash noskimlinks noskimwords">Core Data[8560:265446] *** Terminating app due to uncaught exception "NSInvalidArgumentException", reason: "Unacceptable type of value for attribute: property = "first"; desired type = NSDate; given type = Swift._NSContiguousString; value = Bart."*** First throw call stack:(  0   CoreFoundation                      0x000000010c3f1f45 __exceptionPreprocess + 165  1   libobjc.A.dylib                     0x000000010e118deb objc_exception_throw + 48  2   CoreData                            0x000000010bf8d840 _PFManagedObject_coerceValueForKeyWithDescription + 2864  3   CoreData                            0x000000010bf660d1 _sharedIMPL_setvfk_core + 177  4   Core Data                           0x000000010be82200 _TFC9Core_Data11AppDelegate11applicationfS0_FTCSo13UIApplication29didFinishLaunchingWithOptionsGSqGVSs10DictionaryCSo8NSObjectPSs9AnyObject____Sb + 624  5   Core Data                           0x000000010be82683 _TToFC9Core_Data11AppDelegate11applicationfS0_FTCSo13UIApplication29didFinishLaunchingWithOptionsGSqGVSs10DictionaryCSo8NSObjectPSs9AnyObject____Sb + 179  6   UIKit                               0x000000010cc07034 -[UIApplication _handleDelegateCallbacksWithOptions:isSuspended:restoreState:] + 272  7   UIKit                               0x000000010cc081da -[UIApplication _callInitializationDelegatesForMainScene:transitionContext:] + 3415  8   UIKit                               0x000000010cc0ead3 -[UIApplication _runWithMainScene:transitionContext:completion:] + 1750  9   UIKit                               0x000000010cc0bcb3 -[UIApplication workspaceDidEndTransaction:] + 188  10  FrontBoardServices                  0x0000000110000784 -[FBSSerialQueue _performNext] + 192  11  FrontBoardServices                  0x0000000110000af2 -[FBSSerialQueue _performNextFromRunLoopSource] + 45  12  CoreFoundation                      0x000000010c31e011 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17  13  CoreFoundation                      0x000000010c313f3c __CFRunLoopDoSources0 + 556  14  CoreFoundation                      0x000000010c3133f3 __CFRunLoopRun + 867  15  CoreFoundation                      0x000000010c312e08 CFRunLoopRunSpecific + 488  16  UIKit                               0x000000010cc0b605 -[UIApplication _run] + 402  17  UIKit                               0x000000010cc1041d UIApplicationMain + 171  18  Core Data                           0x000000010be8377d main + 109  19  libdyld.dylib                       0x000000010ec3092d start + 1  20  ???                                 0x0000000000000001 0x0 + 1)libc++abi.dylib: terminating with uncaught exception of type NSException</pre><p>Xcode говорит нам, что он ожидал экземпляр <code class="inline">NSDate</code> для атрибута <strong>first</strong>, но мы передали <code class="inline">String</code>. Если вы откроете модель Core Data, которую мы создали в предыдущей статье, то увидите, что типом атрибута <strong>first</strong> действительно является <b>Date</b>. Измените его на <b>String</b> и запустить приложение еще раз.</p><p>Снова аварийное завершение? Несмотря на то, что это более сложная тема, важно понять, что происходит.</p><h3>Совместимость моделей данных</h3><p>Выходные данные в консоли Xcode должен выглядеть аналогично тому, как представлено ниже. Обратите внимание, что ошибка отличается от предыдущей. Xcode говорит нам, что <b>модель, которая используется для открытия хранилища не совместима с той, что использовалась для его создания</b>. Как же это произошло?</p><pre class="brush: bash noskimlinks noskimwords">Core Data[8879:267986] CoreData: error: -addPersistentStoreWithType:SQLite configuration:(null) URL:file:///Users/Bart/Library/Developer/CoreSimulator/Devices/A263775B-4D73-48C8-BD79-825E0BED5128/data/Containers/Data/Application/D7298848-FC36-46EF-8C35-F890F2DB0C89/Documents/SingleViewCoreData.sqlite options:(null) ... returned error Error Domain=NSCocoaErrorDomain Code=134100 "(null)" UserInfo={metadata={    NSPersistenceFrameworkVersion = 640;    NSStoreModelVersionHashes =     {        Address = &lt;268460b1 0507da45 f37f8fb5 b17628a9 a56beb9c 8666f029 4276074d 11160d13&gt;;        Person = &lt;c9bed257 c4bca383 38cd682a 227f38a8 c1a5bb27 fb02932c 42c62714 47463637&gt;;    };    NSStoreModelVersionHashesVersion = 3;    NSStoreModelVersionIdentifiers =     (        ""    );    NSStoreType = SQLite;    NSStoreUUID = "818D6962-8576-4F35-A334-A1A470561950";    "_NSAutoVacuumLevel" = 2;}, reason=The model used to open the store is incompatible with the one used to create the store} with userInfo dictionary {    metadata =     {        NSPersistenceFrameworkVersion = 640;        NSStoreModelVersionHashes =         {            Address = &lt;268460b1 0507da45 f37f8fb5 b17628a9 a56beb9c 8666f029 4276074d 11160d13&gt;;            Person = &lt;c9bed257 c4bca383 38cd682a 227f38a8 c1a5bb27 fb02932c 42c62714 47463637&gt;;        };        NSStoreModelVersionHashesVersion = 3;        NSStoreModelVersionIdentifiers =         (            ""        );        NSStoreType = SQLite;        NSStoreUUID = "818D6962-8576-4F35-A334-A1A470561950";        "_NSAutoVacuumLevel" = 2;    };    reason = "The model used to open the store is incompatible with the one used to create the store";}Core Data[8879:267986] Unresolved error Error Domain=YOUR_ERROR_DOMAIN Code=9999 "Failed to initialize the application"s saved data" UserInfo={NSLocalizedDescription=Failed to initialize the application"s saved data, NSLocalizedFailureReason=There was an error creating or loading the application"s saved data., NSUnderlyingError=0x7fde6d9acc00 {Error Domain=NSCocoaErrorDomain Code=134100 "(null)" UserInfo={metadata={    NSPersistenceFrameworkVersion = 640;    NSStoreModelVersionHashes =     {        Address = &lt;268460b1 0507da45 f37f8fb5 b17628a9 a56beb9c 8666f029 4276074d 11160d13&gt;;        Person = &lt;c9bed257 c4bca383 38cd682a 227f38a8 c1a5bb27 fb02932c 42c62714 47463637&gt;;    };    NSStoreModelVersionHashesVersion = 3;    NSStoreModelVersionIdentifiers =     (        ""    );    NSStoreType = SQLite;    NSStoreUUID = "818D6962-8576-4F35-A334-A1A470561950";    "_NSAutoVacuumLevel" = 2;}, reason=The model used to open the store is incompatible with the one used to create the store</pre><p>Когда мы впервые запустили приложение, несколько минут назад, Core Data проверив модель данных, создал на ее основе для нас хранилище, - базу данных SQLite в данном случае. Core Data все же умен. Это дает гарантию того, что структура резервного хранилища и что модели данных совместимы. Это жизненно важно, убедиться, что мы получаем обратно из резервного хранилища то, что ожидаем, то, что отправили туда в первый раз.</p><p>Во время первой аварийного завершения мы заметили, что наша модель данных содержит ошибку, и мы изменили тип атрибута <strong>first</strong> с <b>Date</b> на <b>String</b>. Другими словами, мы изменили модель данных, несмотря на то, что Core Data уже создал хранилище для нас на основе неправильной модели данных.</p><p>После обновления модели данных, мы запустили приложение снова и получили второе аварийное завершение. Одна из вещей, которые Core Data делает при создании стека - удостовериться, что модель данных и резервное хранилище (если оно создано) совместимы. Чего и не было в нашем примере, поэтому приложение аварийно завершилось.</p><p>Как нам решить эту проблему? Простое решение заключается в том, чтобы деинсталлировать приложение с устройства (симулятора) и запустить приложение снова. Однако, вы не сможете так сделать, если у вас уже есть приложение в App Store, которым пользуются люди. В этом случае следует использовать механизм миграции, который мы обсудим в одной из следующих статей.</p><p>Так как у нас нет миллионов пользователей нашего приложения, мы может безопасно его удалить с тестового устройства и запустить приложение еще раз. Если все прошло хорошо, новый объект person теперь безопасно хранится в хранилище, базе данных SQLite, созданном Core Data для нас.</p><h3>Проверка резервного хранилища</h3><p>Вы можете проверить, что операция сохранения работает,  заглянув внутрь базы данных SQLite. Если вы запускали приложения в эмуляторе, то перейдите к <b>/Users/&lt;USER&gt;/Library/Developer/CoreSimulator/Devices/&lt;DEVICE_ID&gt;/data/Containers/Data/Application/&lt;APPLICATION_ID&gt;/Documents/SingleViewCoreData.sqlite</b>. Так как расположение данных приложения изменяется с каждым выпуском Xcode, указанный выше путь действителен только для Xcode 7.</p><p>Откройте базу данных SQLite и проверьте таблицу с именем <b>ZPERSON</b>. Таблица должна иметь одну запись, ту, который мы добавили минуту назад.</p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/41/posts/25068/image/figure-database-contents-1.jpg" alt="Core Data и Swift: Управляемые объекты и fetch-запросы..." title="Core Data и Swift: Управляемые объекты и fetch-запросы..." width="50" height="50"></figure><p>Вы должны иметь ввиду две вещи. Во-первых, нет необходимости понимать структуру базы данных. Core Data управляет резервным хранилищем за нас, и нам нет необходимости понимать его структуру для работы с Core Data. Во-вторых, никогда не используйте прямой доступ к резервному хранилищу. Core Data наполняет резервное хранилище, и мы должны уважать это, если мы хотим, чтобы Core Data делал свою работу хорошо. Если мы начнем взаимодействовать с базой данных SQLite — или любым другим типом хранилища — нет гарантии, что Core Data будет продолжать функционировать должным образом. Короче говоря, Core Data отвечает за хранилище, так что оставьте его в покое.</p><h2> <span class="sectionnum">4.</span> Извлечение записей</h2><p>Несмотря на то, что мы будем подробно рассматривать  <code class="inline">NSFetchRequest</code> в следующей статье, нам нужен класс <code class="inline">NSFetchRequest</code> , чтобы запросить у Core Data информацию об объектном графе, которым он управляет. Давайте посмотрим, как мы можем получить запись, которую мы добавили ранее с помощью <code class="inline">NSFetchRequest</code>.</p><pre class="brush: javascript noskimlinks noskimwords">// Initialize Fetch Requestlet fetchRequest = NSFetchRequest()// Create Entity Descriptionlet entityDescription = NSEntityDescription.entityForName("Person", inManagedObjectContext: self.managedObjectContext)// Configure Fetch RequestfetchRequest.entity = entityDescriptiondo {    let result = try self.managedObjectContext.executeFetchRequest(fetchRequest)    print(result)    } catch {    let fetchError = error as NSError    print(fetchError)}</pre><p>После инициализации fetch-запроса, мы создаем объект <code class="inline">NSEntityDescription</code> и присваеваем его свойству <code class="inline">entity</code> этот fetch-запрос. Как вы можете видеть, мы используем класс <code class="inline">NSEntityDescription</code> для того, чтобы сказать Core Data, какая сущность нам интересна.</p><p>Выборку данных выполняет класс <code class="inline">NSManagedObjectContext</code>. Мы вызываем <code class="inline">executeFetchRequest(_:)</code>, передав туда наш fetch-запрос. Так как <code class="inline">executeFetchRequest(_:)</code> является throw-методом [то есть может привести к аварийному завершению работы приложения], мы "заворачиваем" его вызов в оператор <code class="inline">do-catch</code>.</p><p>Если fetch-запрос успешно выполнен, то метод вернет результирующий массив. Обратите внимание, что Core Data всегда возвращает массив при успешном выполнении запроса, даже если ожидаем только один результат или если Core Data не удалось найти каких-либо записей.</p><p>Запустите приложение и проверьте вывод консоли в Xcode. Ниже вы можете увидеть, что было возвращено в виде массива с одним объектом типа <code class="inline">NSManagedObject</code>. Сущность объекта - <b>Person</b> [человек].</p><pre class="brush: bash noskimlinks noskimwords">[&lt;NSManagedObject: 0x7fab71e0cee0&gt; (entity: Person; id: 0xd000000000040000 &lt;x-coredata://E9E9FE9D-D000-4F1D-BF2C-F37CEDF5FC39/Person/p1&gt; ; data: &lt;fault&gt;)]</pre><p>Для доступа к атрибутам записи, мы используем метод ключ-значение (как делали ранее). Важно хорошо усвоить работу с методом ключ-значение, если вы планируете работать с Core Data.</p><pre class="brush: javascript noskimlinks noskimwords">do {    let result = try self.managedObjectContext.executeFetchRequest(fetchRequest)        if (result.count &gt; 0) {        let person = result[0] as! NSManagedObject                print("1 - \(person)")                if let first = person.valueForKey("first"), last = person.valueForKey("last") {            print("\(first) \(last)")        }                print("2 - \(person)")    }    } catch {    let fetchError = error as NSError    print(fetchError)}</pre><p>Вы наверно удивитесь, почему я вывел объект <code class="inline">person</code> до и после вывода имени <code class="inline">person</code>. На самом деле это один из самых важных уроков этой статьи. Взгляните на вывод ниже.</p><pre class="brush: bash noskimlinks noskimwords">1 - &lt;NSManagedObject: 0x7f930b924210&gt; (entity: Person; id: 0xd000000000040000 &lt;x-coredata://E9E9FE9D-D000-4F1D-BF2C-F37CEDF5FC39/Person/p1&gt; ; data: &lt;fault&gt;)Bart Jacobs2 - &lt;NSManagedObject: 0x7f930b924210&gt; (entity: Person; id: 0xd000000000040000 &lt;x-coredata://E9E9FE9D-D000-4F1D-BF2C-F37CEDF5FC39/Person/p1&gt; ; data: {    addresses = "&lt;relationship fault: 0x7f930b924150 "addresses"&gt;";    age = 44;    first = Bart;    last = Jacobs;})</pre><p>В первый раз, когда мы выводим объект <code class="inline">person</code> в консоль, мы видим, <strong>data: &lt;fault&gt;</strong> [значение отсутствует] Второй раз, однако, данные уже содержат атрибуты и взаимосвязи объекта. Почему так? Это все связано с <b>faulting</b>, ключевой концепцией Core Data.</p><h2> <span class="sectionnum">5. </span>Faulting</h2><p>Концепция, лежащая в основе faulting [наличие  отсутствующих  значений], не уникальна для Core Data. Если вы когда-нибудь работали с <b>Active Record</b> на Ruby on Rails, то следующее будет безусловно знакомо. Концепции не являются идентичными, но очень похожи с точки зрения разработчика.</p><p>Core Data старается удерживать в памяти настолько мало, насколько это возможно. Это одна из используемых стратегий <b>faulting</b>. Когда мы извлекли записи для сущности <b>Person</b> минуту назад, Core Data выполнил запрос и получение данных, но он не полностью инициализирует эти записи.</p><p>То, что мы получили обратно - fault,  заполнитель, представляющий запись. Это объект типа <code class="inline">NSManagedObject</code> и мы можем рассматривать его именно так. С помощью не полной инициализизации записи, Core Data сохраняет низкое потребление памяти Для нашего примера это незначительный эффект, но только представьте себе, что произойдет, если бы мы запросили десятки, сотни или даже тысячи записей.</p><p>В подавляющем большинстве случаев об этом совершенно не нужно беспокоиться. В тот момент, когда вы захотите получить доступ к атрибуту или взаимосвязи управляемого объекта, fault становиться <b>fired</b>, что означает, что Core Data заменяет fault в управляемом объекте. Вы можете это наблюдать в нашем примере, также это объясняет, почему второй вывод объекта <code class="inline">person</code> не напечатал fault в консоле.</p><p>Faulting - это то, на чем спотыкаются многие новички и поэтому я хочу убедиться, что вы понимаете основы этой концепции. Мы узнаем больше о faulting в следующих статьях этой серии. Если вы хотите узнать больше о Core Data именно в части faults, то возможно вы захотите прочитать этот <span>Глубокий взгляд на faulting в Core Data</span>.</p><h2> <span class="sectionnum">6.</span> Обновление записей</h2><p>Обновление записей так же просто, как и создание новой записи. Вы получаете запись, измените атрибут или взаимосвязь и сохранить контекст управляемого объекта. Так как управляемый объект, запись, связаны с контекстом управляемого объекта, последнему известно о любых изменениях, добавлении, обновлении и удалении. Когда контекст управляемого объекта сохраняется, Core Data передает все в резервное хранилище.</p><p>Взгляните на следующий блок кода в котором мы обновляем запись: мы получили запись, изменили возраст человека и сохранинили эти изменения.</p><pre class="brush: javascript noskimlinks noskimwords">let person = result[0] as! NSManagedObjectperson.setValue(54, forKey: "age")do {    try person.managedObjectContext?.save()} catch {    let saveError = error as NSError    print(saveError)}</pre><p>Вы можете убедиться в успешном обновлении [записи], взглянув на хранилище SQLite, как мы делали ранее.</p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/41/posts/25068/image/figure-database-contents-2.jpg" alt="Core Data и Swift: Управляемые объекты и fetch-запросы..." title="Core Data и Swift: Управляемые объекты и fetch-запросы..." width="50" height="50"></figure><h2> <span class="sectionnum">7.</span> Удаление записей</h2><p>Удаление записи по той же схеме. О том, что запись надо удалить из постоянного хранилища мы сообщаем контексту управляемого объекта путем вызова <code class="inline">deleteObject(_:)</code> и передачи ему управляемого объекта, который необходимо удалить.</p><p>Удалите в нашем проекте объект person, который мы получили ранее, передав его в метод контекста управляемого объекта <code class="inline">deleteObject(_:)</code>. Обратите внимание, что операция удаления не будет передана в резервное хранилище, до тех пор, пока мы вызовем <code class="inline">save()</code> у контексте управляемого объекта.</p><pre class="brush: javascript noskimlinks noskimwords">let person = result[0] as! NSManagedObjectself.managedObjectContext.deleteObject(person)do {    try self.managedObjectContext.save()} catch {    let saveError = error as NSError    print(saveError)}</pre><p>Вы можете убедиться, что операция удаления прошла успешно, снова взглянув на хранилище SQLite.</p><figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/41/posts/25068/image/figure-database-contents-3.jpg" alt="Core Data и Swift: Управляемые объекты и fetch-запросы..." title="Core Data и Swift: Управляемые объекты и fetch-запросы..." width="50" height="50"></figure><h2>Заключение</h2><p>В этой статье мы рассмотрели намного больше, чем просто создание, получение, обновление и удаление записей. Мы затронули несколько важных концепций, лежащих в основе Core Data, таких как faulting и совместимость моделей данных.</p><p>В следующем выпуске этой серии статей вы узнаете как для создавать и обновлять взаимосвязи, также мы более глубоко рассмотрим класс <code class="inline">NSFetchRequest</code>. Кроме того, мы начнем использовать <code class="inline">NSPredicate</code> и <code class="inline">NSSortDescriptor</code> чтобы сделать наши fetch-запросы гибкими, динамичными и мощными.</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825323-core-data-i-swift-upravlyaemye-obekty-i-fetch-zaprosy" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Core Data" href="https://norma-studio.github.io/article5/220825323-core-data-i-swift-upravlyaemye-obekty-i-fetch-zaprosy" class="tm-article-body__tags-item-link">Core Data</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
30894</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
515</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

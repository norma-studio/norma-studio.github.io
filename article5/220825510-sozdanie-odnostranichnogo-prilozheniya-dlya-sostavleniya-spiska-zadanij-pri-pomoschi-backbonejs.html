
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Создание одностраничного приложения для составления списка заданий при помощи Backbone.js... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Создание одностраничного приложения для составления списка заданий при помощи Backbone.js... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Создание одностраничного приложения для составления списка заданий при помощи Backbone.js... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Создание одностраничного приложения для составления списка заданий при помощи Backbone.js... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Backbone.js – JavaScript-фреймворк для создания гибких веб-приложений. Он предоставляет Модели, Коллекции, События, Маршрутизатор и несколько других замечательных возможностей. В этом руководстве мы разработаем простое приложение для создания списка заданий с возможностями их добавления, редактирования и удаления. Мы также добавим возможность отмет...">
<meta property="og:description" content="Backbone.js – JavaScript-фреймворк для создания гибких веб-приложений. Он предоставляет Модели, Коллекции, События, Маршрутизатор и несколько других замечательных возможностей. В этом руководстве мы разработаем простое приложение для создания списка заданий с возможностями их добавления, редактирования и удаления. Мы также добавим возможность отмет...">
<meta name="twitter:description" content="Backbone.js – JavaScript-фреймворк для создания гибких веб-приложений. Он предоставляет Модели, Коллекции, События, Маршрутизатор и несколько других замечательных возможностей. В этом руководстве мы разработаем простое приложение для создания списка заданий с возможностями их добавления, редактирования и удаления. Мы также добавим возможность отмет...">
<meta property="aiturec:description" content="Backbone.js – JavaScript-фреймворк для создания гибких веб-приложений. Он предоставляет Модели, Коллекции, События, Маршрутизатор и несколько других замечательных возможностей. В этом руководстве мы разработаем простое приложение для создания списка заданий с возможностями их добавления, редактирования и удаления. Мы также добавим возможность отмет...">
<meta property="og:image" content="//www.gravatar.com/avatar/41f51e532403d466f86c65f6dc822e2b?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
<meta property="aiturec:image" content="//www.gravatar.com/avatar/41f51e532403d466f86c65f6dc822e2b?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
<meta name="twitter:image" content="//www.gravatar.com/avatar/41f51e532403d466f86c65f6dc822e2b?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
<meta property="vk:image" content="//www.gravatar.com/avatar/41f51e532403d466f86c65f6dc822e2b?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
<meta property="og:type" content="article">
<link image_src="image" href="//www.gravatar.com/avatar/41f51e532403d466f86c65f6dc822e2b?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825510-sozdanie-odnostranichnogo-prilozheniya-dlya-sostavleniya-spiska-zadanij-pri-pomoschi-backbonejs.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825510-sozdanie-odnostranichnogo-prilozheniya-dlya-sostavleniya-spiska-zadanij-pri-pomoschi-backbonejs.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825510-sozdanie-odnostranichnogo-prilozheniya-dlya-sostavleniya-spiska-zadanij-pri-pomoschi-backbonejs.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825510-sozdanie-odnostranichnogo-prilozheniya-dlya-sostavleniya-spiska-zadanij-pri-pomoschi-backbonejs.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825510-sozdanie-odnostranichnogo-prilozheniya-dlya-sostavleniya-spiska-zadanij-pri-pomoschi-backbonejs.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825510-sozdanie-odnostranichnogo-prilozheniya-dlya-sostavleniya-spiska-zadanij-pri-pomoschi-backbonejs.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825510-sozdanie-odnostranichnogo-prilozheniya-dlya-sostavleniya-spiska-zadanij-pri-pomoschi-backbonejs.html" title="Создание одностраничного приложения для составления списка заданий при помощи Backbone.js... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Создание одностраничного приложения для составления списка заданий при помощи Backbone.js... | envatomarket.ru | norma-studio.github.io" title="Создание одностраничного приложения для составления списка заданий при помощи Backbone.js... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/653463654.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825510-sozdanie-odnostranichnogo-prilozheniya-dlya-sostavleniya-spiska-zadanij-pri-pomoschi-backbonejs.html" class="tm-user-info__username" title="
С. Салин" aria-label="
С. Салин">
С. Салин</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Создание одностраничного приложения для составления списка заданий при помощи Backbone.js...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825510-sozdanie-odnostranichnogo-prilozheniya-dlya-sostavleniya-spiska-zadanij-pri-pomoschi-backbonejs" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Web Development" href="https://norma-studio.github.io/article5/220825510-sozdanie-odnostranichnogo-prilozheniya-dlya-sostavleniya-spiska-zadanij-pri-pomoschi-backbonejs" class="tm-article-snippet__hubs-item-link"><span>Web Development</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825510-sozdanie-odnostranichnogo-prilozheniya-dlya-sostavleniya-spiska-zadanij-pri-pomoschi-backbonejs.html" />
    <link itemprop="image" href="//www.gravatar.com/avatar/41f51e532403d466f86c65f6dc822e2b?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
    <meta itemprop="headline name" content="Создание одностраничного приложения для составления списка заданий при помощи Backbone.js... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Backbone.js – JavaScript-фреймворк для создания гибких веб-приложений. Он предоставляет Модели, Коллекции, События, Маршрутизатор и несколько других замечательных возможностей. В этом руководстве мы разработаем простое приложение для создания списка заданий с возможностями их добавления, редактирования и удаления. Мы также добавим возможность отмет...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Backbone.js – JavaScript-фреймворк для создания гибких веб-приложений. Он предоставляет Модели, Коллекции, События, Маршрутизатор и несколько других замечательных возможностей. В этом руководстве мы разработаем простое приложение для создания списка заданий с возможностями их добавления, редактирования и удаления. Мы также добавим возможность отмет...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p><span>Backbone.js</span> – JavaScript-фреймворк для создания гибких веб-приложений. Он предоставляет Модели, Коллекции, События, Маршрутизатор и несколько других замечательных возможностей. В этом руководстве мы разработаем простое приложение для создания списка заданий с возможностями их добавления, редактирования и удаления. Мы также добавим возможность отметить, что задание <em>выполнено</em>, и поместить его в архив. Для того чтобы длина этого поста оставалась приемлемой, мы не будем добавлять никакого взаимодействия с базой данных. Все данные будут храниться на стороне клиента.<br></p><h2>Предварительная подготовка</h2>  <p>Ниже приводится файловая структура, которую будем использовать:</p>  <pre class="brush: plain noskimlinks noskimwords">css    └── styles.cssjs    └── collections        └── ToDos.js    └── models        └── ToDo.js    └── vendor       └── backbone.js       └── jquery-1.10.2.min.js       └── underscore.js    └── views    └── App.js └── index.html</pre>  <p>Назначение пары файлов очевидно, например <code>/css/styles.css</code> и <code>/index.html</code>. В них содержатся стилевые правила CSS и HTML-разметка. В контексте Backbone.js модель является местом для хранения наших данных. Так что наши задания списка просто будут моделями. И поскольку у нас будет больше одного задания, мы организуем их в виде коллекции. Бизнес-логика (* программный код, реализующий функциональность приложения. Здесь и далее примеч. пер.) распределяется между представлениями и главным файлом приложения, <code>App.js</code>. Из зависимостей для Backbone.js обязательна только <span>Underscore.js</span>. Этот фреймворк также очень хорошо сочетается с <span>jQuery</span>, так что обе эти библиотеки добавляются в папку <code>vendor</code> (* поставщик, вендор). Все, что нам теперь необходимо, – просто написать немного HTML-разметки, и мы готовы к созданию приложения.</p>  <pre class="brush: html noskimlinks noskimwords">&lt;!doctype html&gt;&lt;html&gt;  &lt;head&gt;        &lt;title&gt;My TODOs&lt;/title&gt;        &lt;link rel="stylesheet" type="text/css" href="css/styles.css" /&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class="container"&gt;            &lt;div id="menu" class="menu cf"&gt;&lt;/div&gt;            &lt;h1&gt;&lt;/h1&gt;            &lt;div id="content"&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;script src="js/vendor/jquery-1.10.2.min.js"&gt;&lt;/script&gt;        &lt;script src="js/vendor/underscore.js"&gt;&lt;/script&gt;        &lt;script src="js/vendor/backbone.js"&gt;&lt;/script&gt;        &lt;script src="js/App.js"&gt;&lt;/script&gt;        &lt;script src="js/models/ToDo.js"&gt;&lt;/script&gt;        &lt;script src="js/collections/ToDos.js"&gt;&lt;/script&gt;        &lt;script&gt;            window.onload = function() {                // bootstrap            }        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</pre>  <p>Как вы видите, мы подключаем все внешние файлы JavaScript ближе к концу документа, поскольку согласно установившейся практике это необходимо выполнять в конце тега body. Также мы подготавливаем код для поэтапной загрузки приложения. В документе имеется контейнер для контента, меню и заголовка. Главное навигационное меню является статическим элементом, и мы не будем его менять. Мы заменим контент заголовка и элемента <code>div</code>, расположенного ниже него.</p>  <h2>Планирование приложения</h2>  <p>Всегда хорошо, если у нас имеется план перед началом работы с чем-либо. В Backbone.js нет очень строгих архитектурных принципов, которых нам следует придерживаться. Это является одним из преимуществ данного фреймворка. Так что, перед тем как приступить к реализации бизнес-логики, давайте рассмотрим основополагающие принципы.</p>  <h3>Определение пространства имен</h3>  <p>(* пространство имен – набор правил именования, регулирующий видимость объектов в программе; именованная область видимости). Согласно установившейся практике ваш код следует помещать в его собственную область видимости (* область текста программы, где может быть использован данный идентификатор (имя переменной, именованной константы, функции и т. п.)). Регистрация глобальных переменных или функций – плохая идея. Мы создадим одну модель, одну коллекцию, маршрутизатор и несколько представлений Backbone.js. Все эти элементы должны находиться в собственной области видимости. В <code>App.js</code> будет содержаться класс (* имитация класса), в котором размещается весь код.</p>  <pre class="brush: javascript noskimlinks noskimwords">// App.jsvar app = (function() {    var api = {        views: {},        models: {},        collections: {},        content: null,        router: null,        todos: null,        init: function() {            this.content = $("#content");        },        changeContent: function(el) {            this.content.empty().append(el);            return this;        },        title: function(str) {            $("h1").text(str);            return this;        }    };    var ViewsFactory = {};    var Router = Backbone.Router.extend({});    api.router = new Router();    return api;})();</pre>  <p>Выше показана типичная реализация шаблона проектирования (* обобщённое описание способа решения определённого класса задач) "<span>Открытый модуль</span>". В переменной <code>api</code> содержится объект, возвращаемый функцией и предоставляющий доступ к публичным методам класса. Свойства <code>views</code>, <code>models</code> и <code>collections</code> будут выступать в качестве вместилищ классов, возвращаемых Backbone.js. В <code>content</code> будет содержаться объект jQuery для главного контейнера пользовательского интерфейса. Здесь у нас имеется два вспомогательных метода. При помощи одного обновляется вышеупомянутый контейнер. При помощи второго задается текст заголовка страницы. Затем мы определили модуль под названием <code>ViewsFactory</code>. В нем будут создаваться наши представления, и в конце мы создали маршрутизатор.</p>  <p>Вы можете поинтересоваться, зачем нам нужна фабрика (*  класс (class) используемый для создания экземпляров (instance) других классов. Фабрика нужна, чтобы изолировать создание объектов конкретного класса) для представлений? Что ж, для работы с Backbone.js имеются некоторые распространенные шаблоны. Один из них относится к созданию и использованию представлений.</p>  <pre class="brush: javascript noskimlinks noskimwords">var ViewClass = Backbone.View.extend({ /* logic here */ });var view = new ViewClass();</pre>  <p>Хорошо, если вы инициализировали представления только единожды и оставили их в таком состоянии. Сразу после изменения данных мы обычно вызываем методы представления и обновляем контент его объекта <code>el</code>. Другим очень распространенным подходом является повторное создание всего представления или замена всего элемента DOM. Однако это не совсем удачный выбор с точки зрения производительности. Поэтому мы обычно используем вспомогательный класс, при помощи которого создается и возвращается при необходимости один экземпляр представления.</p>  <h3>Определение компонентов</h3>  <p>У нас имеется пространство имен, так что теперь мы можем приступить к созданию компонентов. Ниже показано, как выглядит код для главного меню:</p>  <pre class="brush: javascript noskimlinks noskimwords">// views/menu.jsapp.views.menu = Backbone.View.extend({    initialize: function() {},    render: function() {}});</pre>  <p>Мы создали свойство под названием <code>menu</code>, в котором хранится класс для навигационного меню. Позже мы можем добавить в модуле фабрики метод, при помощи которого создается его экземпляр.</p>  <pre class="brush: javascript noskimlinks noskimwords">var ViewsFactory = {    menu: function() {        if(!this.menuView) {            this.menuView = new api.views.menu({                 el: $("#menu")            });        }        return this.menuView;    }};</pre>  <p>Выше показано, как мы создадим все представления, и благодаря этому подходу будет гарантировано, что мы получаем только одно представление того же самого типа. В большинстве случаев этот подход работает замечательно.</p>  <h3>Поток данных</h3>  <p>В качестве точки входа приложения выступает <code>App.js</code> и содержащийся в его коде метод <code>init</code>. Ниже показано, что мы вызовем в обработчике события <code>onload</code> для объекта <code>window</code>:</p>  <pre class="brush: javascript noskimlinks noskimwords">window.onload = function() {    app.init();}</pre>  <p>После этого управление передается указанному маршрутизатору. При помощи него на основании URL-адреса выбирается, какой обработчик запускать. В Backbone.js нет типичной архитектуры Модель-Представление-Контроллер (* MVC – Model-View-Controller). Контроллер отсутствует, и большая часть логики помещается в представления. Так что мы подвязываем модели непосредственно к методам представлений, и пользовательский интерфейс после изменения данных немедленно обновляется.</p>  <h2>Управление данными</h2>  <p>Наиболее важная часть нашего небольшого проекта – данные. Нам необходимо управлять нашими заданиями, так что давайте начнем с них. Ниже приводится определение нашей модели.</p>  <pre class="brush: javascript noskimlinks noskimwords">// models/ToDo.jsapp.models.ToDo = Backbone.Model.extend({    defaults: {        title: "ToDo",        archived: false,        done: false    }});</pre>  <p>Всего лишь три поля. В первое помещается текст задания, а при помощи остальных двух, которые являются флажками, отмечается статус записи.</p>  <p>Все объекты в рассматриваемом здесь фреймворке являются собственно распределителями событий. И поскольку модель изменяется при помощи сеттеров, фреймворк знает, когда обновляются данные, и может оповестить остальные части системы об этом. Как только вы подключили что-то для этих оповещений, ваше приложение отреагирует на изменения в модели. Это действительно мощная возможность Backbone.js.</p>  <p>Как я упомянул в начале, у нас будет множество записей и мы организуем их в виде коллекции под названием <code>ToDos</code>.</p>  <pre class="brush: javascript noskimlinks noskimwords">// collections/ToDos.jsapp.collections.ToDos = Backbone.Collection.extend({    initialize: function(){        this.add({ title: "Learn JavaScript basics" });        this.add({ title: "Go to backbonejs.org" });        this.add({ title: "Develop a Backbone application" });    },    model: app.models.ToDo    up: function(index) {        if(index &gt; 0) {            var tmp = this.models[index-1];            this.models[index-1] = this.models[index];            this.models[index] = tmp;            this.trigger("change");        }    },    down: function(index) {        if(index &lt; this.models.length-1) {            var tmp = this.models[index+1];            this.models[index+1] = this.models[index];            this.models[index] = tmp;            this.trigger("change");        }    },    archive: function(archived, index) {        this.models[index].set("archived", archived);    },    changeStatus: function(done, index) {        this.models[index].set("done", done);    }});</pre>  <p>Код коллекции начинается с метода <code>initialize</code>. В нашем случае мы добавили несколько заданий по умолчанию. Конечно же, в реальном мире разработки информация будет поступать из базы данных или еще откуда-то. Но чтобы не рассеивать ваше внимание, мы сделаем это вручную. Другой характерный для коллекций момент – задание значения свойства <code>model</code>. При помощи него классу сообщается информация о типе хранимых данных. За счет остальных методов реализуется логика, касающаяся возможностей нашего приложения. При помощи функций <code>up</code> и <code>down</code> меняется порядок расположения записей. Для простоты мы будем идентифицировать каждое задание лишь при помощи индекса массива коллекции. Это означает, что если нам нужно получить одну конкретную запись, то мы должны указать ее индекс. Таким образом, для изменения порядка расположения записей нам необходимо лишь поменять местами элементы в массиве. Как вы можете догадаться из кода выше, <code>this.models</code> – тот массив, о котором мы говорим. При помощи <code>archive</code> и <code>changeStatus</code> задаются значения свойств переданного элемента. Мы добавляем эти методы здесь, так как у представлений будет доступ к коллекции <code>ToDos</code>, а не непосредственно к заданиям.</p>  <p>Также нам не нужно создавать какие-либо модели класса <code>app.models.ToDo</code>, однако нам действительно необходимо создать образец коллекции <code>app.collections.ToDos</code>.</p>  <pre class="brush: javascript noskimlinks noskimwords">// App.jsinit: function() {    this.content = $("#content");    this.todos = new api.collections.ToDos();    return this;}</pre>  <h2>Отображение нашего первого представления (Главного навигационного меню)</h2>  <p>Первое, что нам нужно отобразить, – главное навигационное меню приложения.</p>  <pre class="brush: javascript noskimlinks noskimwords">// views/menu.jsapp.views.menu = Backbone.View.extend({    template: _.template($("#tpl-menu").html()),    initialize: function() {        this.render();    },    render: function(){        this.$el.html(this.template({}));    }});</pre>  <p>В файле выше только девять строк кода, однако там происходит много крутых вещей. Во-первых, определение шаблона. Помните, что мы добавили Underscore.js в приложение? Мы будем использовать ее шаблонизатор (* программное обеспечение для комбинирования шаблонов с моделью данных для получения конечных документов), поскольку он хорошо работает и им легко пользоваться. </p>  <pre class="brush: javascript noskimlinks noskimwords">_.template(templateString, [data], [settings])</pre>  <p>В результате у вас получается функция, принимающая объект, содержащий вашу информацию в виде пар ключ-значение, и <code>templateString</code> – это HTML-разметка. Хорошо, значит в вышеприведенную функцию передается строка с HTML-разметкой, но зачем там используется <code>$("#tpl-menu").html()</code> ? При разработке небольших одностраничных приложений мы обычно добавляем шаблоны непосредственно в документ следующим образом:</p>  <pre class="brush: html noskimlinks noskimwords">// index.html&lt;script type="text/template" id="tpl-menu"&gt;    &lt;ul&gt;        &lt;li&gt;&lt;a href="#"&gt;List&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href="#archive"&gt;Archive&lt;/a&gt;&lt;/li&gt;        &lt;li class="right"&gt;&lt;a href="#new"&gt;+&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/script&gt;</pre>  <p>И поскольку это тег script, то шаблон не показывается пользователю. С другой стороны, это обычный узел DOM, так что мы могли бы получить его контент при помощи jQuery. Таким образом, при помощи небольшого фрагмента кода выше просто получается контент того тега script. </p>  <p>Метод <code>render</code> очень важен в Backbone.js. Это функция, при помощи которой отображаются данные. Обычно вы привязываете генерируемые моделью события непосредственно к этому методу. Однако в случае с главным меню нам этого не нужно.</p>  <pre class="brush: javascript noskimlinks noskimwords">this.$el.html(this.template({}));</pre>  <p><code>this.$el</code> – объект, созданный фреймворком, и у каждого представления он имеется по умолчанию (перед <code>el</code> имеется <code>$</code>, поскольку мы подключили jQuery). И по умолчанию его значением является пустой <code>&lt;div&gt;&lt;/div&gt;</code>. Естественно, вы можете изменить его при помощи свойства <code>tagName</code>. Однако здесь важнее то, что мы не присваиваем значение тому объекту непосредственно. Мы его не меняем, мы изменяем только его контент. Между строкой выше и следующей строкой существует большая разница:</p>  <pre class="brush: javascript noskimlinks noskimwords">this.$el = $(this.template({}));</pre>  <p>Смысл в том, что если вы хотите увидеть изменения в браузере, то вы должны для начала вызвать метод render, чтобы добавить представление в DOM. Иначе будет добавлен только пустой элемент div. Также может быть другой сценарий, когда у вас имеются вложенные представления. А поскольку вы меняете непосредственно свойство, то родительский компонент не обновляется. Также может нарушиться привязка к событиям, и вам нужно будет снова подключать обработчики. Таким образом, вам действительно необходимо изменять только контент <code>this.$el</code>, а не значение свойства.</p>  <p>Теперь представление готово, и нам необходимо его инициализировать. Давайте добавим его в наш модуль фабрики:</p>  <pre class="brush: javascript noskimlinks noskimwords">// App.jsvar ViewsFactory = {    menu: function() {        if(!this.menuView) {            this.menuView = new api.views.menu({                 el: $("#menu")            });        }        return this.menuView;    }};</pre>  <p>Наконец, просто вызовите метод <code>menu</code> в области для самонастройки приложения:</p>  <pre class="brush: javascript noskimlinks noskimwords">// App.jsinit: function() {    this.content = $("#content");    this.todos = new api.collections.ToDos();    ViewsFactory.menu();    return this;}</pre>  <p>Обратите внимание на то, что хотя мы и создаем новый образец класса навигационного меню, мы передаем уже существующий элемент DOM <code>$("#menu")</code>. Поэтому в свойстве <code>this.$el</code> внутри представления содержится ссылка собственно на <code>$("#menu")</code>.</p>  <h2>Добавление маршрутов</h2>  <p>В Backbone.js имеется поддержка операций <span><em>добавления состояний в стек</em></span>. Другими словами, вы можете манипулировать текущим URL-адресом браузера и переходить между страницами. Однако мы воспользуемся старыми добрыми URL-адресами с хеш-префиксом (* хеш url – все, что идет после символа #), например <code>/#edit/3</code>.</p>  <pre class="brush: javascript noskimlinks noskimwords">// App.jsvar Router = Backbone.Router.extend({    routes: {        "archive": "archive",        "new": "newToDo",        "edit/:index": "editToDo",        "delete/:index": "delteToDo",        "": "list"    },    list: function(archive) {},    archive: function() {},    newToDo: function() {},    editToDo: function(index) {},    delteToDo: function(index) {}});</pre>  <p>Выше приведен наш маршрутизатор. В хеше (* коллекция пар ключ-значение, причем ключом является строка) имеется пять маршрутов. Ключ – то, что вы будете набирать в адресной строке браузера, а значение – функция, которая будет вызываться. Обратите внимание на то, что в составе двух маршрутов имеется <code>:index</code>. Это соответствует синтаксису, которого вы должны придерживаться, если хотите реализовать поддержку динамических URL-адресов. В нашем случае, если вы наберете <code>#edit/3</code>, то при вызове <code>editToDo</code> в качестве значения параметра <code>index </code>будет передано 3. В последней паре содержится пустая строка, и это означает, что она используется для реализации перехода на домашнюю страницу нашего приложения.</p>  <h2>Отображение всего списка заданий</h2>  <p>На данный момент мы создали главное представление для нашего проекта. Данные будут переданы в него из коллекции и выведены на экран. Мы могли бы использовать одно и то же представление для двух целей – отображение всех активных заданий и тех, что помещены в архив. </p>  <p>Перед тем как продолжить реализацию представления для списка, давайте посмотрим, как оно собственно инициализируется.</p>  <pre class="brush: javascript noskimlinks noskimwords">// in App.js views factorylist: function() {    if(!this.listView) {        this.listView = new api.views.list({            model: api.todos        });    }       return this.listView;}</pre>  <p>Обратите внимание на то, что мы передаем коллекцию. Это важно, поскольку позже мы воспользуемся <code>this.model</code> для получения сохраненных данных. Фабрика возвращает наше представление для списка, однако именно при помощи маршрутизатора оно должно быть добавлено на страницу.</p>  <pre class="brush: javascript noskimlinks noskimwords">// in App.js"s routerlist: function(archive) {    var view = ViewsFactory.list();    api    .title(archive ? "Archive:" : "Your ToDos:")    .changeContent(view.$el);    view.setMode(archive ? "archive" : null).render();}</pre>  <p>Пока что метод <code>list</code> в маршрутизаторе вызывается без каких-либо аргументов. Так что представление находится не в режиме <code>archive</code>; при помощи него будут отображаться только текущие задания.</p>  <pre class="brush: javascript noskimlinks noskimwords">// views/list.jsapp.views.list = Backbone.View.extend({    mode: null,    events: {},    initialize: function() {        var handler = _.bind(this.render, this);        this.model.bind("change", handler);        this.model.bind("add", handler);        this.model.bind("remove", handler);    },    render: function() {},    priorityUp: function(e) {},    priorityDown: function(e) {},    archive: function(e) {},    changeStatus: function(e) {},    setMode: function(mode) {        this.mode = mode;        return this;    }});</pre>  <p>Свойство <code>mode</code> будет использовано при рендеринге. Если его значением является <code>"archive"</code>, то будут отображены только находящиеся в архиве записи. <code>events</code> – объект, который мы заполним очень скоро. Это место, где мы назначаем событиям DOM соответствующие обработчики. Остальные методы используются для отклика на действия со стороны пользователя и непосредственно для реализации необходимых возможностей приложения. Например, при помощи <code>priorityUp</code> и <code>priorityDown</code> меняется порядок расположения заданий. За счет <code>archive</code> элемент перемещается в архив. При помощи <code>changeStatus</code> отмечается, что задание выполнено.</p>  <p>В методе <code>initialize</code> происходит нечто интересное. Ранее мы упомянули, что обычно вы будете подвязывать к событиям, возникающим при изменениях в модели (коллекции в нашем случае), метод <code>render</code> представления. Вы можете написать <code>this.model.bind("change", this.render)</code>. Однако очень скоро вы заметите, что ключевое слово <code>this</code> в методе <code>render</code> не будет указывать на само представление. Так происходит из-за смены области видимости. В качестве обходного пути мы создаем обработчик с уже заданной областью видимости. Именно для этого и служит функция <code>bind</code> Underscore. </p>  <p>А ниже приводится реализация метода <code>render</code>.</p>  <pre class="brush: javascript noskimlinks noskimwords">// views/list.jsrender: function() {)    var html = "&lt;ul class="list"&gt;",         self = this;    this.model.each(function(todo, index) {        if(self.mode === "archive" ? todo.get("archived") === true : todo.get("archived") === false) {            var template = _.template($("#tpl-list-item").html());            html += template({                 title: todo.get("title"),                index: index,                archiveLink: self.mode === "archive" ? "unarchive" : "archive",                done: todo.get("done") ? "yes" : "no",                doneChecked: todo.get("done")  ? "checked=="checked"" : ""            });        }    });    html += "&lt;/ul&gt;";    this.$el.html(html);    this.delegateEvents();    return this;}</pre>  <p>Мы перебираем все модели коллекции и генерируем HTML-строку, которая позднее вставляется в DOM-элемент представления. Выполняется несколько проверок для определения того, принадлежат ли задания к тем, что находятся в архиве, или к текущим. При помощи флажка отмечается, что задание <em>выполнено</em>. Так что, для того чтобы это указать, нам необходимо передать атрибут <code>checked=="checked"</code> тому элементу. Вы, вероятно, заметили, что мы используем <code>this.delegateEvents()</code>. В нашем случае это необходимо, поскольку мы отвязываем представление от DOM и привязываем его к нему. Да, мы не заменяем главный элемент, однако обработчики событий удаляются. Поэтому нам необходимо указать Backbone.js, что их следует снова подключить. Использованный в коде выше шаблон выглядит следующим образом:</p>  <pre class="brush: html noskimlinks noskimwords">// index.html&lt;script type="text/template" id="tpl-list-item"&gt;    &lt;li class="cf done-&lt;%= done %&gt;" data-index="&lt;%= index %&gt;"&gt;        &lt;h2&gt;            &lt;input type="checkbox" data-status &lt;%= doneChecked %&gt; /&gt;            &lt;a href="javascript:void(0);" data-up&gt;&amp;#8593;&lt;/a&gt;            &lt;a href="javascript:void(0);" data-down&gt;&amp;#8595;&lt;/a&gt;            &lt;%= title %&gt;        &lt;/h2&gt;        &lt;div class="options"&gt;            &lt;a href="#edit/&lt;%= index %&gt;"&gt;edit&lt;/a&gt;            &lt;a href="javascript:void(0);" data-archive&gt;&lt;%= archiveLink %&gt;&lt;/a&gt;            &lt;a href="#delete/&lt;%= index %&gt;"&gt;delete&lt;/a&gt;        &lt;/div&gt;    &lt;/li&gt;&lt;/script&gt;</pre>  <p>Обратите внимание, что указан класс CSS под названием <code>done-yes</code>, при помощи которого задание отображается с зеленым фоном. Помимо этого имеется множество ссылок, которые мы будем использовать для реализации необходимых функциональных возможностей. У них всех имеются собственные атрибуты HTML5 Data. У главного узла элемента, <code>li</code>, имеется <code>data-index</code>. При помощи значения этого атрибута указывается индекс задания в коллекции. Обратите внимание на то, что специальные выражения, обернутые в <code>&lt;%= ... %&gt;</code>, передаются в функцию <code>template</code>. Это данные, передаваемые в шаблон.</p>  <p>Пора добавить некоторые события для представления. </p>  <pre class="brush: javascript noskimlinks noskimwords">// views/list.jsevents: {    "click a[data-up]": "priorityUp",    "click a[data-down]": "priorityDown",    "click a[data-archive]": "archive",    "click input[data-status]": "changeStatus"}</pre>  <p>В Backbone.js для определения событий используется просто хеш. Сначала вы указываете имя события, а затем – селектор. Значения свойств являются собственно методами представления.</p>  <pre class="brush: javascript noskimlinks noskimwords">// views/list.jspriorityUp: function(e) {    var index = parseInt(e.target.parentNode.parentNode.getAttribute("data-index"));    this.model.up(index);},priorityDown: function(e) {    var index = parseInt(e.target.parentNode.parentNode.getAttribute("data-index"));    this.model.down(index);},archive: function(e) {    var index = parseInt(e.target.parentNode.parentNode.getAttribute("data-index"));    this.model.archive(this.mode !== "archive", index); },changeStatus: function(e) {    var index = parseInt(e.target.parentNode.parentNode.getAttribute("data-index"));    this.model.changeStatus(e.target.checked, index);       }</pre>  <p>Здесь мы используем <code>e.target</code>, передаваемый в обработчик. В нем находится ссылка на элемент DOM, сгенерировавший событие. Мы получаем индекс выбранного задания и обновляем модель в коллекции. После добавления этих четырех функций наш класс готов, и теперь данные отображаются на странице. </p>  <p>Как было упомянуто ранее, мы будем использовать то же самое представление и для страницы <code>Archive</code>.</p>  <pre class="brush: javascript noskimlinks noskimwords">list: function(archive) {    var view = ViewsFactory.list();    api    .title(archive ? "Archive:" : "Your ToDos:")    .changeContent(view.$el);    view.setMode(archive ? "archive" : null).render();},archive: function() {    this.list(true);}</pre>  <p>Выше представлен тот же обработчик для маршрута, что и ранее, однако в этот раз ему в качестве аргумента передается значение <code>true</code>.</p>  <h2>Реализация возможности добавления и редактирования заданий</h2>  <p>Следуя примеру представления для списка, мы могли бы создать другое, при помощи которого отображается форма для добавления и редактирования заданий. Ниже показано, как создается класс для этого:</p>  <pre class="brush: javascript noskimlinks noskimwords">// App.js / views factoryform: function() {    if(!this.formView) {        this.formView = new api.views.form({            model: api.todos        }).on("saved", function() {            api.router.navigate("", {trigger: true});        })    }    return this.formView;}</pre>  <p>Код очень похож на тот, что видели ранее. Однако, в этот раз нам необходимо кое-что выполнить после отправления формы, а именно перенаправить пользователя на главную страницу. Как я сказал ранее, каждый объект, который наследует характеристики классов Backbone.js, является собственно распределителем событий. Имеются методы вроде <code>on</code> и <code>trigger</code>, которыми вы можете воспользоваться.</p>  <p>Перед тем как мы продолжим разбираться с представлением, давайте взглянем на HTML-шаблон:</p>  <pre class="brush: html noskimlinks noskimwords">&lt;script type="text/template" id="tpl-form"&gt;    &lt;form&gt;        &lt;textarea&gt;&lt;%= title %&gt;&lt;/textarea&gt;        &lt;button&gt;save&lt;/button&gt;    &lt;/form&gt;&lt;/script&gt;</pre>  <p>У нас имеется <code>textarea</code> и <code>button</code>. В шаблон должен передаваться аргумент <code>title</code>, значением которого должна быть пустая строка, если мы добавляем новое задание.</p>  <pre class="brush: javascript noskimlinks noskimwords">// views/form.jsapp.views.form = Backbone.View.extend({    index: false,    events: {        "click button": "save"    },    initialize: function() {        this.render();    },    render: function(index) {        var template, html = $("#tpl-form").html();        if(typeof index == "undefined") {            this.index = false;            template = _.template(html, { title: ""});        } else {            this.index = parseInt(index);            this.todoForEditing = this.model.at(this.index);            template = _.template($("#tpl-form").html(), {                title: this.todoForEditing.get("title")            });        }        this.$el.html(template);        this.$el.find("textarea").focus();        this.delegateEvents();        return this;    },    save: function(e) {        e.preventDefault();        var title = this.$el.find("textarea").val();        if(title == "") {            alert("Empty textarea!"); return;        }        if(this.index !== false) {            this.todoForEditing.set("title", title);        } else {            this.model.add({ title: title });        }           this.trigger("saved");          }});</pre>  <p>Код представления содержит всего лишь 40 строк, однако он выполняет свою задачу. Имеется всего один обработчик события, которое возникает при нажатии кнопки save. Метод render ведет себя по-разному в зависимости от значения переданного аргумента <code>index</code>. Например, если мы редактируем запись, то передаем индекс и получаем конкретную модель. Если нет, то форма пуста и будет создано новое задание. В коде выше есть несколько интересный моментов. Во-первых, в render ми воспользовались методом <code>.focus()</code> для перемещения фокуса в форму сразу после отображения представления. Опять-таки, должна быть вызвана функция <code>delegateEvents</code>, поскольку форма могла бы быть отвязана и привязана снова. Метод <code>save</code> начинается с <code>e.preventDefault()</code>. В результате поведение кнопки по умолчанию отменяется, которое в некоторых случаях может заключаться в отправлении формы. В конце, после того как все выполнено, мы генерируем событие <code>saved</code>, при помощи которого остальные части системы оповещаются о том, что задание сохранилось в коллекцию.</p>  <p>Нам необходимо реализовать два метода для маршрутизатора.</p>  <pre class="brush: javascript noskimlinks noskimwords">// App.jsnewToDo: function() {    var view = ViewsFactory.form();    api.title("Create new ToDo:").changeContent(view.$el);    view.render()},editToDo: function(index) {    var view = ViewsFactory.form();    api.title("Edit:").changeContent(view.$el);    view.render(index);}</pre>  <p>Разница между ними заключается в том, что мы передаем index, если переход выполняется по маршруту <code>edit/:index</code>. И, конечно же, заголовок страницы меняется соответствующим образом.</p>  <h2>Реализация возможности удаления записи из коллекции</h2>  <p>Для реализации этой возможности нам не нужно представление. Все необходимое может быть выполнено непосредственно в обработчике маршрутизатора.</p>  <pre class="brush: javascript noskimlinks noskimwords">delteToDo: function(index) {    api.todos.remove(api.todos.at(parseInt(index)));    api.router.navigate("", {trigger: true});}</pre>  <p>Нам известен индекс задания, которое мы хотим удалить. Имеется метод <code>remove</code> класса коллекции, который принимает объект модели. В конце перенаправляем пользователя на главную страницу, где отображается обновленный список.</p>  <h2>Заключение</h2>  <p>Backbone.js предоставляет вам все возможности, необходимые для создания полнофункциональных одностраничных приложений. Мы бы могли даже привязать его к RESTful веб-службе (* веб-служба, построенная с учётом REST (Representational State Transfer – передача состояния представления) на стороне сервера, и при помощи этого фреймворка данные вашего приложения были бы синхронизированы с базой данных. За счет событийно-управляемого подхода разработки (* стиль проектирования программных систем, при котором поведение компонента системы определяется набором возможных внешних событий и ответных реакций компонента на них) нам становится легче использовать метод модульного программирования (* один из ранних методов проектирования программ. Вся программа разбивается на модули, каждый из которых выполняет одну функцию и содержит в себе весь необходимый для этого код и переменные, что позволяет программировать и отлаживать его отдельно. Затем модули постепенно собираются вместе, пока не будет реализована вся система. Этот подход позволил уменьшить сложность разработки и отладки больших программ. Принципы модульного программирования стали составной частью ООП) и построить хорошую архитектуру. Лично я использую Backbone.js для нескольких проектов, и он отлично работает.</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825510-sozdanie-odnostranichnogo-prilozheniya-dlya-sostavleniya-spiska-zadanij-pri-pomoschi-backbonejs" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Web Development" href="https://norma-studio.github.io/article5/220825510-sozdanie-odnostranichnogo-prilozheniya-dlya-sostavleniya-spiska-zadanij-pri-pomoschi-backbonejs" class="tm-article-body__tags-item-link">Web Development</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
35365</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
566</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

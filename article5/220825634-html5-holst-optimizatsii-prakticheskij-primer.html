
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>HTML5 Холст оптимизации: практический пример... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="HTML5 Холст оптимизации: практический пример... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="HTML5 Холст оптимизации: практический пример... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="HTML5 Холст оптимизации: практический пример... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content=" Если вы занимаетесь разработкой на JavaScript достаточно долго, вы, скорее всего, разбился Ваш браузер несколько раз. Проблема, как правило, оказывается некоторые JavaScript ошибка, как бесконечный цикл while; если нет, то следующий подозреваемый-страница преобразований или анимации - то, что включает добавление и удаление элементов на веб-страниц...">
<meta property="og:description" content=" Если вы занимаетесь разработкой на JavaScript достаточно долго, вы, скорее всего, разбился Ваш браузер несколько раз. Проблема, как правило, оказывается некоторые JavaScript ошибка, как бесконечный цикл while; если нет, то следующий подозреваемый-страница преобразований или анимации - то, что включает добавление и удаление элементов на веб-страниц...">
<meta name="twitter:description" content=" Если вы занимаетесь разработкой на JavaScript достаточно долго, вы, скорее всего, разбился Ваш браузер несколько раз. Проблема, как правило, оказывается некоторые JavaScript ошибка, как бесконечный цикл while; если нет, то следующий подозреваемый-страница преобразований или анимации - то, что включает добавление и удаление элементов на веб-страниц...">
<meta property="aiturec:description" content=" Если вы занимаетесь разработкой на JavaScript достаточно долго, вы, скорее всего, разбился Ваш браузер несколько раз. Проблема, как правило, оказывается некоторые JavaScript ошибка, как бесконечный цикл while; если нет, то следующий подозреваемый-страница преобразований или анимации - то, что включает добавление и удаление элементов на веб-страниц...">
<meta property="og:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=575/active/uploads/legacy/tuts/453_optimiseCanvas/source/step1.jpg">
<meta property="aiturec:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=575/active/uploads/legacy/tuts/453_optimiseCanvas/source/step1.jpg">
<meta name="twitter:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=575/active/uploads/legacy/tuts/453_optimiseCanvas/source/step1.jpg">
<meta property="vk:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=575/active/uploads/legacy/tuts/453_optimiseCanvas/source/step1.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=575/active/uploads/legacy/tuts/453_optimiseCanvas/source/step1.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825634-html5-holst-optimizatsii-prakticheskij-primer.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825634-html5-holst-optimizatsii-prakticheskij-primer.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825634-html5-holst-optimizatsii-prakticheskij-primer.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825634-html5-holst-optimizatsii-prakticheskij-primer.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825634-html5-holst-optimizatsii-prakticheskij-primer.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825634-html5-holst-optimizatsii-prakticheskij-primer.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825634-html5-holst-optimizatsii-prakticheskij-primer.html" title="HTML5 Холст оптимизации: практический пример... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="HTML5 Холст оптимизации: практический пример... | envatomarket.ru | norma-studio.github.io" title="HTML5 Холст оптимизации: практический пример... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/45343254534.jpg" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825634-html5-holst-optimizatsii-prakticheskij-primer.html" class="tm-user-info__username" title="
С. Баранов" aria-label="
С. Баранов">
С. Баранов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>HTML5 Холст оптимизации: практический пример...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825634-html5-holst-optimizatsii-prakticheskij-primer" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Animation" href="https://norma-studio.github.io/article5/220825634-html5-holst-optimizatsii-prakticheskij-primer" class="tm-article-snippet__hubs-item-link"><span>Animation</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825634-html5-holst-optimizatsii-prakticheskij-primer.html" />
    <link itemprop="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=575/active/uploads/legacy/tuts/453_optimiseCanvas/source/step1.jpg">
    <meta itemprop="headline name" content="HTML5 Холст оптимизации: практический пример... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content=" Если вы занимаетесь разработкой на JavaScript достаточно долго, вы, скорее всего, разбился Ваш браузер несколько раз. Проблема, как правило, оказывается некоторые JavaScript ошибка, как бесконечный цикл while; если нет, то следующий подозреваемый-страница преобразований или анимации - то, что включает добавление и удаление элементов на веб-страниц...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody"> Если вы занимаетесь разработкой на JavaScript достаточно долго, вы, скорее всего, разбился Ваш браузер несколько раз. Проблема, как правило, оказывается некоторые JavaScript ошибка, как бесконечный цикл while; если нет, то следующий подозреваемый-страница преобразований или анимации - то, что включает добавление и удаление элементов на веб-страниц...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p> Если вы занимаетесь разработкой на JavaScript достаточно долго, вы, скорее всего, разбился Ваш браузер несколько раз. Проблема, как правило, оказывается некоторые JavaScript ошибка, как бесконечный цикл while; если нет, то следующий подозреваемый-страница преобразований или анимации - то, что включает добавление и удаление элементов на веб-странице или анимации CSS свойства. Этот учебник фокусируется на оптимизации анимации производится с помощью JS и HTML5 в элемент . </p><p></p> <p>  Этот учебник начинается и заканчивается с тем, что виджет HTML5 анимации, которые вы видите ниже: </p> <div></div> <p>Мы возьмем его с нами в путешествие, исследуя различные возникающие холст советы по оптимизации и методы и их применение в исходном коде JavaScript виджета. Цель состоит в том, чтобы улучшить скорость выполнения виджета и в конечном итоге с гладкой, больше жидкости виджет анимация, питание от компактной, более эффективный код JavaScript.</p> <p>Исходный файл содержит HTML и JavaScript от каждого шага в учебник, так что вы можете следовать наряду с любой точки.</p> <p>Давайте сделаем первый шаг.</p> <hr><h2>Шаг 1: играть в кино трейлер </h2> <p> Виджет создан на основе фильма Трейлер Синтел, 3D анимационное кино Фонд блендер. Он построен с использованием двух из самых интересных дополнений в HTML5: на элементе  и  элементы.</p> <p>загружает и воспроизводит видеофайл Sintel, а   генерирует свою собственную последовательность анимации, делая снимки воспроизводимого видео и смешивая их с текстом и другой графикой. Когда вы нажимаете, чтобы воспроизвести видео, холст оживает с темным фоном, это большая черно-белая копия воспроизводимого видео. Меньше, цветной экран-кадры видео копируются на место, и промелькнет она, как часть пленки рисунке.</p> <div><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=575/active/uploads/legacy/tuts/453_optimiseCanvas/source/step1.jpg" alt="HTML5 Холст оптимизации: практический пример..." title="HTML5 Холст оптимизации: практический пример..." width="50" height="50"></div> <p>В левом верхнем углу, заголовок и несколько строк текста, которые появляются и исчезают, как проигрывается анимация. Скорость работы скрипта и сопутствующие показатели включены как часть анимации, в небольшой черный ящик в левом нижнем углу с графика и яркий текст. Мы будем смотреть на этот конкретный пункт более подробно позже.</p> <p> Наконец, есть большой вращающейся лопасти, которая летает по сцене в начале анимации, графики которых загружается из внешнего файла изображения в формате PNG.</p> <hr><h2> Шаг 2: просмотрите исходный код </h2> <p> Исходный код содержит обычное соединение с HTML, CSS и JavaScript. HTML является негусто: только с помощью  и  теги, заключенный в контейнер с:</p> <pre class="brush: html noskimlinks noskimwords">&lt;div id="animationWidget" &gt;  &lt;canvas width="368" height="208" id="mainCanvas" &gt;&lt;/canvas&gt;&lt;video width="184" height="104" id="video" autobuffer="autobuffer" controls="controls" poster="poster.jpg" &gt;&lt;source src="sintel.mp4" type="video/mp4" &gt;&lt;/source&gt;&lt;source src="sintel.webm" type="video/webm" &gt;&lt;/source&gt;&lt;/video&gt;&lt;/div&gt;</pre> <p> Контейнер  присваивается идентификатор (animationWidget), которая выступает в качестве крюка для всех правила CSS применяются к нему и его содержание (ниже).</p> <pre class="brush: css noskimlinks noskimwords"> #animationWidget{border:1px #222 solid;position:relative;width: 570px;height: 220px;}#animationWidget canvas{border:1px #222 solid;position:absolute;top:5px;left:5px;}#animationWidget video{position:absolute;top:110px;left:380px;}</pre> <p> В то время как HTML и CSS являются маринованные специи и приправы, его в JavaScript, что это мясо виджета.</p> <ul><li> В верхней части, мы имеем основные объекты, которые будут часто использоваться через скрипт, в том числе ссылки на элемент canvas, а ее 2D-контекст.</li> <li> Функция init() вызывается каждый раз, когда видео начинает играть, и устанавливает все объекты, используемые в сценарии.</li> <li> В sampleVideo (функция) отражает текущего кадра воспроизводимого видео, а setBlade() загружает внешние изображения требует анимации.</li> <li> Темпы и содержание анимации контролируются функции main (), которая является как сердцебиение сценария. На регулярной основе, как только видео начинает играть, он рисует каждый кадр анимации, сначала сняв холст, то вызов каждого из пяти функций скрипта рисования: <ul><li><code> метод drawbackground()</code></li> <li><code> drawFilm()</code></li> <li><code> drawTitle()</code></li> <li><code>drawDescription()</code></li> <li><code>drawStats()</code></li> </ul></li> </ul><p> Как видно из названий, каждая функция рисования отвечает за рисование элемента в сцене анимации. Структурировать код таким образом повышает гибкость и позволяет в дальнейшем легче.</p> <p> Полный сценарий показана ниже. Найдите минутку, чтобы оценить его, и посмотреть, если вы можете определить любые изменения, которые вы хотели сделать, чтобы его ускорить.</p> <pre class="brush: javascript noskimlinks noskimwords">(function(){if( !document.createElement("canvas").getContext ){ return; } //the canvas tag isn"t supportedvar mainCanvas = document.getElementById("mainCanvas"); // points to the HTML canvas element abovevar mainContext = mainCanvas.getContext("2d"); //the drawing context of the canvas elementvar video = document.getElementById("video"); // points to the HTML video elementvar frameDuration = 33; // the animation"s speed in millisecondsvideo.addEventListener( "play", init ); // The init() function is called whenever the user presses play &amp; the video starts/continues playingvideo.addEventListener( "ended", function(){ drawStats(true); } ); //drawStats() is called one last time when the video end, to sum up all the statistics var videoSamples; // this is an array of images, used to store all the snapshots of the playing video taken over time. These images are used to create the "film reel"var backgrounds; // this is an array of images, used to store all the snapshots of the playing video taken over time. These images are used as the canvas backgroundvar blade; //An canvas element to store the image copied from blade.png var bladeSrc = "blade.png"; //path to the blade"s image source filevar lastPaintCount = 0; // stores the last value of mozPaintCount sampledvar paintCountLog = []; // an array containing all measured values of mozPaintCount over timevar speedLog = []; // an array containing all the execution speeds of main(), measured in millisecondsvar fpsLog = []; // an array containing the calculated frames per secong (fps) of the script, measured by counting the calls made to main() per secondvar frameCount = 0; // counts the number of times main() is executed per second.var frameStartTime = 0; // the last time main() was called// Called when the video starts playing. Sets up all the javascript objects required to generate the canvas animation and measure perfomancefunction init(){ if( video.currentTime &gt; 1 ){ return; }bladeSrc = new Image();bladeSrc.src = "blade.png";bladeSrc.onload = setBlade;backgrounds = [];videoSamples = [];fpsLog = [];paintCountLog = [];if( window.mozPaintCount ){ lastPaintCount = window.mozPaintCount; }speedLog = [];frameCount = 0;frameStartTime = 0;main(); setTimeout( getStats, 1000 );}// As the scripts main function, it controls the pace of the animationfunction main(){setTimeout( main, frameDuration );if( video.paused || video.ended ){ return; }var now = new Date().getTime(); if( frameStartTime ){ speedLog.push( now - frameStartTime );}frameStartTime = now;if( video.readyState &lt; 2 ){ return; }frameCount++;mainCanvas.width = mainCanvas.width; //clear the canvasdrawBackground(); drawFilm();drawDescription();drawStats();drawBlade();drawTitle();}// This function is called every second, and it calculates and stores the current frame ratefunction getStats(){if( video.readyState &gt;= 2 ){if( window.mozPaintCount ){ //this property is specific to firefox, and tracks how many times the browser has rendered the window since the document was loadedpaintCountLog.push( window.mozPaintCount - lastPaintCount );lastPaintCount = window.mozPaintCount;}fpsLog.push(frameCount);frameCount = 0;}setTimeout( getStats, 1000 );}// create blade, the ofscreen canavs that will contain the spining animation of the image copied from blade.pngfunction setBlade(){blade = document.createElement("canvas");blade.width = 400;blade.height = 400;blade.angle = 0;blade.x = -blade.height * 0.5;blade.y = mainCanvas.height/2 - blade.height/2; }// Creates and returns a new image that contains a snapshot of the currently playing video.function sampleVideo(){var newCanvas = document.createElement("canvas");newCanvas.width = video.width;newCanvas.height = video.height; newCanvas.getContext("2d").drawImage( video, 0, 0, video.width, video.height );return newCanvas;}// renders the dark background for the whole canvas element. The background features a greyscale sample of the video and a gradient overlayfunction drawBackground(){var newCanvas = document.createElement("canvas");var newContext = newCanvas.getContext("2d");newCanvas.width = mainCanvas.width;newCanvas.height = mainCanvas.height; newContext.drawImage(  video, 0, video.height * 0.1, video.width, video.height * 0.5, 0, 0, mainCanvas.width, mainCanvas.height  );var imageData, data;try{imageData = newContext.getImageData( 0, 0, mainCanvas.width, mainCanvas.height );data = imageData.data;} catch(error){ // CORS error (eg when viewed from a local file). Create a solid fill background insteadnewContext.fillStyle = "yellow";newContext.fillRect( 0, 0, mainCanvas.width, mainCanvas.height );imageData = mainContext.createImageData( mainCanvas.width, mainCanvas.height );data = imageData.data;}//loop through each pixel, turning its color into a shade of greyfor( var i = 0; i &lt; data.length; i += 4 ){var red = data[i]; var green = data[i + 1]; var blue = data[i + 2]; var grey = Math.max( red, green, blue );data[i] =  grey;data[i+1] = grey;data[i+2] = grey;}newContext.putImageData( imageData, 0, 0 );//add the gradient overlayvar gradient = newContext.createLinearGradient( mainCanvas.width/2, 0, mainCanvas.width/2, mainCanvas.height );gradient.addColorStop( 0, "#000" );gradient.addColorStop( 0.2, "#000" );gradient.addColorStop( 1, "rgba(0,0,0,0.5)" );newContext.fillStyle = gradient;newContext.fillRect( 0, 0, mainCanvas.width, mainCanvas.height );mainContext.save();mainContext.drawImage( newCanvas, 0, 0, mainCanvas.width, mainCanvas.height );mainContext.restore();}// renders the "film reel" animation that scrolls across the canvasfunction drawFilm(){var sampleWidth = 116; // the width of a sampled video frame, when painted on the canvas as part of a "film reel"var sampleHeight = 80; // the height of a sampled video frame, when painted on the canvas as part of a "film reel"var filmSpeed = 20; // determines how fast the "film reel" scrolls across the generated canvas animation.var filmTop = 120; //the y co-ordinate of the "film reel" animationvar filmAngle = -10 * Math.PI / 180; //the slant of the "film reel"var filmRight = ( videoSamples.length &gt; 0 )? videoSamples[0].x + videoSamples.length * sampleWidth : mainCanvas.width; //the right edge of the "film reel" in pixels, relative to the canvas//here, we check if the first frame of the "film reel" has scrolled out of view if( videoSamples.length &gt; 0 ){var bottomLeftX = videoSamples[0].x + sampleWidth;var bottomLeftY = filmTop + sampleHeight;bottomLeftX = Math.floor( Math.cos(filmAngle) * bottomLeftX - Math.sin(filmAngle) * bottomLeftY ); // the final display position after rotationif( bottomLeftX &lt; 0 ){ //the frame is offscreen, remove it"s refference from the film arrayvideoSamples.shift();}}// add new frames to the reel as requiredwhile( filmRight &lt;= mainCanvas.width ){var newFrame = {};newFrame.x = filmRight;newFrame.canvas = sampleVideo();videoSamples.push(newFrame);filmRight += sampleWidth;}// create the gradient fill for the reelvar gradient = mainContext.createLinearGradient( 0, 0, mainCanvas.width, mainCanvas.height );gradient.addColorStop( 0, "#0D0D0D" );gradient.addColorStop( 0.25, "#300A02" );gradient.addColorStop( 0.5, "#AF5A00" );gradient.addColorStop( 0.75, "#300A02" );gradient.addColorStop( 1, "#0D0D0D" );mainContext.save();mainContext.globalAlpha = 0.9;mainContext.fillStyle = gradient;mainContext.rotate(filmAngle);// loops through all items of film array, using the stored co-ordinate values of each to draw part of the "film reel"for( var i in videoSamples ){var sample = videoSamples[i];var punchX, punchY, punchWidth = 4, punchHeight = 6, punchInterval = 11.5;//draws the main rectangular box of the samplemainContext.beginPath();mainContext.moveTo( sample.x, filmTop );mainContext.lineTo( sample.x + sampleWidth, filmTop );mainContext.lineTo( sample.x + sampleWidth, filmTop + sampleHeight );mainContext.lineTo( sample.x, filmTop + sampleHeight );mainContext.closePath();//adds the small holes lining the top and bottom edges of the "fim reel"for( var j = 0; j &lt; 10; j++ ){punchX = sample.x + ( j * punchInterval ) + 5;punchY = filmTop + 4;mainContext.moveTo( punchX, punchY + punchHeight );mainContext.lineTo( punchX + punchWidth, punchY + punchHeight );mainContext.lineTo( punchX + punchWidth, punchY );mainContext.lineTo( punchX, punchY );mainContext.closePath();punchX = sample.x + ( j * punchInterval ) + 5;punchY = filmTop + 70;mainContext.moveTo( punchX, punchY + punchHeight );mainContext.lineTo( punchX + punchWidth, punchY + punchHeight );mainContext.lineTo( punchX + punchWidth, punchY );mainContext.lineTo( punchX, punchY );mainContext.closePath();} mainContext.fill();}//loop through all items of videoSamples array, update the x co-ordinate values of each item, and draw its stored image onto the canvasmainContext.globalCompositeOperation = "lighter";for( var i in videoSamples ){var sample = videoSamples[i];sample.x -= filmSpeed;mainContext.drawImage( sample.canvas, sample.x + 5, filmTop + 10, 110, 62 );}mainContext.restore();}// renders the canvas titlefunction drawTitle(){mainContext.save();mainContext.fillStyle = "black";mainContext.fillRect( 0, 0, 368, 25 ); mainContext.fillStyle = "white";mainContext.font = "bold 21px Georgia";mainContext.fillText( "SINTEL", 10, 20 );mainContext.restore();}// renders all the text appearing at the top left corner of the canvasfunction drawDescription(){var text = []; //stores all text items, to be displayed over time. the video is 60 seconds, and each will be visible for 10 seconds.text[0] = "Sintel is an independently produced short film, initiated by the Blender Foundation.";text[1] = "For over a year an international team of 3D animators and artists worked in the studio of the Amsterdam Blender Institute on the computer-animated short "Sintel".";text[2] = "It is an epic short film that takes place in a fantasy world, where a girl befriends a baby dragon.";text[3] = "After the little dragon is taken from her violently, she undertakes a long journey that leads her to a dramatic confrontation.";text[4] = "The script was inspired by a number of story suggestions by Martin Lodewijk around a Cinderella character (Cinder in Dutch is "Sintel"). ";text[5] = "Screenwriter Esther Wouda then worked with director Colin Levy to create a script with multiple layers, with strong characterization and dramatic impact as central goals.";text = text[Math.floor( video.currentTime / 10 )]; //use the videos current time to determine which text item to display.  mainContext.save();var alpha = 1 - ( video.currentTime % 10 ) / 10;mainContext.globalAlpha = ( alpha &lt; 5 )? alpha : 1;mainContext.fillStyle = "#fff";mainContext.font = "normal 12px Georgia";//break the text up into several lines as required, and write each line on the canvastext = text.split(" ");var colWidth = mainCanvas.width * .75;var line = "";var y = 40;for(var i in text ){line += text[i] + " ";if( mainContext.measureText(line).width &gt; colWidth ){mainContext.fillText( line, 10, y ); line = "";y += 12;}}mainContext.fillText( line, 10, y ); mainContext.restore();}//updates the bottom-right potion of the canvas with the latest perfomance statisticsfunction drawStats( average ){var x = 245.5, y = 130.5, graphScale = 0.25;mainContext.save();mainContext.font = "normal 10px monospace";mainContext.textAlign = "left";mainContext.textBaseLine = "top";mainContext.fillStyle = "black";mainContext.fillRect( x, y, 120, 75 );//draw the x and y axis lines of the graphy += 30;x += 10;mainContext.beginPath();mainContext.strokeStyle = "#888";mainContext.lineWidth = 1.5;mainContext.moveTo( x, y );mainContext.lineTo( x + 100, y );mainContext.stroke();mainContext.moveTo( x, y );mainContext.lineTo( x, y - 25 );mainContext.stroke();// draw the last 50 speedLog entries on the graphmainContext.strokeStyle = "#00ffff";mainContext.fillStyle = "#00ffff";mainContext.lineWidth = 0.3;var imax = speedLog.length;var i = ( speedLog.length &gt; 50 )? speedLog.length - 50 : 0mainContext.beginPath();for( var j = 0; i &lt; imax; i++, j += 2 ){mainContext.moveTo( x + j, y );mainContext.lineTo( x + j, y - speedLog[i] * graphScale );mainContext.stroke();}// the red line, marking the desired maximum rendering timemainContext.beginPath();mainContext.strokeStyle = "#FF0000";mainContext.lineWidth = 1;var target = y - frameDuration * graphScale;mainContext.moveTo( x, target );mainContext.lineTo( x + 100, target );mainContext.stroke();// current/average speedLog itemsy += 12;if( average ){var speed = 0;for( i in speedLog ){ speed += speedLog[i]; }speed = Math.floor( speed / speedLog.length * 10) / 10;}else {speed = speedLog[speedLog.length-1];}mainContext.fillText( "Render Time: " + speed, x, y );// canvas fpsmainContext.fillStyle = "#00ff00";y += 12;if( average ){fps = 0;for( i in fpsLog ){ fps += fpsLog[i]; }fps = Math.floor( fps / fpsLog.length * 10) / 10;}else {fps = fpsLog[fpsLog.length-1];}mainContext.fillText( " Canvas FPS: " + fps, x, y );// browser frames per second (fps), using window.mozPaintCount (firefox only)if( window.mozPaintCount ){ y += 12;if( average ){fps = 0;for( i in paintCountLog ){ fps += paintCountLog[i]; }fps = Math.floor( fps / paintCountLog.length * 10) / 10;}else {fps = paintCountLog[paintCountLog.length-1];}mainContext.fillText( "Browser FPS: " + fps, x, y );}mainContext.restore();}//draw the spining blade that appears in the begining of the animationfunction drawBlade(){ if( !blade || blade.x &gt; mainCanvas.width ){ return; }blade.x += 2.5;blade.angle = ( blade.angle - 45 ) % 360;//update blade, an ofscreen canvas containing the blade"s imagevar angle = blade.angle * Math.PI / 180;var bladeContext = blade.getContext("2d");blade.width = blade.width; //clear the canvasbladeContext.save(); bladeContext.translate( 200, 200 ); bladeContext.rotate(angle); bladeContext.drawImage( bladeSrc, -bladeSrc.width/2, -bladeSrc.height/2 );bladeContext.restore();mainContext.save(); mainContext.globalAlpha = 0.95;mainContext.drawImage( blade, blade.x, blade.y + Math.sin(angle) * 50 ); mainContext.restore();}})();</pre> <hr><h2> Шаг 3: оптимизация кода: знать правила </h2> <h3> Первое правило кодекса оптимизация производительности: нет. </h3> <p> Смысл этого правила заключается в предотвращении оптимизация ради оптимизации, так как процесс происходит по цене.</p> <p> Оптимизированный скрипт будет легче для браузера, чтобы проанализировать и обработать, но, как правило, с бременем для людей, которые будет труднее следить и поддерживать. Всякий раз, когда вы решите, что некоторые оптимизации необходимо, ставить какие-то цели заранее, так что вы не увлекайтесь процессом и перестараться.</p> <p> Цель в оптимизации этот виджет будет иметь функции main() выполнить менее чем за 33 миллисекунды, как это предполагается, который будет соответствовать частота кадров воспроизведения видео файлов (синтэл.MP4 и Синтел.формат WebM). Эти файлы были закодированы со скоростью воспроизведения 30 кадров в секунду (тридцати кадров в секунду), что означает примерно 0,33 сек или 33 миллисекунд на Кадр ( 1 секунда ÷ 30 кадров ).</p> <p> Поскольку JavaScript рисует новый кадр анимации на холст каждый раз, когда функция main() вызывается, цель нашего процесса оптимизации будет сделать эту функцию берут 33 миллисекунд или меньше каждый раз, когда он работает. Эта функция многократно вызывает сама себя с помощью метода setTimeout() в JavaScript таймер, как показано ниже.</p> <pre class="brush: javascript noskimlinks noskimwords"> var frameDuration = 33; // set the animation"s target speed in millisecondsfunction main(){if( video.paused || video.ended ){ return false; }setTimeout( main, frameDuration );</pre> <h3>  Второе правило: пока нет. </h3> <p> Это правило подчеркивает, что оптимизация всегда должно быть сделано в конце процесса развития, когда вы уже конкретизированы некоторые полный, рабочий код. Полиция оптимизация позволит нам идти на это, так как скрипт виджета-прекрасный пример полного, рабочая программа, готовая к процессу.</p> <h3>  Третье правило: не еще, а профиль первого. </h3> <p> Это правило о понимании вашей программы с точки зрения производительности. Профилирование поможет вам знать, а не догадываться, какие функции или области сценария занимают большую часть времени или часто используются, так что вы можете сосредоточиться на тех, в процессе оптимизации.  Достаточно критически важна для ведущих браузеров корабль с встроенный в JavaScript профилометры, или расширения, которые предоставляют эту услугу.</p> <p> Я побежал виджет под профайлером в Firebug, и ниже представлен скриншот результатов.</p> <div><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=575/active/uploads/legacy/tuts/453_optimiseCanvas/source/step2.jpg" alt="HTML5 Холст оптимизации: практический пример..." title="HTML5 Холст оптимизации: практический пример..." width="50" height="50"></div> <hr><h2> Шаг 4: Установите Некоторые Показатели Производительности </h2> <p> Как вы запустили виджет, я уверен, что вы нашли все Синтел вещи в порядке, и были абсолютно поражены элемент в правом нижнем углу холста, с красивой графической и блестящий текст.</p> <div><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cdn.tutsplus.com/active/uploads/legacy/tuts/453_optimiseCanvas/source/step4.jpg" class="lazy07" alt="HTML5 Холст оптимизации: практический пример..." title="HTML5 Холст оптимизации: практический пример..." width="50" height="50"></div> <p> Это не просто красивое лицо, что также обеспечивает некоторую статистику производительности в реальном времени на запущенной программы. Его на самом деле простой, голые кости профилировщика JavaScript.  Это верно! Я слышал, что ты, как профилирование, так что я положил профилировщик в кино, так что вы можете профиль во время просмотра.</p> <p> Этот график отслеживает время рендеринга, рассчитывается путем измерения, как долго каждый запуск функции main() в миллисекундах.   Профайлер-это также удобный браузер рендеринга тест скорости. На данный момент, среднее время рендеринга в Firefox 55ms, 90МС в IE 9, 41ms в Chrome, 148ms в опере и 63ms в Safari. Красная горизонтальная линия-это скорость цели, которые мы ставим на 33ms, чтобы соответствовать частоту кадров видео файлов. Чуть ниже график, скорость последнего вызова main() дается в миллисекундах.</p> <p>Профайлер-это также удобный браузер рендеринга тест скорости. На данный момент, среднее время рендеринга в Firefox 55ms, 90МС в IE 9, 41ms в Chrome, 148ms в опере и 63ms в Safari. Все браузеры были запущены на Windows XP, за исключением IE 9, который был представлен в Windows Vista для.</p> <p> Следующий метрический ниже, что это холст кадров в секунду (холст кадров в секунду), полученных путем подсчета, сколько раз в Main() вызывается в секунду. Профайлер отображает последний холст частоту кадров когда видео играет до сих пор, и когда она заканчивается, он показывает среднюю скорость всех вызовов функции main().</p> <p> Последняя метрика браузера ФПС, который измеряет, сколько браузер перерисовывает текущее окно каждую секунду. Это доступно только при просмотре виджетов в Firefox, так как он зависит от того, в настоящее время функция доступна только в браузере под названием Окно.mozPaintCount., свойство JavaScript, который отслеживает, сколько раз в окне браузера была перекрашена так как веб-страница сначала загружается.</p> <p> На перекрашивает, как правило, происходят, когда событие или действие, которое изменяет вид страницы происходит, например, когда вы прокрутите вниз страницу или наведите указатель мыши на ссылку. Это фактически реальная частота кадров в браузере, который определяется как занят текущей веб-страницы.</p> <p>Чтобы оценить, какой эффект неоптимизированных анимации на mozPaintCount, я убрал тег Canvas и JavaScript, так как для отслеживания частоты кадров браузере при проигрывании только видео. Мои тесты были сделаны в консоли Firebug, с помощью функции ниже: </p> <pre class="brush: javascript noskimlinks noskimwords">var lastPaintCount = window.mozPaintCount;setInterval( function(){console.log( window.mozPaintCount - lastPaintCount );lastPaintCount = window.mozPaintCount;}, 1000);</pre> <p>Результаты: частота кадров браузер был между 30 и 32 ФПС, когда видео играет, и упала до 0-1 ФПС, когда видео закончилось. Это означает, что Firefox был регулировать его частоту окно перерисовывается в соответствии игровое видео, закодированное при 30 кадров в секунду.  Когда был выполнен тест с ООН-оптимизирован анимации и видео играющих вместе, он замедлился до 16fps, как браузер был сейчас изо всех сил, чтобы выполнить все JavaScript и еще перекрасить ее окно на время, что воспроизведение видео и анимации холст вяло.</p> <p>Теперь мы начнем настройку нашей программы, и по мере этого мы будем отслеживать время Render Time, Canvas FPS и Browser FPS для измерения эффектов наших изменений.</p> <hr><h2> Шаг 5: Используйте метод requestAnimationFrame() </h2> <p> Последние два вышеприведенных фрагментах кода JavaScript использовать функции setTimeout() и setInterval() функции таймера. Чтобы использовать эти функции, можно указать интервал времени в миллисекундах и функции обратного вызова, вы хотите выполнить истечении этого времени.  Разница между двумя заключается в том, что метод setTimeout() будет вызывать функцию только один раз, а через setInterval() вызывает его повторно.</p> <p>Хотя эти функции всегда были незаменимыми инструментами в комплекте на JavaScript аниматора, у них есть несколько недостатков:</p> <p> Мы сейчас начать настройки нашей программы, и как мы это сделаем, мы будем отслеживать время рендеринга, холст ФПС и ФПС браузера, чтобы оценить эффект изменения.Во-первых, временной интервал установить не всегда надежны. Если программа все еще находится в середине выполнения чего-то еще, когда интервал истекает, функция обратного вызова будет выполняться позже, чем первоначально установленный, как только браузер больше не занят. В функции main (), мы установили интервал в 33 мс - но как профайлер показывает, что функция на самом деле называется Все 148 миллисекунд в опере.</p> <p> Во-вторых, существует проблема с перекрашивает браузера. Если бы у нас была функция обратного вызова, которая генерируется 20 кадров анимации в секунду, в то время как браузер перекрасили своего окна только 12 раз в секунду, 8 вызовы этой функции будут потрачены впустую, так как пользователь никогда не получите, чтобы увидеть результаты.</p> <p> Наконец, браузер не имеет возможности узнать, что вызываемая функция анимирует элементов в документе. Это означает, что если эти элементы прокрутки вне поля зрения, или пользователь нажимает на другую вкладку, обратный вызов будет по-прежнему вам неоднократно выполняться, тратить циклы процессора.</p> <p> Используя метод requestAnimationFrame() решает большинство этих проблем, и ее можно использовать вместо функции таймера анимации в HTML5. Вместо указания временного интервала, метод requestAnimationFrame() синхронизирует вызовов функций в окне браузера перекрашивает.  Это приводит к увеличению объема жидкости, последовательное анимация как нет кадров, и браузер может сделать дальнейшее внутренней оптимизации зная анимация в прогресс. </p> <p> Чтобы заменить функции setTimeout() с помощью метода requestAnimationFrame в наш виджет, то сначала добавьте следующую строку в верхней части нашего скрипта:</p> <pre class="brush: javascript noskimlinks noskimwords">requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || setTimeout;</pre> <p> Как спецификация является еще достаточно новой, в некоторых браузерах или в разных версиях одного браузера имеют собственных экспериментальных реализаций, эта линия гарантирует, что имя функции указывает на правильный метод, если он доступен, и падает обратно в setTimeout (), если не.  Тогда в функции main (), мы меняем эту строку:</p> <pre class="brush: javascript noskimlinks noskimwords"> setTimeout( main, frameDuration );</pre> <p>...чтобы:</p> <pre class="brush: javascript noskimlinks noskimwords">requestAnimationFrame( main, canvas );</pre> <p>Первый параметр принимает функцию обратного вызова, которая в данном случае является функция main (). Второй параметр является необязательным и указывает на элемент DOM, который содержит анимацию. Она должна быть использована для расчета дополнительных оптимизаций.</p> <p> Обратите внимание, что getStats() функция также использует метод setTimeout(), но мы оставим это в месте, поскольку эта функция не имеет ничего общего с анимацией сцены. метод requestAnimationFrame() был создан специально для анимации, так что если ваша функция обратного вызова не делаю анимации, вы можете использовать setTimeout() или setInterval().</p> <hr><h2> Шаг 6: Используйте страницу API для видимости </h2> <p> В последнем шаге мы сделали метод requestAnimationFrame мощность полотно анимации, и теперь у нас новая проблема. Если у нас начать работать виджет, а затем свернуть окно браузера или перейти на новую вкладку, Окно которой виджета перекрасить дроссели вниз, чтобы сохранить власть.  Это также замедляет холст анимации, поскольку он теперь синхронизирован с темпом перекрасить - что было бы прекрасно, если видео не продолжать играть до конца.</p> <p> Нам нужен способ, чтобы определить, когда страница не просматривается, так что мы можете приостановить воспроизведение видео; это когда страница API видимости приходит на помощь.</p> <p> API содержит набор свойств, функций и событий мы можем использовать, чтобы обнаружить, если веб-страница имеет вид или скрытая.  Затем мы можем добавить код, который регулирует поведение нашей программы соответственно. Мы будем использовать этот API, чтобы приостановить воспроизведение видео виджета всякий раз, когда страница неактивна.</p> <p> Мы начнем с добавления нового прослушивателя событий для нашего скрипта:</p> <pre class="brush: javascript noskimlinks noskimwords"> document.addEventListener( "visibilitychange", onVisibilityChange, false);</pre> <p>Далее идет функция обработчика событий:</p> <pre class="brush: javascript noskimlinks noskimwords"> // Adjusts the program behavior, based on whether the webpage is active or hiddenfunction onVisibilityChange() {if( document.hidden &amp;&amp; !video.paused ){  video.pause();  }else  if( video.paused ){  video.play();  }  }</pre> <hr><h2> Шаг 7: для нестандартной фигуры, нарисовать весь путь сразу</h2> <p> Дорожки используются, чтобы создать и нарисовать собственные формы и очертания на элементе  элемент, который будет во все времена иметь один активный путь.</p> <p> Путь содержит список суб-пути, и каждый суб-путь состоит из холста координатой точки связаны либо линией, либо кривой. Весь путь создания и рисования функций свойства объекта контекста холста, и могут быть классифицированы на две группы.</p> <p> Есть подпути-функции, используемые для определения подпути и включают концы lineto(), quadraticCurveTo(), bezierCurveTo () и дуговой(). Тогда у нас есть инсульт() и заполнить(), путь/подпуть функции рисования. Используя инсульт() создает контур, а заливку() создает форму заполнять или цвет, градиент или узор.</p> <p>При рисовании фигуры и наброски на холсте, эффективнее сначала создать весь путь, тогда точно инсульт() или заполнить() это один раз, а не определять и чертеж каждой supbath одновременно. Принимая график профилировщика описано на шаге 4 в качестве примера, каждая одиночная вертикальная синяя линия-подпуть, а все они вместе составляют весь текущий путь.</p> <div><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cdn.tutsplus.com/active/uploads/legacy/tuts/453_optimiseCanvas/source/step4.jpg" class="lazy07" alt="HTML5 Холст оптимизации: практический пример..." title="HTML5 Холст оптимизации: практический пример..." width="50" height="50"></div> <p>Инсульт() метод в настоящее время называется в цикл, который определяет каждый подпуть:</p> <pre class="brush: javascript noskimlinks noskimwords"> mainContext.beginPath();for( var j = 0; i &lt; imax; i++, j += 2 ){mainContext.moveTo( x + j, y ); // define the subpaths starting pointmainContext.lineTo( x + j, y - speedLog[i] * graphScale );// set the subpath as a line, and define its endpointmainContext.stroke(); // draw the subpath to the canvas}</pre> <p>Этот график можно сделать гораздо более эффективно, сначала нужно определить все подпути, то просто рисовал весь путь сразу, как показано ниже.</p> <pre class="brush: javascript noskimlinks noskimwords"> mainContext.beginPath();for( var j = 0; i &lt; imax; i++, j += 2 ){mainContext.moveTo( x + j, y ); // define the subpaths starting pointmainContext.lineTo( x + j, y - speedLog[i] * graphScale );// set the subpath as a line, and define its endpoint}mainContext.stroke(); // draw the whole current path to the mainCanvas.</pre> <hr><h2>Шаг 8: использовать внеэкранный холст для построения сцены </h2> <p> Этот метод оптимизации относится к одним на предыдущем шаге, в том, что они оба основаны на том же принципе минимизации странице перекрашивает.</p> <p> Всякий раз, когда что-то происходит, что меняет вид или содержание документа, браузер должен запланировать операции перекрашивать вскоре после этого на обновление интерфейса. Перекрашивает может быть дорогостоящей операцией с точки зрения циклов процессора и мощность, особенно для плотных страниц с большим количеством элементов и анимации происходит.  Если вы не выстраивая сложные сцены анимации путем добавления множества предметов один раз в элементе , каждое новое дополнение может вызвать целый перекрашивать.</p> <p> Лучше и намного быстрее строить сцену на экране (в памяти)  и после этого красить всю сцену только один раз на экране, видимом элементе .</p> <p> Чуть ниже код, который получает ссылку на виджета  и его контекст, мы добавим пять новых линий, что создать внеэкранный холст объект DOM и сопоставить его размеры с оригинала, видны элемента .</p> <pre class="brush: javascript noskimlinks noskimwords"> var mainCanvas = document.getElementById("mainCanvas"); // points to the on-screen, original HTML canvas elementvar mainContext = mainCanvas.getContext("2d"); // the drawing context of the on-screen canvas element var osCanvas = document.createElement("canvas"); // creates a new off-screen canvas elementvar osContext = osCanvas.getContext("2d"); //the drawing context of the off-screen canvas elementosCanvas.width = mainCanvas.width; // match the off-screen canvas dimensions with that of #mainCanvasosCanvas.height = mainCanvas.height;</pre> <p> Затем мы выполним поиск и замена во всех функциях рисования для всех ссылок на "mainCanvas" и изменить его на "osCanvas".  Ссылки на "mainContext" будет заменено на "osContext". Все теперь будет обращено на новые закадровые холст, вместо оригинального элемента .</p> <p> Наконец, мы добавляем еще одну строку в Main (), которая рисует то, что в настоящее время на экране с помощью элемента  в наших оригинальных элемента .</p> <pre class="brush: javascript noskimlinks noskimwords"> // As the scripts main function, it controls the pace of the animationfunction main(){requestAnimationFrame( main, mainCanvas );if( video.paused || video.currentTime &gt; 59  ){ return; }var now = new Date().getTime(); if( frameStartTime ){ speedLog.push( now - frameStartTime );}frameStartTime = now;if( video.readyState &lt; 2 ){ return; }frameCount++;osCanvas.width = osCanvas.width; //clear the offscreen canvasdrawBackground(); drawFilm();drawDescription();drawStats();drawBlade();drawTitle();mainContext.drawImage( osCanvas, 0, 0 ); // copy the off-screen canvas graphics to the on-screen canvas}</pre> <hr><h2>Шаг 9: Пути Кэша В Виде Растровых Изображений, Когда Это Возможно </h2> <p>Для многих видов графики, с помощью метода drawImage() будет гораздо быстрее, чем строить одни и те же изображения на холст с помощью пути. Если вы обнаружите, что большое зелье скрипта тратится постоянно рисовал один и тот же форм и очертаний, снова и снова, вы можете сохранить определенную работу браузера путем кеширования полученный рисунок в качестве растрового изображения, то рисовать его только один раз на холсте, когда требуется с помощью метода drawImage().</p> <p>Есть два способа сделать это.</p> <p>Первый-путем создания внешнего файла изображения в формате JPG, GIF или PNG изображения, а затем загружать его динамически с помощью JavaScript и скопировав его на свой холст. Единственный недостаток этого метода-это дополнительные файлы, программу придется скачать из сети, но в зависимости от типа графика или что ваше приложение делает, это может оказаться хорошим решением. Виджет анимации использует этот метод, чтобы загрузить спиннинг лезвие графики, которые невозможно было бы воссоздать с помощью всего пути холсте функции рисования.</p> <div><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=575/active/uploads/legacy/tuts/453_optimiseCanvas/source/step9.jpg" alt="HTML5 Холст оптимизации: практический пример..." title="HTML5 Холст оптимизации: практический пример..." width="50" height="50"></div> <p> Второй способ подразумевает как раз после рисования графики на экране вместо загрузки внешнего изображения. Мы будем использовать этот метод для кэширования название виджета анимации.  Сначала мы создаем переменную для ссылки на новое закадровое элемент canvas, который будет создан. Его значение по умолчанию-false, так что мы можем сказать, является ли или не кэшировать изображения был создан и сохраняется после того, как скрипт начинает выполняться:</p> <pre class="brush: javascript noskimlinks noskimwords"> var titleCache = false; // points to an off-screen canvas used to cache the animation scene"s title</pre> <p> Потом мы отредактируем drawTitle (функций) в первый проверить titleCache изображения холст был создан. Если это не так, он создает образ вне экрана и сохраняет ссылку на него в titleCache:</p> <pre class="brush: javascript noskimlinks noskimwords"> // renders the canvas titlefunction drawTitle(){if( titleCache == false ){ // create and save the title imagetitleCache = document.createElement("canvas");titleCache.width = osCanvas.width;titleCache.height = 25;var context = titleCache.getContext("2d");context.fillStyle = "black";context.fillRect( 0, 0, 368, 25 ); context.fillStyle = "white";context.font = "bold 21px Georgia";context.fillText( "SINTEL", 10, 20 );}osContext.drawImage( titleCache, 0, 0 ); }</pre> <hr><h2> Шаг 10: очистить холст с метода clearrect() </h2> <p>Первым шагом в разработке нового кадра анимации, чтобы очистить холст от текущего. Это можно сделать либо сброс ширины элемента canvas, или с помощью метода clearrect() функция.</p> <p> Сброс ширину имеет побочный эффект также, очистка текущего холст контекста по умолчанию, который может притормозить. С помощью метода clearrect() всегда быстрее и лучше, чтобы очистить холст.</p> <p> В функции main (), мы изменим это:</p> <pre class="brush: javascript noskimlinks noskimwords"> osCanvas.width = osCanvas.width; //clear the off-screen canvas</pre> <p>...на это:</p> <pre class="brush: javascript noskimlinks noskimwords"> osContext.clearRect( 0, 0, osCanvas.width, osCanvas.height ); //clear the offscreen canvas</pre> <hr><h2> Шаг 11: Создание Слоев </h2> <p> Если вы работали с изображения или видео-редактирования программного обеспечения, как Gimp или Photoshop ранее, то вы уже знакомы с понятием "слои", где изображение состоит из укладки много изображений поверх друг друга, и каждый из них может быть выбран и изменен отдельно.</p> <p> Наносится на холст сцены анимации, каждый слой будет отдельный элемент canvas, размещены на верхней части друг с другом с помощью CSS, чтобы создать иллюзию одного элемента. В качестве метода оптимизации, это работает лучше всего, когда есть четкое разграничение между переднего плана и фона элементов сцены, причем большая часть действий происходит на переднем плане. Фоновом режиме, затем можно нанести на холст элемент, который не сильно меняется между кадрами анимации, а на переднем плане еще более динамичный элемент canvas над ним. Таким образом, вся сцена не должна быть снова перерисовывается в каждом кадре анимации.</p> <p> К сожалению, виджет анимации-это хороший пример сцены, где мы не можем с пользой применить этот метод, так как оба переднего плана и фона элементов сильно оживляются.</p> <div><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=550/active/uploads/legacy/tuts/453_optimiseCanvas/source/step11.jpg" alt="HTML5 Холст оптимизации: практический пример..." title="HTML5 Холст оптимизации: практический пример..." width="50" height="50"></div> <hr><h2>Шаг 12: обновить только изменения областей сцены анимации </h2> <p>Это еще один метод оптимизации, который в значительной степени зависит от состава анимацию сцены.  Он может быть использован, когда сцена анимации концентрируется вокруг определенной прямоугольную область на холсте. Тогда мы могли бы ясно и просто перекроить перекроить этот регион.</p> <p> Например, название Синтел остается неизменным на протяжении большей части анимации, так что мы могли бы оставить это уголок нетронутой, когда сняв холст на следующий кадр анимации.</p> <div><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=376/active/uploads/legacy/tuts/453_optimiseCanvas/source/step12.jpg" alt="HTML5 Холст оптимизации: практический пример..." title="HTML5 Холст оптимизации: практический пример..." width="50" height="50"></div> <p> Для реализации этой технологии, мы заменяем строки, которые вызывает название функции рисования в Main() с помощью следующих блоков:</p> <pre class="brush: javascript noskimlinks noskimwords"> if( titleCache == false ){ // If titleCache is false, the animation"s title hasn"t been drawn yetdrawTitle(); // we draw the title. This function will now be called just once, when the program startsosContext.rect( 0, 25, osCanvas.width, osCanvas.height ); // this creates a path covering the area outside by the titleosContext.clip(); // we use the path to create a clipping region, that ignores the title"s region}</pre> <hr><h2> Шаг 13: Минимизировать Субпиксельный Рендеринг </h2> <p> Субпиксельный рендеринг и сглаживание происходит, когда браузер автоматически применяет графические эффекты, чтобы удалить неровные края. Это приводит к сглаживанию просмотр изображений и анимации, и автоматически включается всякий раз, когда вы указать дробные координаты, а не целое число для нанесения на холст.</p> <p> Сейчас нет стандарта на то, как это должно быть сделано, так субпиксельного рендеринга немного непоследовательно в разных браузерах, с точки зрения визуализации.  Он также замедляет скорость рендеринга в браузере должен сделать некоторые расчеты, чтобы создать эффект. Как холст сглаживание не может быть непосредственно отключена, единственный способ обойти это с помощью целых чисел на чертеже координаты.</p> <p> Мы используем математику.пол() для обеспечения целого числа в наш сценарий, когда это применимо. Например, следующая строка в drawFilm():</p> <pre class="brush: javascript noskimlinks noskimwords"> punchX = sample.x + ( j * punchInterval ) + 5; // the x co-ordinate</pre> <p> ...переписана как:</p> <pre class="brush: javascript noskimlinks noskimwords"> punchX = sample.x + ( j * punchInterval ) + 5; // the x co-ordinate</pre> <hr><h2>Шаг 14: измерить результаты </h2> <p> Мы просмотрели немало холст методы оптимизации анимации, и его сейчас время, чтобы рассмотреть результаты.</p> <div><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=575/active/uploads/legacy/tuts/453_optimiseCanvas/source/step14.jpg" alt="HTML5 Холст оптимизации: практический пример..." title="HTML5 Холст оптимизации: практический пример..." width="50" height="50"></div> <p> Эта таблица показывает до и после среднего времени render и холст ФПС.  Мы можем увидеть некоторые значительные улучшения во всех браузерах, но это только хром, что на самом деле приближается к достижению нашей первоначальной целью максимальной 33ms время рендеринга. Это означает, что еще многое предстоит сделать для достижения этой цели.</p> <p> Мы могли бы продолжить, применяя более общие методы оптимизации JavaScript, а если и это не помогает, возможно, рассмотреть поубавить анимации, удалив некоторые навороты. Но мы не будем смотреть на другие методы сегодня, как основное внимание было уделено оптимизации для элемента  анимация.</p> <p>Холст API-это довольно таки новый и растет каждый день, поэтому продолжайте экспериментировать, тестирование, изучение и обмен. Спасибо за чтение учебника.</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825634-html5-holst-optimizatsii-prakticheskij-primer" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Animation" href="https://norma-studio.github.io/article5/220825634-html5-holst-optimizatsii-prakticheskij-primer" class="tm-article-body__tags-item-link">Animation</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
39205</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
658</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

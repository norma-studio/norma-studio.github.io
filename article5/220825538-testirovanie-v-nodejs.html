
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Тестирование в Node.js... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Тестирование в Node.js... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Тестирование в Node.js... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Тестирование в Node.js... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Цикл разработки, основанный на тестах, упрощает мыслительный процесс написания кода, делает его легким и ускоряет в долгосрочной перспективе. Но само по себе простое написание тестов еще не является достаточным, необходимо знать, какие типы тестов писать и как структурировать код. В этой статье мы рассмотрим создание небольшого приложения на-Node.j...">
<meta property="og:description" content="Цикл разработки, основанный на тестах, упрощает мыслительный процесс написания кода, делает его легким и ускоряет в долгосрочной перспективе. Но само по себе простое написание тестов еще не является достаточным, необходимо знать, какие типы тестов писать и как структурировать код. В этой статье мы рассмотрим создание небольшого приложения на-Node.j...">
<meta name="twitter:description" content="Цикл разработки, основанный на тестах, упрощает мыслительный процесс написания кода, делает его легким и ускоряет в долгосрочной перспективе. Но само по себе простое написание тестов еще не является достаточным, необходимо знать, какие типы тестов писать и как структурировать код. В этой статье мы рассмотрим создание небольшого приложения на-Node.j...">
<meta property="aiturec:description" content="Цикл разработки, основанный на тестах, упрощает мыслительный процесс написания кода, делает его легким и ускоряет в долгосрочной перспективе. Но само по себе простое написание тестов еще не является достаточным, необходимо знать, какие типы тестов писать и как структурировать код. В этой статье мы рассмотрим создание небольшого приложения на-Node.j...">
<meta property="og:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=694/net/uploads/2013/10/image1.png">
<meta property="aiturec:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=694/net/uploads/2013/10/image1.png">
<meta name="twitter:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=694/net/uploads/2013/10/image1.png">
<meta property="vk:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=694/net/uploads/2013/10/image1.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=694/net/uploads/2013/10/image1.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825538-testirovanie-v-nodejs.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825538-testirovanie-v-nodejs.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825538-testirovanie-v-nodejs.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825538-testirovanie-v-nodejs.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825538-testirovanie-v-nodejs.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825538-testirovanie-v-nodejs.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825538-testirovanie-v-nodejs.html" title="Тестирование в Node.js... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Тестирование в Node.js... | envatomarket.ru | norma-studio.github.io" title="Тестирование в Node.js... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/543543242.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825538-testirovanie-v-nodejs.html" class="tm-user-info__username" title="
А. Морозов" aria-label="
А. Морозов">
А. Морозов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Тестирование в Node.js...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825538-testirovanie-v-nodejs" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Tools &amp; Tips" href="https://norma-studio.github.io/article5/220825538-testirovanie-v-nodejs" class="tm-article-snippet__hubs-item-link"><span>Tools &amp; Tips</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825538-testirovanie-v-nodejs.html" />
    <link itemprop="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=694/net/uploads/2013/10/image1.png">
    <meta itemprop="headline name" content="Тестирование в Node.js... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Цикл разработки, основанный на тестах, упрощает мыслительный процесс написания кода, делает его легким и ускоряет в долгосрочной перспективе. Но само по себе простое написание тестов еще не является достаточным, необходимо знать, какие типы тестов писать и как структурировать код. В этой статье мы рассмотрим создание небольшого приложения на-Node.j...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Цикл разработки, основанный на тестах, упрощает мыслительный процесс написания кода, делает его легким и ускоряет в долгосрочной перспективе. Но само по себе простое написание тестов еще не является достаточным, необходимо знать, какие типы тестов писать и как структурировать код. В этой статье мы рассмотрим создание небольшого приложения на-Node.j...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Цикл разработки, основанный на тестах, упрощает мыслительный процесс написания кода, делает его легким и ускоряет в долгосрочной перспективе. Но само по себе простое написание тестов еще не является достаточным, необходимо знать, какие типы тестов писать и как структурировать код. В этой статье мы рассмотрим создание небольшого приложения на <span>Node.js</span> следуя шаблону TDD.</p><p></p> <p>Помимо простых «unit» тестов, с которыми мы все знакомы; Мы также можем написать Node.js тесты Когда выполняется асинхронный код, это добавляет дополнительное <em>измерение</em>, которое заключается в том, что мы не всегда знаем порядок выполнения функций, или мы можем пытаться что-то проверить в обратном вызове или проверить, как работает асинхронная функция.</p> <p>В этой статье мы будем создавать приложение Node, которое может искать файлы, соответствующие данному запросу. Я знаю, что для этого уже есть инструменты (<em>ack</em>), но для демонстрации TDD я думаю, что это может как раз подходящим проектом. </p> <p>Первый шаг, очевидно, состоит в том, чтобы написать некоторые тесты, но еще до этого нам нужно выбрать фреймворк для тестирования. Вы можете использовать vanilla Node, так как есть встроенная библиотека <code>assert</code>, но этого может быть недостаточно, так как у нас нет test runner для тестов.</p> <p>Другой вариант и, вероятно, мой любимый для общего использования - <span>Jasmine</span>. Он является довольно самодостаточным, и у вас не будет других зависимостей, которые надо будет добавить к уже имеющимся скриптам. Его синтаксис очень чист и прост в чтении. Единственная причина, по которой я не буду использовать его сегодня, состоит в том, что я думаю, что <span>Джек Франклин</span> отлично справился с этим в своей недавней <span>серии Tuts +</span>, и рассказал про все возможные варианты, чтобы вы могли выбрать лучший инструмент для своей ситуации.</p> <hr><h2>Что мы будем строить</h2> <p>В этой статье мы будем использовать гибкий тестовый runner «<span>Mocha</span>» вместе с библиотекой утверждений <span>Chai</span>.</p> <p>В отличие от Jasmine  который больше похож на весь набор тестов в одном пакете, Mocha только заботится об общей структуре, но не имеет никакого отношения к фактическим утверждениям. Это позволяет сохранять постоянный внешний вид при выполнении ваших тестов, но также позволяет использовать ту библиотеку утверждений, которая лучше всего подходит для вашей ситуации.</p> <p>Например, если вы собираетесь использовать библиотеку «assert», вы можете связать ее с Mocha, чтобы добавить некоторую структуру к вашим тестам.</p> <p>Chai - довольно популярный вариант. Даже без каких-либо плагинов, используя API по умолчанию, у вас есть три разных синтаксиса, которые вы можете использовать в зависимости от того, хотите ли вы использовать более классический стиль TDD или более подробный синтаксис BDD.</p> <p>Итак, теперь, когда мы знаем, что мы будем использовать, давайте займемся установкой.</p> <hr><h2>Настройка</h2> <p>Чтобы начать работу, давайте установим Mocha глобально, запустив:</p> <pre class="brush: bash noskimlinks noskimwords">npm install -g mocha</pre> <p>Когда эта команда завершится, создайте новую папку для нашего проекта и запустите внутри нее следующее:</p> <pre class="brush: bash noskimlinks noskimwords">npm install chai</pre> <p>Это установит локальную копию Chai для нашего проекта. Затем создайте папку с именем <code>test</code> внутри каталога нашего проекта, так как в этом месте по умолчанию Mocha будет искать тесты.</p> <p>Это в значительной степени для настройки, в следующем шаге мы поговорим о том, как структурировать ваши приложения, следуя процессу разработки, основанному на тестах.</p> <hr><h2>Структурирование вашего приложения</h2> <p>Следуя подходу TDD, важно знать, что должно иметь свои тесты, а что - нет. Эмпирическое правило заключается в том, чтобы не писать тесты для других людей, которые уже тестировали код. Я имею в виду следующее: предположим, что ваш код открывает файл, вам не нужно проверять отдельную функцию <code>fs</code>, она является частью языка и, предположительно, уже хорошо протестирована. То же самое происходит при использовании сторонних библиотек, вы не должны структурировать функции, которые в первую очередь вызывают эти типы функций. Вы на самом деле не пишете тесты для них, и из-за этого у вас могут возникнуть пробелы в цикле TDD.</p> <p>Теперь, конечно, с каждым стилем программирования есть много разных мнений, и у людей будут разные взгляды на то, что такое TDD. Но подход, который я использую, заключается в том, что вы создаете отдельные компоненты для использования в своем приложении, каждый из которых решает уникальную функциональную проблему. Эти компоненты создаются с использованием TDD, гарантируя, что они работают должным образом, и вы не нарушите их API. Затем вы пишете свой основной скрипт, который по сути является клеем всего остального кода и не нуждается в тестировании / не может быть проверен в определенных ситуациях.</p> <p>Это также означает, что большинство ваших компонентов могут быть повторно использованы в будущем, так как им действительно нечего делать напрямую с помощью основного сценария.</p> <p>Следуя тому, что я только что сказал, обычной практикой является создание папки с именем «<code>lib</code>», куда вы помещаете все отдельные компоненты. Таким образом, к этому моменту вы уже должны установить Mocha и Chai, а затем каталог проекта с двумя папками: «<code>lib</code>» и «<code>test</code>».</p> <hr><h2>Начало работы с TDD</h2> <p>На всякий случай, если вы новичок в TDD, я подумал, что было бы неплохо быстро осветить процесс. Основное правило заключается в том, что вы не можете написать какой-либо код, пока вам об этом не сообщат тесты. </p> <p>По сути, вы пишете, что должен делать ваш код, прежде чем писать сам код. При таком подходе у вас всегда есть четко поставленная цель, которую необходимо закодировать, и вы никогда не отклонитесь от нее, например если отвлечетесь или будете думать слишком далеко на перед. Кроме того, поскольку весь ваш код будет иметь аффилированный с ним тест, вы можете быть уверены, что в будущем вы никогда не сломаете свое приложение.</p> <p>Тест на самом деле - это просто объявление о том, что функция должна выполнять при запуске, затем вы запускаете свой тест, который, очевидно, потерпит неудачу (поскольку вы еще не написали код), а затем вы пишете минимальное количество кода, необходимого для прохождения этого теста. Важно никогда не пропустить этот шаг, потому что иногда тест проходит даже до того, как вы добавите какой-либо код из-за другого кода, который у вас есть в том же классе или функции. Когда это произойдет, вы либо написали больше кода, тогда вы должны были использовать другой тест, или это просто плохой тест (обычно недостаточно конкретный).</p> <p>Опять же, согласно нашему правилу выше, если тест проходит сразу, вы не можете написать какой-либо код, потому что тест не сказал вам об этом. Когда вы постоянно сначала пишете тесты, а затем реализуете функции, то вы тем самым создаете надежные  модули, на которые вы можете положиться.</p> <p>После того, как вы закончите внедрение и тестирование своего компонента, вы можете вернуться и реорганизовать код, чтобы его оптимизировать и очистить, но убедитесь, что рефакторинг не прервет ни одного из проведенных вами тестов и, что более важно, вы не добавили никаких новых непротестированных функций. </p> <p>Каждая тестовая библиотека будет иметь свой собственный синтаксис, но обычно они следуют одной и той же схеме создания утверждений, а затем проверяют, проходят ли они. Поскольку мы используем Mocha и Chai, давайте рассмотрим оба их синтаксиса, начиная с Chai.</p> <hr><h2>Мокка и Чай</h2> <p>Я буду использовать синтаксис «expect» BDD, потому что, как я уже говорил, у Chai есть несколько вариантов из коробки. Этот синтаксис работает следующим образом: вы начинаете с вызова функции ожидания, передавая ей объект, на который хотите включить утверждение, и затем связываете его с определенным тестом. Пример того, что я имею в виду, может быть следующим:</p> <pre class="brush: javascript noskimlinks noskimwords">expect(4+5).equal(9);</pre> <p>Это основной синтаксис, мы говорим, ожидаем, что сумма <code>4</code> и <code>5</code> будет равно <code>9</code>. Теперь это не самый удачный тест, потому что <code>4</code> и <code>5</code> будут сложены Node.js до того, как функция будет даже вызвана, поэтому мы по существу тестируем мои математические навыки, но я надеюсь, что вы получите общую идею. Другая вещь, которую вы должны отметить, заключается в том, что этот синтаксис не очень читабельен с точки зрения обычного английского предложения. Зная это, Chai добавил следующие chain геттеры, которые ничего не делают, но вы можете добавить их, чтобы сделать код более подробным и удобочитаемым. Chain геттеры следующие:</p> <ul><li>to</li> <li>be</li> <li>been</li> <li>is</li> <li>that</li> <li>and</li> <li>have</li> <li>with</li> <li>at</li> <li>of</li> <li>same</li> <li>a</li> <li>an</li> </ul><p>Используя вышеизложенное, мы можем переписать наш предыдущий тест на что-то вроде этого:</p> <pre class="brush: javascript noskimlinks noskimwords">expect(4+5).to.equal(9);</pre> <p>Мне очень нравится ощущение всей библиотеки, которую вы можете проверить в <span>их API</span>. Простые вещи, такие как отрицание операции, так же просто написать, добавив <code>.not</code> до теста:</p> <pre class="brush: javascript noskimlinks noskimwords">expect(4+5).to.not.equal(10);</pre> <p>Поэтому, даже если вы никогда раньше не использовали библиотеку, нетрудно понять, что пытается сделать тест.</p> <p>Последнее, что я хотел бы рассмотреть, прежде чем мы приступим к нашему первому тесту, - это то, как мы структурируем наш код в Mocha</p> <h3>Mocha</h3> <p>Mocha - тестовый бегун, поэтому он на самом деле не слишком много внимания уделяет реальным тестам,  он больше заботится о структуре тестов, потому что это то, как он понимает, что происходит, и как показывать результатов. При написании тестов, вы создаете несколько <code>describe</code> блоков, которые описывают различные компоненты вашей библиотеки, а затем добавляете блоки <code>it</code>, чтобы указать конкретный тест.</p> <p>Для быстрого примера предположим, что у нас есть класс JSON, и у этого класса была функция для разбора JSON, и мы хотели убедиться, что функция синтаксического анализа может обнаружить сильно форматированную строку JSON, мы могли бы структурировать ее так:</p> <pre class="brush: javascript noskimlinks noskimwords">describe("JSON", function() {   describe(".parse()", function() {       it("should detect malformed JSON strings", function(){           //Test Goes Here       });   });});</pre> <p>Это не сложно, и это около 80% личных предпочтений, но если вы сохраните такой формат, результаты теста должны появиться в очень читаемом формате.</p> <p>Теперь мы готовы написать нашу первую библиотеку, давайте начнем с простого синхронного модуля, чтобы лучше познакомиться с системой. Наше приложение должно будет иметь возможность принимать параметры командной строки для настройки таких вещей, как количество уровней папок, вглубь которых должно искать наше приложение, и самого запроса.</p> <p>Чтобы позаботиться обо всем этом, мы создадим модуль, который принимает строку команды и анализирует все включенные опции вместе с их значениями.</p> <h3>Модуль тегов</h3> <p>Это отличный пример модуля, который можно повторно использовать во всех приложениях с командной строкой, так как эта проблема возникает довольно часто. Это будет упрощенная версия фактического пакета, который я использую для npm под названием <span>ClTags</span>. Итак, для начала создайте файл с именем <code>tags.js</code> внутри папки lib, а затем другой файл с именем <code>tagsSpec.js</code> внутри папки с тестами.</p> <p>Нам нужно задействовать expect функцию Chai, так как это будет синтаксис утверждения, который мы будем использовать, и нам нужно вытащить фактический файл тегов, чтобы мы могли его протестировать. В целом с некоторой начальной настройкой он должен выглядеть примерно так:</p> <pre class="brush: javascript noskimlinks noskimwords">var expect = require("chai").expect;var tags = require("../lib/tags.js");describe("Tags", function(){});</pre> <p>Если теперь вы запускаете команду «mocha» из корня нашего проекта, все должно проходить как ожидалось. Теперь давайте подумаем о том, что сделает наш модуль; мы хотим передать ему массив аргументов команды, который использовался для запуска приложения, а затем мы хотим, чтобы он создавал объект со всеми тегами, и было бы неплохо, если бы мы могли также передать ему объект настроек по умолчанию, поэтому, если ничего не будет перезаписано, то у нас будут уже сохранены некоторые настройки.</p> <p>При работе с тегами многие приложения также предоставляют ярлыки, которые являются всего лишь одним символом, поэтому, скажем, мы хотели установить глубину нашего поиска, мы могли бы позволить пользователю либо указать что-то вроде <code>--depth=2</code> или что-то вроде <code>-d=2</code>, что должно иметь тот же эффект.</p> <p>Итак, давайте начнем с длинно сформированных тегов (например, "--depth = 2"). Для начала давайте напишем первый тест:</p> <pre class="brush: javascript noskimlinks noskimwords">describe("Tags", function(){   describe("#parse()", function(){       it("should parse long formed tags", function(){           var args = ["--depth=4", "--hello=world"];           var results = tags.parse(args);           expect(results).to.have.a.property("depth", 4);           expect(results).to.have.a.property("hello", "world");       });   });});</pre> <p>Мы добавили один метод к нашему набору тестов, который называется <code>parse</code>, и мы добавили тест для длинно сформированных тегов. Внутри этого теста я создал команду примера и добавил два утверждения для двух свойств, которые он должен получить.</p> <p>Запустив Mocha, вы должны получить одну ошибку, а именно, что <code>tags</code> не имеют функции <code>parse</code>. Поэтому, чтобы исправить эту ошибку, добавим функцию <code>parse</code> в модуль тегов. Достаточно типичный способ создания node-модуля выглядит так:</p> <pre class="brush: javascript noskimlinks noskimwords">exports = module.exports = {};exports.parse = function() {}</pre> <p>Ошибка говорит, что нам нужен метод <code>parse</code>, поэтому мы его создали, мы не добавили никакого другого кода внутри, потому что тест нам этого еще не сказал. Придерживаясь минимального количества кода, вы уверены, что не напишете кода, больше чем нужно и в результате у вас не появится не протестирванного кода.</p> <p>Теперь давайте снова запустим Mocha, на этот раз мы должны получить ошибку, сообщающую нам, что тест не может прочитать свойство с именем <code>depth</code> из неопределенной переменной. Это потому, что в настоящее время наша функция <code>parse</code> ничего не возвращает, поэтому давайте добавим некоторый код, чтобы она возвращала объект:</p> <pre class="brush: javascript noskimlinks noskimwords">exports.parse = function() {var options = {}return options;}</pre> <p>Мы медленно продвигаемся вперед, если вы снова запустите Mocha, не будет выброшено никаких исключений, просто чистое сообщение об ошибке, в котором говорится, что наш пустой объект не имеет свойства <code>depth</code>.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=694/net/uploads/2013/10/image1.png" alt="Тестирование в Node.js..." title="Тестирование в Node.js..." width="50" height="50"><br></figure><p>Теперь мы можем написать какой-то реальный код. Чтобы наша функция анализировала тег и добавляла его к нашему объекту, нам нужно циклически перебирать массив аргументов и удалять двойные штрихи в начале ключа.</p> <pre class="brush: javascript noskimlinks noskimwords">exports.parse = function(args) {   var options = {}   for (var i in args) { //Cycle through args       var arg = args[i];       //Check if Long formed tag       if (arg.substr(0, 2) === "--") {           arg = arg.substr(2);           //Check for equals sign           if (arg.indexOf("=") !== -1) {               arg = arg.split("=");               var key = arg.shift();               options[key] = arg.join("=");           }       }   }   return options;}</pre> <p>Этот код циклически проходит через список аргументов, поэтому мы имеем дело с длинным сформированным тегом, а затем разбиваем его на первый символ равенства, чтобы создать пару ключей и значений для объекта options.</p> <p>Теперь это почти решает нашу проблему, но если мы снова запустим Mocha, вы увидите, что теперь у нас есть ключ для глубины, но он установлен как строка вместо числа. Следующий фрагмент кода, который нам нужно добавить, - это преобразовать значения в числа, там где это возможно. Это может быть достигнуто с помощью некоторых функций RegEx и <code>parseInt</code> следующим образом:</p> <pre class="brush: javascript noskimlinks noskimwords">        if (arg.indexOf("=") !== -1) {            arg = arg.split("=");            var key = arg.shift();            var value = arg.join("=");            if (/^[0-9]+$/.test(value)) {                value = parseInt(value, 10);            }            options[key] = value;        }</pre> <p>Запустив Mocha, вы должны получить один успешно выполненный тест. Преобразование числа, возможно, должно быть в собственном тесте или, по крайней мере, упомянуто в декларации тестов, чтобы вы, по ошибке, не удалили утверждение о преобразовании числа; поэтому просто добавьте «добавить и преобразовать числа» в <code>it</code> объявление для этого теста или разделите его на новый блок <code>it</code>. Это действительно зависит от того, считаете ли вы это «очевидным поведением по умолчанию» или отдельной функцией. </p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=542/net/uploads/2013/10/image2.png" alt="Тестирование в Node.js..." title="Тестирование в Node.js..." width="50" height="50"><br></figure><p>Теперь, как я пытался подчеркнуть во всей этой статье, когда вы видите успешно проходящую спецификацию, пришло время написать больше тестов. Следующее, что я хотел добавить, - это массив по умолчанию, поэтому внутри файла <code>tagsSpec</code> добавим следующий блок <code>it</code> сразу после предыдущего:</p> <pre class="brush: javascript noskimlinks noskimwords">    it("should parse long formed tags and convert numbers", function(){        var args = ["--depth=4", "--hello=world"];        var results = tags.parse(args);        expect(results).to.have.a.property("depth", 4);        expect(results).to.have.a.property("hello", "world");    });    it("should fallback to defaults", function(){        var args = ["--depth=4", "--hello=world"];        var defaults = { depth: 2, foo: "bar" };        var results = tags.parse(args, defaults);        var expected = {            depth: 4,            foo: "bar",            hello: "world"        };        expect(results).to.deep.equal(expected);    });</pre> <p>Здесь мы используем новый тест, глубокое сравнение, которое полезно для сопоставления двух объектов на равные значения. Кроме того, вы можете использовать тест <code>eql</code>, который является ярлыком, но я думаю, что так выглядит более ясно. Этот тест передает два аргумента в качестве командной строки и передает два значения по умолчанию с одним перекрытием, поэтому мы можем получить хороший разброс по тестовым случаям.</p> <p>Запустив Mocha сейчас, вы должны получить своего рода diff, содержащий различия между ожидаемым и тем, что он получил.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=516/net/uploads/2013/10/image3.png" alt="Тестирование в Node.js..." title="Тестирование в Node.js..." width="50" height="50"><br></figure><p>Давайте теперь вернемся к модулю <code>tags.js</code> и добавим этот функционал. Это довольно простое исправление, нам просто нужно принять второй параметр, и когда он установлен в объект, мы можем заменить стандартный пустой объект в начале этого объекта:</p> <pre class="brush: javascript noskimlinks noskimwords">exports.parse = function(args, defaults) {   var options = {};   if (typeof defaults === "object" &amp;&amp; !(defaults instanceof Array)) {       options = defaults   }</pre> <p>Это вернет нас к зеленому состоянию. Следующее, что я хочу добавить, это возможность просто указать тег без значения и позволить ему работать как логическое значение. Например, если мы просто установим <code>--searchContents</code> или что-то вроде этого, он просто добавит это в наш массив параметров со значением <code>true</code>.</p> <p>Тест для этого будет выглядеть примерно так:</p> <pre class="brush: javascript noskimlinks noskimwords">   it("should accept tags without values as a bool", function(){       var args = ["--searchContents"];       var results = tags.parse(args);       expect(results).to.have.a.property("searchContents", true);   });</pre> <p>Выполнение этого приведет к следующей ошибке:</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=703/net/uploads/2013/10/image4.png" alt="Тестирование в Node.js..." title="Тестирование в Node.js..." width="50" height="50"><br></figure><p>Внутри цикла <code>for</code>, когда мы получили соответствие для длинного сформированного тега, мы проверили, содержит ли он знак равенства; мы можем быстро написать код для этого теста, добавив предложение <code>else</code> к этому оператору <code>if</code> и просто установив значение в <code>true</code>:</p> <pre class="brush: javascript noskimlinks noskimwords">        if (arg.indexOf("=") !== -1) {             arg = arg.split("=");             var key = arg.shift();             var value = arg.join("=");             if (/^[0-9]+$/.test(value)) {                 value = parseInt(value, 10);             }             options[key] = value;        } else {             options[arg] = true;        }</pre> <p>Следующее, что я хочу добавить, это замены для коротких тегов. Это будет третий параметр функции <code>parse</code> и он будет в основном объектом с буквами и соответствующими заменами. Вот спецификация для этого добавления:</p> <pre class="brush: javascript noskimlinks noskimwords">    it("should accept short formed tags", function(){        var args = ["-sd=4", "-h"];        var replacements = {            s: "searchContents",            d: "depth",            h: "hello"        };        var results = tags.parse(args, {}, replacements);        var expected = {            searchContents: true,            depth: 4,            hello: true        };        expect(results).to.deep.equal(expected);    });</pre> <p>Проблема с сокращенными тегами заключается в том, что они могут быть объединены в ряд. То, что я имею в виду под этим, в отличие от длинно сформированных тегов, где каждый из них раздельный, с короткими метками все по-другому - поскольку каждый из них имеет только длину в один символ, вы можете указать три разных, набрав <code>-vgh</code>. Это делает анализ более сложным, потому что нам все равно нужно разрешить оператору equals добавлять значение к указанному последнему тегу, в то же время вам нужно еще зарегистрировать другие теги. Но не беспокойтесь, все это вполне реализуемо.</p> <p>Вот полное исправление с начала функции <code>parse</code>:</p> <pre class="brush: javascript noskimlinks noskimwords">exports.parse = function(args, defaults, replacements) {   var options = {};   if (typeof defaults === "object" &amp;&amp; !(defaults instanceof Array)) {       options = defaults   }   if (typeof replacements === "object" &amp;&amp; !(defaults instanceof Array)) {        for (var i in args) {             var arg = args[i];             if (arg.charAt(0) === "-" &amp;&amp; arg.charAt(1) != "-") {                  arg = arg.substr(1);                  if (arg.indexOf("=") !== -1) {                      arg = arg.split("=");                      var keys = arg.shift();                      var value = arg.join("=");                      arg = keys.split("");                      var key = arg.pop();                      if (replacements.hasOwnProperty(key)) {                           key = replacements[key];                      }                      args.push("--" + key + "=" + value);                  } else {                      arg = arg.split("");                  }                  arg.forEach(function(key){                      if (replacements.hasOwnProperty(key)) {                          key = replacements[key];                      }                      args.push("--" + key);                  });             }        }   }</pre> <p>Здесь очень много кода (в сравнении), но все, что мы делаем, это разделение аргумента на знак равенства, а затем разделение этого ключа на отдельные буквы. Например, если мы передали <code>-gj=asd</code>, мы разделили бы <code>asd</code> на переменную с именем <code>value</code>, а затем разделили бы <code>gj</code> на отдельные символы. Последний символ (<code>j</code> в нашем примере) станет ключом для значения (<code>asd</code>), тогда как любые другие буквы перед ним будут добавлены в виде обычных булевых тегов. Я не хотел просто обрабатывать эти теги сейчас, на всякий случай, когда мы изменим реализацию чуть позже. Итак, мы просто конвертируем эти короткие теги в длинную форматированную версию, а затем позволяем нашему скрипту обрабатывать ее позже.</p> <p>Запуск Mocha снова приведет нас к нашим любимым зеленым результатам четырех тестов, успешно проходящих для этого модуля.</p> <p>Теперь есть еще несколько вещей, которые мы можем добавить к этому модулю тегов, чтобы сделать его ближе к пакету npm, например, возможность хранить текстовые аргументы для таких вещей, как команды или возможность собирать весь текст в конце, как свойство запроса. Но эта статья уже итак становится слишком длинной, и я хотел бы перейти к реализации функции поиска.</p> <hr><h2>Модуль поиска</h2> <p>Мы просто прошли через создание модуля шаг за шагом, следуя подходу TDD, и я надеюсь, что вы теперь понимаете как ему следовать. Но ради целей этой статьи, в остальной ее части, я ускорю процесс тестирования, объединив все вместе и покажу вам окончательные версии тестов. Это скорее руководство к различным ситуациям, которые могут возникнуть и как писать тесты для них.</p> <p>Поэтому просто создайте файл с именем <code>search.js</code> внутри папки lib и файл <code>searchSpec.js</code> внутри тестовой папки.</p> <p>Затем откройте файл spec и давайте настроим наш первый тест, который может быть для функции, чтобы получить список файлов на основе параметра <code>depth</code>, это также отличный пример для тестов, для которых требуется немного внешней настройки для их работы. Когда вы работаете с внешними объектно-подобными данными или в нашем случае с файлами, вы должно быть захотите иметь предопределенную настройку, которая, будет работать с вашими тестами, но вы также не захотите добавлять фейковые данные в свою систему.</p> <p>Существует два варианта решения этой проблемы: вы можете либо замокать эти данные, как я уже упоминал выше, или если вы имеете дело с языками собственных команд для загрузки данных, вам не обязательно их проверять. В подобных случаях вы можете просто предоставить «извлеченные» данные и продолжить тестирование, так как мы сделали с командной строкой в библиотеке тегов. Но в этом случае мы тестируем рекурсивную функциональность, которую мы добавляем к возможностям чтения файлов, в зависимости от указанной глубины. В таких случаях вам нужно написать тест, поэтому нам нужно создать несколько демонстрационных файлов для проверки чтения файла. Альтернатива заключается в том, чтобы, возможно, сделать заглушки для функции <code>fs</code> только для запуска, которые на самом деле ничего не делают, и тогда мы можем подсчитать, сколько раз выполнялась наша фальшивая функция или что-то в этом роде (проверьте <span>шпионов</span>), но для нашего примера я просто собираюсь создать некоторые файлы.</p> <p>Mocha предоставляет функции, которые могут запускаться как до, так и после ваших тестов, поэтому вы можете выполнять эти внешние настройки и очистку для своих тестов.</p> <p>В нашем примере мы создадим пару тестовых файлов и папок на двух разных глубинах, чтобы мы могли проверить эту функциональность:</p> <pre class="brush: javascript noskimlinks noskimwords">var expect = require("chai").expect;var search = require("../lib/search.js");var fs = require("fs");describe("Search", function(){   describe("#scan()", function(){       before(function() {           if (!fs.existsSync(".test_files")) {               fs.mkdirSync(".test_files");               fs.writeFileSync(".test_files/a", "");               fs.writeFileSync(".test_files/b", "");               fs.mkdirSync(".test_files/dir");               fs.writeFileSync(".test_files/dir/c", "");               fs.mkdirSync(".test_files/dir2");               fs.writeFileSync(".test_files/dir2/d", "");           }       });       after(function() {           fs.unlinkSync(".test_files/dir/c");           fs.rmdirSync(".test_files/dir");           fs.unlinkSync(".test_files/dir2/d");           fs.rmdirSync(".test_files/dir2");           fs.unlinkSync(".test_files/a");           fs.unlinkSync(".test_files/b");           fs.rmdirSync(".test_files");       });   });});</pre> <p>Они будут вызваны на основе блока <code>describe</code>, в котором они находятся, и вы даже можете запускать код до и после каждого <code>it</code> блока, используя <code>beforeEach</code> или <code>afterEach</code>. Сами функции просто используют стандартные команды node для создания и удаления файлов соответственно. Затем нам нужно написать фактический тест. Он должен сразу после функции <code>after</code>, все еще внутри блока <code>describe</code>:</p> <pre class="brush: javascript noskimlinks noskimwords">       it("should retrieve the files from a directory", function(done) {           search.scan(".test_files", 0, function(err, flist){               expect(flist).to.deep.equal([                   ".test_files/a",                   ".test_files/b",                   ".test_files/dir/c",                   ".test_files/dir2/d"               ]);               done();           });       });</pre> <p>Это наш первый пример тестирования функции async, но, как вы видите, это так же просто, как и раньше; все, что нам нужно сделать, это использовать функцию <code>done</code>, которую Mocha предоставляет в <code>it</code> декларациях, чтобы рассказать о том, когда мы закончим этот тест.</p> <p>Mocha автоматически определит, указали ли вы <code>done</code> переменную в обратном вызове, и она будет ожидать, что ее вызовут, что позволит вам легко протестировать асинхронный код. Кроме того, стоит упомянуть, что этот шаблон доступен во всем Mocha, вы можете, например, использовать его в функциях <code>before</code> или <code>after</code>, если вам нужно настроить что-то асинхронно.</p> <p>Затем я хотел бы написать тест, который гарантирует, что параметр глубины работает, если он установлен:</p> <pre class="brush: javascript noskimlinks noskimwords">    it("should stop at a specified depth", function(done) {        search.scan(".test_files", 1, function(err, flist) {            expect(flist).to.deep.equal([                ".test_files/a",                ".test_files/b",            ]);            done();        });    });</pre> <p>Здесь ничего особенного, просто еще один простой тест. Запустив это в Mocha, вы получите сообщение об ошибке, что поиск не имеет каких-либо методов, в основном потому, что в нем ничего не написано. Итак, давайте определимся с функцией:</p> <pre class="brush: javascript noskimlinks noskimwords">var fs = require("fs");exports = module.exports = {};exports.scan = function(dir, depth, done) {}</pre> <p>Если вы снова запустите Mocha, он приостанавливает ожидание возврата этой функции async, но поскольку мы вообще не вызываем обратный вызов, тест будет просто таймаутом. По умолчанию он должен истечь через две секунды, но вы можете настроить его с помощью <code>this.timeout (milliseconds)</code> внутри блока describe или it блока, чтобы соответственно настроить их таймауты.</p> <p>Эта функция сканирования должна получить путь и глубину и вернуть список всех найденных файлов. На самом деле это довольно сложно, когда вы начинаете думать о том, как мы, по сути, рекурсируем две разные функции вместе в одной функции. Нам нужно рекурсивно пройти через разные папки, а затем эти папки должны проверять себя и решать, стоит ли двигаться дальше.</p> <p>Выполнение этого синхронно прекрасно, потому что вы можете шагнуть по нему шаг за шагом, медленно выполняя один уровень или путь за раз. Когда вы работаете с асинхронной версией, это становится немного более сложным, потому что вы не можете просто сделать цикл <code>foreach</code> или что-то в этом роде, потому что он не будет приостанавливаться между папками, все они будут по существу выполняться одновременно с возвращением разных значений, и они как бы переписывают друг друга.</p> <p>Поэтому, чтобы заставить его работать, вам нужно создать своего рода стек, в котором вы можете асинхронно обрабатывать по одному (или все сразу, если вы используете очередь вместо этого), а затем сохранить порядок таким образом. Это очень специфический алгоритм, поэтому я просто приведу фрагмент <span>Кристофера Джеффри</span>, который вы можете найти на <span>Stack Overflow</span>. Это не относится только к загрузке файлов, но я использовал это в ряде приложений, в основном, там где нужно обрабатывать массив объектов по одному с помощью асинхронных функций.</p> <p>Нам нужно немного изменить его, потому что мы хотели бы иметь параметр глубины, как работает опция глубины, вы устанавливаете количество уровней папок, которые хотите проверить, или ноль, углубляться бесконечно.</p> <p>Вот завершенная с помощью фрагмента функция:</p> <pre class="brush: javascript noskimlinks noskimwords">exports.scan = function(dir, depth, done) {   depth--;   var results = [];   fs.readdir(dir, function(err, list) {       if (err) return done(err);       var i = 0;       (function next() {           var file = list[i++];           if (!file) return done(null, results);           file = dir + "/" + file;           fs.stat(file, function(err, stat) {               if (stat &amp;&amp; stat.isDirectory()) {                   if (depth !== 0) {                       var ndepth = (depth &gt; 1) ? depth-1 : 1;                       exports.scan(file, ndepth, function(err, res) {                           results = results.concat(res);                           next();                       });                   } else {                       next();                   }               } else {                   results.push(file);                   next();               }           });       })();   });};</pre> <p>Mocha должен пройти оба теста. Последняя функция, которую нам нужно реализовать, - это та, которая примет массив путей и ключевое слово поиска и вернет все совпадения. Вот тест на это:</p> <pre class="brush: javascript noskimlinks noskimwords">    describe("#match()", function(){        it("should find and return matches based on a query", function(){            var files = ["hello.txt", "world.js", "another.js"];            var results = search.match(".js", files);            expect(results).to.deep.equal(["world.js", "another.js"]);            results = search.match("hello", files);            expect(results).to.deep.equal(["hello.txt"]);        });    });</pre> <p>И последнее, но не менее важное: добавим функцию в <code>search.js</code>: </p> <pre class="brush: javascript noskimlinks noskimwords">exports.match = function(query, files){  var matches = [];  files.forEach(function(name) {      if (name.indexOf(query) !== -1) {          matches.push(name);      }  });  return matches;}</pre> <p>Просто чтобы убедиться, снова запустите Mocha, вы должны пройти в общей сложности семь тестов.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=762/net/uploads/2013/10/image5.png" alt="Тестирование в Node.js..." title="Тестирование в Node.js..." width="50" height="50"><br></figure><hr><h2>Все вместе</h2> <p>Последний шаг - действительно написать код-клей, который объединяет все наши модули; поэтому в корне нашего проекта добавьте файл с именем <code>app.js</code> или что-то в этом роде и добавьте в него следующее:</p> <pre class="brush: javascript noskimlinks noskimwords"># !/usr/bin/env nodevar tags = require("./lib/tags.js");var search = require("./lib/search.js");var defaults = {   path: ".",   query: "",   depth: 2}var replacements = {   p: "path",   q: "query",   d: "depth",   h: "help"}tags = tags.parse(process.argv, defaults, replacements);if (tags.help) {   console.log("Usage: ./app.js -q=query [-d=depth] [-p=path]");} else {   search.scan(tags.path, tags.depth, function(err, files) {       search.match(tags.query, files).forEach(function(file){           console.log(file);       });   });}</pre> <p>На самом деле никакой реальной логики здесь нет, мы просто соединяем разные модули вместе, чтобы получить желаемые результаты. Обычно я не тестирую этот код, так как это всего лишь клей кода, который уже был протестирован.</p> <p>Теперь вы можете сделать свой скрипт исполняемым (<code>chmod + x app.js</code> в системе Unix), а затем запустить его так:</p> <pre class="brush: bash noskimlinks noskimwords">./app.js -q=".js"</pre> <p>При желании можно настроить некоторые из других заполнителей.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=451/net/uploads/2013/10/image6.png" alt="Тестирование в Node.js..." title="Тестирование в Node.js..." width="50" height="50"><br></figure><hr><h2>Вывод</h2> <p>В этой статье мы создали полноценное приложение для поиска файлов, хотя и простое, но я думаю, что оно демонстрирует процесс в целом довольно хорошо.</p> <p>Если вы собираетесь часто использовать TDD, то настройте свою среду. Много времени, которое люди связывают с TDD, связано с тем, что им приходится постоянно переключаться между окнами, открывать и закрывать разные файлы, а затем запускать тесты и повторять это 80 десятков раз в день. В таком случае это прерывает ваш рабочий процесс, снижая производительность. Но если у вас есть настройка редактора, например, у вас есть тесты и код бок о бок, или ваша среда IDE поддерживает прыжки назад и вперед, это экономит массу времени. Вы также можете получить свои тесты для автоматического запуска, вызвав его с помощью тега <code>-w</code>, чтобы следить за изменениями в файлах и автоматически запускать все тесты. Такие вещи делают весь процесс более плавным и более полезным.</p> <p>Надеюсь, вам понравилась эта статья, если у вас есть вопросы, вы можете оставить их ниже, свяжитесь со мной в Twitter <span>@gabrielmanricks</span> или на канале Nettuts + IRC (#nettuts on freenode).</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825538-testirovanie-v-nodejs" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Tools &amp; Tips" href="https://norma-studio.github.io/article5/220825538-testirovanie-v-nodejs" class="tm-article-body__tags-item-link">Tools &amp; Tips</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
44424</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
605</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

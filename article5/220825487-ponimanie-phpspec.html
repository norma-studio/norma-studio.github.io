
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Понимание PhpSpec
... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Понимание PhpSpec
... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Понимание PhpSpec
... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Понимание PhpSpec
... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Если вы сравните PhpSpec с другими фреймворками тестирования, вы обнаружите, что это очень сложный и упрямый инструмент. Одной из причин этого является то, что PhpSpec не является фреймворком тестирования, как те, которые вы уже знаете. ...">
<meta property="og:description" content="Если вы сравните PhpSpec с другими фреймворками тестирования, вы обнаружите, что это очень сложный и упрямый инструмент. Одной из причин этого является то, что PhpSpec не является фреймворком тестирования, как те, которые вы уже знаете. ...">
<meta name="twitter:description" content="Если вы сравните PhpSpec с другими фреймворками тестирования, вы обнаружите, что это очень сложный и упрямый инструмент. Одной из причин этого является то, что PhpSpec не является фреймворком тестирования, как те, которые вы уже знаете. ...">
<meta property="aiturec:description" content="Если вы сравните PhpSpec с другими фреймворками тестирования, вы обнаружите, что это очень сложный и упрямый инструмент. Одной из причин этого является то, что PhpSpec не является фреймворком тестирования, как те, которые вы уже знаете. ...">
<meta property="og:image" content="//www.gravatar.com/avatar/f63efc863269f29578f97eb94789ed00?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
<meta property="aiturec:image" content="//www.gravatar.com/avatar/f63efc863269f29578f97eb94789ed00?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
<meta name="twitter:image" content="//www.gravatar.com/avatar/f63efc863269f29578f97eb94789ed00?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
<meta property="vk:image" content="//www.gravatar.com/avatar/f63efc863269f29578f97eb94789ed00?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
<meta property="og:type" content="article">
<link image_src="image" href="//www.gravatar.com/avatar/f63efc863269f29578f97eb94789ed00?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825487-ponimanie-phpspec.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825487-ponimanie-phpspec.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825487-ponimanie-phpspec.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825487-ponimanie-phpspec.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825487-ponimanie-phpspec.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825487-ponimanie-phpspec.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825487-ponimanie-phpspec.html" title="Понимание PhpSpec
... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Понимание PhpSpec
... | envatomarket.ru | norma-studio.github.io" title="Понимание PhpSpec
... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/e_09402063.jpg" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825487-ponimanie-phpspec.html" class="tm-user-info__username" title="
А. Карпов" aria-label="
А. Карпов">
А. Карпов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Понимание PhpSpec
...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825487-ponimanie-phpspec" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="BDD" href="https://norma-studio.github.io/article5/220825487-ponimanie-phpspec" class="tm-article-snippet__hubs-item-link"><span>BDD</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825487-ponimanie-phpspec.html" />
    <link itemprop="image" href="//www.gravatar.com/avatar/f63efc863269f29578f97eb94789ed00?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
    <meta itemprop="headline name" content="Понимание PhpSpec
... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Если вы сравните PhpSpec с другими фреймворками тестирования, вы обнаружите, что это очень сложный и упрямый инструмент. Одной из причин этого является то, что PhpSpec не является фреймворком тестирования, как те, которые вы уже знаете. ...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Если вы сравните PhpSpec с другими фреймворками тестирования, вы обнаружите, что это очень сложный и упрямый инструмент. Одной из причин этого является то, что PhpSpec не является фреймворком тестирования, как те, которые вы уже знаете. ...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Если вы сравните PhpSpec с другими фреймворками тестирования, вы обнаружите, что это очень сложный и упрямый инструмент. Одной из причин этого является то, что PhpSpec не является фреймворком тестирования, как те, которые вы уже знаете. </p><p>Вместо этого это инструмент проектирования, который помогает описать поведение программного обеспечения. Побочным эффектом описания поведения программного обеспечения с PhpSpec является то, что вы получите спецификации, которые также будут служить в качестве тестов впоследствии.</p><p>В этой статье мы заглянем под капот PhpSpec и попытаемся получить более глубокое представление о том, как он работает и как его использовать.</p><p>Если вы хотите освежить в памяти, что такое phpspec, взгляните на мой учебник <span>по началу работы</span>.<br></p><h2>В этой статье...</h2><ul class="task-list"><li>Быстрый обзор внутренностей PhpSpec</li> <li>Разница между TDD и BDD</li> <li>Чем отличается PhpSpec (от PHPUnit)</li> <li>PhpSpec: инструмент проектирования</li> </ul><h2>Быстрый обзор внутренностей PhpSpec</h2><p>Давайте начнем с изучения некоторых ключевых понятий и классов, которые формируют PhpSpec.<br></p><h3>Понимание <code>$this</code> </h3><p>Понимание того, что означает <code>$this</code>, является ключевым для понимания того, чем PhpSpec отличается от других инструментов. В принципе, <code>$this</code> ссылается на экземпляр фактического тестируемого класса. Попробуем углубиться в это немного больше, чтобы лучше понять, что мы имеем в виду.</p><p>Прежде всего, нам нужна спецификация и класс для тестирования. Как вы знаете, генераторы PhpSpec сделают это очень легко для нас:</p><div><pre class="brush: bash noskimlinks noskimwords">$ phpspec desc "Suhm\HelloWorld"$ phpspec runDo you want me to create `Suhm\HelloWorld` for you? y</pre></div><p>Затем, откройте созданный файл spec и попробуем получить немного больше информации о <code>$this</code>:</p><div><pre class="brush: php noskimlinks noskimwords">&lt;?phpnamespace spec\Suhm;use PhpSpec\ObjectBehavior;use Prophecy\Argument;class HelloWorldSpec extends ObjectBehavior{    function it_is_initializable()    {        $this-&gt;shouldHaveType("Suhm\HelloWorld");        var_dump(get_class($this));    }}</pre></div><p><code>get_class()</code> возвращает имя класса для данного объекта. В этом случае мы просто передаем <code>$this</code>, чтобы увидеть, что он возвращает:</p><div><pre class="brush: bash noskimlinks noskimwords">$ string(24) "spec\Suhm\HelloWorldSpec"</pre></div><p>Хорошо, и не удивительно, что <code>get_class()</code> говорит нам, что <code>$this</code> экземпляр <code>spec\Suhm\HelloWorldSpec</code>. Это имеет смысл, поскольку, в конце концов, это просто <em>обычный</em> PHP-код. Если вместо этого мы использовали <code>get_parent_class()</code>, мы бы получили <code>PhpSpec\ObjectBehavior</code>, так как наша спецификация расширяет этот класс.</p><p>Помните, я только что сказал вам, что <code>$this</code> действительно относится к тестируемому классу, который в нашем случае был бы <code>Suhm\HelloWorld</code>? Как вы можете видеть, возвращаемое значение <code>get_class ($this)</code> противоречит <code>$this-&gt;shouldHaveType("Suhm\HelloWorld");</code>.</p><p>Давайте попробуем что-нибудь еще:</p><div><pre class="brush: php noskimlinks noskimwords">&lt;?phpnamespace spec\Suhm;use PhpSpec\ObjectBehavior;use Prophecy\Argument;class HelloWorldSpec extends ObjectBehavior{    function it_is_initializable()    {        $this-&gt;shouldHaveType("Suhm\HelloWorld");        var_dump(get_class($this));        $this-&gt;dumpThis()-&gt;shouldReturn("spec\Suhm\HelloWorldSpec");    }}</pre></div><p>С помощью вышеуказанного кода мы пытаемся вызвать метод с именем <code>dumpThis()</code> в экземпляре <code>HelloWorld</code>. Мы добавим ожидание к вызову метода, ожидая, что возвращаемое значение функции будет строкой, содержащей «<code>spec\Suhm\HelloWorldSpec</code>». Это возвращаемое значение из <code>get_class()</code> в строке выше.</p><p>Опять же, генераторы PhpSpec могут помочь нам с некоторым предварительным кодом:</p><div><pre class="brush: bash noskimlinks noskimwords">$ phpspec runDo you want me to create `Suhm\HelloWorld::dumpThis()` for you? y</pre></div><p>Попробуем также вызвать <code>get_class()</code> из <code>dumpThis()</code>:</p><div><pre class="brush: php noskimlinks noskimwords">&lt;?phpnamespace Suhm;class HelloWorld{    public function dumpThis()    {        return get_class($this);    }}</pre></div><p>Опять же, неудивительно, что мы получаем:</p><div><pre class="brush: bash noskimlinks noskimwords">  10  ✘ it is initializable      expected "spec\Suhm\HelloWorldSpec", but got "Suhm\HelloWorld".</pre></div><p>Похоже, что мы чего-то здесь не замечаем. Я начал с того, что сказал, что <code>$this</code> не относится к тому, что вы думаете, но пока наши эксперименты не показали ничего неожиданного. За исключением одного: как мы могли бы назвать <code>$this-&gt;dumpThis()</code>?</p><p>Чтобы понять это, нам нужно погрузиться в исходный код PhpSpec. Если вы хотите, вы можете прочитать код на <span>GitHub</span>.</p><p>Посмотрите следующий код из <code>src/PhpSpec/ObjectBehavior.php</code> (класс, который расширяет наша спецификация):</p><div><pre class="brush: php noskimlinks noskimwords">/** * Proxies all call to the PhpSpec subject * * @param string $method * @param array  $arguments * * @return mixed */public function __call($method, array $arguments = array()){    return call_user_func_array(array($this-&gt;object, $method), $arguments);}</pre></div><p>Комментарии дают большую часть информации: <code>"Proxies all call to the PhpSpec subject"</code>. Метод PHP <code>__call</code> - это волшебный метод, который вызывается автоматически, когда метод недоступен (или не существует). </p><p>Это означает, что когда мы пытались вызвать <code>$this-&gt;dumpThis()</code>, вызов, по-видимому, был проксирован к объекту PhpSpec. Если вы посмотрите на код, вы увидите, что вызов метода проксирован в <code>$this-&gt;object</code>. (То же самое относится и к свойствам в нашем экземпляре. Все они также связаны с объектом, используя другие магические методы. Посмотрите в исходном коде, чтобы убедиться.)</p><p>Давайте проверим <code>get_class()</code> еще раз и посмотрим, что он должен сказать о <code>$this-&gt;object</code>:</p><div><pre class="brush: php noskimlinks noskimwords">&lt;?phpnamespace spec\Suhm;use PhpSpec\ObjectBehavior;use Prophecy\Argument;class HelloWorldSpec extends ObjectBehavior{    function it_is_initializable()    {        $this-&gt;shouldHaveType("Suhm\HelloWorld");        var_dump(get_class($this-&gt;object));    }}</pre></div><p>И посмотрим, что получилось:</p><pre class="brush: bash noskimlinks noskimwords">string(23) "PhpSpec\Wrapper\Subject"</pre><h3>Еще о <code>Subject</code> </h3><p><code>Subject</code> - это оболочка и реализует <code>PhpSpec\Wrapper\WrapperInterface</code>. Это ключевая часть PhpSpec и позволяет использовать все [казалось бы] магии, которые предоставляет фреймворк. Она содержит в себе экземпляр класса, который мы тестируем, чтобы мы могли делать всевозможные вещи, такие как вызовы методов и свойств, которые не существуют и устанавливать ожидания. </p><p>Как уже упоминалось, PhpSpec очень ориентирован на то, как вы должны писать и специфицировать свой код. Один spec сопоставляется с одним классом. У вас есть только <em>один</em> subject для каждой спецификации. Важно отметить, что это позволяет вам использовать <code>$this</code>, как если бы это был фактический экземпляр, и делает его действительно понятным и содержательным.</p><p>PhpSpec содержит <code>Wrapper</code>, который занимается созданием <code>Subject</code>. Он упаковывает <code>Subject</code> с фактическим объектом, который мы специфицируем. Поскольку <code>Subject</code> реализует <code>WrapperInterface</code>, он должен иметь метод <code>getWrappedObject()</code>, который дает нам доступ к объекту. Это экземпляр объекта, который мы искали ранее с помощью <code>get_class()</code>. </p><p>Попробуем еще раз:</p><div><pre class="brush: php noskimlinks noskimwords">&lt;?phpnamespace spec\Suhm;use PhpSpec\ObjectBehavior;use Prophecy\Argument;class HelloWorldSpec extends ObjectBehavior{    function it_is_initializable()    {        $this-&gt;shouldHaveType("Suhm\HelloWorld");        var_dump(get_class($this-&gt;object-&gt;getWrappedObject()));        // And just to be completely sure:        var_dump($this-&gt;object-&gt;getWrappedObject()-&gt;dumpThis());    }}</pre></div><p>И вот вы идете:</p><div><pre class="brush: bash noskimlinks noskimwords">$ vendor/bin/phpspec runstring(15) "Suhm\HelloWorld"string(15) "Suhm\HelloWorld"</pre></div><p>Несмотря на то, что многое происходит за сценой, в конце мы все еще работаем с фактическим экземпляром объекта <code>Suhm\HelloWorld</code>. Отлично.</p><p>Раньше, когда мы вызывали <code>$this-&gt;dumpThis()</code>, мы узнали, как вызов был фактически проксирован для <code>Subject</code>. Мы также узнали, что <code>Subject</code> является только оболочкой, а не фактическим объектом. </p><p>Благодаря этим знаниям ясно, что мы не можем вызвать <code>dumpThis()</code> на <code>Subject</code> без другого магического метода. <code>Subject</code> имеет метод <code>__call()</code>:</p><div><pre class="brush: php noskimlinks noskimwords">/** * @param string $method * @param array  $arguments * * @return mixed|Subject */public function __call($method, array $arguments = array()){  if (0 === strpos($method, "should")) {      return $this-&gt;callExpectation($method, $arguments);  }  return $this-&gt;caller-&gt;call($method, $arguments);}</pre></div><p>Этот метод делает две вещи. Во-первых, он проверяет, начинается ли имя метода с "should". Если это так, это ожидание, и вызов делегируется методу <code>callExpectation()</code>. Если нет, вызов вместо этого делегируется экземпляру <code>PhpSpec\Wrapper\Subject\Caller</code>. </p><p>На данный момент мы будем игнорировать <code>Caller</code>. Он также содержит обернутый объект и знает, как вызвать на нем методы. <code>Caller</code> возвращает завернутый экземпляр, когда он вызывает методы subject, что позволяет нам связывать ожидания с методами, как это было сделано в случае с dumpThis().</p><p>Вместо этого давайте посмотрим на метод <code>callExpectation()</code>:</p><div><pre class="brush: php noskimlinks noskimwords">/** * @param string $method * @param array  $arguments * * @return mixed */private function callExpectation($method, array $arguments){    $subject = $this-&gt;makeSureWeHaveASubject();    $expectation = $this-&gt;expectationFactory-&gt;create($method, $subject, $arguments);    if (0 === strpos($method, "shouldNot")) {        return $expectation-&gt;match(lcfirst(substr($method, 9)), $this, $arguments, $this-&gt;wrappedObject);    }    return $expectation-&gt;match(lcfirst(substr($method, 6)), $this, $arguments, $this-&gt;wrappedObject);}</pre></div><p>Этот метод отвечает за создание экземпляра <code>PhpSpec\Wrapper\Subject\Expectation\ExpectationInterface</code>. Этот интерфейс определяет метод <code>match()</code>, который <code>callExpectation()</code> вызывает для проверки ожидания. Существует четыре разных вида ожиданий: <code>Positive</code>,  <code>Negative</code>, <code>PositiveThrow</code> и <code>NegativeThrow</code>. Каждый из этих ожиданий содержит экземпляр <code>PhpSpec\Matcher\MatcherInterface</code>, который использует метод <code>match()</code>. Давайте посмотрим на ближайших помощников.</p><h3>Matchers</h3><p>Матчи - это то, что мы используем для определения поведения наших объектов. Всякий раз, когда мы пишем, <code>should ...</code> или <code>shouldNot ...</code>, мы используем матч. Вы можете найти полный список помощников PhpSpec в <span>моем личном блоге</span>.</p><p>В PhpSpec есть много шаблонов, которые расширяют класс <code>PhpSpec\Matcher\BasicMatcher</code>, который реализует <code>MatcherInterface.</code> То, как работают матчи, довольно просто. Давайте взглянем на это вместе, и я также рекомендую вам взглянуть на <span>исходный код</span>.</p><p>В качестве примера рассмотрим этот код из <span><code>IdentityMatcher</code></span>:</p><div><pre class="brush: php noskimlinks noskimwords">/** * @var array */private static $keywords = array(    "return",    "be",    "equal",    "beEqualTo");/** * @param string $name * @param mixed  $subject * @param array  $arguments * * @return bool */public function supports($name, $subject, array $arguments){    return in_array($name, self::$keywords)        &amp;&amp; 1 == count($arguments)    ;}</pre></div><p>Метод <code>supports()</code> определен в <code>MatcherInterface</code>. В этом случае для матча в массиве <code>$keywords</code> определены четыре <em>псевдонима</em>. Это позволит матчеру поддерживать либо: <code>shouldReturn()</code>, <code>shouldBe()</code>, <code>shouldEqual()</code> или <code>shouldBeEqualTo()</code>, либо <code>shouldNotReturn()</code>, <code>shouldNotBe()</code>, <code>shouldNotEqual()</code> или <code>shouldNotBeEqualTo()</code>.</p><p>Из <code>BasicMatcher</code> наследуются два метода: <code>positiveMatch()</code> и <code>negativeMatch()</code>. Они выглядят так:</p><div><pre class="brush: php noskimlinks noskimwords">/** * @param string $name * @param mixed  $subject * @param array  $arguments * * @return mixed * *   @throws FailureException */final public function positiveMatch($name, $subject, array $arguments){    if (false === $this-&gt;matches($subject, $arguments)) {        throw $this-&gt;getFailureException($name, $subject, $arguments);    }    return $subject;}</pre></div><p>Метод <code>positiveMatch()</code> генерирует исключение, если метод <code>matches()</code> (абстрактный метод, который должны реализовывать все соответствующие классы) возвращает <code>false</code>. Метод <code>negativeMatch()</code> работает обратным образом. Метод <code>matches()</code> для <code>theIdentityMatcher</code> использует оператор <code>===</code> для сравнения <code>$subject</code> с аргументом, предоставленным методу сравнения:</p><div><pre class="brush: php noskimlinks noskimwords">/** * @param mixed $subject * @param array $arguments * * @return bool */protected function matches($subject, array $arguments){   return $subject === $arguments[0];}</pre></div><p>Мы могли бы использовать этот помощник следующим образом:</p><div><pre class="brush: php noskimlinks noskimwords">$this-&gt;getUser()-&gt;shouldNotBeEqualTo($anotherUser);</pre></div><p>Что в конечном итоге вызовет функцию <code>negativeMatch(</code>) и убедится, что <code>match()</code> возвращает false.</p><p>Взгляните на некоторых других помощников и посмотрите, что они делают!</p><h3>Обещания большего волшебства</h3><p>Прежде чем мы закончим этот короткий тур по внутренним частям PhpSpec, давайте посмотрим на еще одну магию:</p><div><pre class="brush: php noskimlinks noskimwords">&lt;?phpnamespace spec\Suhm;use PhpSpec\ObjectBehavior;use Prophecy\Argument;class HelloWorldSpec extends ObjectBehavior{    function it_is_initializable(\StdClass $object)    {        $this-&gt;shouldHaveType("Suhm\HelloWorld");        var_dump(get_class($object));    }}</pre></div><p>Добавляя в наш пример тайп хинт для параметра <code>$object</code>, PhpSpec автоматически использует <span>reflection</span> для инъекции экземпляра этого класса. Но с тем, что мы уже видели, действительно ли мы верим, что мы действительно получаем экземпляр <code>StdClass</code>? Давайте проверим еще раз с помощью <code>get_class()</code>:</p><div><pre class="brush: bash noskimlinks noskimwords">$ vendor/bin/phpspec runstring(28) "PhpSpec\Wrapper\Collaborator"</pre></div><p>Нет. Вместо <code>StdClass</code> мы получаем экземпляр <code>PhpSpec\Wrapper\Collaborator</code>. Что это за класс?</p><p>Подобно <code>Subject</code>, <code>Collaborator</code> - это оболочка и реализует <code>WrapperInterface</code>. Он содержит внутри экземпляр <code>\Prophecy\Prophecy\ObjectProphecy</code>, который проистекает из <span>Prophecy</span>, mock фреймворка, который поставляется вместе с PhpSpec. Вместо экземпляра <code>StdClass</code> PhpSpec дает нам мок. Что делает использование моков в PhpSpec предельно простым и позволяет добавлять обещания к нашим объектам следующим образом:</p><div><pre class="brush: php noskimlinks noskimwords">$user-&gt;getAge()-&gt;willReturn(10);$this-&gt;setUser($user);$this-&gt;getUserStatus()-&gt;shouldReturn("child");</pre></div><p>В этом коротком туре по части внутренних компонентов PhpSpec я надеюсь, что вы увидели, что это больше, чем простой фреймворк для тестирования.</p><h2>Разница между TDD и BDD</h2><p>PhpSpec - это инструмент для выполнения SpecBDD, поэтому, чтобы лучше понять, давайте рассмотрим различия между разработкой, основанной на тестах (TDD) и разработкой, основанной на поведении (BDD). После этого мы быстро рассмотрим, чем PhpSpec отличается от других инструментов, таких как PHPUnit.</p><p>TDD - это концепция, позволяющая автоматическим тестам управлять дизайном и внедрением кода. Путем написания небольших тестов для каждой функции, прежде чем их реализовать, когда мы получим проходящий тест, мы знаем, что наш код удовлетворяет этой конкретной функции. После прохождения теста, после рефакторинга, мы прекращаем кодирование и вместо этого записываем следующий тест. Известная мантра «красный», «зеленый», «рефакторинг»!</p><p>BDD имеет свое происхождение от - и очень похож на - TDD. Честно говоря, речь идет главным образом о формулировке, которая действительно важна, поскольку она может изменить то, как мы думаем во время разработки. В тот момент, когда TDD рассказывает о тестировании, BDD рассказывает об описании поведения. </p><p>С TDD мы фокусируемся на проверке того, что наш код работает так, как мы ожидаем, что он будет работать, тогда как с BDD мы сосредоточимся на проверке того, что наш код действительно ведет себя так, как мы этого хотим. Основной причиной появления BDD в качестве альтернативы TDD является отказ от использования слова «тест». С BDD нам не очень интересно тестировать реализацию нашего кода, нас больше интересует тестирование того, что он делает (его поведение). Когда мы используем BDD, вместо TDD, у нас есть истории и спецификации. Это упрощает запись традиционных тестов.</p><p>Истории и спецификации тесно связаны с ожиданиями участников проекта. Написание историй (с помощью такого инструмента, как <span>Behat</span>), предпочтительно будет взаимодействовать вместе с заинтересованными сторонами или экспертами в доменной области. Истории охватывают внешнее поведение. Мы используем спецификации для разработки внутреннего поведения, необходимого для полного заполнения этапов истории. Каждый шаг в истории может потребовать нескольких итераций с написанием спецификаций и внедрением кода, прежде чем спецификация будет удовлетворена. Наши истории вместе с нашими спецификациями помогают нам убедиться, что мы не только строим рабочую вещь, но и то, что она также и правильная. Таким образом, BDD имеет много общего с коммуникацией.</p><h2> Чем PhpSpec отличается от PHPUnit?</h2><p>Несколько месяцев назад заметный член сообщества PHP, Mathias Verraes, разместил пост «<span>Тестовый модуль в твитте</span>» в Twitter. Дело было в том, чтобы подгонять исходный код функциональной модульной тестовой платформы в один твит. Как видно из сути, код действительно функциональный и позволяет писать базовые модульные тесты. Концепция модульного тестирования на самом деле довольно проста: проверьте какое-то утверждение и сообщите пользователю о результате.</p><p>Конечно, большинство тестовых фреймворков, таких как PHPUnit, действительно намного более продвинуты и могут делать гораздо больше, чем структура Mathias, но она по-прежнему показывает важный момент: вы утверждаете что-то, а затем ваш фреймворк запускает это утверждение для вас.</p><p>Давайте рассмотрим очень простой тест PHPUnit:</p><div><pre class="brush: php noskimlinks noskimwords">public function testTrue(){   $this-&gt;assertTrue(false);}</pre></div><p>Сможете ли вы написать суперпростую реализацию фреймворка тестирования, которая могла бы запустить этот тест? Я уверен, что ответ «да», вы можете это сделать. В конце концов, единственное, что должен сделать метод <code>assertTrue()</code>, - это сравнить значение с <code>true</code> и выбросить исключение, если оно не выполнено. В основе всего, что происходит, на самом деле довольно прямолинейно.</p><p>Итак, чем же отличается PhpSpec? Прежде всего, PhpSpec не является инструментом тестирования. Тестирование вашего кода не является основной целью PhpSpec, но это становится побочным эффектом, если вы используете его для разработки своего программного обеспечения путем постепенного добавления спецификаций для поведения (BDD). </p><p>Во-вторых, я думаю, что в вышеуказанных разделах должно было быть ясно, чем отличается PhpSpec. Тем не менее, давайте сравним некоторый код:</p><div><pre class="brush: php noskimlinks noskimwords">// PhpSpecfunction it_is_initializable(){    $this-&gt;shouldHaveType("Suhm\HelloWorld");}// PHPUnitfunction testIsInitializable(){    $object = new Suhm\HelloWorld();    $this-&gt;assertInstanceOf("Suhm\HelloWorld", $object);}</pre></div><p>Поскольку PhpSpec очень самоуверен и высказывает некоторые утверждения о том, как разрабатывается наш код, он дает нам очень простой способ описать наш код. С другой стороны, PHPUnit не делает никаких утверждений в отношении нашего кода и позволяет нам делать в значительной степени то, что мы хотим. В принципе, все PHPUnit для нас в этом примере - это запуск объекта <code>$object</code> с оператором <code>instanceof</code>. </p><p>Несмотря на то, что с PHPUnit может показаться проще начать работу (я не думаю, что это так), если вы не будете осторожны, вы можете легко попасть в ловушки плохого дизайна и архитектуры, потому что он позволяет вам делать что угодно. При этом PHPUnit все еще может быть отличным для многих случаев использования, но это не инструмент разработки, такой как PhpSpec. Нет руководства - вы должны знать, что делаете.</p><h2> PhpSpec: инструмент проектирования</h2><p>На <span>веб-сайте PhpSpec</span> мы можем узнать, что PhpSpec:</p><blockquote><i>Набор инструментов php для создания дизайна по спецификации.</i></blockquote><p>Позвольте мне сказать это еще раз: PhpSpec не является фреймворком тестирования. Это инструмент разработки. Инструмент разработки программного обеспечения. Это не простой фреймворк с утверждениями, который сравнивает значения и бросает исключения. Это инструмент, который помогает нам в разработке и создании хорошо продуманного кода. Он требует от нас мыслить о структуре нашего кода и применять некоторые архитектурные шаблоны, где один класс сопоставляется с одной спецификацией. Если вы нарушите принцип единой ответственности и вам нужно частично что-то замокать, вам не разрешат это делать.</p><p>Удачи со спецификациями!</p><p>Ой! И, наконец, =, поскольку сам PhpSpec специфицирован, я предлагаю вам перейти на GitHub и <span>изучить исходный код, чтобы узнать больше</span>.</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825487-ponimanie-phpspec" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="BDD" href="https://norma-studio.github.io/article5/220825487-ponimanie-phpspec" class="tm-article-body__tags-item-link">BDD</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
41545</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
602</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

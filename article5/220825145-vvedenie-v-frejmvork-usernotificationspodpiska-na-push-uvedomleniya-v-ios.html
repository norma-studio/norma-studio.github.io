
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Вместе с iOS 10, tvOS 10 и watchOS 3, Apple представила новый фреймворк, названный UserNotifications. Этот совершенно новый набор API предоставляет унифицированный, объектно-ориентированный способ работы с локальными и удаленными уведомлениями на этих платформах. Это особенно полезно, так как теперь по сравнению с существующим API, обрабатывать лок...">
<meta property="og:description" content="Вместе с iOS 10, tvOS 10 и watchOS 3, Apple представила новый фреймворк, названный UserNotifications. Этот совершенно новый набор API предоставляет унифицированный, объектно-ориентированный способ работы с локальными и удаленными уведомлениями на этих платформах. Это особенно полезно, так как теперь по сравнению с существующим API, обрабатывать лок...">
<meta name="twitter:description" content="Вместе с iOS 10, tvOS 10 и watchOS 3, Apple представила новый фреймворк, названный UserNotifications. Этот совершенно новый набор API предоставляет унифицированный, объектно-ориентированный способ работы с локальными и удаленными уведомлениями на этих платформах. Это особенно полезно, так как теперь по сравнению с существующим API, обрабатывать лок...">
<meta property="aiturec:description" content="Вместе с iOS 10, tvOS 10 и watchOS 3, Apple представила новый фреймворк, названный UserNotifications. Этот совершенно новый набор API предоставляет унифицированный, объектно-ориентированный способ работы с локальными и удаленными уведомлениями на этих платформах. Это особенно полезно, так как теперь по сравнению с существующим API, обрабатывать лок...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/41/posts/21925/preview_image/preview-image@2x.jpg">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/41/posts/21925/preview_image/preview-image@2x.jpg">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/41/posts/21925/preview_image/preview-image@2x.jpg">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/41/posts/21925/preview_image/preview-image@2x.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/41/posts/21925/preview_image/preview-image@2x.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825145-vvedenie-v-frejmvork-usernotificationspodpiska-na-push-uvedomleniya-v-ios.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825145-vvedenie-v-frejmvork-usernotificationspodpiska-na-push-uvedomleniya-v-ios.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825145-vvedenie-v-frejmvork-usernotificationspodpiska-na-push-uvedomleniya-v-ios.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825145-vvedenie-v-frejmvork-usernotificationspodpiska-na-push-uvedomleniya-v-ios.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825145-vvedenie-v-frejmvork-usernotificationspodpiska-na-push-uvedomleniya-v-ios.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825145-vvedenie-v-frejmvork-usernotificationspodpiska-na-push-uvedomleniya-v-ios.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825145-vvedenie-v-frejmvork-usernotificationspodpiska-na-push-uvedomleniya-v-ios.html" title="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS... | envatomarket.ru | norma-studio.github.io" title="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/31231313312.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825145-vvedenie-v-frejmvork-usernotificationspodpiska-na-push-uvedomleniya-v-ios.html" class="tm-user-info__username" title="
Д. Грунин" aria-label="
Д. Грунин">
Д. Грунин</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825145-vvedenie-v-frejmvork-usernotificationspodpiska-na-push-uvedomleniya-v-ios" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="iOS" href="https://norma-studio.github.io/article5/220825145-vvedenie-v-frejmvork-usernotificationspodpiska-na-push-uvedomleniya-v-ios" class="tm-article-snippet__hubs-item-link"><span>iOS</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825145-vvedenie-v-frejmvork-usernotificationspodpiska-na-push-uvedomleniya-v-ios.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/41/posts/21925/preview_image/preview-image@2x.jpg">
    <meta itemprop="headline name" content="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Вместе с iOS 10, tvOS 10 и watchOS 3, Apple представила новый фреймворк, названный UserNotifications. Этот совершенно новый набор API предоставляет унифицированный, объектно-ориентированный способ работы с локальными и удаленными уведомлениями на этих платформах. Это особенно полезно, так как теперь по сравнению с существующим API, обрабатывать лок...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Вместе с iOS 10, tvOS 10 и watchOS 3, Apple представила новый фреймворк, названный UserNotifications. Этот совершенно новый набор API предоставляет унифицированный, объектно-ориентированный способ работы с локальными и удаленными уведомлениями на этих платформах. Это особенно полезно, так как теперь по сравнению с существующим API, обрабатывать лок...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<h2>Введение</h2><p>Вместе с iOS 10, tvOS 10 и watchOS 3, Apple представила новый фреймворк, названный <strong>UserNotifications</strong>. Этот совершенно новый набор API предоставляет унифицированный, объектно-ориентированный способ работы с локальными и удаленными уведомлениями на этих платформах. Это особенно полезно, так как теперь по сравнению с существующим API, обрабатывать локальные или удаленные уведомления можно очень схожим образом, а доступ к контенту уведомлений больше не делается через словари.</p><p>В этом уроке я расскажу об основах этого нового фреймворка и покажу, как вы можете легко использовать его для поддержки уведомлений для ваших приложений.</p><p>Для этого урока требуется, чтобы вы запустили Xcode 8 с последними версиями SDK для iOS, tvOS и watchOS.</p><h2> <span class="sectionnum">1.</span> Регистрируем уведомления</h2><p>Первым шагом для любого приложения, поддерживающего уведомления, является запрос разрешения от пользователя. Как и в предыдущих версиях iOS, при использовании фреймворка UserNotifications обычно это делается, как только приложение запускается. </p><p>Перед использованием любого из UserNotifications API вам нужно добавить следующий оператор импорта в любые Swift файлы, которые обращаются к фреймворку:<br></p><pre class="brush: javascript noskimlinks noskimwords">import UserNotifications</pre><p>Далее, чтобы зарегистрировать приложение для уведомлений, вам необходимо добавить следующий код <code class="inline">application(_:didFinishLaunchingWithOptions:)</code> в <code class="inline">AppDelegate</code>:</p><pre class="brush: javascript noskimlinks noskimwords">let center = UNUserNotificationCenter.current()let options: UNAuthorizationOptions = [.alert, .badge, .sound]center.requestAuthorization(options: options) { (granted, error) in    if granted {        application.registerForRemoteNotifications()    }}</pre><p>Изначально с помощью этого кода мы получаем ссылку на текущий объект <code class="inline">UNUserNotificationCenter</code>. Затем мы настраиваем наш <code class="inline">UNAuthorizationOptions</code> с возможностью уведомлений, которые мы хотим получать от нашего приложения. Обратите внимание, что здесь вы можете выбрать любую комбинацию параметров — например, просто <code class="inline">alert</code> или <code class="inline">badge</code> и <code class="inline">sound</code>. </p><p>Используя оба этих объекта, мы запрашиваем авторизацию для нашего приложения для отображения уведомлений, вызывая метод <code class="inline">requestAuthorization(options:completionHandler:)</code> для нашего <code class="inline">UNUserNotificationCenter</code>. Блок обработчика завершения кода имеет два переданных в него параметра:</p><ul><li>Значение <code class="inline">Bool</code> указывающее, была ли предоставлена ​​авторизация пользователем.</li> <li>Необязательный объект <code class="inline">Error</code>, который будет содержать информацию, если по какой-либо причине система не сможет запросить авторизацию для вашего приложения.</li> </ul><p>Вы увидите, что в приведенном выше коде, если авторизация предоставлена ​​пользователем, мы регистрируемся для удаленных уведомлений. Если вы хотите реализовать push-уведомления, эта строка кода обязательна. Вам также нужно будет сделать несколько дополнительных настроек для вашего проекта, как описано в этом руководстве:</p><ul class="roundup-block__contents posts--half-width roundup-block--card"><li class="roundup-block__content posts__post"><article><header><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/41/posts/21925/preview_image/preview-image@2x.jpg" alt="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS..." title="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS..." width="50" height="50"></span><span></span></header><div class="posts__post-teaser">Apple изначально вводила push-уведомления, чтобы приложения могли реагировать на события, если приложение не работает на переднем плане. Однако...</div> <footer class="posts__post-details"><div class="posts__post-teaser-overlay"></div> <div class="posts__post-publication-meta"> <img sizes="76px" class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/41/profiles/1304/profileImage/me_400.jpg" alt="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS..." title="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS..." width="50" height="50"><div class="posts__post-details__info"> <address class="posts__post-author"><span>Барт Джейкобс</span></address> <time class="posts__post-publication-date" datetime="2014-08-15 16:05:15 UTC">15 авг 2014 года</time></div> </div> <div class="posts__post-primary-category topic-code"><span>Пуш-уведомления</span></div></footer></article></li></ul><p>Обратите внимание, что регистрация для удаленных уведомлений вызовет тот же обратный вызов метода <code class="inline">UIApplication</code>, что и в предыдущих версиях iOS. При успешном будет вызвано: <code class="inline">application(_:didRegisterForRemoteNotificationsWithDeviceToken:)</code>, а при ошибке <code class="inline">application(_:didFailToRegisterForRemoteNotificationsWithError:)</code>.</p><h2> <span class="sectionnum">2.</span> Уведомления по графику</h2><p>В этом разделе нашего урока мы полностью сосредоточимся на локальных уведомлениях по графику, с использованием фреймворка UserNotifications. Отправка удаленных push-уведомлений не изменилась из-за введения этого нового фреймворка.</p><p>Локальное уведомление перед планированием представлено  экземпляром класса <code class="inline">UNNotificationRequest</code>. Объекты этого типа состоят из следующих компонентов:</p><ul><li> <strong>Идентификатор</strong>: уникальная <code class="inline">String</code>, которая позволяет отличать отдельные уведомления друг от друга.</li> <li> <strong>Контент</strong>: объект <code class="inline">UNNotificationContent</code>, который содержит всю информацию, необходимую для отображения вашего уведомления, включая название, подзаголовок и значок с количеством уведомлений.</li> <li> <strong>Триггер</strong>: объект <code class="inline">UNNotificationTrigger</code>, который используется системой для определения того, когда ваше уведомление должно быть «отправлено» в ваше приложение. </li> </ul><p>Во-первых, мы рассмотрим различные типы триггеров, которые вы можете настроить для локальных уведомлений. Класс <code class="inline">UNNotificationTrigger</code> является абстрактным классом, что означает, что вы никогда не должны создавать его экземпляры напрямую. Вместо этого вы будете использовать доступные подклассы. В настоящее время фреймворк UserNotifications предоставляет три из них:</p><ul><li> <code class="inline"><strong>UNTimeIntervalNotificationTrigger</strong></code>, который позволяет отправлять уведомление через определенное количество времени после его планирования.</li> <li> <code class="inline"><strong>UNCalendarNotificationTrigger</strong></code>, который позволяет отправлять уведомление в определенную дату и время, независимо от того, когда оно было запланировано.</li> <li> <code class="inline"><strong>UNLocationNotificationTrigger</strong></code>, который позволяет отправлять уведомления, когда пользователь входит или выезжает в указанный географический регион.</li> </ul><p>В следующем коде показано, как можно создать триггер для каждого типа:</p><pre class="brush: javascript noskimlinks noskimwords">let timeTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 60.0 * 60.0, repeats: false)var date = DateComponents()date.hour = 22let calendarTrigger = UNCalendarNotificationTrigger(dateMatching: date, repeats: true)let center = CLLocationCoordinate2D(latitude: 40.0, longitude: 120.0)let region = CLCircularRegion(center: center, radius: 500.0, identifier: "Location")region.notifyOnEntry = true;region.notifyOnExit = false;let locationTrigger = UNLocationNotificationTrigger(region: region, repeats: false)</pre><p>С помощью приведенного выше кода были созданы следующие условия триггера:</p><ul><li><code class="inline">timeTrigger</code> сработает через час после запланированного уведомления. Параметр <code class="inline">timeInterval</code> переданный в <code class="inline">UNTimeIntervalNotificationTrigger</code>, измеряется в секундах.</li> <li><code class="inline">calendarTrigger</code> будет непрерывно запускаться каждый день в 10:00 PM (22:00). Точную дату и время срабатывания триггера можно легко изменить, изменив другие свойства объекта <code class="inline">DateComponents</code>, который вы передаете в инициализатор <code class="inline">UNCalendarNotificationTrigger</code>.</li> <li><code class="inline">locationTrigger</code> сработает, когда пользователь будет находиться в пределах 500 метров от обозначенной координаты, в данном случае 40°N 120°E. Как вы можете видеть из кода, этот тип триггера может использоваться для любой координаты и/или региона, а также может инициировать уведомление при входе и выходе из региона.</li> </ul><p>Затем нам необходимо создать контент уведомления. Это делается путем создания экземпляра класса <code class="inline">UNMutableNotificationContent</code>. Этот класс должен использоваться как обычный класс <code class="inline">UNNotificationContent</code>, имеющий доступ только для чтения различных свойств содержимого уведомления.</p><p>Следующий код показывает, как можно создать контент для базового уведомления:</p><pre class="brush: javascript noskimlinks noskimwords">let content = UNMutableNotificationContent()content.title = "Notification Title"content.subtitle = "Notification Subtitle"content.body = "Some notification body information to be displayed."content.badge = 1content.sound = UNNotificationSound.default()</pre><p>Если вам нужен полный список доступных вам свойств, взгляните на класс <code class="inline">UNMutableNotificationContent</code> <span>по этой ссылке</span>.</p><p>Наконец, нам просто нужно создать объект <code class="inline">UNNotificationRequest</code> и запланировать его. Это можно осуществить с помощью следующего кода:</p><pre class="brush: javascript noskimlinks noskimwords">let request = UNNotificationRequest(identifier: "LocalNotification", content: content, trigger: timeTrigger)UNUserNotificationCenter.current().add(request) { error in    if let error = error {        // Do something with error    } else {        // Request was added successfully    }}</pre><p>Изначально с помощью этого кода мы создаем объект запроса в инициализатор, передавая идентификатор, объект содержимого и триггер. Затем мы вызываем метод <code class="inline">add(_:completionHandler:)</code> для текущего объекта <code class="inline">UNUserNotificationCenter</code> и используем обработчик завершения для выполнения алгоритмы на основании того, было ли уведомление запланировано правильно. </p><h2> <span class="sectionnum">3.</span> Получение уведомлений</h2><p>При использовании фреймворка UserNotifications, обработка входящих уведомлений обрабатывается объектом, который вы назначаете в соответствии с протоколом <code class="inline">UNUserNotificationCenterDelegate</code>. Это может быть любой объект, и вам не обязательно быть делегировано приложением, как в предыдущих версиях iOS. </p><p>Однако важно отметить, что вы должны установить своё поручение до того, как приложение будет полностью запущено. Для iOS приложения это означает, что вы должны назначить свое поручение либо в методе <code class="inline">application(_:willFinishLaunchingWithOptions:)</code>, либо в <code class="inline">application(_:didFinishLaunchingWithOptions:)</code>. Настройка делегирования для пользовательских уведомлений выполняется очень легко с помощью следующего кода:</p><pre class="brush: javascript noskimlinks noskimwords">UNUserNotificationCenter.current().delegate = delegateObject</pre><p>Теперь ваш делегат установлен, когда приложение получает уведомление, есть только два метода, о которых вам нужно побеспокоиться. Оба метода передаются объекту <code class="inline">UNNotification</code>, который отображает полученное уведомление. Этот объект содержит свойство <code class="inline">date</code>, которое сообщает вам, когда было доставлено уведомление, и свойство <code class="inline">request</code>, которое является экземпляром класса <code class="inline">UNNotificationRequest</code>, упомянутого ранее. Из этого объекта запроса вы можете получить доступ к содержимому уведомления, а также (если необходимо) триггер для уведомления. Этот объект-триггер будет экземпляром одного из подклассов <code class="inline">UNNotificationTrigger</code>, упомянутых ранее, или, в случае push-уведомлений, экземпляром класса <code class="inline">UNPushNotificationTrigger</code>.</p><p>Первый метод, определенный протоколом <code class="inline">UNUserNotificationCenterDelegate</code> — это метод <code class="inline">userNotificationCenter(_:willPresent:withCompletionHandler:)</code>. Он вызывается только тогда, когда ваше приложение запущено на переднем плане и получает уведомление. Отсюда вы можете получить доступ к контенту уведомления и при необходимости показать свой собственный интерфейс вашего приложения. Кроме того, вы можете сообщить системе, показать уведомление с различными параметрами, обычно это тогда, когда приложение не запущено. Доступны следующие варианты:</p><ul><li>Alert — Оповещение для отображения системного интерфейса для уведомления</li> <li>Sound — Звук для воспроизведения звука, связанного с уведомлением</li> <li>Badge — пузырик-счетчик для редактирования «пузыря» вашего приложения на главном экране пользователя</li> </ul><p> В следующем коде показана примерная реализация метода <code class="inline">userNotificationCenter(_:willPresent:withCompletionHandler:)</code>:</p><pre class="brush: javascript noskimlinks noskimwords">func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) {    let content = notification.request.content    // Process notification content        completionHandler([.alert, .sound]) // Display notification as regular alert and play sound}</pre><p>Другим методом, определенным протоколом <code class="inline">UNUserNotificationCenterDelegate</code>, является метод <code class="inline">userNotificationCenter(_:didReceive:withCompletionHandler:)</code>. Этот метод вызывается, когда пользователь взаимодействует с уведомлением для вашего приложения любым способом, в том числе отклоняя его или открывая из него ваше приложение. </p><p>Вместо объекта <code class="inline">UNNotification</code>, этот метод имеет объект <code class="inline">UNNotificationResponse</code>, переданный в него в качестве параметра. Этот объект содержит объект <code class="inline">UNNotification</code>, отображающий полученное уведомление. Он также включает свойство <code class="inline">actionIdentifier</code>, чтобы определить, как пользователь взаимодействовал с уведомлением. В случае отклонения уведомления или открытия вашего приложения фреймворк UserNotifications предоставит вам постоянные идентификаторы действий для сравнения.</p><p>В следующем коде показана примерная реализация метода <code class="inline">userNotificationCenter(_:didReceive:withCompletionHandler:)</code>:</p><pre class="brush: javascript noskimlinks noskimwords">func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {    let actionIdentifier = response.actionIdentifier        switch actionIdentifier {    case UNNotificationDismissActionIdentifier: // Notification was dismissed by user        // Do something        completionHandler()    case UNNotificationDefaultActionIdentifier: // App was opened from notification        // Do something        completionHandler()    default:        completionHandler()    }}</pre><p><span class="sectionnum">Обратите внимание, что для обоих методов делегации очень важно, чтобы вы вызывали обработчик завершения, как только вы закончили обработку уведомления. Как только вы это сделаете, система будет знать, что вы сделали это уведомление и можете выполнять любые необходимые процессы, такие как помещение уведомления в Центр уведомлений пользователя.</span></p><h2> <span class="sectionnum">4.</span> Управление уведомлениями</h2><p>Иногда пользователь вашего приложения может получать несколько уведомлений, пока ваше приложение не запущено. Они также могут открывать ваше приложение непосредственно с главного экрана, а не через уведомление. В любом из этих случаев не будет вызываться ни один из методов протокола <code class="inline">UNUserNotificationCenterDelegate</code>. При работе с локальными уведомлениями иногда может потребоваться удаление запланированного уведомления до его отображения пользователю.</p><p>Из-за этого фреймворк UserNotifications предоставляет следующие методы для текущего экземпляра <code class="inline">UNUserNotificationCenter</code> для работы с незавершенными локальными уведомлениями и доставки уведомлений, которые еще не обработаны:</p><ul><li> <code class="inline"><strong>getPendingNotificationRequests(completionHandler:)</strong></code> предоставляет вам массив объектов <code class="inline">UNNotificationRequest</code> в обработчике завершения. Этот массив будет содержать все запланированные локальные уведомления, которые ещё не были запущены.</li> <li> <code class="inline"><strong>removePendingNotificationRequests(withIdentifiers:)</strong></code> удаляет все запланированные локальные уведомления с идентификаторами, содержащимися в массиве <code class="inline">String</code>, который вы передаете в качестве параметра.</li> <li> <code class="inline"><strong>removeAllPendingNotificationRequests</strong></code> удаляет все запланированные локальные уведомления для вашего приложения.</li> <li> <code class="inline"><strong>getDeliveredNotifications(completionHandler:)</strong></code> предоставляет вам массив объектов <code class="inline">UNNotification</code> в обработчике завершения. Этот массив будет содержать все уведомления, которые будут показываться в вашем приложении, которые всё ещё видны в Центре уведомлений пользователя.</li> <li> <code class="inline"><strong>removeDeliveredNotifications(withIdentifiers:)</strong></code> удаляет все доставленные уведомления с идентификаторами, содержащимися в массиве <code class="inline">String</code>, который вы передаёте из Центра уведомлений пользователя.</li> <li> <code class="inline"><strong>removeAllDeliveredNifications</strong></code> удаляет всё полученные уведомления для вашего приложения.</li> </ul><h2> <span class="sectionnum">5.</span> Уведомления о пользовательских действиях</h2><p>Фреймворк UserNotifications также упрощает возможность использовать для вашего приложения пользовательские категории уведомлений и действия, введенные в iOS 8. </p><p>Во-первых, вам нужно определить пользовательские действия и категории, которые ваше приложение поддерживает, используя классы <code class="inline">UNNotificationAction</code> и <code class="inline">UNNotificationCategory</code> соответственно. Для действий, в которых вы хотите, чтобы пользователь мог вводить текст, вы можете использовать класс <code class="inline">UNTextInputNotificationAction</code>, который является подклассом <code class="inline">UNNotificationAction</code>. После определения ваших действий и категорий вам просто нужно вызвать метод <code class="inline">setNotificationCategories(_:)</code> для текущего экземпляра <code class="inline">UNUserNotificationCenter</code>. Следующий код показывает, как вы могли бы легко записывать ответы и удалять действия для категории уведомления сообщений в своем приложении:</p><pre class="brush: javascript noskimlinks noskimwords">let replyAction = UNTextInputNotificationAction(identifier: "com.usernotificationstutorial.reply", title: "Reply", options: [], textInputButtonTitle: "Send", textInputPlaceholder: "Type your message")let deleteAction = UNNotificationAction(identifier: "com.usernotificationstutorial.delete", title: "Delete", options: [.authenticationRequired, .destructive])let category = UNNotificationCategory(identifier: "com.usernotificationstutorial.message", actions: [replyAction, deleteAction], intentIdentifiers: [], options: [])center.setNotificationCategories([category])</pre><p>Затем, когда пользователь использует одно из ваших настраиваемых действий для уведомления, вызывается тот же самый метод <code class="inline">userNotificationCenter(_:didReceive:withCompletionHandler:)</code>, который мы рассмотрели ранее. В этом случае идентификатор действия передаваемого объекта <code class="inline">UNNotificationResponse</code> будет таким же, как и тот, который вы определили для своего действия. Важно также отметить, что если пользователь взаимодействовал с действием уведомления посредством текстового поля, объект ответа, переданный в этот метод, будет иметь тип <code class="inline">UNTextInputNotificationResponse</code>.</p><p>Следующий код показывает пример реализации этого метода, включая логику для действий, созданных ранее:</p><pre class="brush: javascript noskimlinks noskimwords">func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {    let actionIdentifier = response.actionIdentifier    let content = response.notification.request.content        switch actionIdentifier {    case UNNotificationDismissActionIdentifier: // Notification was dismissed by user        // Do something        completionHandler()    case UNNotificationDefaultActionIdentifier: // App was opened from notification        // Do something        completionHandler()    case "com.usernotificationstutorial.reply":        if let textResponse = response as? UNTextInputNotificationResponse {            let reply = textResponse.userText            // Send reply message            completionHandler()        }    case "com.usernotificationstutorial.delete":        // Delete message        completionHandler()    default:        completionHandler()    }}</pre><p>Кроме того, если вы хотите использовать пользовательские действия для своих локальных уведомлений, вы можете просто установить свойство <code class="inline">categoryIdentifier</code> для объекта <code class="inline">UNMutableNotificationContent</code> при создании уведомления.</p><h2>Заключение</h2><p>Новый фреймворк UserNotifications предоставляет полностью функциональный и простой в использовании объектно-ориентированный API для работы с локальными и удаленными уведомлениями на iOS, watchOS и tvOS. Это упрощает планирование локальных уведомлений для различных сценариев, а также значительно упрощает весь поток обработки входящих уведомлений и настраиваемых действий.</p><p>Как всегда, не забудьте оставить свои комментарии и отзывы в ниже. Ознакомьтесь с некоторыми другими статьями и уроками о новых функциях в iOS 10 и watchOS 3!</p><ul class="roundup-block__contents posts--half-width roundup-block--list"><li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/41/posts/26707/preview_image/wwdc-2016@2x.jpg" alt="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS..." title="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS..." width="50" height="50"><div class="roundup-block__primary-category topic-code">iOS</div> <div class="roundup-block__content-title">WWDC 2016 Последствия</div> <div class="roundup-block__author">Дэвис Алли</div></span></li> <li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/769/posts/26870/preview_image/ios-10@2x.jpg" alt="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS..." title="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS..." width="50" height="50"><div class="roundup-block__primary-category topic-code">iOS SDK</div> <div class="roundup-block__content-title">Созодаём приложение iMessage в iOS 10</div> <div class="roundup-block__author">Дэвис Алли</div></span></li> <li class="roundup-block__content"><span><img class="lazy07" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=400/uploads/users/769/posts/27126/preview_image/watchos-3@2x.jpg" alt="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS..." title="Введение в фреймворк UserNotificationsПодписка на пуш-уведомления в iOS..." width="50" height="50"><div class="roundup-block__primary-category topic-code">watchOS</div> <div class="roundup-block__content-title">Что нового в watchOS 3: фоновые задачи</div> <div class="roundup-block__author">Дэвис Алли</div></span></li> </ul><p></p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825145-vvedenie-v-frejmvork-usernotificationspodpiska-na-push-uvedomleniya-v-ios" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="iOS" href="https://norma-studio.github.io/article5/220825145-vvedenie-v-frejmvork-usernotificationspodpiska-na-push-uvedomleniya-v-ios" class="tm-article-body__tags-item-link">iOS</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
34581</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
686</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

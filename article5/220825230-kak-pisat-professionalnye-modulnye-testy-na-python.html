
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Как писать профессиональные модульные тесты на Python... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Как писать профессиональные модульные тесты на Python... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Как писать профессиональные модульные тесты на Python... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Как писать профессиональные модульные тесты на Python... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Тестирование, это основа серьёзной разработки программного обеспечения. Существует много видов тестирования, но наиболее важный вид, это модульное тестирование. Модульное тестирование даёт уверенность в том, что вы сможете использовать хорошо протестированные блоки в качестве базовых элементов, полагаться на них и использовать при создании программ...">
<meta property="og:description" content="Тестирование, это основа серьёзной разработки программного обеспечения. Существует много видов тестирования, но наиболее важный вид, это модульное тестирование. Модульное тестирование даёт уверенность в том, что вы сможете использовать хорошо протестированные блоки в качестве базовых элементов, полагаться на них и использовать при создании программ...">
<meta name="twitter:description" content="Тестирование, это основа серьёзной разработки программного обеспечения. Существует много видов тестирования, но наиболее важный вид, это модульное тестирование. Модульное тестирование даёт уверенность в том, что вы сможете использовать хорошо протестированные блоки в качестве базовых элементов, полагаться на них и использовать при создании программ...">
<meta property="aiturec:description" content="Тестирование, это основа серьёзной разработки программного обеспечения. Существует много видов тестирования, но наиболее важный вид, это модульное тестирование. Модульное тестирование даёт уверенность в том, что вы сможете использовать хорошо протестированные блоки в качестве базовых элементов, полагаться на них и использовать при создании программ...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1199/profiles/19709/profileImage/gigi_kettlebell_400x400.jpg">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1199/profiles/19709/profileImage/gigi_kettlebell_400x400.jpg">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1199/profiles/19709/profileImage/gigi_kettlebell_400x400.jpg">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1199/profiles/19709/profileImage/gigi_kettlebell_400x400.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1199/profiles/19709/profileImage/gigi_kettlebell_400x400.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825230-kak-pisat-professionalnye-modulnye-testy-na-python.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825230-kak-pisat-professionalnye-modulnye-testy-na-python.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825230-kak-pisat-professionalnye-modulnye-testy-na-python.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825230-kak-pisat-professionalnye-modulnye-testy-na-python.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825230-kak-pisat-professionalnye-modulnye-testy-na-python.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825230-kak-pisat-professionalnye-modulnye-testy-na-python.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825230-kak-pisat-professionalnye-modulnye-testy-na-python.html" title="Как писать профессиональные модульные тесты на Python... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Как писать профессиональные модульные тесты на Python... | envatomarket.ru | norma-studio.github.io" title="Как писать профессиональные модульные тесты на Python... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/543543242.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825230-kak-pisat-professionalnye-modulnye-testy-na-python.html" class="tm-user-info__username" title="
А. Морозов" aria-label="
А. Морозов">
А. Морозов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Как писать профессиональные модульные тесты на Python...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825230-kak-pisat-professionalnye-modulnye-testy-na-python" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Python" href="https://norma-studio.github.io/article5/220825230-kak-pisat-professionalnye-modulnye-testy-na-python" class="tm-article-snippet__hubs-item-link"><span>Python</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825230-kak-pisat-professionalnye-modulnye-testy-na-python.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/1199/profiles/19709/profileImage/gigi_kettlebell_400x400.jpg">
    <meta itemprop="headline name" content="Как писать профессиональные модульные тесты на Python... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Тестирование, это основа серьёзной разработки программного обеспечения. Существует много видов тестирования, но наиболее важный вид, это модульное тестирование. Модульное тестирование даёт уверенность в том, что вы сможете использовать хорошо протестированные блоки в качестве базовых элементов, полагаться на них и использовать при создании программ...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Тестирование, это основа серьёзной разработки программного обеспечения. Существует много видов тестирования, но наиболее важный вид, это модульное тестирование. Модульное тестирование даёт уверенность в том, что вы сможете использовать хорошо протестированные блоки в качестве базовых элементов, полагаться на них и использовать при создании программ...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Тестирование, это основа серьёзной разработки программного обеспечения. Существует много видов тестирования, но наиболее важный вид, это модульное тестирование. Модульное тестирование даёт уверенность в том, что вы сможете использовать хорошо протестированные блоки в качестве базовых элементов, полагаться на них и использовать при создании программы. Они увеличивают ваш инструментарий из проверенного кода за пределами ваших конструкций и стандартной библиотеки. Кроме того Python предоставляет отличную поддержку для написания модульных тестов.<br></p><h2>Действующий пример</h2><p>Прежде чем погрузиться в принципы, эвристики и руководства, давайте посмотрим репрезентативный модульный тест в действии. Класс <code class="inline">SelfDrivingCar</code> это частичное выполнение логики вождения автопилота автомобиля. Главным образом он контролирует скорость автомобиля. Он рспознаёт объекты впереди, ограничение скорости, а также прибытие или нет в пункт назначения. </p><pre class="brush: python noskimlinks noskimwords">class SelfDrivingCar(object):    def __init__(self):        self.speed = 0        self.destination = None            def _accelerate(self):        self.speed += 1            def _decelerate(self):        if self.speed &gt; 0:            self.speed -= 1                        def _advance_to_destination(self):        distance = self._calculate_distance_to_object_in_front()        if distance &lt; 10:            self.stop()        elif distance &lt; self.speed / 2:            self._decelerate()        elif self.speed &lt; self._get_speed_limit():            self._accelerate()        def _has_arrived(self):        pass            def _calculate_distance_to_object_in_front(self):        pass            def _get_speed_limit(self):        pass            def stop(self):        self.speed = 0            def drive(self, destination):        self.destination = destination        while not self._has_arrived():                        self._advance_to_destination()        self.stop()    def __init__(self):        self.speed = 0        self.destination = None            def _accelerate(self):        self.speed += 1            def _decelerate(self):        if self.speed &gt; 0:            self.speed -= 1                        def _advance_to_destination(self):        distance = self._calculate_distance_to_object_in_front()        if distance &lt; 10:            self.stop()        elif distance &lt; self.speed / 2:            self._decelerate()        elif self.speed &lt; self._get_speed_limit():            self._accelerate()        def _has_arrived(self):        pass            def _calculate_distance_to_object_in_front(self):        pass            def _get_speed_limit(self):        pass            def stop(self):        self.speed = 0            def drive(self, destination):        self.destination = destination        while not self._has_arrived():                        self._advance_to_destination()        self.stop()</pre><p>Вот модульный тест для метода <code class="inline">stop() </code>чтобы раззадорить ваш аппетит. Я расскажу подробности позже. </p><pre class="brush: python noskimlinks noskimwords">from unittest import TestCaseclass SelfDrivingCarTest(TestCase):    def setUp(self):        self.car = SelfDrivingCar()            def test_stop(self):        self.car.speed = 5        self.car.stop()        # Verify the speed is 0 after stopping        self.assertEqual(0, self.car.speed)                # Verify it is Ok to stop again if the car is already stopped        self.car.stop()        self.assertEqual(0, self.car.speed)</pre><h2>Руководство по модульному тестированию</h2><h3>Основные идеи</h3><p>Написание хороших модульных тестов это тяжелый труд. Написание модульных тестов занимает время. Когда вы меняете код, необходимо изменять тесты. Иногда в вашем тесте будут ошибки. Это означает, что вы должны быть по-настоящему идейным. Польза огромна, даже для небольших проектов, но это не бесплатно.</p><h3>Будьте дисциплинированы</h3><p>Вы должны быть дисциплинированным. Будьте последовательным. Убедитесь, что все тесты выполнены. Не отказывайтесь от тестов, только потому что вы «знаете», что код в порядке.</p><h3>Автоматизируйте</h3><p>Чтобы помочь вам быть дисциплинированным, необходимо автоматизировать модульные тесты. Тесты должны запускаться автоматически на значимых этапах, таких как проектирование или развертывание. В идеале ваша система управления версиями должна отклонять код, который не прошел все тесты.</p><h3>Непротестированный код плохой по определению</h3><p>Если вы не проверили его, вы не сможете сказать, что он работает. Это значит, что вы должны рассматривать его как плохой. Если это критический код, не разворачивайте его в производство.</p><h2>Пояснения</h2><h3>Что такое модуль?</h3><p>Модуль в смысле тестирования это файл, содержащий набор определённых функций или класс. Если у вас есть файл с несколькими классами, вы должны написать модульный тест для каждого из них.</p><h3>Делать TDD или не делать TDD</h3><p><span>Тест драйв разработка</span>, это практика, где вы пишете тесты, до того как вы пишете код. Есть несколько преимуществ этого подхода, но я рекомендую отказаться от него, если у вас есть возможность написать тесты позже. </p><p>Причина заключается в том, что я проектирую код. Я пишу код, смотрю на него, переписываю, еще раз смотрю и быстро переписываю ещё раз. Написание тестов сначала ограничивает и замедляет меня. </p><p>После того, как я сделаю первоначальный дизайн, я сразу напишу тесты, до интеграции со всей системой. Тем не менее, это отличный способ найти себя в создании модульных тестов, и это гарантирует, что весь ваш код будет проверен.</p><h3>Unittest модуль</h3><p>Модуль <span>Unittest</span> поставляется со стандартной библиотекой Python. Она предоставляет собой класс под названием <code class="inline">TestCase</code>, из которого можно вызвать ваш класс. Затем можно переопределить метод <code class="inline">setUp()</code> чтобы подготовить среду до начала тестирования и/или метод класса <code class="inline">classSetUp()</code> чтобы подготовить среду для всех тестов (не очищающуюся между разными тестами). Существуют соответствующие методы <code class="inline">tearDown()</code> и <code class="inline">classTearDown()</code>, которые также можно переопределить.</p><p>Ниже приведены соответствующие разделы из нашего класса <code class="inline">SelfDrivingCarTest</code>. Я использую только метод <code class="inline">setUp()</code>. Я создаю новый экземпляр <code class="inline">SelfDrivingCar</code> и сохраняю его в <code class="inline">self.car</code>, поэтому он доступен для каждого теста.</p><pre class="brush: python noskimlinks noskimwords">from unittest import TestCaseclass SelfDrivingCarTest(TestCase):    def setUp(self):        self.car = SelfDrivingCar()</pre><p>Следующий шаг — написать специфические методы теста для тестирования кода внутри теста — в этом случае класс <code class="inline">SelfDrivingCar</code> — делает то, что он должен делать. Структура тестового метода довольно обычная:</p><ul><li>Подготовка среды (необязательно).</li> <li>Подготовьте ожидаемый результат.</li> <li>Вызовите код теста.</li> <li>Убедитесь, что фактический результат совпадает с ожидаемым результатом.</li> </ul><p>Обратите внимание, что результат не должен быть результатом метода. Он может быть изменением состояния класса, сторонним эффектом, например как добавление новой строки в базе данных, записью файла или отправкой сообщения по электронной почте.</p><p>Например метод <code class="inline">stop()</code> класса <code class="inline">SelfDrivingCar</code> не возвращает ничего, но он меняет внутреннее состояние, устанавливая скорость на 0. Метод <code class="inline">assertEqual()</code>, предоставляемый базовым классом <code class="inline">TestCase</code> используется здесь для проверки, того что вызов <code class="inline">stop()</code> работает, как и требуется.</p><pre class="brush: python noskimlinks noskimwords">def test_stop(self):        self.car.speed = 5        self.car.stop()        # Verify the speed is 0 after stopping        self.assertEqual(0, self.car.speed)                # Verify it is Ok to stop again if the car is already stopped        self.car.stop()        self.assertEqual(0, self.car.speed)</pre><p>Здесь на самом деле два теста. Первый тест, чтобы убедиться, что если скорость автомобиля равна 5 и <code class="inline">stop()</code> вызывается, то скорость становится равна 0. И еще один тест, чтобы убедиться, что ничего не случится, если вызвать <code class="inline">stop()</code> снова, когда автомобиль уже остановился.</p><p>Позже я расскажу о других тестах для дополнительных функциональных возможностей.</p><h3>Doctest модуль</h3><p><span>Doctest</span> модуль очень интерестный. Он позволяет использовать интерактивные примеры в docstring и проверять результаты, включая исключения. </p><p>Я не применяют и не рекомендую использовать doctest для крупномасштабных систем. Хорошее тестирование требует много труда. Тест-код обычно намного больше, чем тестируемый код. Docstrings - это не совсем подходящий инструмент для написания комплексных тестов. Хотя они классные Вот как выглядит <code class="inline">factorial</code> функция для doc-тестов:</p><pre class="brush: python noskimlinks noskimwords">import mathdef factorial(n):    """Return the factorial of n, an exact integer &gt;= 0.    If the result is small enough to fit in an int, return an int.    Else return a long.    &gt;&gt;&gt; [factorial(n) for n in range(6)]    [1, 1, 2, 6, 24, 120]    &gt;&gt;&gt; [factorial(long(n)) for n in range(6)]    [1, 1, 2, 6, 24, 120]    &gt;&gt;&gt; factorial(30)    265252859812191058636308480000000L    &gt;&gt;&gt; factorial(30L)    265252859812191058636308480000000L    &gt;&gt;&gt; factorial(-1)    Traceback (most recent call last):        ...    ValueError: n must be &gt;= 0    Factorials of floats are OK, but the float must be an exact integer:    &gt;&gt;&gt; factorial(30.1)    Traceback (most recent call last):        ...    ValueError: n must be exact integer    &gt;&gt;&gt; factorial(30.0)    265252859812191058636308480000000L    It must also not be ridiculously large:    &gt;&gt;&gt; factorial(1e100)    Traceback (most recent call last):        ...    OverflowError: n too large    """    if not n &gt;= 0:        raise ValueError("n must be &gt;= 0")    if math.floor(n) != n:        raise ValueError("n must be exact integer")    if n+1 == n:  # catch a value like 1e300        raise OverflowError("n too large")    result = 1    factor = 2    while factor &lt;= n:        result *= factor        factor += 1    return resultif __name__ == "__main__":    import doctest    doctest.testmod()<br></pre><p>Как вы видите, docstring намного больше, чем код функции. Это не улучшает читаемость кода.<br></p><h3>Запуск тестов</h3><p>OK. Вы написали модульные тесты. Для большой системы у вас будет десятки / сотни / тысячи модулей и классов, возможно,размещенных в разных папках. Как вы будете запускаете все тесты?</p><p>Модуль unittest дает различные возможности для проведения групповых тестов и их программирования. Проверка <span>Загрузки и Выполнения тестов /Loading and Running Tests.</span> Но самый простой способ - открытие теста. Данный параметр был добавлен только в Python 2.7. В Pre-2.7 вы могли использовать <span>nose</span>, чтобы найти и запустить тесты. У nose есть несколько других преимуществ, таких как запуск тестовых функций без необходимости создания класса для ваших тестовых случаев. Но для целей в этой статьи, давайте придерживаться unittest.</p><p>Чтобы найти и запустить тесты на основе unittest, просто введите в командной строке:</p><p><code class="inline">python -m unittest discover</code></p><p>Unittest будет проверять все файлы и подкаталоги, запускать все найденные тесты и обеспечит хороший отчет, а также покажет время выполнения. Если вы хотите увидеть, какие тесты выполняются, вы можете добавить флаг -v:</p><p><code class="inline">python -m unittest discover -v</code></p><p>Существует несколько флагов, которые управляют операцией:</p><pre class="brush: plain noskimlinks noskimwords">python -m unittest -hUsage: python -m unittest [options] [tests]Options:  -h, --help       Show this message  -v, --verbose    Verbose output  -q, --quiet      Minimal output  -f, --failfast   Stop on first failure  -c, --catch      Catch control-C and display results  -b, --buffer     Buffer stdout and stderr during test runsExamples:  python -m unittest test_module               - run tests from test_module  python -m unittest module.TestClass          - run tests from module.TestClass  python -m unittest module.Class.test_method  - run specified test method[tests] can be a list of any number of test modules, classes and testmethods.Alternative Usage: python -m unittest discover [options]Options:  -v, --verbose    Verbose output  -f, --failfast   Stop on first failure  -c, --catch      Catch control-C and display results  -b, --buffer     Buffer stdout and stderr during test runs  -s directory     Directory to start discovery ("." default)  -p pattern       Pattern to match test files ("test*.py" default)  -t directory     Top level directory of project (default to                   start directory)For test discovery all test modules must be importable from the toplevel directory of the project.</pre><h3>Определение степени покрытия кода</h3><p>Определение степени покрытия кода часто игнорируют. Само понятие означает, сколько кода действительно проверено тестами. Например, если у вас есть функция с инструкцией <code class="inline">if-else</code>, и вы проверяете только ветвь<code class="inline">if</code>, то вы не знаете, работает ли ветка <code class="inline">else</code> или нет.  В следующем примере кода функция <code class="inline">add()</code> проверяет тип своих аргументов. Если оба являются целыми числами, они просто добавляют их.  </p><p>Если оба являются строками, то он пытается преобразовать их в целые числа и добавить. В противном случае он вызывает исключение. Функция <code class="inline">test_add()</code> проверяет функцию <code class="inline">add()</code> с аргументами, которые являются как целыми числами, так и аргументами, которые являются плавающим значением и проверяют правильное поведение в каждом случае. Но степень покрытия теста является незавершенной. В случае, если строковые аргументы были не протестированы. В результате тест проходит успешно, но ошибка в ветке, где аргументы были строками, не были обнаружены (см. «intg»?).</p><pre class="brush: python noskimlinks noskimwords">import unittestdef add(a, b):    """This function adds two numbers a, b and returns their sum    a and b may integers    """    if isinstance(a, int) and isinstance(b, int):        return a + b    elseif isinstance(a, str) and isinstance(b, str):        return int(a) + intg(b)    else:        raise Exception("Invalid arguments")class Test(unittest.TestCase):    def test_add(self):        self.assertEqual(5, add(2, 3))        self.assertEqual(15, add(-6, 21))        self.assertRaises(Exception, add, 4.0, 5.0)unittest.main()       </pre><p>Вот вывод:</p><pre class="brush: plain noskimlinks noskimwords">----------------------------------------------------------------------Ran 1 test in 0.000sOKProcess finished with exit code 0</pre><h2>Практические Unit Tests</h2><p>Написание тестов промышленной мощности нелегкая и непростая задача. Есть несколько вещей, которые нужно учитывать и компромиссы, на которые следует пойти.</p><h3>Разработка тестирования</h3><p>Если ваш код - это мешанина или набор нелепых строк, где разные уровни абстракции смешиваются друг с другом, и каждый фрагмент кода зависит от другого кода, вам будет трудно его протестировать.  Кроме того, всякий раз, когда вы что-то будете менять, вам также придется обновить кучу тестов.</p><p>Хорошей новостью является то, что разработка программного обеспечения общего назначения - это именно то, что вам нужно для проверки.  В частности, хорошо продуманный модульный код, в котором каждый компонент несет четкую ответственность и взаимодействует с другими компонентами через четко определенные интерфейсы, создаст удобные модульные тесты. </p><p>Например, наш класс <code class="inline">SelfDrivingCar</code> отвечает за высокоуровневую работу автомобиля: ехать, останавливаться, перемещаться.  Он имеет метод <code class="inline">calculate_distance_to_object_in_front()</code>, который еще не реализован. Эта функциональность, вероятно, должна быть реализована полностью отдельной подсистемой.  Он может включать в себя считывание данных с различных датчиков, взаимодействие с другими автомобилями с помощью самостоятельного управления, целый стек "машинного зрения" для анализа изображений с нескольких камер.</p><p>Давайте посмотрим, как это работает на практике.  <code class="inline">SelfDrivingCar</code> примет аргумент, называемый <code class="inline">object_detector,</code> который имеет метод <code class="inline">calculate_distance_to_object_in_front()</code>, и он делегирует эту функцию объекту. Теперь нет необходимости в проверке, потому что <code class="inline">object_detector</code> отвечает (и должен быть протестирован) за него. Вам по-прежнему нужно, чтобы модуль тестировал то, что вы правильно используете <code class="inline">object_detector</code>.</p><pre class="brush: python noskimlinks noskimwords">class SelfDrivingCar(object):    def __init__(self, object_detector):        self.object_detector        self.speed = 0        self.destination = None                    def _calculate_distance_to_object_in_front(self):        return self.object_detector.calculate_distance_to_object_in_front()</pre><h3>Затраты и выгоды</h3><p>Количество усилий, которые вы вкладываете в тестирование, должно быть сопоставимо с затратами на неудачу, насколько стабильным является код и насколько легко его можно исправить, если проблемы обнаружены в строке.</p><p>Например, наш класс автопилота автомобилей критически важен. Если метод <code class="inline">stop()</code> не работает должным образом, наш автомобиль может убить людей, уничтожить имущество и пустить под откос другие автомобили. Если вы создаете автопилот для автомобиль, я подозреваю, предполагаю, что ваши юнит-тесты для метода <code class="inline">stop()</code> будут более тщательными, чем мои. </p><p>С другой стороны, если одна кнопка в вашем веб-приложении на странице, которая расположена тремя уровнями ниже главной страницы, немного мерцает, когда кто-то ее щелкает, вы можете это исправить, но, вероятно, вы не будете добавлять отдельный модульный тест для этого случая. Данный метод не оправдывает себя экономически. </p><h3>Мышление тестирования</h3><p>Мышление тестирования очень важно. Один из принципов, который я использую, состоит в том, что каждый кусок кода имеет как минимум двух пользователей: код, который использует его, и пользователь, который его тестирует. Это простое правило помогает с разработкой и зависимостей. Если вы помните, что вам нужно написать тест для своего кода, вы не добавите много зависимостей, которые трудно восстановить во время тестирования.</p><p>Например, предположим, что ваш код должен что-то вычислять. Для этого ему необходимо загрузить данные из базы, прочитать файл конфигурации и динамически обратиться к некоторыми REST API для получения актуальной информации. Все это может потребоваться по разным причинам, но при этом, ели вы разместите всё это в одной функции, это очень затруднит тестирование. Это возможно звучит смешно, но гораздо лучше изначально структурировать ваш код.</p><h3>Чистые функции</h3><p>Самым простым кодом для тестирования являются чистые функции. Чистые функции - это функции, которые имеют доступ только к значениям их параметров, не имеют побочных эффектов и возвращают один и тот же результат при вызове с теми же аргументами. Они не изменяют состояние вашей программы, не получают доступа к файловой системе или сети. Их преимуществ слишком много, чтобы их сейчас перечислять. </p><p>Почему их легко проверить? Потому что нет необходимости устанавливать специальную среду для их тестирования. Вы просто передаете аргументы и проверяете результат. Вы также знаете, что до тех пор, пока тестируемый код не изменится, ваш тест тоже не должен изменяться. </p><p>Сравните его с функцией, которая считывает XML-файл конфигурации. Ваш тест должен будет создать XML-файл и передать его имя файла в тестируемый код. Не трудная задача. Но предположим, что кто-то решил, что XML просто ужасен, и все файлы конфигурации должны находиться в JSON. Они занимаются своим делом и конвертируют все файлы конфигурации в JSON. Они проводят все тесты, включая ваши, и <em>все</em> они успешно завершаются! </p><p>Почему? Потому что код не изменился. Он все еще ожидает файл конфигурации XML, и ваш тест по-прежнему создает XML-файл для него.  Но при выполнении ваш код получит файл JSON, который он не сможет проанализировать.</p><h4>Обработка ошибок тестирования</h4><p>Обработка ошибок - это еще одна вещь, которая важна для тестирования. Она также является частью разработки. Кто несет ответственность за правильность ввода? Каждая функция и метод должны быть понятны. Если это ответственность функции, то она должна проверять вводные данные, но если это ответственность клиента, то функция выполняется, предполагая, что вводные данные правильные. Общая точность системы будет обеспечена путем тестирования для клиента, для того, чтобы убедиться, что он передает правильные данные в вашу функцию.</p><p>Как правило, вы хотите проверить ввод в общедоступном интерфейсе, потому что вам не обязательно знаеть, кто будет обращаться к вашему коду. Давайте посмотрим на метод <code class="inline">drive()</code> автопилота автомобиля. Этот метод ожидает параметр "destination". Параметр «destination» будет использоваться позже в навигации, но метод "drive" ничего не делает, чтобы мы смогли убедиться в его корректности. </p><p>Предположим, что цель должна быть параметрами широты и долготы. Существуют всевозможные тесты, которые можно выполнить, чтобы убедиться, что они действуют(например, определить пункт назначения в середине моря). Для наших целей давайте просто убедимся, что это параметры в диапазоне от 0,0 до 90,0 по широте и от -180,0 до 180,0 по долготе.</p><p>Вот обновленный класс <code class="inline">SelfDrivingCar</code>. Я просто выполнил некоторые из нереализованных методов, потому что метод <code class="inline">drive()</code> вызывает некоторые из этих методов прямо или косвенно.</p><pre class="brush: python noskimlinks noskimwords">class SelfDrivingCar(object):    def __init__(self, object_detector):        self.object_detector = object_detector        self.speed = 0        self.destination = None    def _accelerate(self):        self.speed += 1    def _decelerate(self):        if self.speed &gt; 0:            self.speed -= 1    def _advance_to_destination(self):        distance = self._calculate_distance_to_object_in_front()        if distance &lt; 10:            self.stop()        elif distance &lt; self.speed / 2:            self._decelerate()        elif self.speed &lt; self._get_speed_limit():            self._accelerate()    def _has_arrived(self):        return True    def _calculate_distance_to_object_in_front(self):        return self.object_detector.calculate_distance_to_object_in_front()    def _get_speed_limit(self):        return 65    def stop(self):        self.speed = 0    def drive(self, destination):        self.destination = destination        while not self._has_arrived():            self._advance_to_destination()        self.stop()</pre><p>Чтобы проверить, как обработались ошибки в тесте, я передаю неверные аргументы и думаю, что они должным образом будут отвергнуты. Вы можете сделать это, используя <code class="inline">self.assertRaises()</code> метод <code class="inline">unittest.TestCase.</code> Этот метод очень удачный, если код под тестированием действительно вызывает исключение.<br></p><p>Давайте посмотрим на это в действии. Метод <code class="inline">test_drive()</code> пропускает широту и долготу вне допустимого диапазона и ждет, что метод <code class="inline">drive()</code> вызовет исключение.</p><pre class="brush: python noskimlinks noskimwords">from unittest import TestCasefrom self_driving_car import SelfDrivingCarclass MockObjectDetector(object):    def calculate_distance_to_object_in_front(self):        return 20class SelfDrivingCarTest(TestCase):    def setUp(self):        self.car = SelfDrivingCar(MockObjectDetector())    def test_stop(self):        self.car.speed = 5        self.car.stop()        # Verify the speed is 0 after stopping        self.assertEqual(0, self.car.speed)        # Verify it is Ok to stop again if the car is already stopped        self.car.stop()        self.assertEqual(0, self.car.speed)    def test_drive(self):        # Valid destination        self.car.drive((55.0, 66.0))        # Invalid destination wrong range        self.assertRaises(Exception, self.car.drive, (-55.0, 200.0))</pre><p>Тест не выполняется, поскольку метод <code class="inline">drive ()</code> не проверяет его аргументы на достоверность и не вызывает исключения. Вы получите хороший отчет с полной информацией о том, что не удалось, где и почему.</p><pre class="brush: plain noskimlinks noskimwords">python -m unittest discover -vtest_drive (untitled.test_self_driving_car.SelfDrivingCarTest) ... FAILtest_stop (untitled.test_self_driving_car.SelfDrivingCarTest) ... ok======================================================================FAIL: test_drive (untitled.test_self_driving_car.SelfDrivingCarTest)----------------------------------------------------------------------Traceback (most recent call last):  File "/Users/gigi/PycharmProjects/untitled/test_self_driving_car.py", line 29, in test_drive    self.assertRaises(Exception, self.car.drive, (-55.0, 200.0))AssertionError: Exception not raised----------------------------------------------------------------------Ran 2 tests in 0.000sFAILED (failures=1)</pre><p>Чтобы исправить это, давайте обновим метод <code class="inline">drive()</code>, чтобы фактически проверить диапазон его аргументов:</p><pre class="brush: python noskimlinks noskimwords">def drive(self, destination):        lat, lon = destination        if not (0.0 &lt;= lat &lt;= 90.0):            raise Exception("Latitude out of range")        if not (-180.0 &lt;= lon &lt;= 180.0):            raise Exception("Latitude out of range")                self.destination = destination        while not self._has_arrived():            self._advance_to_destination()        self.stop()<br></pre><p>Теперь все тесты проходят.</p><pre class="brush: plain noskimlinks noskimwords">python -m unittest discover -vtest_drive (untitled.test_self_driving_car.SelfDrivingCarTest) ... oktest_stop (untitled.test_self_driving_car.SelfDrivingCarTest) ... ok----------------------------------------------------------------------Ran 2 tests in 0.000sOK</pre><h3>Тестирование частных методов</h3><p>Должны ли вы проверять каждую функцию и метод? В частности, следует ли тестировать частные методы, называемые только вашим кодом?  Обычный неудовлетворительный ответ: «В зависимости от ситуации». </p><p>Я постараюсь помочь вам и рассказать, от чего это зависит. Вы точно знаете, кто называет ваш частный метод - это ваш собственный код. В том случае, если ваши тесты служат для общедоступных методов, которые вызывают ваш частный метод и являются комплексными, которые вы уже полностью протестировали. Но если частный метод очень сложный, вы можете протестировать его отдельно. Решайте сами.</p><h3>Как организовать ваши модульные тесты</h3><p>В большой системе не всегда ясно, как провести тесты. Должен ли быть один большой файл со всеми тестами для пакета или отдельный тестовый файл для каждого класса? Должны ли тесты быть в том же файле, что и тестируемый код, или в том же каталоге?</p><p>Вот система, которую я использую. Тесты должны быть полностью отделены от тестируемого кода (следовательно, я не использую doctest). В идеале ваш код должен быть в пакете. Тесты для каждого пакета должны находиться в каталоге вашего дочернего узла. В каталоге тестов должен быть один файл для каждого модуля вашего пакета с именем <code class="inline">test_&lt;module name&gt;</code>. </p><p>Например, если в вашем пакете есть три модуля: <code class="inline">module_1.py</code>, <code class="inline">module_2.py</code> и <code class="inline">module_3.py</code>, вы должны иметь три тестовых файла: <code class="inline">test_module_1.py</code>, <code class="inline">test_module_2.py</code> и <code class="inline">test_module_3.py</code> в каталоге тестов. </p><p>Этот подход имеет ряд преимуществ. Это дает определённость уже при просмотре каталогов, сразу видно, что вы не забыли протестировать.  Это также помогает сохранять тесты в приемлимых размерах. Предполагая, что ваши модули имеют приемлимый размер, тестовый код для каждого модуля будет в собственном файле, который может быть немного больше, чем тестируемый модуль, но все же удобно размещён в одном файле. </p><h2>Заключение</h2><p>Юнит- тесты являются основой качествнного кода. В этом уроке я изучил некоторые принципы и рекомендации для работы с модульным тестированием и объяснил нескольких лучших практик. Чем больше система, которую вы строите, тем более важными становятся модульные тесты.  Но одних модульных тестов недостаточно. Другие типы тестов также необходимы для крупномасштабных систем: интеграционные тесты, тесты производительности, тесты нагрузки, тестирование на уязвимость, тесты на прием данных и другие. </p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825230-kak-pisat-professionalnye-modulnye-testy-na-python" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Python" href="https://norma-studio.github.io/article5/220825230-kak-pisat-professionalnye-modulnye-testy-na-python" class="tm-article-body__tags-item-link">Python</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
32383</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
474</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

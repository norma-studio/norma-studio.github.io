
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Введение в-React фреймворк
... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Введение в-React фреймворк
... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Введение в-React фреймворк
... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Введение в-React фреймворк
... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="В сегодняшнем мире фреймворков Javascript философия дизайна является ключевым дифференцирующим фактором. Если вы сравните популярные JS-фреймворки, такие как EmberJS, AngularJS, Backbone, Knockout и т.д., Вы обязательно найдете различия в своих абстракциях, моделях мысли, конечно, терминологии. Это прямое следствие основополагающей философии дизайн...">
<meta property="og:description" content="В сегодняшнем мире фреймворков Javascript философия дизайна является ключевым дифференцирующим фактором. Если вы сравните популярные JS-фреймворки, такие как EmberJS, AngularJS, Backbone, Knockout и т.д., Вы обязательно найдете различия в своих абстракциях, моделях мысли, конечно, терминологии. Это прямое следствие основополагающей философии дизайн...">
<meta name="twitter:description" content="В сегодняшнем мире фреймворков Javascript философия дизайна является ключевым дифференцирующим фактором. Если вы сравните популярные JS-фреймворки, такие как EmberJS, AngularJS, Backbone, Knockout и т.д., Вы обязательно найдете различия в своих абстракциях, моделях мысли, конечно, терминологии. Это прямое следствие основополагающей философии дизайн...">
<meta property="aiturec:description" content="В сегодняшнем мире фреймворков Javascript философия дизайна является ключевым дифференцирующим фактором. Если вы сравните популярные JS-фреймворки, такие как EmberJS, AngularJS, Backbone, Knockout и т.д., Вы обязательно найдете различия в своих абстракциях, моделях мысли, конечно, терминологии. Это прямое следствие основополагающей философии дизайн...">
<meta property="og:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=546/net/uploads/2013/11/mvc-flow.png">
<meta property="aiturec:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=546/net/uploads/2013/11/mvc-flow.png">
<meta name="twitter:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=546/net/uploads/2013/11/mvc-flow.png">
<meta property="vk:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=546/net/uploads/2013/11/mvc-flow.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=546/net/uploads/2013/11/mvc-flow.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825546-vvedenie-v-react-frejmvork.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825546-vvedenie-v-react-frejmvork.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825546-vvedenie-v-react-frejmvork.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825546-vvedenie-v-react-frejmvork.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825546-vvedenie-v-react-frejmvork.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825546-vvedenie-v-react-frejmvork.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825546-vvedenie-v-react-frejmvork.html" title="Введение в-React фреймворк
... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Введение в-React фреймворк
... | envatomarket.ru | norma-studio.github.io" title="Введение в-React фреймворк
... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/636536435.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825546-vvedenie-v-react-frejmvork.html" class="tm-user-info__username" title="
С. Торгашев" aria-label="
С. Торгашев">
С. Торгашев</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Введение в-React фреймворк
...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825546-vvedenie-v-react-frejmvork" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Web Development" href="https://norma-studio.github.io/article5/220825546-vvedenie-v-react-frejmvork" class="tm-article-snippet__hubs-item-link"><span>Web Development</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825546-vvedenie-v-react-frejmvork.html" />
    <link itemprop="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=546/net/uploads/2013/11/mvc-flow.png">
    <meta itemprop="headline name" content="Введение в-React фреймворк
... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="В сегодняшнем мире фреймворков Javascript философия дизайна является ключевым дифференцирующим фактором. Если вы сравните популярные JS-фреймворки, такие как EmberJS, AngularJS, Backbone, Knockout и т.д., Вы обязательно найдете различия в своих абстракциях, моделях мысли, конечно, терминологии. Это прямое следствие основополагающей философии дизайн...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">В сегодняшнем мире фреймворков Javascript философия дизайна является ключевым дифференцирующим фактором. Если вы сравните популярные JS-фреймворки, такие как EmberJS, AngularJS, Backbone, Knockout и т.д., Вы обязательно найдете различия в своих абстракциях, моделях мысли, конечно, терминологии. Это прямое следствие основополагающей философии дизайн...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



 <p>В сегодняшнем мире фреймворков Javascript философия дизайна является ключевым дифференцирующим фактором. Если вы сравните популярные JS-фреймворки, такие как EmberJS, AngularJS, Backbone, Knockout и т.д., Вы обязательно найдете различия в своих абстракциях, моделях мысли, конечно, терминологии. Это прямое следствие основополагающей философии дизайна. Но, в принципе, все они делают одну вещь, которая заключается в абстрагировании DOM таким образом, что вы не имеете прямого отношения к элементам HTML.</p> <p>Я лично считаю, что фреймворк становится интересным, когда он предоставляет набор абстракций, которые позволяют использовать другой способ мышления. В этом аспекте, <span>react</span>, новый фреймворк JS от людей из Facebook, заставит вас переосмыслить (в некоторой степени), как вы разложите пользовательский интерфейс и взаимодействие вашего приложения. Достигнув версии <span>0.4.1</span> (на момент написания этой статьи), React предлагает удивительно простую, но эффективную модель для создания приложений JS, которые смешивают восхитительный коктейль другого типа.</p> <p>В этой статье мы рассмотрим строительные блоки React и рассмотрим стиль мышления, который может показаться контр-интуитивным с первого раза. Но, как говорят React, «<span>Дайте ему пять минут</span>», а затем вы увидите, как этот подход станет более естественным.</p> <h2> Мотивы</h2> <p>История <span>React</span> началась в пределах Facebook, где она заваривалась на некоторое время. Достигнув достаточно стабильного состояния, разработчики решили открыть его несколько месяцев назад. Интересно, что сайт Instagram также поддерживается React Framework.</p> <p>React приближается к задаче DOM-абстракции с несколько иной точки зрения. Чтобы понять, как это происходит, давайте быстро замаскируем методы, принятые ранее описанными фреймворками.</p> <h3>Обзор высокоуровневой структуры приложений JS</h3> <p>Шаблон проектирования MVC (Model-View-Controller) имеет основополагающее значение для разработки пользовательского интерфейса не только в веб-приложениях, но и в интерфейсных приложениях на любой платформе. В случае веб-приложений DOM является физическим представлением View. Сам DOM генерируется из текстового html-шаблона, который извлекается из другого файла, блока сценариев или предварительно скомпилированной функции шаблона. <code>View</code> - это объект, который привносит текстовый шаблон в виде фрагмента DOM. Он также настраивает обработчики событий и заботится о том, чтобы манипулировать деревом DOM как часть его жизненного цикла. </p> <p>Чтобы <code>View</code> было полезным, оно должно отображать некоторые данные и, возможно, разрешать взаимодействие с пользователем. Данные представляют собой <code>Model</code>, которая поступает из некоторого источника данных (базы данных, веб-службы, локального хранилища и т.д.). Frameworks обеспечивают способ «привязки» данных к представлению, так что изменения в данных автоматически отражаются с изменениями в представлении. Этот автоматический процесс называется <em>привязкой данных</em>, и есть API / методы, чтобы сделать это как можно более незаметным.</p> <p>Триада MVC дополняется <code>Controller</code>, который взаимодействует с представлением и моделью и управляет потоком данных (модели) в представлении View и пользовательских событиях из представления, что может привести к изменениям в модели.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=546/net/uploads/2013/11/mvc-flow.png" alt="Введение в React фреймворк..." title="Введение в React фреймворк..." width="50" height="50"><br></figure><p>Фреймворки, которые автоматически обрабатывают поток данных взад и вперед между View и Model, поддерживают внутренний цикл событий. Этот цикл событий необходим для прослушивания определенных пользовательских событий, событий изменения данных, внешних триггеров и т.д., А затем определяет, есть ли какое-либо изменение из предыдущего цикла. Если есть изменения, на обоих концах (Вид или Модель), фреймворк гарантирует, что обе они будут синхронизированы.</p> <h3>Что отличает React?</h3> <p>С помощью React View-часть триады MVC занимает заметное место и свернута в объект, называемый <code>Component</code>. Компонент поддерживает неизменяемый пакет свойств, называемый <code>props</code>, и <code>state</code>, которое представляет пользовательский интерфейс пользователя. Компонент, генерирующий представление <code>Component</code>, является довольно интересным и, возможно, причиной, по которой React выделяется по сравнению с другими фреймворками. Вместо создания физического DOM непосредственно из файла шаблона / скрипта / функции <code>Component</code> создает промежуточный DOM, который является резервным для реального HTML DOM. Затем выполняется дополнительный шаг, чтобы перевести этот промежуточный DOM в настоящий HTML DOM.</p> <p>В качестве части промежуточного поколения DOM <code>Component</code> также присоединяет обработчики событий и связывает данные, содержащиеся в <code>props</code> и <code>state</code>. </p> <p>Если идея промежуточного DOM звучит немного чуждо, не беспокойтесь. Вы уже видели эту стратегию, принятую языковыми режимами (aka Virtual Machines) для интерпретируемых языков. Наша собственная среда выполнения JavaScript, сначала генерирует промежуточное представление, прежде чем выплескивать нативаный код. Это справедливо и для других языков на основе VM, таких как Java, C #, Ruby, Python и т.д.</p> <p>React ловко использует эту стратегию для создания промежуточного DOM до создания окончательного HTML DOM. Промежуточный-DOM - это всего лишь графический объект JavaScript и не отображается напрямую. Существует шаг перевода, который создает реальный DOM. Это основной метод, который заставляет React выполнять быстрые манипуляции с DOM. </p> <h2> React в глубине</h2> <p>Чтобы лучше понять, как React делает все это, давайте немного погрузимся в глубь; начиная с <code>Component</code>. Component является основным строительным блоком в React. Вы можете составить пользовательский интерфейс вашего приложения, собрав дерево Компонентов. Каждый компонент предоставляет реализацию метода <code>render()</code>, где он создает промежуточный DOM. Вызов <code>React.renderComponent()</code> в корневом компоненте приводит к рекурсивному спусканию по дереву компонентов и созданию промежуточного DOM. Затем промежуточный-DOM преобразуется в реальный HTML DOM.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2013/11/component-dom-tree.png" alt="Введение в React фреймворк..." title="Введение в React фреймворк..." width="50" height="50"><br></figure><p>Поскольку создание промежуточного DOM является неотъемлемой частью компонента, React предоставляет удобное расширение на основе XML для JavaScript, называемое JSX, для построения дерева компонентов в виде набора узлов XML. Это облегчает визуализацию и объяснение DOM. JSX также упрощает ассоциацию обработчиков событий и свойств в качестве атрибутов xml. Поскольку JSX является языком расширения, для создания окончательного JavaScript есть инструмент (командная строка и встроенный браузер). Узлы XML JSX отображаются непосредственно в компонент. Стоит отметить, что React работает независимо от JSX, а язык JSX упрощает создание промежуточного DOM. </p> <h3>Tooling</h3> <p>Ядро React Framework можно загрузить с собственного <span>веб-сайта</span>. Кроме того, для JSX → JS-преобразования вы можете использовать встроенный браузер <span>JSXTransformer</span> или использовать инструмент командной строки, называемый <span>react-tools</span> (установленными через NPM). Для его загрузки вам понадобится установка Node.js. Инструмент командной строки позволяет предварительно скомпилировать файлы JSX и избежать перевода в браузере. Это определенно рекомендуется, если ваши файлы JSX являются большими или многочисленными.</p> <h3>Простой компонент</h3> <p>Хорошо, мы до сих пор видели много теории, и я уверен, что вы испытываете желание увидеть какой-то настоящий код. Давайте перейдем к нашему первому примеру:</p> <pre class="brush: noskimlinks noskimwords">/** @jsx React.DOM */var Simple = React.createClass({  getInitialState: function(){    return { count: 0 };  },  handleMouseDown: function(){    alert("I was told: " + this.props.message);    this.setState({ count: this.state.count + 1});  },  render: function(){    return &lt;div&gt;      &lt;div class="clicker" onMouseDown={this.handleMouseDown}&gt;        Give me the message!      &lt;/div&gt;      &lt;div class="message"&gt;Message conveyed        &lt;span class="count"&gt;{this.state.count}&lt;/span&gt; time(s)&lt;/div&gt;    &lt;/div&gt;    ;  }});React.renderComponent(&lt;Simple message="Keep it Simple"/&gt;,                  document.body);</pre> <p>Хотя этот код довольно прост, приведенный выше код действительно покрывает хорошее количество площади поверхности React:</p> <ul><li>Мы создаем компонент Simple с помощью <code>React.createClass</code> и передаем объект, реализующий некоторые основные функции. Наиболее важным является <code>render()</code>, который создает промежуточный DOM.</li> <li>Здесь мы используем JSX для определения DOM, а также прикрепляем обработчик событий mousedown. Синтаксис <code>{}</code> полезен для включения выражений JavaScript для атрибутов (<code>onMouseDown = {this.handleClick}</code>) и дочерние узлы (<code>&lt;span class = "count"&gt; {this.state.count} &lt;/ span&gt;</code>). Обработчики событий, связанные с синтаксисом {}, автоматически привязываются к экземпляру компонента. Таким образом, <code>this</code> внутри функции event-обработчика относится к экземпляру компонента. Комментарий к первой строке <code>/** @jsx React.DOM */ </code>является сигналом для преобразования JSX для перевода в JS. <em>Без этой строки комментариев перевода не будет.</em> </li> </ul><p>Мы можем запустить инструмент командной строки (<em>jsx</em>) в режиме просмотра и автоматически компилировать изменения из JSX → JS. Исходные файлы находятся в папке <em>/src</em>, а вывод создается в <em>/build</em>.</p> <pre class="brush: bash noskimlinks noskimwords">jsx --watch src/ build/</pre> <p>Вот сгенерированный JS-файл:</p> <pre class="brush: noskimlinks noskimwords">/** @jsx React.DOM */var Simple = React.createClass({displayName: "Simple",  getInitialState: function(){    return { count: 0 };  },  handleMouseDown: function(){    alert("I was told: " + this.props.message);    this.setState({ count: this.state.count + 1});  },  render: function(){    return React.DOM.div(null,       React.DOM.div( {className:"clicker", onMouseDown:this.handleMouseDown}, " Give me the message! "      ),      React.DOM.div( {className:"message"}, "Message conveyed ",        React.DOM.span( {className:"count"}, this.state.count), " time(s)")    )    ;  }});React.renderComponent(Simple( {message:"Keep it Simple"}),                  document.body);</pre> <p>Обратите внимание, как теги <code>&lt;div/&gt;</code> и <code>&lt;span/&gt;</code> сопоставляются с экземплярами <code>React.DOM.div</code> и <code>React.DOM.span</code>.</p> <ul><li>Теперь давайте вернемся к нашему примеру кода. Внутри <code>handleMouseDown</code> мы используем <code>this.props</code> для чтения переданного свойства <em>message</em>. Мы устанавливаем <em>message</em> в последней строке фрагмента, в вызове <code>React.renderComponent()</code> где мы создаем компонент <code>&lt;Simple/&gt;</code>. Цель <code>this.props</code> - хранить данные, которые были переданы компоненту. Он считается неизменным, и только компонент более высокого уровня допускается вносить изменения и передавать его по дереву компонентов.</li> <li>Внутри <code>handleMouseDown</code> мы также устанавливаем некоторое пользовательское состояние с <code>this.setState()</code> для отслеживания количества раз, когда сообщение отображалось. Вы заметите, что мы используем <code>this.state</code> в методе <code>render()</code>. Каждый раз, когда вы вызываете <code>setState()</code>, React также запускает метод <code>render()</code>, чтобы синхронизировать DOM. Помимо <code>React.renderComponent()</code>, <code>setState()</code> - еще один способ принудительного визуального обновления.</li> </ul><h3>Синтетические события</h3> <p>События, выставленные на промежуточном DOM, такие как <code>onMouseDown</code>, также действуют как слой indirection, прежде чем они будут установлены на реальном DOM. Эти события, таким образом, называются <em>Синтетические события</em>. React принимает <span>событийное-делегировани</span>е, которое является хорошо известным методом, и присоединяет события только на корневом уровне реального DOM. Таким образом, на реальном DOM есть только один истинный обработчик событий. Кроме того, эти синтетические события также обеспечивают уровень согласованности, скрывая разницу между браузером и элементом.</p> <p>Комбинация промежуточных данных DOM и синтетических событий дает вам стандартный и последовательный способ определения пользовательских интерфейсов в разных браузерах и даже устройствах.</p> <h3>Жизненный цикл компонентов</h3> <p>Компоненты в структуре React имеют определенный жизненный цикл и воплощают машину состояний, состоящую из трех разных состояний. </p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2013/11/component-lifecycle.png" alt="Введение в React фреймворк..." title="Введение в React фреймворк..." width="50" height="50"><br></figure><p>Компонент оживает после установки <em>Mounted</em>. Результаты монтирования при просмотре рендеринга, который генерирует дерево компонентов (промежуточное DOM). Это дерево преобразуется и помещается в контейнер-узел реального DOM. Это прямой результат вызова <code>React.renderComponent()</code>.</p> <p>После установки компонент остается в состоянии <em>Update</em>. Компонент обновляется при изменении состояния с помощью <code>setState()</code> или изменении props с помощью <code>setProps()</code>. Это, в свою очередь, приводит к вызову <code>render()</code>, который приводит DOM в синхронизацию с данными (<code>props</code> + <code>state</code>). Между последующими обновлениями React будет вычислять дельту между предыдущим деревом компонентов и вновь сгенерированным деревом. Это очень оптимизированный шаг (и флагманская функция), который минимизирует манипуляции с реальным DOM.</p> <p>Конечное состояние - <em>Unmounted</em>. Это происходит, когда вы явно вызываете <code>React.unmountAndReleaseReactRootNode()</code> или автоматически, если компонент был дочерним, который больше не генерируется в вызове <code>render()</code>. Чаще всего вам не приходится иметь дело с этим и просто позвольте React делать всю работу за вас.</p> <p>Теперь это было бы большим недостатком, если React не сообщил бы вам, когда он переместился между состояниями <em>Mounted-Update-Unmounted</em>. К счастью, это не так, и есть хуки, которые вы можете переопределить, чтобы получать уведомления о изменениях жизненного цикла. Имена говорят сами за себя:</p> <ul><li> <code>getInitialState()</code>: подготовить исходное состояние компонента</li> <li><code>componentWillMount()</code></li> <li><code>componentDidMount()</code></li> <li><code>componentWillReceiveProps()</code></li> <li> <code>shouldComponentUpdate()</code>: полезно, если вы хотите контролировать, когда рендер должен быть пропущен. </li> <li><code>componentWillUpdate()</code></li> <li><code>render()</code></li> <li><code>componentDidUpdate()</code></li> <li><code>componentWillUnmount()</code></li> </ul><p>Методы <code>componentWill*</code> вызываются перед изменением состояния, после чего вызывается метод <code>componentDid*</code>.</p> <div> Некоторые имена методов, похоже, взяли реплику из фреймворков Cocoa в Mac и iOS </div> <h3>Различные фичи</h3> <p>Внутри дерева компонентов данные должны всегда течь вниз. Родительский компонент должен установить <code>props</code> дочернего компонента для передачи любых данных от родителя к ребенку. Это называется парой <em>Owner-Owned</em>. С другой стороны, пользовательские события (мышь, клавиатура, касания) всегда будут всплывать от ребенка до корневого компонента, если только не обрабатываются между ними. </p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=591/net/uploads/2013/11/data-event-flow.png" alt="Введение в React фреймворк..." title="Введение в React фреймворк..." width="50" height="50"><br></figure><p>Когда вы создаете промежуточный DOM в <code>render(</code>), вы также можете назначить свойство <code>ref</code> дочернему компоненту. Затем вы можете обратиться к нему от родителя, используя свойство <code>refs</code>. Это показано в нижеприведенном фрагменте.</p> <pre class="brush: noskimlinks noskimwords">  render: function(){    // Set a ref     return &lt;div&gt;        &lt;span ref="counter" class="count"&gt;{this.state.count}&lt;/span&gt;        &lt;/div&gt;;  }  handleMouseDown: function(){    // Use the ref    console.log(this.refs.counter.innerHTML);  },</pre> <p>Как часть метаданных компонента, вы можете установить начальное состояние (<code>getInitialState()</code>), которое мы видели ранее в методах жизненного цикла. Вы также можете установить значения props по умолчанию с помощью <code>getDefaultProps()</code>, а также установить некоторые правила проверки этих props с помощью <code>propTypes</code>. <span>Документация</span> дает хороший обзор различных видов проверок (проверки типов, требуемые и т.д.), которые вы можете выполнить.</p> <p>React также поддерживает концепцию <em>Mixin</em> для извлечения многоразовых элементов поведения, которые могут быть введены в разрозненные Компоненты. Вы можете передавать миксины, используя свойство <code>mixins</code> компонента. </p> <p>Теперь давайте реанимируем и построим более полный компонент, который использует эти функции.</p> <h2> Редактор формы, построенный с использованием React</h2> <p>В этом примере мы создадим редактор, который принимает простой DSL (Domain Specific Language) для создания фигур. Когда вы вводите данные, вы увидите соответствующий вывод сбоку, давая вам прямую обратную связь. </p> <p>DSL позволяет создавать три вида фигур: эллипс, прямоугольник и текст. Каждая форма указана на отдельной строке вместе с кучей свойств стилизации. Синтаксис прост и немного заимствован из CSS. Чтобы проанализировать строку, мы используем Regex, который выглядит так:</p> <pre class="brush: noskimlinks noskimwords">  var shapeRegex = /(rect|ellipse|text)(\s[a-z]+:\s[a-z0-9]+;)*/i;</pre> <p>В качестве примера, следующий набор строк описывает два прямоугольника и текстовую метку ...</p> <pre class="brush: noskimlinks noskimwords">// React labeltext value:React; color: #00D8FF; font-size: 48px; text-shadow: 1px 1px 3px #555; padding: 10px; left: 100px; top: 100px;// left logorect background:url(react.png) no-repeat; border: none; width: 38; height: 38; left: 60px; top: 120px;// right logorect background:url(react.png) no-repeat; border: none; width: 38; height: 38; left: 250px; top: 120px;</pre> <p>... генерируя вывод, показанный ниже:</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cdn.tutsplus.com/net/uploads/2013/11/react-shapes.png" class="lazy07" alt="Введение в React фреймворк..." title="Введение в React фреймворк..." width="50" height="50"><br></figure><h3>Настройка</h3> <p>Хорошо, давайте продолжим и создадим этот редактор. Мы начнем с файла HTML (<code>index.html</code>), где мы помещаем разметку верхнего уровня и включаем библиотеки и сценарии приложений. Я только показываю соответствующие части:</p> <pre class="brush: html noskimlinks noskimwords">&lt;body&gt;&lt;select class="shapes-picker"&gt;  &lt;option value="--"&gt;-- Select a sample --&lt;/option&gt;  &lt;option value="react"&gt;React&lt;/option&gt;  &lt;option value="robot"&gt;Robot&lt;/option&gt;&lt;/select&gt;&lt;div class="container"&gt;&lt;/div&gt;&lt;!-- Libraries --&gt;&lt;script src="../../lib/jquery-2.0.3.min.js"&gt;&lt;/script&gt;&lt;script src="../../lib/react.js"&gt;&lt;/script&gt;&lt;!-- Application Scripts --&gt;&lt;script src="../../build/shape-editor/ShapePropertyMixin.js"&gt;&lt;/script&gt;&lt;script src="../../build/shape-editor/shapes/Ellipse.js"&gt;&lt;/script&gt;&lt;script src="../../build/shape-editor/shapes/Rectangle.js"&gt;&lt;/script&gt;&lt;script src="../../build/shape-editor/shapes/Text.js"&gt;&lt;/script&gt;&lt;script src="../../build/shape-editor/ShapeParser.js"&gt;&lt;/script&gt;&lt;script src="../../build/shape-editor/ShapeCanvas.js"&gt;&lt;/script&gt;&lt;script src="../../build/shape-editor/ShapeEditor.js"&gt;&lt;/script&gt;&lt;script src="../../build/shape-editor/shapes.js"&gt;&lt;/script&gt;&lt;script src="../../build/shape-editor/app.js"&gt;&lt;/script&gt;&lt;/body&gt;</pre> <p>В приведенном выше фрагменте <code>container</code> div содержит наш DOM, созданный React. Наши сценарии приложений включены из каталога <code>/build</code>. Мы используем JSX внутри наших компонентов и наблюдателя командной строки (<code>jsx</code>), помещая преобразованные JS-файлы в <code>/build</code>. Обратите внимание, что эта команда наблюдателя является частью модуля NPM с <code>react-tools</code>.</p> <pre class="brush: bash noskimlinks noskimwords">jsx --watch src/ build/</pre> <p>Редактор разбит на набор компонентов, которые перечислены ниже:</p> <ul><li> <strong>ShapeEditor</strong>: корневой компонент в дереве компонентов</li> <li> ShapeCanvas: отвечает за создание фигур-Компонентов (Эллипс, Прямоугольник, Текст). Он содержится в ShapeEditor.</li> <li> <strong>ShapeParser</strong>: отвечает за разбор текста и извлечение списка определений фигур. Он анализирует строки за строкой с помощью регулярного выражения, которое мы видели ранее. Неверные строки игнорируются. Это не компонент, а вспомогательный объект JS, используемый ShapeEditor.</li> <li> <strong>Ellipse, Rectangle, Text</strong>: Компоненты формы. Они становятся наследниками ShapeCanvas.</li> <li> <strong>ShapePropertyMixin</strong>: предоставляет вспомогательные функции для извлечения стилей, найденных в определениях фигур. Это смешано с тремя компонентами формы, используя свойство <code>mixins</code>.</li> <li> <strong>app</strong>: точка входа для редактора. Она генерирует корневой компонент (ShapeEditor) и позволяет вам выбрать образец формы из раскрывающегося списка.</li> </ul><p>Связь этих объектов показана в аннотированном дереве компонентов:</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=487/net/uploads/2013/11/component-tree.png" alt="Введение в React фреймворк..." title="Введение в React фреймворк..." width="50" height="50"><br></figure><h3>Компонент ShapeEditor</h3> <p>Давайте посмотрим на реализацию некоторых из этих компонентов, начиная с ShapeEditor.</p> <pre class="brush: noskimlinks noskimwords">/** @jsx React.DOM */var ShapeEditor = React.createClass({  componentWillMount: function () {    this._parser = new ShapeParser();  },  getInitialState: function () {    return { text: "" };  },  render: function () {    var shapes = this._parser.parse(this.state.text);    var tree = (      &lt;div&gt;        &lt;textarea class="editor" onChange={this.handleTextChange} /&gt;        &lt;ShapeCanvas shapes={shapes} /&gt;      &lt;/div&gt;);    return tree;  },  handleTextChange: function (event) {    this.setState({ text: event.target.value })  }});</pre> <p>Как следует из названия, ShapeEditor предоставляет возможность редактирования, генерируя <code>&lt;textarea /&gt;</code> и прямую обратную связь на <code>&lt;ShapeCanvas / &lt;</code>. Он прослушивает событие <code>onChange</code> (события в React всегда называются с флагом верблюда) в <code>&lt;textarea /&gt;</code> и при каждом изменении задает свойство <code>text</code> у <code>state</code> компонента. Как упоминалось ранее, всякий раз, когда вы устанавливаете состояние с помощью <code>setState()</code>, рендер вызывается автоматически. В этом случае <code>render()</code> ShapeEditor вызывается, где мы анализируем текст из состояния и перестраиваем фигуры. Обратите внимание, что мы начинаем с начального состояния пустого текста, который устанавливается в хуке <code>getInitialState()</code>.</p> <p>Для разбора текста в набор фигур, мы используем экземпляр <code>ShapeParser</code>. Я не учитывал детали анализатора, чтобы обсуждение было сосредоточено на React. Экземпляр парсера создается в hook компонента <code>componentWillMount()</code>. Это вызывается непосредственно перед монтированием компонентов и является хорошим местом для любых инициализаций до того, как произойдет первый рендеринг.</p> <p>Обычно рекомендуется, чтобы вы выполнили всю сложную обработку с помощью метода <code>render()</code>. Обработчики событий просто устанавливают состояние, а <code>render()</code> - это концентратор для всей вашей основной логики.</p> <p><code>ShapeEditor</code> использует эту идею, чтобы выполнить синтаксический анализ внутри своего <code>render()</code> и пересылать обнаруженные фигуры, задав свойство <code>shapes</code> <code>ShapeCanvas</code>. Это то, как данные стекают в дерево компонентов, от владельца (<code>ShapeEditor</code>) до принадлежащего (<code>ShapeCanvas</code>).</p> <p>Последнее, что нужно отметить здесь, это то, что у нас есть первый комментарий к строке, чтобы указать JSX → JS-перевод.</p> <h3>ShapeCanvas для создания фигур</h3> <p>Затем мы перейдем к компонентам ShapeCanvas и Ellipse, Rectangle и Text.</p> <p>p&gt; <code>ShapeCanvas</code> довольно прост, с его основной обязанностью является генерировать соответствующие компоненты <code>&lt;Ellipse /&gt;</code>, <code>&lt;Rectangle /&gt;</code> и <code>&lt;Text /&gt;</code> из переданных в определениях фигур (<code>this.props.shapes</code>). Для каждой формы мы передаем анализируемые свойства с выражением атрибута: <code>properties = {shape.properties}</code>.</p> <pre class="brush: noskimlinks noskimwords">/** @jsx React.DOM */var ShapeCanvas = React.createClass({  getDefaultProps: function(){    return {      shapes: []    };  },  render: function () {    var self = this;    var shapeTree = &lt;div class="shape-canvas"&gt;    {      this.props.shapes.map(function(s) {        return self._createShape(s);      })    }      &lt;/div&gt;;    var noTree = &lt;div class="shape-canvas no-shapes"&gt;No Shapes Found&lt;/div&gt;;    return this.props.shapes.length &gt; 0 ? shapeTree : noTree;  },  _createShape: function(shape) {    return this._shapeMap[shape.type](shape);  },  _shapeMap: {    ellipse: function (shape) {      return &lt;Ellipse properties={shape.properties} /&gt;;    },    rect: function (shape) {      return &lt;Rectangle properties={shape.properties} /&gt;;    },    text: function (shape) {      return &lt;Text properties={shape.properties} /&gt;;    }  }});</pre> <p>Другое отличие здесь в том, что наше дерево компонентов не является статичным, как в ShapeEditor. Вместо этого он динамически генерируется путем циклического перемещения по пройденным формам. Мы также показываем сообщение <code>"No Shapes Found"</code>, если ничего не показывать.</p> <h3>Формы: эллипс, прямоугольник, текст</h3> <p>Все формы имеют сходную структуру и отличаются только стилем. Они также используют <code>ShapePropertyMixin</code> для обработки генерации стиля.</p> <p>Вот Эллипс:</p> <pre class="brush: noskimlinks noskimwords">/** @jsx React.DOM */var Ellipse = React.createClass({  mixins: [ShapePropertyMixin],  render:function(){    var style = this.extractStyle(true);    style["border-radius"] = "50% 50%";    return &lt;div style={style} class="shape" /&gt;;  }});</pre> <p>Реализация для <code>extractStyle()</code> предоставляется <code>ShapePropertyMixin</code>.</p> <p>Компонент Rectangle следует, конечно, без стиля <em>border-radius</em>. Компонент Text имеет дополнительное свойство, называемое <code>value</code>, которое устанавливает внутренний текст для <code>&lt;div/&gt;</code>. </p> <p>Вот текст, чтобы это было ясно:</p> <pre class="brush: noskimlinks noskimwords">/** @jsx React.DOM */var Text = React.createClass({  mixins: [ShapePropertyMixin],  render:function(){    var style = this.extractStyle(false);    return &lt;div style={style} class="shape"&gt;{this.props.properties.value}&lt;/div&gt;;  }});</pre> <h3>Связывание всего вместе с App.js</h3> <p><code>app.js</code> - это то, где мы собираем все это вместе. Здесь мы создаем корневой компонент, <code>ShapeEditor</code>, а также предоставляем поддержку для переключения между несколькими образцами. Когда вы выбираете другой образец из раскрывающегося списка, мы загружаем некоторый предопределенный текст в <code>ShapeEditor</code> и заставляем <code>ShapeCanvas</code> обновляться. Это происходит в методе <code>readShapes()</code>.</p> <pre class="brush: noskimlinks noskimwords">/** @jsx React.DOM */var shapeEditor = &lt;ShapeEditor /&gt;;React.renderComponent(  shapeEditor,  document.getElementsByClassName("container")[0]);function readShapes() {  var file = $(".shapes-picker").val(),    text = SHAPES[file] || "";  $(".editor").val(text);  shapeEditor.setState({ text: text }); // force a render}$(".shapes-picker").change(readShapes);readShapes(); // load time</pre> <p>Чтобы реализовать творческую сторону, вот робот, созданный с помощью редактора Shape:</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cdn.tutsplus.com/net/uploads/2013/11/robot.png" class="lazy07" alt="Введение в React фреймворк..." title="Введение в React фреймворк..." width="50" height="50"><br></figure><h2>И это для вас!</h2> <p>Уф! Это была довольно длинная статья, и, достигнув этого момента, у вас должно быть чувство достижения! </p> <p>Мы рассмотрели здесь много концепций: интегральная роль компонентов во фреймворке, использование JSX для легкого описания дерева компонентов (aka intermediate-DOM), различные хуки для подключения к lifecyle компонента, использование <code>state</code> и <code>props</code> для управления процессом визуализации, использование Mixins для исключения повторного использования и, наконец, вытягивания всего этого вместе с примером редактора Shape.</p> <p>Я надеюсь, что эта статья даст вам достаточно стимула для создания нескольких приложений React для себя. Чтобы продолжить свое исследование, здесь несколько удобных ссылок:</p> <ul><li><span>Документация</span></li> <li><span>Исходный код на Github</span></li> <li><span>Блог</span></li> </ul>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825546-vvedenie-v-react-frejmvork" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Web Development" href="https://norma-studio.github.io/article5/220825546-vvedenie-v-react-frejmvork" class="tm-article-body__tags-item-link">Web Development</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
34656</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
322</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>


<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>API Rewrite: типы записей и таксономии... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="API Rewrite: типы записей и таксономии... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="API Rewrite: типы записей и таксономии... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="API Rewrite: типы записей и таксономии... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Это вторая часть серии, посвященной API переписывания WordPress. В первой части мы ознакомились с основами API переписывания WordPress. В этом уроке мы рассмотрим настройки перезаписи, доступные нам при регистрации типа записи или таксономии. Хотя пользовательские типы сообщений и таксономии (в отличие от сообщений, категорий и тегов по умолч...">
<meta property="og:description" content="Это вторая часть серии, посвященной API переписывания WordPress. В первой части мы ознакомились с основами API переписывания WordPress. В этом уроке мы рассмотрим настройки перезаписи, доступные нам при регистрации типа записи или таксономии. Хотя пользовательские типы сообщений и таксономии (в отличие от сообщений, категорий и тегов по умолч...">
<meta name="twitter:description" content="Это вторая часть серии, посвященной API переписывания WordPress. В первой части мы ознакомились с основами API переписывания WordPress. В этом уроке мы рассмотрим настройки перезаписи, доступные нам при регистрации типа записи или таксономии. Хотя пользовательские типы сообщений и таксономии (в отличие от сообщений, категорий и тегов по умолч...">
<meta property="aiturec:description" content="Это вторая часть серии, посвященной API переписывания WordPress. В первой части мы ознакомились с основами API переписывания WordPress. В этом уроке мы рассмотрим настройки перезаписи, доступные нам при регистрации типа записи или таксономии. Хотя пользовательские типы сообщений и таксономии (в отличие от сообщений, категорий и тегов по умолч...">
<meta property="og:image" content="//www.gravatar.com/avatar/99c40eb6a15d5177d940890784cc797d?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
<meta property="aiturec:image" content="//www.gravatar.com/avatar/99c40eb6a15d5177d940890784cc797d?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
<meta name="twitter:image" content="//www.gravatar.com/avatar/99c40eb6a15d5177d940890784cc797d?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
<meta property="vk:image" content="//www.gravatar.com/avatar/99c40eb6a15d5177d940890784cc797d?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
<meta property="og:type" content="article">
<link image_src="image" href="//www.gravatar.com/avatar/99c40eb6a15d5177d940890784cc797d?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825643-api-rewrite-tipy-zapisei-i-taksonomii.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825643-api-rewrite-tipy-zapisei-i-taksonomii.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825643-api-rewrite-tipy-zapisei-i-taksonomii.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825643-api-rewrite-tipy-zapisei-i-taksonomii.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825643-api-rewrite-tipy-zapisei-i-taksonomii.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825643-api-rewrite-tipy-zapisei-i-taksonomii.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825643-api-rewrite-tipy-zapisei-i-taksonomii.html" title="API Rewrite: типы записей и таксономии... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="API Rewrite: типы записей и таксономии... | envatomarket.ru | norma-studio.github.io" title="API Rewrite: типы записей и таксономии... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/636536435.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825643-api-rewrite-tipy-zapisei-i-taksonomii.html" class="tm-user-info__username" title="
С. Торгашев" aria-label="
С. Торгашев">
С. Торгашев</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>API Rewrite: типы записей и таксономии...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825643-api-rewrite-tipy-zapisei-i-taksonomii" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Creative Coding" href="https://norma-studio.github.io/article5/220825643-api-rewrite-tipy-zapisei-i-taksonomii" class="tm-article-snippet__hubs-item-link"><span>Creative Coding</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825643-api-rewrite-tipy-zapisei-i-taksonomii.html" />
    <link itemprop="image" href="//www.gravatar.com/avatar/99c40eb6a15d5177d940890784cc797d?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG">
    <meta itemprop="headline name" content="API Rewrite: типы записей и таксономии... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Это вторая часть серии, посвященной API переписывания WordPress. В первой части мы ознакомились с основами API переписывания WordPress. В этом уроке мы рассмотрим настройки перезаписи, доступные нам при регистрации типа записи или таксономии. Хотя пользовательские типы сообщений и таксономии (в отличие от сообщений, категорий и тегов по умолч...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Это вторая часть серии, посвященной API переписывания WordPress. В первой части мы ознакомились с основами API переписывания WordPress. В этом уроке мы рассмотрим настройки перезаписи, доступные нам при регистрации типа записи или таксономии. Хотя пользовательские типы сообщений и таксономии (в отличие от сообщений, категорий и тегов по умолч...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Это вторая часть серии, посвященной API переписывания WordPress. В первой части мы ознакомились с основами API переписывания WordPress. В этом уроке мы рассмотрим настройки перезаписи, доступные нам при регистрации типа записи или таксономии. Хотя пользовательские типы сообщений и таксономии (в отличие от сообщений, категорий и тегов по умолчанию) не имеют преимуществ от интерфейса «Настройки» -&gt; «Постоянная ссылка», настройка перезаписей для пользовательских типов все еще довольно проста. Мы также будем использовать методы, представленные в первой части, поэтому, если вы еще этого не сделали, я рекомендую вам прочитать WordPress "<span>Rewrite API Part One: Основы</span>.<!--more--></p><hr><h2>Сброс правил переписывания</h2> <p>Когда вы регистрируете пользовательский тип, WordPress также регистрирует правила перезаписи (на самом деле, <em>не совсем</em>, и я объясню почему в разделе «Permastructures»). Как упоминалось в первой части, эти правила будут включены только после того, как правила перезаписи будут «сброшены». Темы и плагины могут вызвать эту «очистку», вызывая <span><code>flush_rewrite_rules ()</code></span>. Это необходимо и нужно сделать только один раз при активации, а затем снова при деактивации (чтобы очистить себя).</p> <p>Очевидно, что перед сбросом правил перезаписи вам необходимо добавить их. Однако ловушка <code>init</code> инициализации, для которой типы записей должны быть зарегистрированы, уже была запущена, и когда это было так, ваш плагин или тема еще не были активны, и поэтому ваши типы записей и таксономии еще не зарегистрированы. Для того чтобы зарегистрировать правила перезаписи, которые поставляются с вашими типами постов и таксономиями, это означает, что вам нужно «вручную» зарегистрировать их при активации перед сбросом правил перезаписи. Итак, это должна быть ваша установка:</p> <pre class="brush: php noskimlinks noskimwords">function wptuts_register_types() {  //function which registers your custom post type and taxonomies}add_action("init","wptuts_register_types");function wptuts_plugin_activation() {// Register types to register the rewrite ruleswptuts_register_types();// Then flush themflush_rewrite_rules();}register_activation_hook( __FILE__, "wptuts_plugin_activation");function wptuts_plugin_deactivation() {flush_rewrite_rules();}register_activation_hook( __FILE__, "wptuts_plugin_activation");</pre> <p>Темы могут использовать ловушки <code>after_switch_theme</code> для активации и <code>switch_theme</code> для деактивации.</p> <hr><h2>Пользовательские типы сообщений</h2> <p>Когда вы регистрируете тип записи с помощью <span><code>register_post_type</code></span>, один из доступных вам аргументов - это аргумент rewrite. Это должен быть массив со следующими ключами:</p> <ul><li> <code>slug</code> - слаг, используемый для определения типа записи в URL. К этому сообщению добавляется слаг для постоянной ссылки, например. <code>www.example.com/<strong>books</strong>/the-wizard-of-oz</code> </li> <li> with_front - true (правда) или false (ложь). Если структура постоянных ссылок вашего сообщения начинается с постоянной базы, такой как «/ blog», - это также можно добавить в структуру постоянных ссылок вашего пользовательского типа, установив для нее значение true, например. Истина даст www.example.com/blog/books/ и ложь www.example.com/books/ </li> <li> <code>каналы </code>- правда или ложь. Нужно ли создавать правила перезаписи корма, например, <code>www.example.com/books/feed/rss</code> и <code>www.example.com/book/rss</code>. Значением по умолчанию является значение <code>has_archive</code>.</li> <li> <code>страницы</code> - правда или ложь. Создавать ли правило для «милой» нумерации страниц для архива типов записей, например, <code>www.example.com/books/page/2</code> вместо <code>www.example.com/books?page=2</code>. По умолчанию true.</li> <li> <code>ep_mask</code> - раньше это был отдельный аргумент: <code>permalink_epmask</code>. Начиная с 3.4 он будет перемещен в массив перезаписи. По умолчанию используется <code>EP_PERMALINK</code>.</li> </ul><p>Ключи "feeds" и "pages" относятся только к архивной странице пост-типа (для которой необходимо установить для аргумента <code>has_archive</code> значение true). Из этого массива переписывания WordPress автоматически генерирует правила перезаписи для ваших типов записей. В качестве примера:</p> <pre class="brush: php noskimlinks noskimwords">$labels = array("name" =&gt; __("Books", "your-plugins-translation-domain"),//array of labels);$args = array("labels" =&gt; $labels,"has_archive"=&gt;true,"rewrite" =&gt; array("slug"=&gt;"books","with_front"=&gt; false,"feed"=&gt; true,"pages"=&gt; true));register_post_type("book",$args);</pre> <p>Даст следующие правила переписывания:</p> <ul><li>Постоянная ссылка на книгу <code>«Волшебник страны Оз»</code>: <code>www.example.com/books/the-wizard-of-oz</code> </li> <li>Архив всех книг<code> www.example.com/books</code> (и <code>www.example.com/books/page/2</code>)</li> <li>The feed  вышеуказанного архива: <code>www.example.com/books/feed/rss</code> (и <code>www.example.com/books/rss</code>)</li> </ul><hr><h2>Таксономии (сисмематика)</h2> <p>Функция <span><code>register_taxonomy ()</code></span> предлагает меньше вариантов:</p> <ul><li> <code>slug</code> – a slug -  для определения таксономии, например <code>www.example.com/<strong>genre</strong>/history</code> </li> <li> <code>with_front</code> – как указано выше.</li> <li> <code>иерархический</code> - правда или ложь. Если установлено значение true и таксономия является иерархической, термин постоянная ссылка отражает иерархию. По умолчанию false.</li> <li> <code>ep_mask </code>– Добавлено в 3.4. EP маска разделе ниже.</li> </ul><p>Первые два варианта аналогичны приведенным выше. Параметр иерархии дает термину постоянные ссылки ту же структуру, что и страницы. Например, пусть «История» будет жанром, а «Военная история» - поджанром. При иерархическом значении false «Военная история» будет иметь постоянную ссылку:</p> <pre class="brush: php noskimlinks noskimwords">www.example.com/genre/military-history</pre> <p>Принимая во внимание значение true, оно будет иметь:</p> <pre class="brush: php noskimlinks noskimwords">www.example.com/genre/military/military-history</pre> <p>Регистрация таксономии автоматически регистрирует каналы ваших таксономических терминов:</p> <pre class="brush: php noskimlinks noskimwords">www.example.com/genre/military-history/feed</pre> <blockquote> <p>Вы можете получить постоянную ссылку на ссылку канала для любого термина таксономии с помощью <code>$ feed_link = get_term_feed_link ($ term_id, $ taxonomy, $ feed)</code></p> </blockquote> <hr><h2>Сообщение типа архивов</h2> <p>По умолчанию WordPress не создает «симпатичных» постоянных ссылок для архивов года, месяца или дня вашего пользовательского типа записей (ни для архива автора, но мы оставим его пока). В то время как:</p> <pre class="brush: php noskimlinks noskimwords">www.example.com/?post_type=book&amp;year=2012&amp;monthnum=05</pre> <p>Правильно дает архив всех книг, опубликованных в мае 2012 года:</p> <pre class="brush: php noskimlinks noskimwords">www.example.com/books/2012/05</pre> <p>Выдаст ошибку 404. Однако мы можем просто добавить дополнительные правила перезаписи, используя доступные методы API перезаписи, которые мы рассмотрели в первой части. Один из способов - добавить следующий список правил перезаписи при регистрации типа сообщения:</p> <pre class="brush: php noskimlinks noskimwords">// Add day archive (and pagination)add_rewrite_rule("books/([0-9]{4})/([0-9]{2})/([0-9]{2})/page/?([0-9]{1,})/?","index.php?post_type=book&amp;year=$matches[1]&amp;monthnum=$matches[2]&amp;day=$matches[3]&amp;paged=$matches[4]","top");add_rewrite_rule("books/([0-9]{4})/([0-9]{2})/([0-9]{2})/?","index.php?post_type=book&amp;year=$matches[1]&amp;monthnum=$matches[2]&amp;day=$matches[3]","top");// Add month archive (and pagination)add_rewrite_rule("books/([0-9]{4})/([0-9]{2})/page/?([0-9]{1,})/?","index.php?post_type=book&amp;year=$matches[1]&amp;monthnum=$matches[2]&amp;paged=$matches[3]","top");add_rewrite_rule("books/([0-9]{4})/([0-9]{2})/?","index.php?post_type=book&amp;year=$matches[1]&amp;monthnum=$matches[2]","top");// Add year archive (and pagination)add_rewrite_rule("books/([0-9]{4})/page/?([0-9]{1,})/?","index.php?post_type=book&amp;year=$matches[1]&amp;paged=$matches[2]","top");add_rewrite_rule("books/([0-9]{4})/?","index.php?post_type=book&amp;year=$matches[1]","top");</pre> <p>Это может легко запутаться, особенно если учесть, что вам нужно будет добавить дополнительные правила, если вы хотите, чтобы ваши архивы поддерживали красивые URL для своих каналов. Однако приведенное выше иллюстрирует важный факт о добавлении пользовательских правил: порядок, в котором добавляются правила, важен.</p> <p>Напомним, что эти правила добавляются в массив перезаписи в том порядке, в котором вы вызываете <code>add_rewrite_rule</code>. При анализе запроса WordPress использует <em>первое</em> правило соответствия. Попробуйте изменить порядок добавления правил архивирования года и месяца. Вы найдете, что <code>www.example.com/books/2012/04/</code> перенесет вас в архив 2012 года. Это связано с тем, что этот URL соответствует шаблонам для архивов года и месяца, но первый был добавлен первым.<strong> Не забудьте всегда добавлять более определенное правило в первую очередь.</strong></p> <p>С другой стороны, если вы добавите правило перезаписи, регулярное выражение которого уже существует как правило, это правило должно быть переопределено новым.</p> <hr><h2>Permastructures </h2> <p>Есть простой способ достичь вышеупомянутого: <span><code>add_permastruct</code></span>. Эта функция используется WordPress для создания «», из которых она генерирует правила перезаписи (как выше), которые обрабатывают нумерацию страниц и каналы. Когда вы регистрируете пользовательский тип записи, WordPress не создает автоматически все правила перезаписи. Вместо этого он регистрирует permastructure - и только тогда, когда правила генерируются (то есть, когда они очищаются), WordPress использует эти permastructures для генерации реальных правил перезаписи.</p> <p>Примером permastructure является тот, который вы используете в Настройки -&gt; Постоянные ссылки. Они принимают любые «жестко запрограммированные» слагы или любые теги, которые существуют по умолчанию или были добавлены с помощью <code>add_rewrite_tag</code>, который мы рассмотрели в первой части. Например, permastructure<code>% year% /% category% /% author%</code> будет генерировать следующие правила перезаписи:</p> <ul><li>  <code>www.example.com/2012/url-rewriting/stephen </code>  </li> <li>  <code>www.example.com/2012/URL-Rewriting/Stephen/Page/2</code>  </li> <li>  <code>www.example.com/2012/URL-Rewriting/Stephen/Feed/RSS</code>  </li> </ul><ul><li>  <code>www.example.com/2012/URL-Rewriting/</code>  </li> <li>  <code>www.example.com/2012/URL-Rewriting/Page/2</code>  </li> <li>  <code>www.example.com/2012/URL-Rewriting/Feed/RSS</code>  </li> </ul><ul><li>  <code>www.example.com/2012/</code>  </li> <li>  <code>www.example.com/2012/Page/2</code>  </li> <li>  <code>www.example.com/2012/Feed/RSS</code>  </li> </ul><h3><code>Add_permastruct функция</code></h3> <p><code>Функция add_permastruct принимает четыре аргумента:</code></p> <ul><li> <code>name</code> - уникальный слаг для идентификации вашей  permastructure</li> <li> <code>struct</code> - сама permastructure, например, <code>"% Год% /% Категория% /% Автор%"</code></li> <li> <code>with_front</code> – true или false. Это тот же самый аргумент как при регистрации типа пост</li> <li> <code>ep_mask</code> – маска EP см ниже</li> </ul><p>Здесь необходимо сделать пару предупреждений об использовании <code>add_permastruct</code>. Во-первых: вам нужно убедиться, что пользовательская структура не конфликтует с правилами переписывания WordPress для постов и страниц. Это может быть сделано, предварительно ожидая Ваш обычай permastructure с чем-то трудно закодированным. Например:</p> <pre class="brush: php noskimlinks noskimwords">"something-hard-coded/%year%/%monthnum%/%day%"</pre> <p>Во-вторых, правила добавляются в таком порядке, поэтому, если ваши теги являются «слишком общими», последние правила могут никогда не применяться. Например, приведенная выше структура (которую вы можете попробовать на странице «Настройки» -&gt; «Постоянные ссылки») в целом работает хорошо, за исключением того, что:</p> <pre class="brush: php noskimlinks noskimwords">www.example.com/2012/page/2</pre> <p>Интерпретируется как страница постов автора "2" в категории "page" в 2012 году. Если вы хотите использовать <code>add_permastruct</code> и правильно разбивать правила разбивки на страницы и каналы, то вам нужно будет использовать теги, которые не являются "общими" (под этим я подразумеваю, что выражения регулярных выражений не являются общими). <code>% author%</code> и <code>% category%</code> являются хорошими примерами универсального тега, поскольку они обычно соответствуют любому символу.</p> <h3>Пример пользовательской пермаструктуры: Тип публикации Дата Архивы</h3> <p>С другой стороны, теги year(год), month (месяц) и day (день) очень специфичны - они соответствуют только положительным целым числам длины четыре и два, поэтому мы можем использовать <code>add_permastruct</code> для нашего архива дат типа записей. Из-за специфики тегов даты,нам нужно, чтобы эти правила были добавлены <em>перед</em> тем как есть правила постоянной ссылки на тип сообщения - поэтому добавьте следующее непосредственно <em>перед</em> регистрацией типа сообщения:</p> <pre class="brush: php noskimlinks noskimwords">// Please note that this will only work on WordPress 3.4+ http://core.trac.wordpress.org/ticket/19871add_rewrite_tag("%book_cpt%","(book)s","post_type=");add_permastruct("book_archive", "%book_cpt%/%year%/%monthnum%/%day%");</pre> <p>В приведенном выше примере пользовательский тег<code>% book_cpt%</code> действует как жестко заданный элемент, чтобы отличать эту структуру от других правил (согласно первому предупреждению). Сгенерированные правила будут применяться только в том случае, если<code>% book_cpt%</code> соответствует "books", и в этом случае часть "book" захватывается и интерпретируется как значение для <code>post_type</code>. Обратите внимание, что <code>add_rewrite_tag</code>  (переписать тег) принимает только третий аргумент начиная с WordPress 3.4. Тем не менее, вы можете использовать следующие обходные пути:</p> <pre class="brush: php noskimlinks noskimwords">global $wp_rewrite;$wp_rewrite-&gt;add_rewrite_tag("%book_cpt%","(book)s","post_type=");</pre> <p>Установив архивы книг, вы также можете ожидать, что</p> <pre class="brush: php noskimlinks noskimwords">www.example.com/books?year=2012</pre> <p>Приведет нас к книжному архиву 2012 года. Однако, тестирование показывает, что вместо этого мы переходим на страницу архива после года:</p> <pre class="brush: php noskimlinks noskimwords">www.example.com/2012/</pre> <p>WordPress перенаправил нас на другую страницу из-за того, что известно как <span>канонизация</span>.</p> <hr><h2>Каноническое перенаправление </h2> <p>Как правило, есть много URL, которые могут указывать на один и тот же контент на вашем сайте. Например:</p> <pre class="brush: php noskimlinks noskimwords">www.example.com/year/2012www.example.com/year/2012/page/1www.example.com/2012/////////page/1www.example.com/index.php/2012/www.example.com/index.php////2012///page/1</pre> <p>Все вы попадете на первую страницу вашего архива 2012 года. С точки зрения SEO это не очень хорошо - мы не можем предполагать, что поисковые системы будут распознавать эти URL как один и тот же ресурс, и эти URL могут в конечном итоге конкурировать друг с другом. Google может также активно наказывать вас за <span>дублирующийся контент</span>, и, хотя он хорошо определяет, когда это дублирование не является «вредоносным», он все же рекомендует перенаправить эти лишние URL-адреса на один предпочтительный «канонический» (или стандартный) URL-адрес. Это называется <strong>канонизация</strong>.</p> <p>Это не только помогает консолидировать рейтинги, такие как популярность ссылок, но и помогает вашим пользователям. Если они используют некрасивый или «неправильный» URL-адрес - их перенаправляют на «правильный» URL-адрес, и то, что находится в их адресной строке, - это то, к чему они с большей вероятностью вернутся.</p> <p>Начиная с версии 2.1.0 WordPress обрабатывал каноническое перенаправление, даже принимая обоснованное предположение о требуемом контенте, если исходный запрос возвратил 404. К сожалению, в этом случае WordPress перенаправляет на неправильный URL-адрес. Это потому, что URL-адрес, который мы на самом деле хотим, не является понятным для WordPress и игнорирует часть URL-адреса «тип публикации». К счастью, однако, мы можем использовать фильтр <span><code>redirect_canonical</code></span>, чтобы исправить это.</p> <pre class="brush: php noskimlinks noskimwords">add_filter("redirect_canonical", "wptuts_redirect_canonical", 10, 2);function wptuts_redirect_canonical($redirect_url, $requested_url) {global $wp_rewrite;// Abort if not using pretty permalinks, is a feed, or not an archive for the post type "book"if( ! $wp_rewrite-&gt;using_permalinks() || is_feed() || ! is_post_type_archive("book") )return $redirect_url;// Get the original query parts$redirect = @parse_url($requested_url);$original = $redirect_url;if( !isset($redirect["query"] ) )$redirect["query"] ="";// If is year/month/day - append yearif ( is_year() || is_month() || is_day() ) {$year = get_query_var("year");$redirect["query"] = remove_query_arg( "year", $redirect["query"] );$redirect_url = user_trailingslashit(get_post_type_archive_link("book")).$year;}// If is month/day - append monthif ( is_month() || is_day() ) {$month = zeroise( intval(get_query_var("monthnum")), 2 );$redirect["query"] = remove_query_arg( "monthnum", $redirect["query"] );$redirect_url .= "/".$month;}// If is day - append dayif ( is_day() ) {$day = zeroise( intval(get_query_var("day")), 2 );$redirect["query"] = remove_query_arg( "day", $redirect["query"] );$redirect_url .= "/".$day;}// If paged, apppend paginationif ( get_query_var("paged") &gt; 0 ) {$paged = (int) get_query_var("paged");$redirect["query"] = remove_query_arg( "paged", $redirect["query"] );if ( $paged &gt; 1 )$redirect_url .= user_trailingslashit("/page/$paged", "paged");}if( $redirect_url == $original )return $original;// tack on any additional query vars$redirect["query"] = preg_replace( "#^\??&amp;*?#", "", $redirect["query"] );if ( $redirect_url &amp;&amp; !empty($redirect["query"]) ) {parse_str( $redirect["query"], $_parsed_query );$_parsed_query = array_map( "rawurlencode", $_parsed_query );$redirect_url = add_query_arg( $_parsed_query, $redirect_url );}return $redirect_url;}</pre> <p>Вышеуказанная функция длинная, но не очень сложная. Он может быть улучшен и предназначен только как пример того, что вы можете сделать с фильтром <code>redirect_canonical</code>. Сначала он проверяет, включены ли постоянные ссылки, что мы следим за нашим «книжным» архивом, а не за фидом. Затем он проверяет по очереди:</p> <ol><li>Это архив года, месяца или дня? Если это так, удалите переменную year из строки запроса и установите URL-адрес перенаправления на www.example.com/books/[year]. </li> <li>Это архив месяца или дня? Если это так, удалите переменную monthnum из строки запроса и добавьте значение к URL-адресу перенаправления: <code>www.example.com/books/[year]/[monthnum]</code> </li> <li>Это дневной архив? Если это так, удалите переменную "day" из строки запроса и добавьте значение к URL-адресу перенаправления: <code>www.example.com/books/[year]/[monthnum]/[day]]</code> </li> <li>Наконец, если есть переменная с постраничной передачей, добавьте ее в URL перенаправления.</li> </ol><hr><h2>Теги в типе поста Постоянные ссылки</h2> <p>Еще одна функция, которая не поддерживается для типов записей или таксономий «из коробки», - это использование тегов в структуре постоянных ссылок. Хотя теги, используемые в "slug" массива переписывания типа записей (или таксономии), интерпретируются правильно, WordPress не заменяет эти теги соответствующими значениями при генерации постоянных ссылок - нам нужно заменить их самим. Однако использование таких тегов также нарушает страницу архива типа записи, поэтому мы будем использовать другой метод. В качестве примера, давайте предположим, что мы хотим, чтобы наш пользовательский тип записи «книга» имел структуру:</p> <pre class="brush: php noskimlinks noskimwords">www.example.com/books/[some-genre]/[a-book]</pre> <p>Я использую пример пользовательской таксономии, но те же методы можно использовать для любой пермаструктуры (например, включая дату, автора или даже пользовательское поле). Прежде всего, мы добавим правило перезаписи:</p> <pre class="brush: php noskimlinks noskimwords">function wptuts_custom_tags() {add_rewrite_rule("^books/([^/]+)/([^/]+)/?","index.php?post_type=book&amp;genre=$matches[1]&amp;book=$matches[2]","top");}add_action("init","wptuts_custom_tags");</pre> <p>Теперь, например, <code>www.example.com/book/fiction/the-wizard-of-oz</code> указывает на книгу «<code>the wizard-of-oz</code>». Однако постоянная ссылка, генерируемая WordPress, все еще производит <code>www.example.com/book/the-wizard-of-oz</code>. Следующим шагом является изменение созданной постоянной ссылки.</p> <p>Мы сделали нечто подобное в первой части, когда хотели использовать пользовательский тег в структуре post-permalink. Затем мы использовали фильтр <span><code>post_link</code></span>; на этот раз мы используем эквивалент для пользовательских типов записей, фильтр <span><code>post_type_link</code></span>. Используя этот хук, мы можем внедрить нашу структуру в постоянные ссылки книг.</p> <pre class="brush: php noskimlinks noskimwords">function wptuts_book_link( $post_link, $id = 0 ) {$post = get_post($id);if ( is_wp_error($post) || "book" != $post-&gt;post_type || empty($post-&gt;post_name) )return $post_link;// Get the genre:$terms = get_the_terms($post-&gt;ID, "genre");if( is_wp_error($terms) || !$terms ) {$genre = "uncategorised";}else {$genre_obj = array_pop($terms);$genre = $genre_obj-&gt;slug;}return home_url(user_trailingslashit( "books/$genre/$post-&gt;post_name" ));}add_filter( "post_type_link", "wptuts_book_link" , 10, 2 );</pre> <hr><h2>Управление переписыванием WordPress</h2> <p>Давайте расширим указанную выше структуру постоянных ссылок для достижения следующего:</p> <ul><li>Отдельная книга: <code>www.example.com/books/[some-genre]/[a-book]</code> </li> <li>Все книги в жанре: <code>www.example.com/books/[some-genre]</code> </li> <li>Все книги: <code>www.example.com/books/</code> </li> </ul><p>Напомним, что порядок, в котором правила перезаписи добавляются, имеет значение. В частности, правила, добавленные в первую очередь, имеют приоритет.</p> <p>Итак, сначала мы регистрируем нашу пользовательскую таксономию "жанр" с помощью:</p> <pre class="brush: php noskimlinks noskimwords">$args = array(..."rewrite" =&gt; array("slug"=&gt;"books"),...)register_taxonomy("genre",$args);</pre> <p>Это добавляет следующую permastructure:</p> <ul><li>Книги в жанре: <code>www.example.com/books/[some-genre]</code> </li> </ul><p>После регистрации таксономии мы регистрируем наш собственный тип записи следующим образом:</p> <pre class="brush: php noskimlinks noskimwords">$args = array(..."rewrite" =&gt; array("slug"=&gt;"books"),...)register_post_type("book",$args);</pre> <p>Это будет регистрировать следующие правила:</p> <ul><li>Все книги: <code>www.example.com/books/ (которые нам нужны)</code></li> <li>Конкретная книга: <code>www.example.com/books/[a-book] (чего мы не делаем)</code></li> </ul><p>Однако второе противоречит (и «побивается») конкурирующему правилу, добавленному при регистрации нашей таксономии. Полученная структура:</p> <ul><li>Книга под названием «slug»: (Слаг) <code>www.example.com/books/fiction/slug</code> </li> <li>Книги в жанре "slug": <code>www.example.com/books/slug</code> </li> <li>Все книги: <code>www.example.com/books/</code> </li> </ul><hr><h2>EP_Masks</h2> <p>Ранее, когда мы смотрели на регистрацию типов записей, таксономий (или иным образом, структур), WordPress позволил нам указать нашу собственную «<code>ep_mask</code>». Так что они?</p> <p>В первой части мы рассмотрели, как мы можем добавлять конечные точки с помощью <span><code>add_rewrite_endpoint</code></span>. Второй аргумент в этой функции - это константа (или комбинация констант, использующая побитовые операторы), которые определяют, где добавляется конечная точка. Например:</p> <pre class="brush: php noskimlinks noskimwords">add_rewrite_endpoint( "form", EP_PAGES );</pre> <p>Добавляет форму перезаписи <code>c (/(.*))?/?$</code> к каждой странице постоянная ссылка и:</p> <pre class="brush: php noskimlinks noskimwords">add_rewrite_endpoint( "json", EP_PAGES | EP_PERMALINKS);</pre> <p>Добавляет переписать <code>json (/(.*))?/?$</code> к каждому сообщению и постоянной ссылке на страницу. Таким образом, эти константы задают «местоположение» (то есть «в конце постоянной ссылки»), и они называются <em>масками конечных точек </em>(или масками ep).</p> <p>Когда вы регистрируете тип записи, WordPress регистрирует permastructure - и связанную с ним маску конечной точки. Затем, когда создаются правила перезаписи, он также добавляет все правила перезаписи конечной точки, которые были добавлены к этой маске конечной точки.</p> <p>Например, когда WordPress регистрирует тип записи «Страница» по умолчанию - он связывает маску конечной точки <code>EP_PAGES</code> с пермаструктурой страницы. Затем любые правила перезаписи конечной точки, добавленные в <code>EP_PAGES</code>, фактически добавляются в пермаструктуру этой страницы. Когда вы регистрируете тип сообщения, вы можете указать собственную маску конечной точки или использовать существующую. По умолчанию это <code>EP_PERMALINKS</code> - это означает, что любые правила перезаписи конечной точки, которые добавляются в<code> EP_PERMALINKS</code>, добавляются в правила перезаписи вашего пользовательского типа записи.</p> <p>Конечно, вы можете не захотеть добавлять правила конечной точки для вашего типа поста (в этом случае вы можете использовать маску конечной точки<code> EP_NONE</code>), или вы можете захотеть добавить некоторые правила перезаписи конечной точки <em>только</em> к вашему типу поста. Для этого сначала нужно создать маску конечной точки, которая является не чем иным, как константой, которая удовлетворяет:</p> <ol><li>Значение константы представляет собой положительное число и степень 2: 2<sup>x</sup> (например, 2097152 = 2<sup>21</sup>).</li> <li>Это значение <strong>уникально</strong> </li> </ol><p>Требование степени 2 необходимо, потому что WordPress использует двоичную логику, чтобы определить, куда следует добавить правила конечной точки. К сожалению, это почти невозможно проверить, поэтому лучший совет - добавлять маски конечных точек только при необходимости и придавать им очень высокое значение (например, 2<sup>21</sup>). На момент написания 2<sup>0</sup> до 2<sup>13</sup> используются Core.</p> <p>Определите маску конечной точки непосредственно перед регистрацией типа сообщения или таксономии:</p> <pre class="brush: php noskimlinks noskimwords">define("EP_BOOK", 8388608); // 8388608 = 2^23$args = array("labels" =&gt; $labels,"has_archive"=&gt;true,"rewrite" =&gt; array("slug"=&gt;"books""with_front"=&gt; false"feed"=&gt; true"pages"=&gt; true"ep_mask"=&gt; EP_BOOK));register_post_type("book",$args);// Then you can endpoint rewrite rules to this endpoint maskadd_rewrite_endpoint("loan", EP_BOOK);</pre> <p>(Примечание. Выше используются аргументы WordPress 3.4. Если вы используете более старую версию WordPress, вам придется использовать устаревшую <code>permalink_epmask</code>.). Начиная с WordPress 3.4, вы также можете указать маску конечной точки при регистрации таксономии.</p> <hr><h2>Краткое изложение</h2> <p>В этом уроке я рассмотрел основы API перезаписи для типов записей и таксономий, а также некоторые более сложные темы. Обработка переписываний в WordPress (обязательно) сложна, и лучший способ понять это - изучить <span>исходный код</span> и проверить его с помощью того, что вы узнали, и плагина анализатора перезаписи.</p> <p>На данный момент есть пара заявок, проходящих через разработку WordPress Trac, касающихся API Rewrite. В будущем мы увидим гораздо более простой и бесконфликтный способ передачи масок конечных точек.</p> <ul><li><span>Улучшение документации и удобства использования WP_Rewrite Endpoint</span></li> <li><span>Лучшая поддержка пользовательских типов записей в WP_Rewrite</span></li> <ul></ul></ul>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825643-api-rewrite-tipy-zapisei-i-taksonomii" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Creative Coding" href="https://norma-studio.github.io/article5/220825643-api-rewrite-tipy-zapisei-i-taksonomii" class="tm-article-body__tags-item-link">Creative Coding</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
33714</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
487</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>


<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Тестирование контроллеров в Laravel... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Тестирование контроллеров в Laravel... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Тестирование контроллеров в Laravel... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Тестирование контроллеров в Laravel... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Тестирование контроллеров - не самая легкая штука в мире. Или если перефразировать, то тестировать их трудно до тех пор, пока не станет понятно, что нужно тестировать....">
<meta property="og:description" content="Тестирование контроллеров - не самая легкая штука в мире. Или если перефразировать, то тестировать их трудно до тех пор, пока не станет понятно, что нужно тестировать....">
<meta name="twitter:description" content="Тестирование контроллеров - не самая легкая штука в мире. Или если перефразировать, то тестировать их трудно до тех пор, пока не станет понятно, что нужно тестировать....">
<meta property="aiturec:description" content="Тестирование контроллеров - не самая легкая штука в мире. Или если перефразировать, то тестировать их трудно до тех пор, пока не станет понятно, что нужно тестировать....">
<meta property="og:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=800/net/uploads/2013/04/instantiable.jpg">
<meta property="aiturec:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=800/net/uploads/2013/04/instantiable.jpg">
<meta name="twitter:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=800/net/uploads/2013/04/instantiable.jpg">
<meta property="vk:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=800/net/uploads/2013/04/instantiable.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=800/net/uploads/2013/04/instantiable.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825574-testirovanie-kontrollerov-v-laravel.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825574-testirovanie-kontrollerov-v-laravel.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825574-testirovanie-kontrollerov-v-laravel.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825574-testirovanie-kontrollerov-v-laravel.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825574-testirovanie-kontrollerov-v-laravel.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825574-testirovanie-kontrollerov-v-laravel.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825574-testirovanie-kontrollerov-v-laravel.html" title="Тестирование контроллеров в Laravel... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Тестирование контроллеров в Laravel... | envatomarket.ru | norma-studio.github.io" title="Тестирование контроллеров в Laravel... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/45343254534.jpg" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825574-testirovanie-kontrollerov-v-laravel.html" class="tm-user-info__username" title="
С. Баранов" aria-label="
С. Баранов">
С. Баранов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Тестирование контроллеров в Laravel...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825574-testirovanie-kontrollerov-v-laravel" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="PHP" href="https://norma-studio.github.io/article5/220825574-testirovanie-kontrollerov-v-laravel" class="tm-article-snippet__hubs-item-link"><span>PHP</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825574-testirovanie-kontrollerov-v-laravel.html" />
    <link itemprop="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=800/net/uploads/2013/04/instantiable.jpg">
    <meta itemprop="headline name" content="Тестирование контроллеров в Laravel... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Тестирование контроллеров - не самая легкая штука в мире. Или если перефразировать, то тестировать их трудно до тех пор, пока не станет понятно, что нужно тестировать....">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Тестирование контроллеров - не самая легкая штука в мире. Или если перефразировать, то тестировать их трудно до тех пор, пока не станет понятно, что нужно тестировать....</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Тестирование контроллеров - не самая легкая штука в мире. Или если перефразировать, то тестировать их трудно до тех пор, пока не станет понятно, <em>что</em> нужно тестировать.</p><p>Нужно ли в тестах контроллеров проверять текст на странице? Стоит ли затрагивать базу данных? Стоит ли проверять наличие переменных в файлах отображений? Если это ваш первый раз, когда вы собираетесь тестировать контроллеры, то все эти вопросы могут легко возникнуть у вас. Разрешите вам помочь.</p>  <blockquote> <p>Тесты контроллеров должны проверять ответы, проверять что были сделаны корректные запросы к базе данных, а так же что определенные экземпляры переменных были переданы в файл отображения.</p> </blockquote> <p>Процесс тестирования контроллеров может быть разделен на три части.</p> <ul><li> <strong>Изоляция</strong>: мокаем все зависимости (возможно и включая <code>View</code>).</li> <li> <strong>Вызов:</strong> выполняем нужный метод контроллера.</li> <li> <strong>Проверка:</strong> Выполнение утверждений, что состояние было установлено должным образом.</li> </ul><hr><h2>Hello World в тестировании контроллеров</h2> <p>Лучше всего разобраться в этих вещая, изучая примеры. Рассмотрим "<em>hello world</em>" в тестировании контроллеров Laravel.</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php# app/tests/controllers/PostsControllerTest.phpclass PostsControllerTest extends TestCase {  public function testIndex()  {      $this-&gt;client-&gt;request("GET", "posts");  }}</pre> <p>Laravel использует несколько компонентов Symfony, чтобы облегчить процесс тестирования маршрутов и представлений, включая HttpKernel, DomCrawler и BrowserKit. Вот почему нужно, чтобы ваши PHPUnit тесты были унаследованы не от <code>PHPUnit\_Framework\_TestCase</code>, а от <code>TestCase</code>. Не беспокойтесь, Laravel попревшему их использует, но при этом расширяет, чтобы можно было настроить приложение Laravel для тестирования, а так же предоставить большое разнообразие методов-хелперов для проверки утверждений. Подробнее об этом в ближайшее время.</p> <p>В примере кода выше мы делаем <code>GET</code> запрос к <code>/posts</code>, или <code>localhost:8000/posts</code>. Предполагая, что эта строчка кода была использована на свежей установке Laravel, Symfony генерирует исключение <code>NotFoundHttpException</code>. Попробуйте сами, выполнив <code>phpunit</code> из командной строки.</p> <pre class="brush: bash noskimlinks noskimwords">$ phpunit1) PostsControllerTest::testIndexSymfony\Component\HttpKernel\Exception\NotFoundHttpException:</pre> <p>На <em>человеческом языке</em> это означает: "<em>Эй, я попробовал сделать запрос к этому маршруту, но у тебя, дурак, там ничего не зарегистрировано!</em>".</p> <p>Как вы можете себе представить, такой тип запроса будет очень распространенным, так что имеет смысл предоставить для него собственный метод, такой как <code>$this-&gt; call()</code>. И в самом деле у Laravel есть такой! Это означает, что предыдущий пример можно переписать следующим образом:</p> <pre class="brush: php noskimlinks noskimwords">#app/tests/controllers/PostsControllerTest.phppublic function testIndex(){    $this-&gt;call("GET", "posts");}</pre> <h3>Перегрузка — это ваш друг</h3> <p>Хотя мы и будем придерживаться базового функционала в этой главе, но в моих личных проектов я делаю шаг дальше, и определяю такие методы, как <code>$this-&gt; get()</code>, <code>$this-&gt; post()</code>, и др. Благодаря перегрузки PHP для этого требуется добавить один единственный метод в класс <code>app/tests/TestCase.php</code>.</p> <pre class="brush: php noskimlinks noskimwords"># app/tests/TestCase.phppublic function __call($method, $args){    if (in_array($method, ["get", "post", "put", "patch", "delete"]))    {        return $this-&gt;call($method, $args[0]);    }    throw new BadMethodCallException;}</pre> <p>Теперь вы можете использовать <code>$this-&gt;get("posts")</code> и получить точно такой же результат, как и в предыдущих двух примерах. Как было замечено выше, продолжим работать дальше с базовым функционалом фреймворка.</p> <p>Чтобы заставить эти тесты выполняться, нам всего лишь нужно подготовить нужный маршрут.</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php# app/routes.phpRoute::get("posts", function(){    return "all posts";});</pre> <p>Повторный запуск <code>phpunit</code> в этот раз вернет нам зеленый цвет.</p> <hr><h2>Хелперы подтверждений Laravel</h2> <p>Чаще всего вы будете писать тесты, которые будут проверять, что контролер передает определенные переменные в файл отображения. Например, метод <code>index</code> контроллера <code>PostsController</code> должен передать переменную <code>$posts</code> в соответствующее отображение, верно? Чтобы таким образом в отображении можно было перебрать все посты и отобразить их на странице. Это очень важный тест, который следовало бы написать!</p> <p>Если это является довольно распространенной задачей, то почему бы Laravel не предоставить для этого соответствующую проверку утверждения? Конечно, это так. И конечно же Laravel предоставит.</p> <p><code>Illuminate\Foundation\Testing\TestCase</code> включает в себя набор методов, которые значительно уменьшат количество кода, который вам нужно будет написать для проверки таких базовых утверждений. Этот список включает следующие проверки:</p> <ul><li><code>assertViewHas</code></li> <li><code>assertResponseOk</code></li> <li><code>assertRedirectedTo</code></li> <li><code>assertRedirectedToRoute</code></li> <li><code>assertRedirectedToAction</code></li> <li><code>assertSessionHas</code></li> <li><code>assertSessionHasErrors</code></li> </ul><p>Следующие примеры вызывают <code>GET /posts</code> и проверяют, что файл отображения получает переменную <code>$posts</code>.</p> <pre class="brush: php noskimlinks noskimwords"># app/tests/controllers/PostsControllerTest.phppublic function testIndex(){    $this-&gt;call("GET", "posts");    $this-&gt;assertViewHas("posts");}</pre> <blockquote> <p><strong>Совет:</strong> когда заходит вопрос о форматировании, я предпочитаю оставлять пустую строку между проверкой утверждения теста и кодом, который подготавливает состояние.</p> </blockquote> <p><code>assertViewHas</code> является просто синтаксическим сахаром и анализирует объект ответа, который был возвращен из метода <code>$this-&gt;call()</code>, проверяя, что данные, связанные с отображением, содержат переменную <code>posts</code>.</p> <p>При исследовании содержимого объекта ответа, есть два основных варианта.</p> <ul><li> <code>$response-&gt;getOriginalContent()</code>: возвращает оригинальный контент, или возвращенный из <code>View</code>. Так же можно воспользоваться свойством <code>original</code> напрямую, вместо вызова метода <code>getOriginalContent</code>.</li> <li> <code>$response-&gt;getContent()</code>: возвращает отрисованный вывод. Если из маршрута возвращается экземпляр <code>View</code>, то <code>getContent()</code> вернет HTML. Это может быть полезно для проверок структуры DOM, таких как "<em>в отображении должна содержаться строка</em>".</li> </ul><p>Представим, что маршрут <code>posts</code> имеет следующее содержимое:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php# app/routes.phpRoute::get("posts", function(){    return View::make("posts.index");});</pre> <p>Если мы выполним <code>phpunit</code>, то получим полезное сообщение о нашем <em>следующем шаге</em>.</p> <pre class="brush: bash noskimlinks noskimwords">1) PostsControllerTest::testIndexFailed asserting that an array has the key "posts".</pre> <p>Чтобы тесты выполнились, нам просто нужно получить посты и передать их в отображение.</p> <pre class="brush: php noskimlinks noskimwords"># app/routes.phpRoute::get("posts", function(){    $posts = Post::all();    return View::make("posts.index", ["posts", $posts]);});</pre> <p>Важно заметить одну вещь, что этот код проверяет лишь только то, что переменная <code>$posts</code> была передана в отображение. Он не проверяет само ее значение. Метод <code>assertViewHas</code> принимает дополнительный второй аргумент, чтобы проверить как значение переменной, так и ее существование.</p> <pre class="brush: php noskimlinks noskimwords"># app/tests/controllers/PostsControllerTest.phppublic function testIndex(){    $this-&gt;call("GET", "posts");    $this-&gt;assertViewHas("posts", "foo");}</pre> <p>В этом модифицированном примере, несмотря на то что, переменная <code>$posts</code> была передана в отображение, она равна <code>foo</code>, соответственно тесты не выполнятся. В такой ситуации лучше не проверять на определенное значение, а вместо этого проверять что объект является экземпляром класса <code>Illuminate\Database\Eloquent\Collection</code>. Как нам это реализовать? У PHPUnit есть полезный метод <code>assertInstanceOf</code>, как раз подходящий под наши нужды.</p> <pre class="brush: php noskimlinks noskimwords"># app/tests/controllers/PostsControllerTest.phppublic function testIndex(){    $response = $this-&gt;call("GET", "posts");    $this-&gt;assertViewHas("posts");    // getData() returns all vars attached to the response.    $posts = $response-&gt;original-&gt;getData()["posts"];    $this-&gt;assertInstanceOf("Illuminate\Database\Eloquent\Collection", $posts);}</pre> <p>Теперь мы проверяем, что переменная <code>$posts</code>, переданная контроллером <strong>должна обязательно</strong> быть экземпляром класса <code>Illuminate\Database\Eloquent\Collection</code>. Отлично.</p> <hr><h2>Мокаем базу данных.</h2> <p>Однако до сих пор есть одна вопиющая проблема с нашими тестами. Вы уже поняли какая?</p> <blockquote> <p>Для каждого теста выполняется SQL запрос к базе данных. Хотя для некоторых видов тестирования (приемочное и интеграционное) это может быть и нужно, но для простого тестирования контроллеров, это только снизит производительность.</p> </blockquote> <p>На данный момент я уже наверно просверлил вам череп. Мы не заинтересованы в тестировании возможности Eloquent доставать записи из базы. У него есть свои собственные тесты. Тэйлор знает свою работу! Давайте не будем тратить время и силы, повторяя те же тесты.</p> <p>Вместо этого лучше замокать базу данных, и просто убедиться, что соответствующие методы вызываются с нужными аргументами. Или другими словами, нужно убедиться что метод <code>Post::all()</code> никогда не будет вызван и не затронет базу данных. Мы знаем, что он работает и он не нуждается в тестах.</p> <p>Эта секция будет полностью зависеть от библиотеки Mockery. Пожалуйста, просмотрите эту главу <span>из моей книги</span>, если вы еще не знакомы с ней.</p> <h3>Необходимый рефакторинг</h3> <p>К сожалению мы написали свой код так, что его практически невозможно тестировать.</p> <pre class="brush: php noskimlinks noskimwords"># app/routes.phpRoute::get("posts", function(){    // Ouch. We can"t test this!!    $posts = Post::all();    return View::make("posts.index")        -&gt;with("posts", $posts);});</pre> <p>Именно поэтому считается плохой практикой делать прямые вызовы к методам Eloquent прямо из контроллеров. Не путайте фасады в Laravel, которые в целях тестирования могут быть заменены на моки (<code>Queue::shouldReceive()</code>), с моделями Eloquent. Решением является инъекция уровня абстракции базы данных в контроллер через конструктор. А это потребует небольшого рефакторинга.</p> <blockquote> <p><strong>Внимание:</strong> расположение логики внутри колбэков маршрутов может быть полезно для мелких проектов и API, но при этом создает большие проблемы при тестировании. Для приложений более-менее серьезных размеров использоуйте контроллеры.</p> </blockquote> <p>Зарегистрируем новый ресурс, заменив маршрут <code>posts</code> на следующий:</p> <pre class="brush: php noskimlinks noskimwords"># app/routes.phpRoute::resource("posts", "PostsController");</pre> <p>... создадим необходимый для работы ресурса контроллер с помощью Artisan.</p> <pre class="brush: bash noskimlinks noskimwords">$ php artisan controller:make PostsControllerController created successfully!</pre> <p>Теперь вместо того, чтобы напрямую ссылаться на модель <code>Post</code>, встроем эту зависимость через конструктор контроллер. Вот сокращенный пример, в котором пропущены все restful методы за исключением одного, который мы в настоящее время рассматриваем в тестировании.</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php# app/controllers/PostsController.phpclass PostsController extends BaseController {  protected $post;  public function __construct(Post $post)  {      $this-&gt;post = $post;  }  public function index()  {      $posts = $this-&gt;post-&gt;all();      return View::make("posts.index")          -&gt;with("posts", $posts);  }}</pre> <blockquote> <p>Обратите внимание что лучше указать тип интерфейса, чем ссылаться на саму модель Eloquent. Но всему свое время! Давайте работать дальше.</p> </blockquote> <p>Это гораздо лучший способ организации кода. Так как модель теперь встроена как зависимость, мы теперь можем подменить ее замоканной версией для тестирования. Вот пример того, как это можно сделать:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php# app/tests/controllers/PostsControllerTest.phpclass PostsControllerTest extends TestCase {  public function __construct()  {      // We have no interest in testing Eloquent      $this-&gt;mock = Mockery::mock("Eloquent", "Post");  }  public function tearDown()  {      Mockery::close();  }  public function testIndex()  {      $this-&gt;mock           -&gt;shouldReceive("all")           -&gt;once()           -&gt;andReturn("foo");      $this-&gt;app-&gt;instance("Post", $this-&gt;mock);      $this-&gt;call("GET", "posts");      $this-&gt;assertViewHas("posts");  }}</pre> <p>Ключевое преимущество такого подхода в том, что к базе данных не будет сделано ни одного запроса. Вместо этого, используя Mockery, мы просто проверяем что метод <code>all</code> у модели был вызван.</p> <pre class="brush: php noskimlinks noskimwords">$this-&gt;mock    -&gt;shouldReceive("all")    -&gt;once();</pre> <p>К сожалению если вы решили отказаться от кодирования на основе интерфейсов, и вместо этого встроете модель <code>Post</code> в контроллер, то из-за статики, могут быть проблемы при использовании Mockery. Именно поэтому мы заменяем как <code>Post</code>, так и <code>Eloquent</code> классы в конструкторе теста, до загрузки их оригинальных верси1. Таким образом у нас появляется возможность задать ожидания в тестах. Минусом такого подхода является то, что мы не можем обратится к любому из существующим методов с помощью Mockery, используя <code>makePartial()</code>.</p> <h3>IoC контейнер</h3> <p>Контейнер зависимостей Laravel во много раз упрощает процесс встраивания зависимостей в ваши классы. Каждый раз, когда запрашивается контроллер, он достается из контейнера зависимостей. Таким образом когда нам нужно объявить, что мок-версию <code>Post</code> следует использовать для тестирования, мы всего лишь должны предоставить Laravel соответствующий экземпляр <code>Post</code>, который следует использовать.</p> <pre class="brush: php noskimlinks noskimwords">$this-&gt;app-&gt;instance("Post", $this-&gt;mock);</pre> <blockquote> <p>Рассматривайте этот код как, "<em>Эй Laravel, когда тебе нужен экземпляр <code>Post</code>, используй мою замоканную версию</em>". Так как app наследуется от <code>Container</code>, то у нас есть доступ ко всем методам контейнера.</p> </blockquote> <p>После создания экземпляра контроллера Laravel использует возможности отражения PHP для чтения подсказок типов и встраивает все зависимости для вас сам. Именно так! Не нужно делать для этого привязку в самом контейнере, он все сделает автоматически!</p> <hr><h2>Редиректы</h2> <p>Еще одна проверка, которую вы постоянно будете использовать, это проверка что пользователь был перенаправлен в нужное место, возможно с добавлением нового поста в базу данных. Как мы можем это сделать?</p> <pre class="brush: php noskimlinks noskimwords"># app/tests/controllers/PostsControllerTest.phppublic function testStore(){    $this-&gt;mock         -&gt;shouldReceive("create")         -&gt;once();    $this-&gt;app-&gt;instance("Post", $this-&gt;mock);    $this-&gt;call("POST", "posts");    $this-&gt;assertRedirectedToRoute("posts.index");}</pre> <p>Предполагая, что мы следуем restfull, то чтобы добавить новый пост, мы должны сделать <code>POST</code> запрос к коллекции или <code>posts</code> (не путать метод запроса <code>POST</code> с именем ресурса).</p> <pre class="brush: php noskimlinks noskimwords">$this-&gt;call("POST", "posts");</pre> <p>Затем нам нужно всего лишь воспользоваться другой проверкой утверждения Laravel - <code>assertRedirectedToRoute</code>.</p> <blockquote> <p><strong>Совет:</strong> когда в Laravel регистрируется ресурс (<code>Route::resource()</code>), то фреймворк автоматически регистрируется все необходимые маршруты. Можете выполнить <code>php artisan routes</code>, если вы вдруг забыли имена этих маршрутов.</p> </blockquote> <p>Вы так же возможно захотите проверить, что супреглобальная переменная <code>$_POST</code> была передана методу <code>create</code>. Хотя в действительности мы физически и не отправляем форму, мы попрежнему можем реализовать это с помощью метода <code>Input::replace()</code>, который позволяет подделать этот массив. Вот пример измененного теста, который использует метод Mockery <code>with()</code>, чтобы проверить аргументы, переданные в метод с помощью <code>shouldReceive</code>.</p> <pre class="brush: php noskimlinks noskimwords"># app/tests/controllers/PostsControllerTest.phppublic function testStore(){    Input::replace($input = ["title" =&gt; "My Title"]);&lt;/p&gt;    $this-&gt;mock         -&gt;shouldReceive("create")         -&gt;once()         -&gt;with($input);    $this-&gt;app-&gt;instance("Post", $this-&gt;mock);    $this-&gt;call("POST", "posts");    $this-&gt;assertRedirectedToRoute("posts.index");}</pre> <hr><h2>Пути</h2> <p>Еще одна вещь, которую мы не рассмотрели в тестах - это валиация. Есть два различных сценария в методе <code>store</code>, в зависимости от того, прошла валидация успешно или нет:</p> <ol><li>Возвращаемся назад к форме "Create Post" и показываем ошибки валидации.<br></li> <li>Перенаправляем на коллекцию или на одноименный маршрут, <code>posts.index</code>.<br></li> </ol><blockquote> <p>Лучше всего, когда каждый тест затрагивает свой отдельный сценарий.</p> </blockquote> <p>Первый будет для неуспешной валидации.</p> <pre class="brush: php noskimlinks noskimwords"># app/tests/controllers/PostsControllerTest.phppublic function testStoreFails(){    // Set stage for a failed validation    Input::replace(["title" =&gt; ""]);    $this-&gt;app-&gt;instance("Post", $this-&gt;mock);    $this-&gt;call("POST", "posts");    // Failed validation should reload the create form    $this-&gt;assertRedirectedToRoute("posts.create");    // The errors should be sent to the view    $this-&gt;assertSessionHasErrors(["title"]);}</pre> <p>Код выше явно определяет какие ошибки должны существовать. Кроме того, можно опустить аргумент <code>assertSessionHasErrors</code>, в этом случае будет просто проверка, что пресутствовали сообщения (что редирект включает в себя <code>withErrors($errors)</code>).</p> <p>Теперь тест, который проверяет успешную валидацию.</p> <pre class="brush: php noskimlinks noskimwords"># app/tests/controllers/PostsControllerTest.phppublic function testStoreSuccess(){    // Set stage for successful validation    Input::replace(["title" =&gt; "Foo Title"]);&lt;/p&gt;    $this-&gt;mock         -&gt;shouldReceive("create")         -&gt;once();    $this-&gt;app-&gt;instance("Post", $this-&gt;mock);    $this-&gt;call("POST", "posts");    // Should redirect to collection, with a success flash message    $this-&gt;assertRedirectedToRoute("posts.index", ["flash"]);}</pre> <p>Код для этих обоих тестов может выглядеть следующим образом:</p> <pre class="brush: php noskimlinks noskimwords"># app/controllers/PostsController.phppublic function store(){    $input = Input::all();    // We"ll run validation in the controller for convenience    // You should export this to the model, or a service    $v = Validator::make($input, ["title" =&gt; "required"]);    if ($v-&gt;fails())    {        return Redirect::route("posts.create")            -&gt;withInput()            -&gt;withErrors($v-&gt;messages());    }    $this-&gt;post-&gt;create($input);    return Redirect::route("posts.index")        -&gt;with("flash", "Your post has been created!");}</pre> <p>Обратите внимание, как <code>Validator</code> встраивается прямо в контроллер? В общем рекомендовал бы вынести это в абстракцию в виде сервиса. Таким образом, вы сможете тестировать валидацию изолированно от любых контроллеров или маршрутов. Тем не менее давайте оставим для простоты все как есть. Единственное на что стоит обратить внимание, что в действительности мы не мокаем <code>Validator</code>, хотя безусловно можно сделать и это. Так как этот класс является фасадом, то его легко можно подменить замоканной версией, через метод <code>shouldReceive</code> без необходимости инъекции через конструктор. Win!</p> <pre class="brush: php noskimlinks noskimwords"># app/controllers/PostsController.phpValidator::shouldReceive("make")    -&gt;once()    -&gt;andReturn(Mockery::mock(["fails" =&gt; "true"]));</pre> <p>Время от время вы станете замечать, то метод, который нужно замокать, должен возвращать объект, самого себя. К счастью, с Mockery это легко сделать, нужно только лишь создать анонимную заглушку, и передать массив, который представляет собой имя метода и значение ответа соответственно. Например так:</p> <pre class="brush: php noskimlinks noskimwords">Mockery::mock(["fails" =&gt; "true"])</pre> <p>мы подготовляем объект, который содержит метод <code>fails()</code> и возвращает <code>true</code>.</p> <hr><h2>Репозитории</h2> <p>Для оптимальной гибкости, вместо того, чтобы создать прямую связь между контроллер и ORM, как Eloquent, лучше работать с интерфейсами. Значительным преимуществом такого подхода является, что вам возможно необходимо будет сменить Eloquent на Mongo или Redis, что при таком подходе потребует изменения лишь одной строчки кода. И более того, контроллер даже не будет затронут.</p> <blockquote> <p>Репозитории представляют уровень доступа к данным в вашем приложении.</p> </blockquote> <p>Как может выглядеть интерфейс для работы с уровнем базы данных для модели <code>Post</code>? Начнем.</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php# app/repositories/PostRepositoryInterface.phpinterface PostRepositoryInterface {    public function all();    public function find($id);    public function create($input);}</pre> <p>Его конечно же можно будет расширить, но мы добавим необходимый минимум методов: <code>all</code>, <code>find</code> и <code>create</code>. Обратите внимание что интерфейсы репозиториев располагаются в <code>app/repositories</code>. Так как эта папка по умолчанию не используется при автозагрузке, то нам необходимо обновить файл <code>composer.json</code>.</p> <pre class="brush: js noskimlinks noskimwords">// composer.json"autoload": {  "classmap": [    // ....    "app/repositories"  ]}</pre> <blockquote> <p>Когда новый класс добавляется в директорию, не забывайте запускать <code>composer dump-autoload -o</code>. Флаг <code>-o</code> (<em>optimize</em>) является необязательным, но рекомендуется его постоянно использовать,</p> </blockquote> <p>Если вы попытаетесь встроить этот интерфейс в ваш контроллер, то Laravel этого не позволит сделать. Продолжаем; попробуем и посмотрим, что получится. Вот измененный <code>PostController</code>, который был обновлен на использование инъекции интерфейса, вместо простой Eloquent модели <code>Post</code>.</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php# app/controllers/PostsController.phpuse Repositories\PostRepositoryInterface as Post;class PostsController extends BaseController {    protected $post;    public function __construct(Post $post)    {        $this-&gt;post = $post;    }    public function index()    {        $posts = $this-&gt;post-&gt;all();        return View::make("posts.index", ["posts" =&gt; $posts]);    }}</pre> <p>Если запустите сервер и посмотрите вывод, то встретите страницу с ошибкой, которая сообщает что "<em>PostRepositoryInterface is not instantiable.</em>"</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=800/net/uploads/2013/04/instantiable.jpg" alt="Тестирование контроллеров в Laravel..." title="Тестирование контроллеров в Laravel..." width="50" height="50"><br></figure><p>Если задуматься, то понятно почему фреймворк ругается на это! Laravel умен, но не умеет читать мысли. Ему нужно указать какую именно реализацию интереса следует использовать внутри контроллера.</p> <p>Сейчас давайте добавим эту привязку в <code>app/routes.php</code>. Затем воспользуемся сервис провайдерами для расположения подобного рода логики.</p> <pre class="brush: php noskimlinks noskimwords"># app/routes.phpApp::bind(    "Repositories\PostRepositoryInterface",    "Repositories\EloquentPostRepository");</pre> <p>Перефразируем этот вызов функции как "<em>Laravel, детка, когда тебе потребуется экземпляр <code>PostRepositoryInterface</code>, я хочу, чтобы ты использовал <code>EloquentPostRepository</code>.</em>"</p> <p><code>app/repositories/EloquentPostRepository</code> просто будет оберткой над Eloquent, которая реализует <code>PostRepositoryInterface</code>. Таким образом, мы не ограничиваем API (или любую другую реализацию) на интерпретацию Eloquent; мы можем назвать методы как захотим.</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php namespace Repositories;# app/repositories/EloquentPostRepository.phpuse Repositories\PostRepositoryInterface;use Post;class EloquentPostRepository implements PostRepositoryInterface {  public function all()  {      return Post::all();  }  public function find($id)  {      return Post::find($id);  }  public function create($input)  {      return Post::create($input);  }}</pre> <blockquote> <p>Некоторые из вас могут возразить, что модель <code>Post</code> следует встроить в эту реализацию для целей тестирования. Если вы согласны, то просто встройте ее через конструктор как обычно.</p> </blockquote> <p>Это все, что нужно сделать! Обновляем браузер, и все снова работает. Только теперь ваше приложение гораздо лучше структурировано, и контроллер более не привязан к Eloquent.</p> <p>Представим что через несколько месяцев спустя, ваш босс приходит к вам и говорит, что вам нужно заменить Eloquent на Redis. Отлично, так как мы организовали наше приложение для подобного рода изменений, все что будет нужно - это создать новую реилизацию <code>app/repositories/RedisPostRepository</code>.</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php namespace Repositories;# app/repositories/RedisPostRepository.phpuse Repositories\PostRepositoryInterface;class RedisPostRepository implements PostRepositoryInterface {  public function all()  {      // return all with Redis  }  public function find($id)  {      // return find one with Redis  }  public function create($input)  {      // return create with Redis  }}</pre> <p>И обновить привязку:</p> <pre class="brush: php noskimlinks noskimwords"># app/routes.phpApp::bind(    "Repositories\PostRepositoryInterface",    "Repositories\RedisPostRepository");</pre> <p>Теперь мгновенно в контролере будет использоваться Redis. Вы обратили внимание что <code>app/controllers/PostsController.php</code> даже не затрагивался нами. В этом то и вся прелесть!</p> <hr><h2>Структура</h2> <p>Пока что в этом уроке, наша организация была не самой лучшей. Привязки контейнера в файле <code>routes.php</code>? Все репозитории сгруппированы вместе в одной директории? Конечно такой подход может работать вначале, но очень скоро окажется, что это никак не масштабируется.</p> <p>В заключительной части статьи, мы изменим наш код в сторону PSR, и используем сервис провайдеров для регистрации наших привязок в контейнере.</p> <blockquote> <p>PSR-0 определяет обязательные требования, которые должны соблюдаться для автозагрузчика.</p> </blockquote> <p>Автозагрузчик PSR-0 может быть зарегистрирован через Composer, с помощью объекта <code>psr-0</code>.</p> <pre class="brush: js noskimlinks noskimwords">// composer.json"autoload": {    "psr-0": {        "Way": "app/lib/"    }}</pre> <p>Синтаксис сперва может показаться непонятным. Тоже самое было и для меня. Простым способом расшифровать <code>"Way": "app/lib/"</code> будет подумать про себя "базовая папка для пространства имен <code>Way</code> находится в <code>app/lib</code>". Конечно же замените здесь мою фамилию на название вашего собственного проекта. Структура папок при этом должна быть следующей:</p> <ul><li>app/ <ul><li>lib/</li> <li>Way/</li> </ul></li> </ul><p>Затем вместе группирования всех репозиториев в папке <code>repositories</code>, более элегантным решением будет сгруппировать их по категориям в различные папки, вроде этого:</p> <ul><li>app/ <ul><li>lib/</li> <li>Way/ <ul><li>Storage/</li> <li>Post/ <ul><li>PostRepositoryInterface.php</li> <li>EloquentPostRepository.php</li> </ul></li> </ul></li> </ul></li> </ul><p>Важно, что мы придерживаемся этого соглашения именования файлов и папок, если мы хотим чтобы автозагрузчик работал так, как ожидалось. Единственная вещь, которая осталась - это обновить пространства имен для <code>PostRepositoryInterface</code> и <code>EloquentPostRepository</code>.</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php namespace Way\Storage\Post;# app/lib/Way/Storage/Post/PostRepositoryInterface.phpinterface PostRepositoryInterface {    public function all();    public function find($id);    public function create($input);}</pre> <p>И реализация:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php namespace Way\Storage\Post;# app/lib/Way/Storage/Post/EloquentPostRepository.phpuse Post;class EloquentPostRepository implements PostRepositoryInterface {    public function all()    {        return Post::all();    }    public function find($id)    {        return Post::find($id);    }    public function create($input)    {        return Post::create($input);    }}</pre> <p>Вот так, теперь выглядит гораздо лучше. Но как насчет тех надоедливых привязок? Файл с маршрутами может быть удобным местом для экспериментов, но лучше их хранить отдельно. Вместо маршрутов воспользуемся сервис провайдерами.</p> <blockquote> <p>Сервис провайдеры - это не более чем загрузчики классов, которые могут делать все, что вам нужно: зарегистрировать привязку, обработать событие, импортировать файл маршрутов и прочее.</p> </blockquote> <p>Laravel автоматически вызовет метод <code>register()</code> у сервис провайдера.</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php namespace Way\Storage;# app/lib/Way/Storage/StorageServiceProvider.phpuse Illuminate\Support\ServiceProvider;class StorageServiceProvider extends ServiceProvider {    // Triggered automatically by Laravel    public function register()    {        $this-&gt;app-&gt;bind(            "Way\Storage\Post\PostRepositoryInterface",            "Way\Storage\Post\EloquentPostRepository"        );    }}</pre> <p>Чтобы дать знать Laravel о новом сервис провайдере, необходимо добавить его в файл <code>app/config/app.php</code> в массив <code>providers</code>.</p> <pre class="brush: php noskimlinks noskimwords"># app/config/app.php"providers" =&gt; array(    "Illuminate\Foundation\Providers\ArtisanServiceProvider",    "Illuminate\Auth\AuthServiceProvider",    // ...    "Way\Storage\StorageServiceProvider")</pre> <p>Отлично; теперь у нас есть отдельный файл для регистрации новых привязок.</p> <h3>Обновляем тесты</h3> <p>Имея в виду нашу новую структуру, теперь вместо того чтобы мокать саму модель Eloquent, мы можем замокать <code>PostRepositoryInterface</code>. Вот пример одного из таких тестов:</p> <pre class="brush: php noskimlinks noskimwords"># app/tests/controllers/PostsControllerTest.phppublic function testIndex(){    $mock = Mockery::mock("Way\Storage\Post\PostRepositoryInterface");    $mock-&gt;shouldReceive("all")-&gt;once();    $this-&gt;app-&gt;instance("Way\Storage\Post\PostRepositoryInterface", $mock);    $this-&gt;call("GET", "posts");    $this-&gt;assertViewHas("posts");}</pre> <p>Однако мы можем улучшить и это. Очевидно, что каждый метод <code>PostsControllerTest</code> потребует замоканную версию репозитория. Таким образом гораздо лучше будет выделить эту отдельную подготовительную работу в свой собственный метод следующим образом:</p> <pre class="brush: php noskimlinks noskimwords"># app/tests/controllers/PostsControllerTest.phppublic function setUp(){    parent::setUp();    $this-&gt;mock("Way\Storage\Post\PostRepositoryInterface");}public function mock($class){    $mock = Mockery::mock($class);    $this-&gt;app-&gt;instance($class, $mock);    return $mock;}public function testIndex(){    $this-&gt;mock-&gt;shouldReceive("all")-&gt;once();    $this-&gt;call("GET", "posts");    $this-&gt;assertViewHas("posts");}</pre> <p>Неплохо, да?</p> <p>Теперь вы даже можете использовать моки с моделью Eloquent. Это позволит выполнить следующее:</p> <pre class="brush: php noskimlinks noskimwords">Post::shouldReceive("all")-&gt;once();</pre> <p>За кулисами будет замокан <code>PostRepositoryInterface</code> и обновлена привязка в контейнере. Вы уже не сможете получить код гораздо проще, чем этот!</p> <p>Чтобы получить возможность использовать подобного рода синтаксис, нужно обновить модель <code>Post</code>, а еще лучше <code>BaseModel</code>, от которой наследуются все Eloquent модели. Вот примере этого:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php# app/models/Post.phpclass Post extends Eloquent {    public static function shouldReceive()    {        $class = get_called_class();        $repo = "Way\Storage\{$class}\{$class}RepositoryInterface";        $mock = Mockery::mock($repo);        App::instance($repo, $mock);        return call_user_func_array([$mock, "shouldReceive"], func_get_args());    }}</pre> <p>Если вы сможете справиться с внутренним диалогом "<em>Должен ли я встраивать тестовую логику в боевой код</em>", то обнаружите, что это позволяет сделать тесты гораздо более читабельными.</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php# app/tests/controllers/PostsControllerTest.phpclass PostsControllerTest extends TestCase {    public function tearDown()    {        Mockery::close();    }    public function testIndex()    {        Post::shouldReceive("all")-&gt;once();        $this-&gt;call("GET", "posts");        $this-&gt;assertViewHas("posts");    }    public function testStoreFails()    {        Input::replace($input = ["title" =&gt; ""]);        $this-&gt;call("POST", "posts");        $this-&gt;assertRedirectedToRoute("posts.create");        $this-&gt;assertSessionHasErrors();    }    public function testStoreSuccess()    {        Input::replace($input = ["title" =&gt; "Foo Title"]);        Post::shouldReceive("create")-&gt;once();        $this-&gt;call("POST", "posts");        $this-&gt;assertRedirectedToRoute("posts.index", ["flash"]);    }}</pre> <p>Хорошо, не правда ли? Надеюсь, эта статья не была слишком нудной. Главное что стоит подчерпнуть из этой статьи - это организация ваших репозиториев таким образом, чтобы можно было их легко мокать и встраивать в ваши контроллеры. В результате использования такого подхода, ваши тесты будут выполняться молниеносно!</p> <blockquote> <p>Эта статья — отрывок из моей предстоящей книги <span>Laravel Testing Decoded</span>. Оставайтесь со мной до ее выпуска в мае 2013 г.!</p> </blockquote>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825574-testirovanie-kontrollerov-v-laravel" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="PHP" href="https://norma-studio.github.io/article5/220825574-testirovanie-kontrollerov-v-laravel" class="tm-article-body__tags-item-link">PHP</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
37478</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
314</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>


<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Серия про искусственный интеллект - Часть 1: Поиск путей
... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Серия про искусственный интеллект - Часть 1: Поиск путей
... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Серия про искусственный интеллект - Часть 1: Поиск путей
... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Серия про искусственный интеллект - Часть 1: Поиск путей
... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Этот урок является первым из трех, в котором обсуждается, как подключить искусственный интеллект (AI) в игры и приложения, которые вы создаете. В первом уроке мы узнаем о поиске пути....">
<meta property="og:description" content="Этот урок является первым из трех, в котором обсуждается, как подключить искусственный интеллект (AI) в игры и приложения, которые вы создаете. В первом уроке мы узнаем о поиске пути....">
<meta name="twitter:description" content="Этот урок является первым из трех, в котором обсуждается, как подключить искусственный интеллект (AI) в игры и приложения, которые вы создаете. В первом уроке мы узнаем о поиске пути....">
<meta property="aiturec:description" content="Этот урок является первым из трех, в котором обсуждается, как подключить искусственный интеллект (AI) в игры и приложения, которые вы создаете. В первом уроке мы узнаем о поиске пути....">
<meta property="og:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=480/active/uploads/legacy/tuts/141_ai/Tutorial/PF-07.jpg">
<meta property="aiturec:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=480/active/uploads/legacy/tuts/141_ai/Tutorial/PF-07.jpg">
<meta name="twitter:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=480/active/uploads/legacy/tuts/141_ai/Tutorial/PF-07.jpg">
<meta property="vk:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=480/active/uploads/legacy/tuts/141_ai/Tutorial/PF-07.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=480/active/uploads/legacy/tuts/141_ai/Tutorial/PF-07.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825718-seriya-pro-iskusstvennyj-intellekt--chast-1-poisk-putej.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825718-seriya-pro-iskusstvennyj-intellekt--chast-1-poisk-putej.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825718-seriya-pro-iskusstvennyj-intellekt--chast-1-poisk-putej.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825718-seriya-pro-iskusstvennyj-intellekt--chast-1-poisk-putej.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825718-seriya-pro-iskusstvennyj-intellekt--chast-1-poisk-putej.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825718-seriya-pro-iskusstvennyj-intellekt--chast-1-poisk-putej.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825718-seriya-pro-iskusstvennyj-intellekt--chast-1-poisk-putej.html" title="Серия про искусственный интеллект - Часть 1: Поиск путей
... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Серия про искусственный интеллект - Часть 1: Поиск путей
... | envatomarket.ru | norma-studio.github.io" title="Серия про искусственный интеллект - Часть 1: Поиск путей
... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/64533ghhjgjj.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825718-seriya-pro-iskusstvennyj-intellekt--chast-1-poisk-putej.html" class="tm-user-info__username" title="
С. Парфенов" aria-label="
С. Парфенов">
С. Парфенов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Серия про искусственный интеллект - Часть 1: Поиск путей
...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825718-seriya-pro-iskusstvennyj-intellekt--chast-1-poisk-putej" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Games" href="https://norma-studio.github.io/article5/220825718-seriya-pro-iskusstvennyj-intellekt--chast-1-poisk-putej" class="tm-article-snippet__hubs-item-link"><span>Games</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825718-seriya-pro-iskusstvennyj-intellekt--chast-1-poisk-putej.html" />
    <link itemprop="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=480/active/uploads/legacy/tuts/141_ai/Tutorial/PF-07.jpg">
    <meta itemprop="headline name" content="Серия про искусственный интеллект - Часть 1: Поиск путей
... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Этот урок является первым из трех, в котором обсуждается, как подключить искусственный интеллект (AI) в игры и приложения, которые вы создаете. В первом уроке мы узнаем о поиске пути....">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Этот урок является первым из трех, в котором обсуждается, как подключить искусственный интеллект (AI) в игры и приложения, которые вы создаете. В первом уроке мы узнаем о поиске пути....</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



 <p>Этот урок является первым из трех, в котором обсуждается, как подключить искусственный интеллект (AI) в игры и приложения, которые вы создаете. В первом уроке мы узнаем о поиске пути.</p> <p><!--more--></p> <hr><h2>Обзор результата работы</h2> <p>Давайте посмотрим финальный результат, над которым мы будем работать:</p> <div class="tutorial_image"> <object width="550" height="400" data="https://activetuts.s3.amazonaws.com/tuts/141_ai/Tutorial/Grafos.swf" type="application/x-shockwave-flash"><param name="src" value="http://activetuts.s3.amazonaws.com/tuts/141_ai/Tutorial/Grafos.swf"></object> </div> <p>Нажмите на точку, затем на другую точку, и ИИ определит самый короткий путь, чтобы пройти между ними. Вы можете использовать раскрывающийся список, чтобы выбрать алгоритм который будет использовать AI.</p> <hr><h2> <span>Шаг 1: Обзор серий AI</span></h2> <p>Этот урок станет первым из трех, в котором будет обсуждаться встраивание искусственного интеллекта (AI) в игры и приложения, которые вы создаете. Вы можете подумать, что это слишком сложно, но на самом деле всё довольно просто! Я объясню два ключевых аспекта ИИ в играх, а затем создам классную игру, используя то, что мы узнаем. Надеюсь, вам понравится наша краткая серия!</p> <hr><h2> <span>Шаг 2: Введение</span></h2> <p>В играх один из самых важных аспектов - сделать её эффективной, то есть выполнить то, что она должна делать, используя минимальные ресурсы. Для этого существует целая наука.</p> <p>В этом уроке мы рассмотрим ключевой аспект развития игры: поиск пути. Мы обсудим два лучших метода, то как они работают, и то как работать с ними в AS3, и наконец, но не в последнюю очередь, когда их использовать.  Давайте начнем..</p> <hr><h2> <span>Шаг 3: Итак, о чем идет речь?</span></h2> <p>Предположим, вы находитесь посередине леса с 50 различными потенциальными маршрутами, у вас почти нет энергии и вам нужно найти лучший выход, как бы вы это сделали?</p> <p>Один из вариантов –пройти по каждому из 50 маршрутов; метод проб и ошибок. Вы обязательно выберетесь, но это займет слишком много времени. Это не новая проблема, и многие люди предложили множество идей как её решить. Одним из них был Эдсгер В. Дейкстра, который разработал алгоритм для получения кратчайшего пути имея граф, источник и цель.</p> <p>Прежде чем мы сможем начать решение проблемы, мы должны создать те элементы, граф который содержит всю информацию, узлы, которые являются точками графика, и линии, соединяющие точки. Представляйте, как будто граф - это карта: точки - это города, а линии - это дороги, которые их соединяют.</p> <hr><h2> <span>Шаг 4: Настройка проекта</span></h2> <p>Прежде чем мы начнем писать код, давайте сначала настроим наше рабочее пространство. Создайте новую папку и назовите ее «PathFinding». Внутри создайте другую папку и назовите ее «Graph». Затем в папке PathFinding создайте новый FLA-файл Flash (AS3) и назовите его «PathFinding».</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=480/active/uploads/legacy/tuts/141_ai/Tutorial/PF-07.jpg" alt="Серия про искусственный интеллект - Часть 1: Поиск путей..." title="Серия про искусственный интеллект - Часть 1: Поиск путей..." width="50" height="50"></div> <hr><h2> <span>Шаг 5: Создание символа узла</span></h2> <p>В файле «PathFinding.fla» Выберите «exportforactionscript» ив качествеклассанапишите «Graph.Node». Выберите «export for actionscript» и в качестве класса напишите «Graph.Node»,</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=477/active/uploads/legacy/tuts/141_ai/Tutorial/PF-06.jpg" alt="Серия про искусственный интеллект - Часть 1: Поиск путей..." title="Серия про искусственный интеллект - Часть 1: Поиск путей..." width="50" height="50"></div> <hr><h2> <span>Шаг 6: Рисование узла</span></h2> <p>Внутри узла Movieclip создайте новый круг с радиусом 25 и поместите его в центр. Затем добавьте новое текстовое поле, установите параметрDynamic и дайте ему имя экземпляра «idx_txt» и поместите его в центр сцены.</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=830/active/uploads/legacy/tuts/141_ai/Tutorial/PF-00.jpg" alt="Серия про искусственный интеллект - Часть 1: Поиск путей..." title="Серия про искусственный интеллект - Часть 1: Поиск путей..." width="50" height="50"></div> <hr><h2> <span>Шаг 7: Создание точки</span></h2> <p>Каждая точка состоит из двух основных элементов; индекс для его идентификации и его положение на графе. Помня об этом, создайте новый класс внутри папки / пакета Graph и назовите его «Node». Расширьте им класс спрайтов, а затем просто добавьте две переменные: однуint для индекса и Vector3D для позиции. Кроме того, добавьте их соответствующий набор и получите методы:</p> <pre class="brush: actionscript3 noskimlinks noskimwords">package Graph{  import flash.display.Sprite;import flash.geom.Vector3D;public class Node extends Sprite{private var pos:Vector3D;private var index:int;public function Node(idx:int,n_Pos:Vector3D){index=idx;pos=n_Pos;this.x=n_Pos.x;this.y=n_Pos.y;idx_txt.text=String(idx)}public function getIndex():int{return index;}public function setPos(n_Pos:Vector3D):void{pos=n_Pos;}public function getPos():Vector3D{return pos;}}}</pre> <hr><h2> <span>Шаг 8: Создание Линии</span></h2> <p>Линия содержит три элемента: индексы двух точек, которые он соединяет, и его «стоимость» (или <em>расстояние между</em> точками в данном случае). Опять же в пакете / папке Graph создайте новый класс и назовите его «Edge»; Расширьте им класс Sprite.</p> <p>Теперь добавьте две переменныеints для точек и одну переменную Number для стоимости, затем добавьте соответствующий отправляющие и принимающие методы:</p> <pre class="brush: actionscript3 noskimlinks noskimwords">package Graph{import flash.display.Sprite;import flash.geom.Vector3D;public class Edge extends Sprite{private var from:int;     //The index of the node from which this edge departsprivate var to:int;       //The index of the node from which this edge arrivesprivate var cost:Number;  //The cost of crossing through this node (i.e. the distance)public function Edge(n_From:int,n_To:int,n_Cost:Number=1.0){from=n_From;to=n_To;cost=n_Cost;this.z=1;}public function getFrom():int{return from;}public function setFrom(n_From:int):void{from=n_From;}public function getTo():int{return to;}public function setTo(n_To:int):void{to=n_To;}public function setCost(n_Cost:Number):void{cost=n_Cost;}public function getCost():Number{return cost;}        /*          Since the edge is just a line that connects the nodes,          we will use this method to draw the edge, the style refers to how we will          want the edge to be        */public function drawEdge(fromPos:Vector3D,toPos:Vector3D,style:String="normal"){switch(style){case "normal":                //If it is normal, create a gray linethis.graphics.clear();this.graphics.lineStyle(1, 0x999999, .3);this.graphics.moveTo(fromPos.x,fromPos.y);this.graphics.lineTo(toPos.x,toPos.y);break;case "path":                //If it is a line from the path, create a black linethis.graphics.clear();this.graphics.lineStyle(2, 0x000000,1);this.graphics.moveTo(fromPos.x,fromPos.y);this.graphics.lineTo(toPos.x,toPos.y);break;case "visited":                //If it is a line used by the algorithm, create a red linethis.graphics.clear();this.graphics.lineStyle(1, 0xFF0000,1);this.graphics.moveTo(fromPos.x,fromPos.y);this.graphics.lineTo(toPos.x,toPos.y);break;}}}}</pre> <hr><h2> <span>Шаг 9: Создание графа</span></h2> <p>Граф является более сложным элементом, поскольку он должен хранить всю информацию. В папке Graphсоздайте новый класс и назовите его Graph. Поскольку он просто содержит данные, нет необходимости расширять класс Sprite.</p> <p>Граф будет содержать Вектор со всеми точками на графе, другой Вектор с линиями, которые имеются в каждой точке, и статическую переменнуюint, чтобы получить следующий,доступный индекс для точки. Таким образом, будет легче получить доступ ко всем элементам на графе, поскольку индекс точки будет являться ключом вектора линий, что означает, что если вы хотите получить линию точки с индексом 3, вы получаете доступ к Вектору линий в 3 позиции, и вы сможете обратиться к линиям для этой точки.</p> <p>Теперь давайте создадим эти переменные:</p> <pre class="brush: actionscript3 noskimlinks noskimwords">package Graph{public class Graph{private static var nextIndex:int=0;private var nodes:Vector.&lt;Node&gt;;private var edges:Vector.&lt;Array&gt;;public function Graph(){nodes=new Vector.&lt;Node&gt;();edges=new Vector.&lt;Array&gt;();}}}</pre> <p>Графу также нужны методы для добавления и получения узлов и линий:</p> <pre class="brush: actionscript3 noskimlinks noskimwords">package Graph{public class Graph{private static var nextIndex:int=0;private var nodes:Vector.&lt;Node&gt;;private var edges:Vector.&lt;Array&gt;;public function Graph(){nodes=new Vector.&lt;Node&gt;();edges=new Vector.&lt;Array&gt;();}        //In order to get the node, we just ask for the index of it, and access the nodes vector with that keypublic function getNode(idx:int):Node{return nodes[idx];}        //To get an edge, we ask for the two nodes that it connects,        //then we retrieve all the edges of the from node and search if one of them        //goes to the same node as the edge we are looking for, if it does, that"s our edge.public function getEdge(from:int,to:int):Edge{var from_Edges:Array = edges[from] as Array;for(var a:int=0;a&lt;from_Edges.length;a++){if(from_Edges[a].getTo()==to){return from_Edges[a];}}return null;}        //To add a node to the graph, we first look if it already exist on it,        //if it doesn"t, then we add it to the nodes vector, and add an array to the        //edges vector where we will store the edges of that node, finally we increase        //the next valid index int in order to give the next available index in the graphpublic function addNode(node:Node):int{if(validIndex(node.getIndex())){nodes.push(node);edges.push(new Array());nextIndex++;}return 0;}        //To add an edge we must first look if both nodes it connects actually exist,        //then we must see if this edge already exist on the graph, finally we add it        //to the array of edges of the node from where it comespublic function addEdge(edge:Edge):void{if(validIndex(edge.getTo())&amp;&amp;validIndex(edge.getFrom())){if(getEdge(edge.getFrom(),edge.getTo())==null){(edges[edge.getFrom()]as Array).push(edge);}}}        //To get the edges of a node, just return the array given by the edges vector        //at node"s index positionpublic function getEdges(node:int):Array{return edges[node];}        //This function checks if the node index is between the range of already added nodes        //which is form 0 to the next valid index of the graphpublic function validIndex(idx:int):Boolean{return (idx&gt;=0&amp;&amp;idx&lt;=nextIndex)}        //Just returns the amount of nodes already added to the graphpublic function numNodes():int{return nodes.length;}        //This is to redraw all the edges on the graph to get them to the normal stylepublic function redraw():void{for each(var a_edges:Array in edges){for each(var edge:Edge in a_edges){edge.drawEdge(getNode(edge.getFrom()).getPos(),getNode(edge.getTo()).getPos());}}}        //This function return the next valid node index to be addedpublic static function getNextIndex():int{return nextIndex;}}}</pre> <hr><h2> <span>Шаг 10: Построение Графа</span></h2> <p>Итак, теперь, когда у нас есть все необходимые элементы, давайте продолжим и построим граф.</p> <p>В папке PathFinding создайте новый класс и назовите его «Main», это будет наш основной класс:</p> <pre class="brush: actionscript3 noskimlinks noskimwords">package{import flash.display.Sprite;public class Main extends Sprite{public function Main(){}}}</pre> <p>Теперь нам нужно импортировать классы, которые мы только что создали, так как они находятся в папке Graph. Затем создайте две переменные: одну для графа и другую, которая представляет собой массив позиции точек, которые мы хотим добавить. После этого добавьте эти точки и их линии:</p> <pre class="brush: actionscript3 noskimlinks noskimwords">package{import flash.display.Sprite;import Graph.*;import flash.geom.Vector3D;public class Main extends Sprite{var graph:Graph = new Graph();        //This array contains the position of the different nodes in the graph (x,y)var nodes:Array =new Array( [110,20], [80,50], [300,200], [180,250], [380,380], [500,200] );         //This array contains the edges that connects the different nodes (from,to)var edges:Array = new Array([0,1],[0,5],[0,3],[1,2],[1,0],[1,4],[2,1],[2,5],[3,1],[3,5],[4,0],[4,5],[5,2],[5,3]);public function Main(){  //A loop in order to create all the nodesfor(var a:int=0;a&lt;nodes.length;a++){var node:Node = new Node(Graph.Graph.getNextIndex(), new Vector3D(nodes[a][0],nodes[a][1]));graph.addNode(node);addChild(node);}          //Another loop to create all the edges between nodesfor(var b:int=0;b&lt;edges.length;b++){var from:int = edges[b][0];var to:int = edges[b][1];var edge:Edge = new Edge(from,to,Vector3D.distance(graph.getNode(from).getPos(),graph.getNode(to).getPos()));graph.addEdge(edge);                //Since the drawEdge method requires the position vectors, we get the nodes                //from the graph with their index and then get their position with getPos()edge.drawEdge(graph.getNode(from).getPos(),graph.getNode(to).getPos());addChild(edge);}}}}</pre> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=545/active/uploads/legacy/tuts/141_ai/Tutorial/PF-09.jpg" alt="Серия про искусственный интеллект - Часть 1: Поиск путей..." title="Серия про искусственный интеллект - Часть 1: Поиск путей..." width="50" height="50"></div> <hr><h2> <span>Шаг 11: Как выбрать правильный путь?</span></h2> <p>Как я уже вам говорил, существует много способов получить кратчайший путь между двумя точками, например, DFS (DeepFirstSearch) или BFS (BroadFirstSearch), но иногда вы не просто хотите получить путь, соединяющий точки, вы также хотите получить «самый лучший» путь, который чаще всего означает тот путь, который занимает меньше времени или находится ближе, в зависимости от того, что вам нужно.</p> <p>Во время этого урока я буду просто ссылаться на него как на тот, который <em>стоит</em> меньше. (В нашем случае помните, что «стоимость» означает расстояние. В игре вы можете искать наименее опасный путь, или тот, который использует наименьшее количество топлива или наиболее скрытный...)</p> <p>Существуют алгоритмы, которые работают основываясь на стоимость, наиболее важными из которых являются Алгоритм Дейкстры и Алгоритм A* (A-Star). Давайте сначала поговорим об алгоритме Дейкстры.</p> <hr><h2> <span>Шаг 12: Введение в алгоритм Дейкстры</span></h2> <p>Этот алгоритм был создан <span>Edsger Dijkstra</span> в 1959 году. Он рассчитывается в зависимости от стоимости, которую представляет каждая линия, линии с более низкой стоимостью всегда будут выбираться первыми, поэтому, когда вы достигнете цели, вы будете уверены, что путь - это самый выгодный путь из возможных.</p> <hr><h2> <span>Шаг 13: Как работает алгоритм Дейкстры</span></h2> <p>Поскольку этот алгоритм работает с затратами, у нас должно быть место, где мы будем хранить стоимость перехода на каждую точку из исходной позиции (стартовой точки); назовём это вектором стоимости.</p> <p>Например, если исходной позицией является точка 0, когда мы обращаемся к вектору стоимости в позиции 3, он вернет самую низкую стоимость, перехода от 0 до 3 точки.Нам также понадобится способ сохранения кратчайшего пути: я объясню понятие Кратчайшего Древа путей на следующем этапе.</p> <p>Основные этапы алгоритма следующие:</p> <ol><li> Добавляем свою лучшую линию в Древо Кратчайших путей.</li> <li> Добавляем свою лучшую линию в Древо Кратчайших путей.</li> <li> Если это целевая точка, завершаем поиск.</li> <li> Извлекаем все линии этой точки.</li> <li> Для каждой линии вычисляем стоимость перехода от исходной точки к точке прибытия.</li> <li> Если общая стоимость этой точки меньше стоимости точки прибытия, обновляем стоимость точки новым значением.</li> <li> Берём следующую ближайшую точку, еще не проанализированную.</li> <li> Повторяем это действие до достижения цели, или до перебора всех точек.</li> </ol><p>Анимация придаст этому больше смысла. Здесь мы пытаемся перейти от 1 до 6 точки:</p> <div class="tutorial_image"> <object width="300" height="330" data="https://activetuts.s3.amazonaws.com/tuts/141_ai/Tutorial/Dijkstra.swf" type="application/x-shockwave-flash"><param name="src" value="http://activetuts.s3.amazonaws.com/tuts/141_ai/Tutorial/Dijkstra.swf"></object> </div> <hr><h2> <span>Шаг 14: Основные элементы алгоритма</span></h2> <p> Этот алгоритм состоит из разных векторов, которые будут хранить всю необходимую информацию, например затраты на переход к точкам, или лучший путь до текущего места. Я объясню это получше:</p> <ul><li>Вектор затрат: здесь мы сохраним наилучшую стоимость до тех пор, пока не достигнем определенной точки из отправной точки. Например, если исходной точкой будет 3 и мы обращаемся к элементу 6 вектора стоимости, мы получим наилучшую стоимость, найденную до сих пор, начиная с 3, исходной точки, до точки 6.</li> <li>Древо Кратчайших Путей (SPT): этот вектор содержит линию наименьших затрат для перехода к определенной точке. Это означает, что, если мы получим доступ к элементу 7 на SPT, он вернет лучшую линию для доступа к этой точке.</li> <li>SearchFrontier (SF): этот вектор будет хранить наилучшую линию для доступа к определенной точке, почти так же, как и SPT, но здесь будут все точки, которые еще не находятся в SPT. Это означает, что SF будет работать в качестве тестовой области, где мы проверим все линии для однойточки, когда все линии будут проанализированы, мы будем уверены, что SF содержит лучший результат, поэтому мы можем добавить его в SPT. </li> <li>Очередь с индексированным приоритетом (pq): приоритетная очередь представляет собой структуру данных, которая всегда сохраняет свои элементы упорядоченным способом. Поскольку алгоритм должен сначала получить точку с наименьшими затратами, эта структура будет располагать точки в порядке убывания в зависимости от их затратности, но поскольку мы хотим получить индекс точки, а не сами затраты, мы используем индексированную очередь приоритетов. Например, если первым элементом pq является точка 4, это будет означать, что это та точка, которая имеет самую низкую стоимость.</li> </ul><p><strong>Примечание</strong>: AS3 не содержит много структур данных, включая индексированную <span>очередь приоритетов</span>, поэтому я написал код для использования его в этом уроке. Чтобы получить его, просто загрузите исходные файлы и импортируйте папку <code>utils</code> в папку PathFinding. Класс <code>utils.IndexPriorityQ</code>.</p> <hr><h2> <span>Шаг 15. Создание папки с алгоритмом</span></h2> <p>Прежде чем мы начнем писать код, в папке PathFinding создайте новую папку и назовите ее «Algorithms».</p> <p>В этой новой папке создайте новый класс AS3 с именем «Dijkstra»:</p> <pre class="brush: actionscript3 noskimlinks noskimwords">package Algorithms  {public class Dijkstra {public function Dijkstra() {}}}</pre> <hr><h2> <span>Шаг 16: Алгоритм Дейкстры в AS3</span></h2> <p>Теперь давайте напишем алгоритм. Это потребует трех основных вещей: собственно графа, отправной точки и целевой точки; мы также должны создавать векторы, о которых мы только что говорили (стоимость, SPT, SF). Не забудьте импортировать классы Graph:</p> <pre class="brush: actionscript3 noskimlinks noskimwords">package Algorithms  {import Graph.Edge;import Graph.Graph;import utils.IndexedPriorityQ;public class Dijkstra {private var graph:Graph//The graph where the search will be madeprivate var SPT:Vector.&lt;Edge&gt;;//The Shortest path tree containing edgesprivate var cost2Node:Vector.&lt;Number&gt;;//The Cost vector containing numbersprivate var SF:Vector.&lt;Edge&gt;;//The Search Frontier containing edgesprivate var source:int;                 //Where will the search startprivate var target:int;                 //Where will the search endpublic function Dijkstra(g:Graph) {}}}</pre> <hr><h2> <span>Шаг 17: Функция поиска</span></h2> <p>Как только мы установили класс, мы можем начать кодирование алгоритма, который будет находиться в функции «Search». Я поясню код комментариями, поэтому, если у вас все еще остались вопросы, возвращайтесь к шагам 12 и 13, чтобы напомнить себе, о том, как работает этот алгоритм:</p> <pre class="brush: actionscript3 noskimlinks noskimwords">private function search():void{//This will be the indexed priority Queue that will sort the nodesvar pq:IndexedPriorityQ = new IndexedPriorityQ(cost2Node)//To start the algorithm we first add the source to the pqpq.insert(source);//With this we make sure that we will continue the search until there are no more nodes on the pqwhile(!pq.isEmpty()){/* 1.- Take the closest node not yet analyzed *///We get the Next Closest Node (NCN) which is the first element of the pqvar NCN:int = pq.pop();/* 2.-Add its best edge to the Shortest Path Tree (Its best edge is stored on the SF) */SPT[NCN]=SF[NCN];//This will color the actual edge red in order to see which edges the algorithm has analyzedif(SPT[NCN]){SPT[NCN].drawEdge(graph.getNode(SPT[NCN].getFrom()).getPos(),graph.getNode(SPT[NCN].getTo()).getPos(),"visited");}/* 3.- If it is the target node, finish the search */if(NCN==target)return;/* 4.- Retrieve all the edges of this node */var edges:Array=graph.getEdges(NCN);//With this loop we will analyze each of the edges of the arrayfor each(var edge:Edge in edges){/* 5.- For each edge calculate the cost of moving from the source node to the arrival Node *///The total cost is calculated by: Cost of the node + Cost of the edgevar nCost:Number = cost2Node[NCN]+edge.getCost();//If the arrival node has no edge on the SF, then add its cost to the//Cost vector, the arrival node to the pq, and add the edge to the SFif(SF[edge.getTo()]==null){cost2Node[edge.getTo()]=nCost;pq.insert(edge.getTo());SF[edge.getTo()]=edge;}/* 6.- If the cost of this edge is less than the cost of the arrival node until now, then update the node cost with the new one */else if((nCost&lt;cost2Node[edge.getTo()])&amp;&amp;(SPT[edge.getTo()]==null)){cost2Node[edge.getTo()]= nCost;//Since the cost of the node has changed, we need to reorder again the pq to reflect the changespq.reorderUp();//Because this edge is better, we update the SF with this edgeSF[edge.getTo()]=edge;}}}}</pre> <hr><h2> <span>Шаг 18: Получение пути</span></h2> <p>Когда функция завершит поиск, у нас будет весь путь, который будет запущен на SPT, поэтому мы можем получить его. Поскольку SPT выбрал лучшую линию для доступа к точке, мы сможем проработать его, чтобы получить лучший путь. Возьмем в качестве ссылки следующее изображение, полученное из предыдущей анимации:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://cdn.tutsplus.com/active/uploads/legacy/tuts/141_ai/Tutorial/PF-04.jpg" class="lazy07" alt="Серия про искусственный интеллект - Часть 1: Поиск путей..." title="Серия про искусственный интеллект - Часть 1: Поиск путей..." width="50" height="50"></div> <p>Если мы обратимся к SPT на целевой точке, которая в этом случае равна 6, она вернет лучшую линию, чтобы попасть туда. Это будет 6 - 5 линия.  Теперь, если мы повторим этот процесс с новой точкой, который идет с линией, в 5 мы получим лучшее преимущество, чтобы добраться до этой точки, который является линией 5 - 2. Повторение этого процесса еще раз с точкой 2 даст нам линию 2 - 1, поэтому мы, наконец, дойдем до начала, теперь соединяясь с этими линиями, получим наилучший путь: 6&gt; 5&gt; 2&gt; 1.</p> <p>Как вы видите, мы должны двигаться назад, начиная с цели и переходя к отправной точке, чтобы получить лучший путь.</p> <hr><h2> <span>Шаг 19: Функция getPath</span></h2> <p>Создайте новую функцию, которая будет возвращать массив с точками пути, назовите его «getPath»:</p> <pre class="brush: actionscript3 noskimlinks noskimwords">public function getPath():Array{var path:Array = new Array();if(target&lt;0) return path;var nd:int = target;path.push(nd);while((nd!=source)&amp;&amp;(SPT[nd]!=null)){SPT[nd].drawEdge(graph.getNode(SPT[nd].getFrom()).getPos(),graph.getNode(SPT[nd].getTo()).getPos(),"path");nd = SPT[nd].getFrom();path.push(nd);}path=path.reverse();return path;}</pre> <hr><h2> <span>Шаг 20: Завершаем класс Дийкстра</span></h2> <p>Мы закончили почти все, нам просто нужно заполнить конструктор и вызвать функцию поиска, поэтому класс будет выглядеть так:</p> <pre class="collapse: true; brush: actionscript3 noskimlinks noskimwords">package Algorithms{import Graph.Edge;import Graph.Graph;import utils.IndexedPriorityQ;public class Dijkstra {private var graph:Graphprivate var SPT:Vector.&lt;Edge&gt;private var cost2Node:Vector.&lt;Number&gt;private var SF:Vector.&lt;Edge&gt;private var source:int;private var target:int;public function Dijkstra(n_graph:Graph,src:int,tar=int) {graph=n_graph;source=src;target=tar;SPT= new Vector.&lt;Edge&gt;(graph.numNodes());cost2Node = new Vector.&lt;Number&gt;(graph.numNodes());SF = new Vector.&lt;Edge&gt;(graph.numNodes());search();}private function search():void{var pq:IndexedPriorityQ = new IndexedPriorityQ(cost2Node)pq.insert(source);while(!pq.isEmpty()){var NCN:int = pq.pop();SPT[NCN]=SF[NCN];if(SPT[NCN]){SPT[NCN].drawEdge(graph.getNode(SPT[NCN].getFrom()).getPos(),graph.getNode(SPT[NCN].getTo()).getPos(),"visited");}if(NCN==target)return;var edges:Array=graph.getEdges(NCN);for each(var edge:Edge in edges){var nCost:Number = cost2Node[NCN]+edge.getCost();if(SF[edge.getTo()]==null){cost2Node[edge.getTo()]=nCost;pq.insert(edge.getTo());SF[edge.getTo()]=edge;}else if((nCost&lt;cost2Node[edge.getTo()])&amp;&amp;(SPT[edge.getTo()]==null)){cost2Node[edge.getTo()]= nCost;pq.reorderUp();SF[edge.getTo()]=edge;}}}}public function getPath():Array{var path:Array = new Array();if((target&lt;0)||(SPT[target]==null)) return path;var nd:int=target;path.push(nd);while((nd!=source)&amp;&amp;(SPT[nd]!=null)){SPT[nd].drawEdge(graph.getNode(SPT[nd].getFrom()).getPos(),graph.getNode(SPT[nd].getTo()).getPos(),"path");nd = SPT[nd].getFrom()path.push(nd);}path = path.reverse();return path;}}}</pre> <hr><h2> <span>Шаг 21: Создание нового графа</span></h2> <p>Чтобы увидеть лучший результат работы алгоритма, я написал класс, который помогает с созданием графов. Он называется Grapher и находится внутри папки utils, которая идёт вместе с исходными файлами. Этот класс создает сетку точек, с которой мы можем наблюдать, как алгоритм движется по графу.</p> <p>С помощью этого класса снова откройте файл «Main.as»  и измените его. Теперь у нас будет следующий код:</p> <pre class="brush: actionscript3 noskimlinks noskimwords">package{import flash.display.Sprite;import Graph.*;import utils.Grapher;public class Main extends Sprite{var graph:Graph = new Graph();public function Main(){//The parameters of the Grapher class are the width and height of the stage//the number of columns and rows, and then the graph for storing the data//After this we just add  the grapher to the stage and we are done.//This will create a grid of nodes of 7*7var grapher:Grapher = new Grapher(550,400,7,7,graph);addChild(grapher);}}}</pre> <p>Сохраните и запустите файл, и вы получите этот результат:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=548/active/uploads/legacy/tuts/141_ai/Tutorial/PF-03.jpg" alt="Серия про искусственный интеллект - Часть 1: Поиск путей..." title="Серия про искусственный интеллект - Часть 1: Поиск путей..." width="50" height="50"></div> <hr><h2> <span>Шаг 22: Использование алгоритма Дейкстры</span></h2> <p>Теперь давайте продолжим и проведем поиск с новым алгоритмом, который мы только что сделали. Импортируйте класс Dijkstra, создайте экземпляр и вызовите функцию getPath:</p> <pre class="brush: actionscript3 noskimlinks noskimwords">package{import flash.display.Sprite;import Graph.*;import utils.Grapher;import Algorithms.Dijkstra;public class Main extends Sprite{var graph:Graph = new Graph();public function Main(){var grapher:Grapher = new Grapher(550,400,7,7,graph);addChild(grapher);//We create a new Dijkstra search that will look a path from node 24 to node 35var dijkstra:Dijkstra = new Dijkstra(graph,24,35);dijkstra.getPath();}}}</pre> <p>Сохраните и запустите файл. Вы увидите линии, которые алгоритм проанализировал обозначенные красным, это лучший путь (от точки 24 до точки 35), появляющийся как черная линия:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=543/active/uploads/legacy/tuts/141_ai/Tutorial/PF-02.jpg" alt="Серия про искусственный интеллект - Часть 1: Поиск путей..." title="Серия про искусственный интеллект - Часть 1: Поиск путей..." width="50" height="50"></div> <hr><h2> <span>Шаг 23: Нет ли чего получше?</span></h2> <p>Как видим, алгоритм Дейкстры находит кратчайший путь между двумя точками, но, как показывает последнее изображение, там много красных линий. Это означает, что все эти линии были проанализированы, что немаловажно, потому что сейчас у нас небольшой граф, но представьте себе больший; там было бы слишком много линий для анализа. Если бы мы могли найти способ упростить это и сделать алгоритм еще более эффективным ... итак, я представляю вам алгоритм A * (A-Star).</p> <hr><h2> <span>Шаг 24: Алгоритм A*</span></h2> <p>Алгоритм A* представляет собой модифицированную версию Dijkstra. Он учитывает измененный способ получения стоимости каждой точки с <span>эвристическим</span> подходом. Это означает, что мы немного «помогаем» алгоритму и рассказываем ему, куда идти, работая как компас и перемещая алгоритм непосредственно к цели.</p> <p>Вместо вычисления стоимости точки путем суммирования стоимости линии к стоимости сохраненной точки теперь вычисляется суммированием стоимости сохранённой точки и эвристической стоимостью, которая представляет собой оценку того, насколько близко к цели, точка, которую мы анализируем. Эта стоимость называется стоимостью F.</p> <hr><h2> <span>Шаг 25: Стоимость F</span></h2> <p>Стоимость F вычисляется по следующей формуле: F = G + H, где G - стоимость точки, а H - эвристическая стоимость от этойточки до цели. В этом уроке стоимость H будет рассчитываться с использованием <span>евклидова расстояния</span> между точкой и целью, что является прямой линией между двумя точками.</p> <p>Смысл, того что мы делаем, заключается в том, что в конце будут проверены первые точки с более низкой стоимостью F и потому, что стоимость F будет зависеть в основном от стоимости H, в конце алгоритм всегда будет определять приоритеты точек, ближайших к цели.</p> <hr><h2> <span>Шаг 26: Алгоритм A* в AS3</span></h2> <p>В папке Algorithmsсоздайте новый класс «Astar». Переменные внутри класса будут почти такими же, как класс Dijkstra, но здесь у нас будет другой вектор для хранения F-стоимости каждой точки:</p> <pre class="brush: actionscript3 noskimlinks noskimwords">package Algorithms{import Graph.Edge;import Graph.Graph;import flash.geom.Vector3D;import utils.IndexedPriorityQ;public class Astar {private var graph:Graphprivate var SPT:Vector.&lt;Edge&gt;private var G_Cost:Vector.&lt;Number&gt;//This vector will store the G cost of each nodeprivate var F_Cost:Vector.&lt;Number&gt;//This vector will store the F cost of each nodeprivate var SF:Vector.&lt;Edge&gt;private var source:int;private var target:int;public function Astar(n_graph:Graph,src:int,tar:int){graph=n_graph;source=src;target=tar;SPT= new Vector.&lt;Edge&gt;(graph.numNodes());G_Cost = new Vector.&lt;Number&gt;(graph.numNodes());F_Cost = new Vector.&lt;Number&gt;(graph.numNodes());SF = new Vector.&lt;Edge&gt;(graph.numNodes());search();}}}</pre> <h2> <span>Шаг 27: Новый класс поиска</span></h2> <p>Единственная разница между функцией поиска алгоритма Dijkstra и этим будет заключаться в том, что точки будут сортироваться (в очереди с индексированным приоритетом) в зависимости от вектора стоимости F и что Fвектор стоимости будет задаваться рассчитанной стоимостью H и сохраненной стоимостью G:</p> <pre class="brush: actionscript3 noskimlinks noskimwords">private function search():void{//The pq is now sorted depending on the F cost vectorvar pq:IndexedPriorityQ = new IndexedPriorityQ(F_Cost)pq.insert(source);while(!pq.isEmpty()){var NCN:int = pq.pop();SPT[NCN]=SF[NCN];if(SPT[NCN]){SPT[NCN].drawEdge(graph.getNode(SPT[NCN].getFrom()).getPos(),graph.getNode(SPT[NCN].getTo()).getPos(),"visited");}if(NCN==target)return;var edges:Array=graph.getEdges(NCN);for each(var edge:Edge in edges){//The H cost is obtained by the distance between the target node, and the arrival node of the edge being analyzedvar Hcost:Number = Vector3D.distance(graph.getNode(edge.getTo()).getPos(),graph.getNode(target).getPos())var Gcost:Number = G_Cost[NCN] + edge.getCost();var to:int=edge.getTo();if(SF[edge.getTo()]==null){F_Cost[edge.getTo()]=Gcost+Hcost;G_Cost[edge.getTo()]=Gcost;pq.insert(edge.getTo());SF[edge.getTo()]=edge;}else if((Gcost&lt;G_Cost[edge.getTo()])&amp;&amp;(SPT[edge.getTo()]==null)){F_Cost[edge.getTo()]=Gcost+Hcost;G_Cost[edge.getTo()]=Gcost;pq.reorderUp();SF[edge.getTo()]=edge;}}}}</pre> <hr><h2> <span>Шаг 28: Полный класс A*</span></h2> <p>Это единственные изменения, которые необходимы, поскольку функция getPath для обоих классов одинакова. В конце класс будет выглядеть следующим образом:</p> <pre class="collapse: true; brush: actionscript3 noskimlinks noskimwords">package Algorithms  {import Graph.Edge;import Graph.Graph;import flash.geom.Vector3D;import utils.IndexedPriorityQ;public class Astar {private var graph:Graphprivate var SPT:Vector.&lt;Edge&gt;private var G_Cost:Vector.&lt;Number&gt;//This vector will store the G cost of each nodeprivate var F_Cost:Vector.&lt;Number&gt;//This vector will store the F cost of each nodeprivate var SF:Vector.&lt;Edge&gt;private var source:int;private var target:int;public function Astar(n_graph:Graph,src:int,tar:int){graph=n_graph;source=src;target=tar;SPT= new Vector.&lt;Edge&gt;(graph.numNodes());G_Cost = new Vector.&lt;Number&gt;(graph.numNodes());F_Cost = new Vector.&lt;Number&gt;(graph.numNodes());SF = new Vector.&lt;Edge&gt;(graph.numNodes());search();}private function search():void{//The pq is now sorted depending on the F cost vectorvar pq:IndexedPriorityQ = new IndexedPriorityQ(F_Cost)pq.insert(source);while(!pq.isEmpty()){var NCN:int = pq.pop();SPT[NCN]=SF[NCN];if(SPT[NCN]){SPT[NCN].drawEdge(graph.getNode(SPT[NCN].getFrom()).getPos(),graph.getNode(SPT[NCN].getTo()).getPos(),"visited");}if(NCN==target)return;var edges:Array=graph.getEdges(NCN);for each(var edge:Edge in edges){//The H cost is obtained by the distance between the target node, and the arrival node of the edge being analyzedvar Hcost:Number = Vector3D.distance(graph.getNode(edge.getTo()).getPos(),graph.getNode(target).getPos())var Gcost:Number = G_Cost[NCN] + edge.getCost();var to:int=edge.getTo();if(SF[edge.getTo()]==null){F_Cost[edge.getTo()]=Gcost+Hcost;G_Cost[edge.getTo()]=Gcost;pq.insert(edge.getTo());SF[edge.getTo()]=edge;}else if((Gcost&lt;G_Cost[edge.getTo()])&amp;&amp;(SPT[edge.getTo()]==null)){F_Cost[edge.getTo()]=Gcost+Hcost;G_Cost[edge.getTo()]=Gcost;pq.reorderUp();SF[edge.getTo()]=edge;}}}}public function getPath():Array{var path:Array = new Array();if(target&lt;0) return path;var nd:int = target;path.push(nd);while((nd!=source)&amp;&amp;(SPT[nd]!=null)){SPT[nd].drawEdge(graph.getNode(SPT[nd].getFrom()).getPos(),graph.getNode(SPT[nd].getTo()).getPos(),"path");nd = SPT[nd].getFrom();path.push(nd);}path=path.reverse();return path;}}}</pre> <hr><h2> <span>Шаг 29: Использование алгоритма A*</span></h2> <p>Еще раз откройте файл «Main.as» и импортируйте класс Astar, затем удалите созданный нами Dijkstra, заменив его на поиск A*:</p> <pre class="brush: actionscript3 noskimlinks noskimwords">package{import flash.display.Sprite;import Graph.*;import utils.Grapher;import Algorithms.Dijkstra;import Algorithms.Astar;public class Main extends Sprite{var graph:Graph = new Graph();public function Main(){var grapher:Grapher = new Grapher(550,400,7,7,graph);addChild(grapher);//We create a new Astar search that will look a path from node 24 to node 35var astar:Astar = new Astar(graph,24,35);astar.getPath();}}}</pre> <p>Сохраните и запустите файл. Как вы можете видеть, результат очень впечатляет, нет красных линий, что означает, что поиск шел напрямую от источника к цели без анализа дополнительных линий:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=538/active/uploads/legacy/tuts/141_ai/Tutorial/PF-01.jpg" alt="Серия про искусственный интеллект - Часть 1: Поиск путей..." title="Серия про искусственный интеллект - Часть 1: Поиск путей..." width="50" height="50"></div> <hr><h2> <span>Шаг 30: Какой из них лучше?</span></h2> <p>Ну, хотя алгоритм A * быстрее и эффективнее получает прямой путь от источника к цели, будут случаи, когда Dijkstra будет лучшим вариантом.</p> <p>Например, представьте себе игру RTS, где вы указали своему жителю пойти и найти некоторые ресурсы; с алгоритмом A* вам нужно будет выполнить поиск для каждого ресурса на карте, а затем проанализировать, какой из них ближе. С поиском Dijkstra, так как он использует ту же сумму по всем направлениям, первый найденный им ресурс будет лучшим для сбора, и вы выполнили бы только один поиск по сравнению со многими поисками A*.</p> <p>В основном, вы захотите использовать алгоритм Dijkstra, когда вы выполняете общий поиск, а алгоритм A*, когда ищете определенный элемент.</p> <hr><h2>Заключение</h2> <p>На этом урок завершается. Я надеюсь, что вам понравилось и вы будете использовать его в ваших проектах. Следите за следующим уроком этой серии про AI и дайте мне знать, что вы думаете об этом.</p> <p>Спасибо за чтение!  -Eduardo</p> 

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825718-seriya-pro-iskusstvennyj-intellekt--chast-1-poisk-putej" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Games" href="https://norma-studio.github.io/article5/220825718-seriya-pro-iskusstvennyj-intellekt--chast-1-poisk-putej" class="tm-article-body__tags-item-link">Games</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
38503</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
363</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

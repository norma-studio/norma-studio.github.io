
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Чат в реальном времени с Node.js Readline и Socket.io... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Чат в реальном времени с Node.js Readline и Socket.io... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Чат в реальном времени с Node.js Readline и Socket.io... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Чат в реальном времени с Node.js Readline и Socket.io... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Node.js имеет недооцененный модуль в своей стандартной библиотеке, что на удивление полезно. Модуль Readline делает то, что и говорит его название: он считывает строку ввода с терминала. Его можно использовать, чтобы задать пользователю вопрос или два или создать запрос в нижней части экрана. В этом уроке я намерен продемонстрировать возможности Re...">
<meta property="og:description" content="Node.js имеет недооцененный модуль в своей стандартной библиотеке, что на удивление полезно. Модуль Readline делает то, что и говорит его название: он считывает строку ввода с терминала. Его можно использовать, чтобы задать пользователю вопрос или два или создать запрос в нижней части экрана. В этом уроке я намерен продемонстрировать возможности Re...">
<meta name="twitter:description" content="Node.js имеет недооцененный модуль в своей стандартной библиотеке, что на удивление полезно. Модуль Readline делает то, что и говорит его название: он считывает строку ввода с терминала. Его можно использовать, чтобы задать пользователю вопрос или два или создать запрос в нижней части экрана. В этом уроке я намерен продемонстрировать возможности Re...">
<meta property="aiturec:description" content="Node.js имеет недооцененный модуль в своей стандартной библиотеке, что на удивление полезно. Модуль Readline делает то, что и говорит его название: он считывает строку ввода с терминала. Его можно использовать, чтобы задать пользователю вопрос или два или создать запрос в нижней части экрана. В этом уроке я намерен продемонстрировать возможности Re...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/304/posts/20953/final_image/final.png">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/304/posts/20953/final_image/final.png">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/304/posts/20953/final_image/final.png">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/304/posts/20953/final_image/final.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/304/posts/20953/final_image/final.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825512-chat-v-realnom-vremeni-s-nodejs-'readline-i-socketio.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825512-chat-v-realnom-vremeni-s-nodejs-'readline-i-socketio.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825512-chat-v-realnom-vremeni-s-nodejs-'readline-i-socketio.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825512-chat-v-realnom-vremeni-s-nodejs-'readline-i-socketio.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825512-chat-v-realnom-vremeni-s-nodejs-'readline-i-socketio.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825512-chat-v-realnom-vremeni-s-nodejs-'readline-i-socketio.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825512-chat-v-realnom-vremeni-s-nodejs-'readline-i-socketio.html" title="Чат в реальном времени с Node.js Readline и Socket.io... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Чат в реальном времени с Node.js Readline и Socket.io... | envatomarket.ru | norma-studio.github.io" title="Чат в реальном времени с Node.js Readline и Socket.io... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/543234456.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825512-chat-v-realnom-vremeni-s-nodejs-'readline-i-socketio.html" class="tm-user-info__username" title="
А. Гаврилов" aria-label="
А. Гаврилов">
А. Гаврилов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Чат в реальном времени с Node.js Readline и Socket.io...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825512-chat-v-realnom-vremeni-s-nodejs-'readline-i-socketio" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Web Development" href="https://norma-studio.github.io/article5/220825512-chat-v-realnom-vremeni-s-nodejs-'readline-i-socketio" class="tm-article-snippet__hubs-item-link"><span>Web Development</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825512-chat-v-realnom-vremeni-s-nodejs-'readline-i-socketio.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/304/posts/20953/final_image/final.png">
    <meta itemprop="headline name" content="Чат в реальном времени с Node.js Readline и Socket.io... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Node.js имеет недооцененный модуль в своей стандартной библиотеке, что на удивление полезно. Модуль Readline делает то, что и говорит его название: он считывает строку ввода с терминала. Его можно использовать, чтобы задать пользователю вопрос или два или создать запрос в нижней части экрана. В этом уроке я намерен продемонстрировать возможности Re...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Node.js имеет недооцененный модуль в своей стандартной библиотеке, что на удивление полезно. Модуль Readline делает то, что и говорит его название: он считывает строку ввода с терминала. Его можно использовать, чтобы задать пользователю вопрос или два или создать запрос в нижней части экрана. В этом уроке я намерен продемонстрировать возможности Re...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Node.js имеет недооцененный модуль в своей стандартной библиотеке, что на удивление полезно. Модуль <span>Readline</span> делает то, что и говорит его название: он считывает строку ввода с терминала. Его можно использовать, чтобы задать пользователю вопрос или два или создать запрос в нижней части экрана. В этом уроке я намерен продемонстрировать возможности Readline и создать в режиме реального времени CLI-чат, поддерживаемый Socket.io. Клиент будет не только отправлять простые сообщения, но и иметь команды для эмоций с <code class="inline">/me</code>, личные сообщения с <code class="inline">/msg</code> и разрешать изменение псевдонимов с помощью <code class="inline">/nick</code>.<br></p><h2>Немного о Readline</h2><p>Это, вероятно, самое простое использование Readline:</p><pre class="brush: javascript noskimlinks noskimwords">var readline = require("readline");var rl = readline.createInterface(process.stdin, process.stdout);rl.question("What is your name? ", function(answer) {  console.log("Hello, " + answer );rl.close();});</pre><p>Мы включаем модуль, создаем интерфейс Readline со стандартными потоками ввода и вывода, а затем задаем пользователю одноразовый вопрос. Это первое использование Readline: задание вопросов. Если вам нужно что-то подтвердить с помощью пользователя, возможно, в форме популярного: «Вы хотите сделать это? (Y/n)», которые пронизывают инструменты CLI, <code class="inline">readline.question()</code> - это способ сделать это.<br></p><p>Другая функциональность, которую предоставляет Readline, - это приглашение, которое можно настроить с помощью символа по умолчанию «<b>&gt;</b>» и временно приостановить, чтобы предотвратить ввод. Для нашего клиента чата Readline это будет наш основной интерфейс. Будет одно вхождение <code class="inline">readline.question()</code>, чтобы спросить у пользователя псевдоним, но все остальное будет <code class="inline">readline.prompt()</code>.<br></p><h2>Управление вашими зависимостями</h2><p>Начнем со скучной части: зависимостей. Этот проект будет использовать <code class="inline">socket.io</code>, пакет <code class="inline">socket.io-client</code> и <code class="inline">ansi-color</code>. Ваш файл <code class="inline">package.json</code> должен выглядеть примерно так:</p><pre class="brush: javascript noskimlinks noskimwords">{    "name": "ReadlineChatExample","version": "1.0.0","description": "CLI chat with readline and socket.io","author": "Matt Harzewski","dependencies": {"socket.io": "latest","socket.io-client": "latest","ansi-color": "latest"},"private": true}</pre><p>Запустите <code class="inline">npm install</code>, и все должно выполнится автоматически.<br></p><h2>Сервер</h2><p>Для этого урока мы будем использовать невероятно простой сервер Socket.io:</p><pre class="brush: javascript noskimlinks noskimwords">var socketio = require("socket.io");// Listen on port 3636var io = socketio.listen(3636);io.sockets.on("connection", function (socket) {    // Broadcast a user"s message to everyone else in the roomsocket.on("send", function (data) {io.sockets.emit("message", data);    });});</pre><p>Все, что он делает, - это принимает входящее сообщение от одного клиента и передает его всем. Вероятно, сервер будет более надежным для крупномасштабного приложения, но для этого простого примера его должно быть достаточно.<br></p><p>Это должно быть сохранено в каталоге проекта как <code class="inline">server.js</code>.<br></p><h2>Клиент<br></h2><p>Прежде чем мы перейдем к интересной части, нам нужно включить наши зависимости, определить некоторые переменные и запустить интерфейс Readline и сокет.</p><pre class="brush: javascript noskimlinks noskimwords">var readline = require("readline"),socketio = require("socket.io-client"),util = require("util"),color = require("ansi-color").set;var nick;var socket = socketio.connect("localhost", { port: 3636 });var rl = readline.createInterface(process.stdin, process.stdout);</pre><p>На данный момент код очень понятен. У нас есть переменная nickname, соединение сокета (через пакет <code class="inline">socket.io-client</code>) и наш интерфейс Readline.</p><p>Socket.io будет подключаться к localhost через порт <code class="inline">3636</code> в этом примере, конечно, это будет изменено на домен и порт вашего собственного сервера, если вы делаете приложение для рабочего чата.</p><h2>Клиент: запрашиваем имя пользователя<br></h2><p>Теперь пришло время для нашего первого использования Readline! Мы хотим попросить пользователя выбрать ник, который будет идентифицировать их в чате. Для этого мы будем использовать метод <code class="inline">questionline()</code> Readline.</p><pre class="brush: javascript noskimlinks noskimwords">// Set the usernamerl.question("Please enter a nickname: ", function(name) {    nick = name;var msg = nick + " has joined the chat";socket.emit("send", { type: "notice", message: msg });rl.prompt(true);});</pre><p>Мы устанавливаем переменную ник из значения, полученного от пользователя, отправляем сообщение на сервер (которое будет передано другим клиентам), которое наш пользователь присоединился к чату, затем переключите интерфейс Readline обратно в режим подсказки. Значение <code class="inline">true</code>, переданное в <code class="inline">prompt()</code>, гарантирует, что символ приглашения будет правильно отображаться. (В противном случае курсор может перейти в нулевую позицию на линии, а «<b>&gt;</b>» не будет отображаться.<br></p><p>К сожалению, у Readline есть разочаровывающая проблема с методом <code class="inline">prompt()</code>. Он не очень хорошо сочетается с <code class="inline">console.log()</code>, который выводит текст на ту же строку, что и символ приглашения, оставляя блуждающие символы «<b>&gt;</b>»  и другие странности. Чтобы исправить это, мы не будем использовать <code class="inline">console.log</code> в любом месте этого приложения, за исключением одного . Вместо этого вывод должен быть передан этой функции:</p><pre class="brush: javascript noskimlinks noskimwords">function console_out(msg) {    process.stdout.clearLine();process.stdout.cursorTo(0);console.log(msg);rl.prompt(true);}</pre><p>Это <i>слегка</i> хитрое решение гарантирует, что текущая строка на консоли пуста и что курсор находится в нулевой позиции перед печатью вывода. Затем оно явно требует, чтобы запрос выводился снова, потом.<br></p><p>Итак, в оставшейся части этого руководства вы увидите <code class="inline">console_out()</code> вместо <code class="inline">console.log()</code>.</p><h2>Клиент: Обработка ввода<br></h2><p>Есть два типа ввода, которые пользователь может ввести: чат и команды. Мы знаем, что командам предшествует косая черта, поэтому их легко различить.<br></p><p>В Readline есть несколько обработчиков событий, но наиболее важным является, несомненно, <code class="inline">line</code>. Всякий раз, когда символ новой строки обнаруживается во входном потоке (из клавиши возврата или ввода), срабатывает это событие. Поэтому нам нужно подключиться к <code class="inline">line</code> для нашего обработчика ввода.</p><pre class="brush: javascript noskimlinks noskimwords">rl.on("line", function (line) {    if (line[0] == "/" &amp;&amp; line.length &gt; 1) {var cmd = line.match(/[a-z]+\b/)[0];var arg = line.substr(cmd.length+2, line.length);chat_command(cmd, arg);} else {// send chat messagesocket.emit("send", { type: "chat", message: line, nick: nick });rl.prompt(true);}});</pre><p>Если первый символ входной строки является косой чертой, мы знаем, что это команда, для которой потребуется больше обработки. В противном случае мы просто отправляем обычное сообщение чата и сбрасываем запрос. Обратите внимание на разницу между данными, переданными через сокет, и для сообщения соединения на предыдущем шаге. Он использует другой <code class="inline">type</code>, поэтому принимающий клиент знает, как отформатировать сообщение, и мы также передаем переменную <code class="inline">nick</code>.<br></p><p>Имя команды (<code class="inline">cmd</code>) и текст, следующий за ним (<code class="inline">arg</code>), изолированы  регулярным выражением и магией подстроки, затем мы передаем их функции, обрабатывающей команду.</p><pre class="brush: javascript noskimlinks noskimwords">function chat_command(cmd, arg) {    switch (cmd) {case "nick":var notice = nick + " changed their name to " + arg;nick = arg;socket.emit("send", { type: "notice", message: notice });break;case "msg":var to = arg.match(/[a-z]+\b/)[0];var message = arg.substr(to.length, arg.length);socket.emit("send", { type: "tell", message: message, to: to, from: nick });break;case "me":var emote = nick + " " + arg;socket.emit("send", { type: "emote", message: emote });break;default:console_out("That is not a valid command.");}}</pre><p>Если пользователь набирает <code class="inline">/nick gollum</code>, то переменная <code class="inline">nick</code> сбрасывается на <code class="inline">gollum</code>, где раньше, возможно, раньше был <code class="inline">smaagol</code>, и на сервер будет отправлено уведомление.</p><p>Если пользователь набирает <code class="inline">/msg bilbo Where is the precious?</code>, Одно и то же регулярное выражение используется для разделения получателя и сообщения, тогда объект с типом сообщения <code class="inline">tell</code> отправляется на сервер. Это будет отображаться немного иначе, чем обычное сообщение и не должно быть видимым для других пользователей. По общему признанию, наш чрезмерно простой сервер будет вслепую отдавать сообщение всем, но клиент будет игнорировать подсказки, которые не адресованы правильному нику. Более надежный сервер может быть более дискретным.<br></p><p>Команда emote используется в форме <code class="inline">/me is eating second breakfast</code>. Ник добавляется к emote таким образом, который должен быть знаком любому, кто использовал IRC или играл в многопользовательскую ролевую игру.<br></p><h2>Клиент: обработка входящих сообщений<br></h2><p>Теперь клиенту нужен способ получения сообщений. Все, что нам нужно сделать, это подключиться к событию <code class="inline">message</code> клиента Socket.io и соответствующим образом форматировать данные для вывода.</p><pre class="brush: javascript noskimlinks noskimwords">socket.on("message", function (data) {    var leader;if (data.type == "chat" &amp;&amp; data.nick != nick) {leader = color("&lt;"+data.nick+"&gt; ", "green");console_out(leader + data.message);}else if (data.type == "notice") {console_out(color(data.message, "cyan"));}else if (data.type == "tell" &amp;&amp; data.to == nick) {leader = color("["+data.from+"-&gt;"+data.to+"]", "red");console_out(leader + data.message);}else if (data.type == "emote") {console_out(color(data.message, "cyan"));}});</pre><p>Сообщения с типом <code class="inline">chat</code>, которые <i>не были</i> отправлены клиентом с использованием нашего ника, отображаются с ником и текстом чата. Пользователь уже может видеть, что он набрал в Readline, поэтому нет смысла выводить его снова. Здесь я использую пакет <code class="inline">ansi-color</code>, чтобы немного раскрасить результат. Это делать не обязательно, но это облегчает общение с чатом.<br></p><p>Сообщения с типом <code class="inline">notice</code> или <code class="inline">emote</code> печатаются как есть, хотя и окрашены в голубой цвет.<br></p><p>Если сообщение содержит тип <code class="inline">tell</code>, а ник равен текущему имени этого клиента, вывод принимает форму <code class="inline">[Somebody-&gt;You] Hi!</code>. Конечно, это не очень личное. Если вы хотите видеть сообщения <i>всех</i>, все, что вам нужно сделать, это убрать часть <code class="inline">&amp;&amp; data.to == nick</code>. В идеале сервер должен знать, какой клиент должен отправить сообщение, а не отправлять его клиентам, которые ему не нужны. Но это добавляет ненужную сложность, которая выходит за рамки данного руководства.<br></p><h2>Зажги!<br></h2><p>Теперь посмотрим, все ли работает. Чтобы проверить это, запустите сервер, выполнив <code class="inline">node server.js</code>, а затем откройте пару новых окон терминала. В новых окнах выполните <code class="inline">node client.js</code> и введите ник. Затем вы сможете общаться между ними, считая, что все идет хорошо.<br></p><p>Надеюсь, этот учебник показал вам, как легко начать работу с модулем Readline. Вы можете попробовать добавить дополнительные функции в приложение чата, для большей практики. И, наконец, проверьте <span>документацию Readline</span> для полного API.</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825512-chat-v-realnom-vremeni-s-nodejs-'readline-i-socketio" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Web Development" href="https://norma-studio.github.io/article5/220825512-chat-v-realnom-vremeni-s-nodejs-'readline-i-socketio" class="tm-article-body__tags-item-link">Web Development</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
35747</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
387</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

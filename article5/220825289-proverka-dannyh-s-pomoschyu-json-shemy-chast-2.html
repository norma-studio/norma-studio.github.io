
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Проверка данных с помощью JSON-схемы, часть 2
... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Проверка данных с помощью JSON-схемы, часть 2
... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Проверка данных с помощью JSON-схемы, часть 2
... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Проверка данных с помощью JSON-схемы, часть 2
... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="В первой части этого урока вы узнали, как создавать довольно продвинутые схемы, используя все доступные ключевые слова проверки. Многие реальные примеры данных JSON более сложны, чем наш пользовательский пример. Попытка поставить все требования к таким данным в одном файле может привести к очень большой схеме, которая также может иметь много дублир...">
<meta property="og:description" content="В первой части этого урока вы узнали, как создавать довольно продвинутые схемы, используя все доступные ключевые слова проверки. Многие реальные примеры данных JSON более сложны, чем наш пользовательский пример. Попытка поставить все требования к таким данным в одном файле может привести к очень большой схеме, которая также может иметь много дублир...">
<meta name="twitter:description" content="В первой части этого урока вы узнали, как создавать довольно продвинутые схемы, используя все доступные ключевые слова проверки. Многие реальные примеры данных JSON более сложны, чем наш пользовательский пример. Попытка поставить все требования к таким данным в одном файле может привести к очень большой схеме, которая также может иметь много дублир...">
<meta property="aiturec:description" content="В первой части этого урока вы узнали, как создавать довольно продвинутые схемы, используя все доступные ключевые слова проверки. Многие реальные примеры данных JSON более сложны, чем наш пользовательский пример. Попытка поставить все требования к таким данным в одном файле может привести к очень большой схеме, которая также может иметь много дублир...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/463/profiles/18875/profileImage/3c7051a.jpg">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/463/profiles/18875/profileImage/3c7051a.jpg">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/463/profiles/18875/profileImage/3c7051a.jpg">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/463/profiles/18875/profileImage/3c7051a.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/463/profiles/18875/profileImage/3c7051a.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825289-proverka-dannyh-s-pomoschyu-json-shemy-chast-2.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825289-proverka-dannyh-s-pomoschyu-json-shemy-chast-2.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825289-proverka-dannyh-s-pomoschyu-json-shemy-chast-2.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825289-proverka-dannyh-s-pomoschyu-json-shemy-chast-2.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825289-proverka-dannyh-s-pomoschyu-json-shemy-chast-2.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825289-proverka-dannyh-s-pomoschyu-json-shemy-chast-2.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825289-proverka-dannyh-s-pomoschyu-json-shemy-chast-2.html" title="Проверка данных с помощью JSON-схемы, часть 2
... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Проверка данных с помощью JSON-схемы, часть 2
... | envatomarket.ru | norma-studio.github.io" title="Проверка данных с помощью JSON-схемы, часть 2
... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/64535356345.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825289-proverka-dannyh-s-pomoschyu-json-shemy-chast-2.html" class="tm-user-info__username" title="
В. Чендылов" aria-label="
В. Чендылов">
В. Чендылов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Проверка данных с помощью JSON-схемы, часть 2
...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825289-proverka-dannyh-s-pomoschyu-json-shemy-chast-2" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="JSON" href="https://norma-studio.github.io/article5/220825289-proverka-dannyh-s-pomoschyu-json-shemy-chast-2" class="tm-article-snippet__hubs-item-link"><span>JSON</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825289-proverka-dannyh-s-pomoschyu-json-shemy-chast-2.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/463/profiles/18875/profileImage/3c7051a.jpg">
    <meta itemprop="headline name" content="Проверка данных с помощью JSON-схемы, часть 2
... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="В первой части этого урока вы узнали, как создавать довольно продвинутые схемы, используя все доступные ключевые слова проверки. Многие реальные примеры данных JSON более сложны, чем наш пользовательский пример. Попытка поставить все требования к таким данным в одном файле может привести к очень большой схеме, которая также может иметь много дублир...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">В первой части этого урока вы узнали, как создавать довольно продвинутые схемы, используя все доступные ключевые слова проверки. Многие реальные примеры данных JSON более сложны, чем наш пользовательский пример. Попытка поставить все требования к таким данным в одном файле может привести к очень большой схеме, которая также может иметь много дублир...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>В первой части этого урока вы узнали, как создавать довольно продвинутые схемы, используя все доступные ключевые слова проверки. Многие реальные примеры данных JSON более сложны, чем наш пользовательский пример. Попытка поставить все требования к таким данным в одном файле может привести к очень большой схеме, которая также может иметь много дублирования.</p><h2>Структурирование ваших схем</h2> <p>Стандарт JSON-схемы позволяет разбивать схемы на несколько частей. Давайте посмотрим на пример данных для навигации по новостным сайтам:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "level": 1,  "parent_id": null,  "visitors": "all",  "color": "white",  "pages": [    {      "page_id": 1,      "short_name": "home",      "display_name": "Home",      "url": "/home",      "navigation": {        "level": 2,        "parent_id": 1,        "color": "blue",        "pages": [          {            "page_id": 11,            "short_name": "headlines",            "display_name": "Latest headlines",            "url": "/home/latest",            "navigation": {              "level": 3,              "parent_id": 11,              "color": "white",              "pages": [                {                  "page_id": 111,                  "short_name": "latest_all",                  "display_name": "All",                  "url": "/home/latest"                },                ...              ]            }          },          {            "page_id": 12,            "short_name": "events",            "display_name": "Events",            "url": "/home/events"          }        ]      }    },    ...  ]}</pre> <p>Структура навигации выше несколько похожа на ту, которую вы можете увидеть на веб-сайте <span>http://dailymail.co.uk</span>. Вы можете увидеть более полный пример в <span>репозитории GitHub</span>.</p> <p>Структура данных сложна и рекурсивна, но схемы, описывающие эти данные, довольно просты:</p> <p>navigation.json:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "$schema": "http://json-schema.org/draft-04/schema#",  "id": "http://mynet.com/schemas/navigation.json#",  "title": "Navigation",  "definitions": {    "positiveIntOrNull": { "type": ["null", "integer"], "minimum": 1 }  },  "type": "object",  "additionalProperties": false,  "required": [ "level", "parent_id", "color", "pages" ],  "properties": {    "level":     { "$ref": "defs.json#/definitions/positiveInteger" },    "parent_id": { "$ref": "#/definitions/positiveIntOrNull" },    "visitors":  { "enum": [ "all", "subscribers", "age18" ] },    "color":     { "$ref": "defs.json#/definitions/color" },    "pages":     {      "type": "array",      "items": { "$ref": "page.json#" }    }  }}</pre> <p>page.json:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "$schema": "http://json-schema.org/draft-04/schema#",  "id": "http://mynet.com/schemas/page.json#",  "title": "Page",  "type": "object",  "additionalProperties": false,  "required": [ "page_id", "short_name", "display_name", "path" ],  "properties": {    "page_id":      { "$ref": "defs.json#/definitions/positiveInteger" },    "short_name":   { "type": "string", "pattern": "^[a-z_]+$" },    "display_name": { "type": "string", "minLength": 1 },    "path":         { "type": "string", "pattern": "^(?:/[a-z_\-]+)+$" },    "color":        { "$ref": "defs.json#/definitions/color" },    "navigation":   { "$ref": "navigation.json#" }  }}</pre> <p>defs.json:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "$schema": "http://json-schema.org/draft-04/schema#",  "id": "http://mynet.com/schemas/defs.json#",  "title": "Definitions",    "definitions": {    "positiveInteger": { "type": "integer", "minimum": 1 },    "color": {      "anyOf": [        { "enum": [ "red", "green", "blue", "white" ] },        { "type": "string", "pattern": "^#(?:(?:[0-9a-fA-F]{1,2})){3}$" }      ]    }  }}</pre> <p>Посмотрите вышеприведенные схемы и навигационные данные, которые они описывают (что действительно в соответствии с схемой <code class="inline">navigation.json</code>). Главное заметить, что схема <code class="inline">navigation.json</code> ссылается на схему <code class="inline">page.json</code>, которая, в свою очередь, ссылается на первую.</p> <p>Код JavaScript для проверки пользовательской записи по схеме может быть:</p> <pre class="brush: javascript noskimlinks noskimwords">var Ajv = require("ajv");var ajv = Ajv({  allErrors: true,  schemas: [    require("./navigation.json"),    require("./page.json"),    require("./defs.json")  ]});var validate = ajv.getSchema("http://mynet.com/schemas/navigation.json#");var valid = validate(navigationData);if (!valid) console.log(validate.errors);</pre> <p>Все образцы кода доступны в <span>репозитории GitHub</span>.</p> <p><span>Ajv</span>, валидатор, используемый в примере, является самым быстрым механизмом проверки JSON-Schema для JavaScript. Я создал его, поэтому я собираюсь использовать его в этом уроке. Мы рассмотрим, как он в конечном итоге сравнивается с другими валидаторами, чтобы вы могли выбрать правильный для себя.</p> <h3>Задания</h3> <p>См. <span>часть 1 учебника</span> для получения инструкций о том, как установить репозиторий с задачами и проверить свои ответы.</p> <h3>Ссылки между схемами с ключевым словом «$ref»</h3> <p>Стандарт JSON-Schema позволяет повторно использовать повторяющиеся части схем, используя ссылки с ключевым словом <strong>«$ref»</strong>. Как видно из примера навигации, вы можете ссылаться на расположенную схему:</p> <ul><li>в другом файле: используйте URI схемы, определенный в свойстве «<strong>id</strong>»</li> <li>в любой части другого файла: добавьте указатель JSON к ссылке схемы</li> <li>в любой части текущей схемы: добавьте указатель JSON к «#»,</li> </ul><p>Вы также можете обратиться ко всей текущей схеме, используя <strong>«$ref»</strong>, равную «#», - это позволяет создавать рекурсивные схемы, ссылаясь на себя.</p> <p>Итак, в нашем примере схема в <code class="inline">navigation.json</code> относится к:</p> <ul><li>схема <code class="inline">page.json</code> </li> <li> <code class="inline">definitions</code> в схеме <code class="inline">defs.json</code> </li> <li>определение <code class="inline">positiveIntOrNull</code> в той же схеме</li> </ul><p>Схема в <code class="inline">page.json</code> означает:</p> <ul><li>назад к схеме <code class="inline">navigation.json</code> </li> <li>также к <code class="inline">definitions</code> в файле <code class="inline">defs.json</code> </li> </ul><p>Стандарт требует, чтобы <strong>«$ref»</strong> был единственным свойством в объекте, поэтому, если вы хотите применить ссылочную схему в дополнение к другой схеме, вы должны использовать ключевое слово <strong>«allOf»</strong>.</p> <h3>Задание 1</h3> <p>Рефакторинг пользовательской схемы из <span>части 1 учебника</span> с использованием ссылок. Разделите схему на два файла: <code class="inline">user.json</code> и <code class="inline">connection.json</code>.</p> <p>Поместите свои схемы в файлы <code class="inline">part2/task1/user.json</code> и <code class="inline">part2/task1/connection.json</code> и запустите <code class="inline">node part2/task1/validate</code>, чтобы проверить правильность ваших схем.</p> <h3>JSON-Pointer</h3> <p>JSON-pointer - это стандарт, определяющий пути к частям файлов JSON. Стандарт описан в <span>RFC6901</span>.</p> <p>Этот путь состоит из сегментов (может быть любой строки), связанных с символом «/». Если сегмент содержит символы «~» или «/», их следует заменить на «~ 0» и «~ 1». Каждый сегмент означает свойство или индекс в данных JSON.</p> <p>Если вы посмотрите на пример навигации, «$ref», который определяет свойство color, это “defs.json#/definitions/color” где «defs.json#» - это URI схемы, а “/definitions/color” - указатель JSON. Он указывает на цвет свойства внутри определений свойств.</p> <p>Соглашение состоит в том, чтобы поместить все части схемы, которые используются в refs внутри свойства <code class="inline">definitions</code> схемы (как вы можете видеть в примере). Хотя стандарт JSON-схемы резервирует ключевое слово <code class="inline">definitions</code> для этой цели, не требуется размещать подсхемы там. JSON-pointer позволяет вам ссылаться на любую часть файла JSON.</p> <p>Когда указатели JSON используются в URI, все символы, которые недопустимы в URI, должны быть экранированы (в JavaScript может использоваться глобальная функция <code class="inline">encodeURIComponent</code>).</p> <p>JSON-указатели могут использоваться не только в JSON-схемах. Они могут использоваться для представления пути в данных JSON для любого свойства или элемента. Вы можете использовать <span>json-указатель</span> библиотеки для доступа к объектам с помощью указателей JSON.</p> <h3>Задача 2</h3> <p>В приведенном ниже файле JSON описывается структура папок и файлов (имена папок начинаются с «/»):</p> <pre class="brush: javascript noskimlinks noskimwords">{  "/": {    "/documents": {      "my_story~.rtf": {        "type": "document",        "application": ["Word", "TextEdit"],        "size": 30476      },      ...    },    "/system": {      "/applications": {        "Word": {          "type": "executable",          "size": 1725058307        },        ...      }    }  }}</pre> <p>Каковы указатели JSON, которые указывают на:</p> <ul><li>размер приложения «Слово»,</li> <li>размер "my_story~.rtf" документ,</li> <li>имя второго приложения, которое может открыть «my_story~.rtf», документ?</li> </ul><p>Поместите свои ответы в <code class="inline">part2/task2/json_pointers.json</code> и запустите <code class="inline">node part2/task2/validate</code>, чтобы проверить их.</p> <h3>Идентификаторы схемы</h3> <p>Обычно схемы имеют свойство <strong>«id»</strong> верхнего уровня, которое имеет URI схемы. Когда <strong>«$ref»</strong> используется в схеме, его значение рассматривается как URI, который разрешен относительно схемы <strong>«id»</strong>.</p> <p>Разрешение работает так же, как браузер разрешает URI, которые не являются абсолютными, - они разрешены относительно URI схемы, который находится в свойстве <strong>«id»</strong>. Если <strong>«$ref»</strong> является именем файла, он заменяет имя файла в <strong>«id»</strong>. В примере навигации идентификатор схемы навигации <code class="inline">«http://mynet.com/schemas/navigation.json#»</code>, поэтому, когда ссылка <code class="inline">«page.json#»</code> разрешена, полный URI схемы страницы становится <code class="inline">«http://mynet.com/schemas/page.json#»</code> (то есть <strong>«id»</strong> схемы <code class="inline">page.json</code>).</p> <p>Если <strong>«$ref»</strong> схемы страницы - это путь, например. <code class="inline">"/page.json"</code>, то он был бы разрешен как <code class="inline">«http://mynet.com/page.json#»</code>. И <code class="inline">«/folder/page.json»</code> будет разрешен как <code class="inline">«http://mynet.com/folder/page.json#»</code>.</p> <p>Если <strong>«$ref»</strong> начинается с символа «#», он рассматривается как хэш-фрагмент и добавляется к пути в <strong>«id»</strong> (заменяя в нем хэш-фрагмент). В примере навигации ссылка <code class="inline">"defs.json#/definitions/color"</code> разрешена как <code class="inline">"http://mynet.com/schemas/defs.json#/definitions/color"</code> где <code class="inline">"http://mynet.com/schemas/defs.json#"</code> - это идентификатор схемы определений, а <code class="inline">"definitions/color"</code> рассматривается как указатель JSON внутри него.</p> <p>Если <strong>«$ref»</strong> был полным URI с другим доменным именем, так же, как ссылки работают в браузере, он был бы разрешен как один и тот же полный URI.</p> <h3>Внутренние идентификаторы схемы</h3> <p>Стандарт JSON-схемы позволяет вам использовать <strong>«id»</strong> внутри схемы, чтобы идентифицировать эти подсхемы, а также изменить базовый URI относительно того, какие внутренние ссылки будут разрешены, - это называется «изменение области разрешения». Это, вероятно, одна из самых запутанных частей стандарта, и поэтому она не очень часто используется.</p> <p>Я бы не рекомендовал чрезмерно использовать внутренние идентификаторы, с одним исключением ниже, по двум причинам:</p> <ul><li>Очень немногие валидаторы последовательно следуют стандарту и правильно разрешают ссылки при использовании внутренних идентификаторов (Ajv полностью соответствует стандарту здесь).</li> <li>Схемы становятся все труднее понять.</li> </ul><p>Мы по-прежнему рассмотрим, как это работает, потому что вы можете столкнуться с схемами, использующими внутренние идентификаторы, и есть случаи, когда их использование помогает структурировать ваши схемы.</p> <p>Во-первых, давайте посмотрим на наш пример навигации. Большая часть ссылок находится в объекте <code class="inline">definitions</code> и делает ссылки довольно длинными. Есть способ сократить их, добавив идентификаторы в определения. Это обновленная схема <code class="inline">defs.json</code>:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "$schema": "http://json-schema.org/draft-04/schema#",  "id": "http://mynet.com/schemas/defs.json#",  "title": "Definitions",    "definitions": {    "positiveInteger": { "id": "#positiveInteger", "type": "integer", "minimum": 1 },    "color": {      "id": "#color",      "anyOf": [        { "enum": [ "red", "green", "blue", "white" ] },        { "type": "string", "pattern": "^#(?:(?:[0-9a-fA-F]{1,2})){3}$" }      ]    }  }}</pre> <p>Теперь вместо ссылок <code class="inline">"defs.json#/definitions/positiveInteger"</code> и <code class="inline">"defs.json#/definitions/color"</code> которые используются в навигации и схемах страниц, вы можете использовать более короткие ссылки: <code class="inline">"defs.json#positiveInteger"</code> и <code class="inline">"defs.json#color"</code>. Это очень распространенное использование внутренних идентификаторов, поскольку это позволяет сделать ваши ссылки более короткими и читаемыми. Обратите внимание, что, хотя этот простой случай будет корректно обрабатываться большинством механизмов проверки JSON-схемы, некоторые из них могут его не поддерживать.</p> <p>Давайте рассмотрим более сложный пример с идентификаторами. Вот пример схемы JSON:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "id": "http://x.y.z/rootschema.json#",  "definitions": {    "bar": { "id": "#bar", "type": "string" }  },  "subschema": {    "id": "http://somewhere.else/completely.json#",    "definitions": {      "bar": { "id": "#bar", "type": "integer" }    },    "type": "object",    "properties": {      "foo": { "$ref": "#bar" }    }  },  "type": "object",  "properties": {    "bar": { "$ref": "#/subschema" },    "baz": { "$ref": "#/subschema/properties/foo" },    "bax": { "$ref": "http://somewhere.else/completely.json#bar" }  }}</pre> <p>В очень немногих строках это стало очень запутанным. Посмотрите на пример и попытайтесь выяснить, какое свойство должно быть строкой и какое целое.</p> <p>Схема определяет объект со свойствами <code class="inline">bar</code>, <code class="inline">baz</code> и <code class="inline">bax</code>. Свойство <code class="inline">bar</code> должно быть объектом, действительным в соответствии с подсхемой, которая требует, чтобы его свойство <code class="inline">foo</code> было действительным в соответствии с ссылкой «<code class="inline">bar</code>». Поскольку подсхема имеет свой собственный <strong>«id»</strong>, полный URI для ссылки будет <code class="inline">"http://somewhere.else/completely.json#bar"</code>, поэтому он должен быть целым числом.</p> <p>Теперь посмотрим на свойства <code class="inline">baz</code> и <code class="inline">bax</code>. Ссылки для них написаны по-другому, но они указывают на ту же ссылку <code class="inline">"http://somewhere.else/completely.json#bar"</code> и оба они должны быть целыми числами. Хотя свойство <code class="inline">baz</code> указывает непосредственно на схему <code class="inline">{"$ ref": "#bar"}</code>, оно все равно должно быть разрешено относительно идентификатора подсхемы, потому что оно находится внутри него. Таким образом, приведенный ниже объект действителен в соответствии с этой схемой:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "bar": { "foo": 1 },  "baz": 2,  "bax": 3}</pre> <p>Многие валидаторы схемы JSON не будут обрабатывать их правильно, и поэтому идентификаторы, которые изменяют область разрешения, следует использовать с осторожностью.</p> <h3>Задача 3</h3> <p>Решение этой головоломки поможет вам лучше понять, как работают ссылки и изменение области разрешения. Ваша схема:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "id": "http://x.y.z/rootschema.json#",  "title": "Task 3",  "description": "Schema with references - create a valid data",  "definitions": {    "my_data": { "id": "#my_data", "type": "integer" }  },  "schema1": {    "id": "#foo",    "allOf": [ { "$ref": "#my_data" } ]  },  "schema2": {    "id": "otherschema.json",    "definitions": {      "my_data": { "id": "#my_data", "type": "string" }    },    "nested": {      "id": "#bar",      "allOf": [ { "$ref": "#my_data" } ]    },    "alsonested": {      "id": "t/inner.json#baz",      "definitions": {        "my_data": { "id": "#my_data", "type": "boolean" }      },      "allOf": [ { "$ref": "#my_data" } ]    }  },  "schema3": {    "id": "http://somewhere.else/completely#",    "definitions": {      "my_data": { "id": "#my_data", "type": "null" }    },    "allOf": [ { "$ref": "#my_data" } ]  },  "type": "object",  "properties": {    "foo": { "$ref": "#foo" },    "bar": { "$ref": "otherschema.json#bar" },    "baz": { "$ref": "t/inner.json#baz" },    "bax": { "$ref": "http://somewhere.else/completely#" },    "quux": { "$ref": "#/schema3/allOf/0" }  },  "required": [ "foo", "bar", "baz", "bax", "quux" ]}</pre> <p>Создайте объект, действительный в соответствии с этой схемой.</p> <p>Поместите свой ответ в <code class="inline">part2/task3/valid_data.json</code> и запустите <code class="inline">node part2/task3/validate</code>, чтобы проверить его.</p> <h3>Загрузка ссылочных схем</h3> <p>До сих пор мы рассматривали разные схемы, ссылаясь друг на друга, не обращая внимания на то, как они загружаются в валидатор.</p> <p>Один из подходов состоит в том, чтобы все подключенные схемы были предварительно загружены, как в приведенном выше примере навигации. Но бывают ситуации, когда это либо непрактично, либо невозможно - например, если схема, которую вам нужно использовать, предоставляется другим приложением или если вы заранее не знаете все возможные схемы, которые могут потребоваться.</p> <p>В таких случаях валидатор может загружать ссылки на схемы в момент проверки данных. Но это сделает процесс проверки медленным. Ajv позволяет вам скомпилировать схему в функцию проверки асинхронной загрузки отсутствующих ссылочных схем в процессе. Сама проверка будет по-прежнему синхронной и быстрой.</p> <p>Например, если навигационные схемы доступны для загрузки из URI в их идентификаторах, код для проверки данных по навигационной схеме может быть следующим:</p> <pre class="brush: javascript noskimlinks noskimwords">var Ajv = require("ajv");var request = require("request");var ajv = Ajv({ allErrors: true, loadSchema: loadSchema });var _validateNav; // validation function will be cached here once loaded and compiledfunction validateNavigation(data, callback) {  if (_validateNav) setTimeout(_validate);  loadSchema("http://mynet.com/schemas/navigation.json", function(err, schema) {    if (err) return callback(err);    ajv.compileAsync(schema, function(err, v) {      if (err) callback(err);      else {        _validateNav = v;        _validate();      }    });  });  function _validate() {    var valid = _validateNav(data);    callback(null, { valid: valid, errors: _validateNav.errors });  }}function loadSchema(uri, callback) {  request.json(uri, function(err, res, body) {    if (err || res.statusCode &gt;= 400)      callback(err || new Error("Loading error: " + res.statusCode));    else      callback(null, body);  });}</pre> <p>Код определяет функцию <code class="inline">validateNavigation</code>, которая загружает схему и компилирует функцию проверки, когда она вызывается в первый раз, и всегда возвращает результат проверки посредством обратного вызова. Существуют различные способы его улучшения, начиная с предварительной загрузки и компиляции схемы отдельно, прежде чем она будет использоваться в первый раз, для учета того факта, что функция может быть вызвана несколько раз, прежде чем она проведет кэширование схемы (<code class="inline">ajv.compileAsync</code> уже обеспечивает что схема всегда запрашивается только один раз).</p> <p>Теперь мы рассмотрим новые ключевые слова, которые предлагаются для версии 5 стандарта JSON-схемы.</p> <h2>Предложения JSON-Schema Version 5</h2> <p>Хотя эти предложения не были доработаны в качестве стандартного проекта, они могут быть использованы сегодня - имитатор Ajv реализует их. Они существенно расширяют то, что вы можете проверить с помощью JSON-схемы, поэтому стоит их использовать.</p> <p>Чтобы использовать все эти ключевые слова с Ajv, вам нужно использовать опцию <code class="inline">v5: true</code>.</p> <h3>Ключевые слова « constant» и « contains»</h3> <p>Эти ключевые слова добавляются для удобства.</p> <p>Ключевое слово <strong>«constant»</strong> требует, чтобы данные были равны значению ключевого слова. Без этого ключевого слова это могло быть достигнуто с помощью ключевого слова <strong>«enum»</strong> с одним элементом в массиве элементов.</p> <p>Эта схема требует, чтобы данные были равны 1:</p> <pre class="brush: javascript noskimlinks noskimwords">{ "constant": 1 }</pre> <p>Ключевое слово <strong>«contains»</strong> требует, чтобы какой-либо элемент массива соответствовал схеме в этом ключевом слове. Это ключевое слово относится только к массивам; любой другой тип данных будет действителен в соответствии с ним. Сложнее выразить это требование, используя только ключевые слова из версии 4, но это возможно.</p> <p>Эта схема требует, чтобы, если данные представляют собой массив, то по крайней мере один из его элементов является целым числом:</p> <pre class="brush: javascript noskimlinks noskimwords">{ "contains": { "type": "integer" } }</pre> <p>Это эквивалентно следующему:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "not": {    "type": "array",    "items": {      "not": { "type": "integer" }    }  }}</pre> <p>Для того чтобы эта схема была действительной, либо данные не должны быть массивом, либо не должны иметь все его элементы нецелыми (то есть какой-то элемент должен быть целым).</p> <p>Обратите внимание, что и ключевое слово «<strong>contains</strong>», и эквивалентная схема выше не будут работать, если данные являются пустым массивом.</p> <h3>Ключевое слово "patternGroups"</h3> <p>Это ключевое слово предлагается для замены «<strong>patternProperties</strong>». Он позволяет ограничить количество свойств, соответствующих шаблону, который должен существовать в объекте. Ajv поддерживает как «<strong>patternGroups</strong>», так и «<strong>patternProperties</strong>» в режиме v5, потому что первый из них гораздо более подробный, и если вы не хотите ограничивать количество свойств, которые вы можете предпочесть, используя второй.</p> <p>Например, схема:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "patternGroups": {    "^[a-z]+$": {      "schema": { "type": "string" }    },    "^[0-9]+$": {      "schema": { "type": "number" }    }  }}</pre> <p>эквивалентна этой схеме:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "patternProperties": {    "^[a-z]+$": { "type": "string" },    "^[0-9]+$": { "type": "number" }  }}</pre> <p>Они обе требуют, чтобы объект имел только свойства с ключами, состоящими только из строчных букв со значениями типа string и с ключами, состоящими только из чисел со значениями типа число. Они не требуют какого-либо количества таких свойств и не ограничивают максимальное число. Это то, что вы можете сделать с «<strong>patternGroups</strong>»:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "patternGroups": {    "^[a-z]+$": {      "minimum": 1,      "maximum": 3,      "schema": { "type": "string" }    },    "^[0-9]+$": {      "minimum": 1,      "schema": { "type": "number" }    }  }}</pre> <p>В приведенной выше схеме есть дополнительные требования: должно быть по крайней мере одно свойство, соответствующее каждому шаблону, и не более трех свойств, ключи которых содержат только буквы.</p> <p>Вы не можете достичь этого с помощью «<strong>patternProperties</strong>».</p> <h3>Ключевые слова для ограничения форматированных значений «<strong>formatMaximum</strong>» / «<strong>formatMaximum</strong>» </h3> <p>Эти ключевые слова вместе с «<strong>exclusiveFormatMaximum</strong>» / «<strong>exclusiveFormatMinimum</strong>» позволяют вам устанавливать лимиты на время, дату и потенциально другие строковые значения, которые имеют формат, необходимый для ключевого слова «<strong>format</strong>».</p> <p>Эта схема требует, чтобы данные были датой, и она больше или равна 1 января 2016 года:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "format": "date",  "formatMinimum": "2016-01-01"}</pre> <p>Ajv поддерживает сравнение форматированных данных для форматов «дата», «время» и «дата-время», и вы можете определить пользовательские форматы, которые будут поддерживать ограничения с помощью ключевых слов «<strong>formatMaximum</strong>» / «<strong>formatMaximum</strong>».</p> <h3>Ключевое слово "switch"</h3> <p>Хотя все предыдущие ключевые слова либо позволяли вам лучше выражать то, что было возможно без них, либо немного расширять возможности, они не изменяли декларативный и статический характер схемы. Это ключевое слово позволяет вам выполнять динамическую проверку и зависящую от данных. Он содержит несколько случаев if-then.</p> <p>Проще объяснить на примере:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "switch": [    { "if": { "minimum": 50 }, "then": { "multipleOf": 5 } },    { "if": { "minimum": 10 }, "then": { "multipleOf": 2 } },    { "if": { "maximum": 4 }, "then": false }  ]}</pre> <p>Схема выше последовательно проверяет данные против подсхем в ключевых словах «<strong>if</strong>», пока одна из них не проверит проверку. Когда это произойдет, он проверяет схему в ключе «<strong>then</strong>» в том же объекте, который будет результатом проверки всей схемы. Если значение «<strong>then</strong>» равно <code class="inline">false</code>, проверка немедленно прекращается.</p> <p>Таким образом, приведенная выше схема требует, чтобы это значение:</p> <ul><li>либо больше или равно 50, и кратно 5</li> <li>или между 10 и 49 и кратным 2</li> <li>или между 5 и 9</li> </ul><p>Этот конкретный набор требований может быть выражен без ключевого слова switch, но есть более сложные случаи, когда это невозможно.</p> <h3>Задача 4</h3> <p>Создайте схему, эквивалентную последнему примеру выше, без использования ключевого слова switch.</p> <p>Поместите свой ответ в <code class="inline">part2/task4/no_switch_schema.json</code> и запустите <code class="inline">node part2/task4/validate</code>, чтобы проверить его.</p> <p>Ключевое слово «<strong>switch</strong>» также может содержать ключевое слово «<strong>continue</strong>» с логическим значением. Если это значение <code class="inline">true</code>, проверка будет продолжена после успешного согласования схемы «<strong>if</strong>» с успешной проверкой схемы «<strong>then</strong>». Это похоже на переход к следующему случаю в инструкции для оператора JavaScript, хотя в JavaScript провал является поведением по умолчанию, а ключевому слову «<strong>switch</strong>» требуется явная инструкция «<strong>продолжить</strong>». Это еще один простой пример с инструкцией «<strong>continue</strong>»:</p> <pre class="brush: javascript noskimlinks noskimwords">"schema": {  "switch": [    { "if": { "minimum": 10 }, "then": { "multipleOf": 2 }, "continue": true },    { "if": { "minimum": 20 }, "then": { "multipleOf": 5 } }  ]}</pre> <p>Если выполняется первое условие «<strong>if</strong>» и выполняется требование «<strong>then</strong>», проверка будет продолжать проверять второе условие.</p> <h3>Ссылка "$data"</h3> <p>Ключевое слово <strong>«$data»</strong> еще больше расширяет возможности JSON-схемы и делает проверку более динамичной и зависящей от данных. Оно позволяет поместить значения из некоторых свойств данных, элементов или ключей в определенные ключевые слова схемы.</p> <p>Например, эта схема определяет объект с двумя свойствами, где, если оба определены, «больше» должно быть больше или равно «меньше» - значение «меньше» используется как минимум для «большего»:</p> <pre class="brush: javascript noskimlinks noskimwords">"schema": {  "properties": {    "smaller": {},    "larger": {      "minimum": { "$data": "1/smaller" }    }  }}</pre> <p>Ajv реализует ссылку «$data» для большинства ключевых слов, значения которых не являются схемами. Он не выполняет проверку, если ссылка <strong>«$data»</strong> указывает на неправильный тип и преуспевает, если она указывает на неопределенное значение (или если путь не существует в объекте).</p> <p>Итак, что такое строковое значение в ссылке <strong>«$data»</strong>? Он похож на JSON-указатель, но это не совсем так. Это относительный JSON-указатель, который определяется этим <span>стандартом</span>.</p> <p>Он состоит из целого числа, которое определяет, сколько раз поиск должен пересекать объект (1 в приведенном выше примере означает прямой родительский элемент), за которым следует указатель «#» или JSON.</p> <p>Если за номером следует «#», то значение JSON-указателя будет разрешено как имя свойства или индекс элемента, который имеет объект. Таким образом, «0#» вместо «1/smaller» будет разрешать строку « larger», а «1#» будет недопустимой, так как все данные не являются членами какого-либо объекта или массива. Эта схема:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "type": "object",  "patternProperties": {    "^date$|^time$": { "format": { "$data": "0#" } }  }}</pre> <p>эквивалентно этому:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "type": "object",  "properties": {    "date": { "format": "date" },    "time": { "format": "time" }  }}</pre> <p>потому что {"$ data": "0 #"} заменяется именем свойства.</p> <p>Если за номером в указателе следует указатель JSON, то этот JSON-указатель разрешен, начиная с родительского объекта, к которому относится этот номер. Вы можете увидеть, как это работает в первом примере « smaller» / « larger».</p> <p>Давайте снова посмотрим на наш пример навигации. Одним из требований, которые вы можете видеть в данных, является то, что свойство <code class="inline">page_id</code> в объекте страницы всегда равно свойству <code class="inline">parent_id</code> в содержащемся навигационном объекте. Мы можем выразить это требование в схеме <code class="inline">page.json</code>, используя ссылку <strong>«$data»</strong>:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "$schema": "http://json-schema.org/draft-04/schema#",  "id": "http://mynet.com/schemas/page.json#",  ...  "switch": [{    "if": { "required": [ "navigation" ] },    "then": {      "properties": {        "page_id": { "constant": { "$data": "1/navigation/parent_id" } }      }    }  }]}</pre> <p>Ключевое слово <strong>«switch»</strong>, добавленное в схему страницы, требует, чтобы, если объект страницы имеет свойство <code class="inline">navigation</code>, значение свойства <code class="inline">page_id</code> должно быть таким же, как значение свойства <code class="inline">parent_id</code> в объекте навигации. То же самое можно достичь без ключевого слова <strong>«switch»</strong>, но оно менее выразительно и содержит дублирование:</p> <pre class="brush: javascript noskimlinks noskimwords">{  ...  "anyOf": [    { "not": { "required": [ "navigation" ] } },    {      "required": [ "navigation" ],      "properties": {        "page_id": { "constant": { "$data": "1/navigation/parent_id" } }      }    }  ]}</pre> <h3>Задача 5</h3> <p><span>Примеры</span> относительных JSON-указателей могут быть полезны.</p> <p>Используя ключевые слова v5, определите схему для объекта с двумя требуемыми свойствами <code class="inline">list</code> и <code class="inline">order</code>. Список должен быть массивом, который имеет до пяти номеров. Все элементы должны быть номерами, и их следует заказывать в порядке возрастания или убывания, как определено свойством <code class="inline">order</code>, которое может быть «<code class="inline">asc</code>» или «<code class="inline">desc</code>».</p> <p>Например, это действительный объект:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "list": [ 1, 3, 3, 6, 9 ],  "order": "asc"}</pre> <p>и это недействительно:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "list": [ 9, 7, 3, 6, 2 ],  "order": "desc"}</pre> <p>Поместите свой ответ в <code class="inline">part2/task5/schema.json</code> и запустите <code class="inline">node part2/task5/validate</code>, чтобы проверить его.</p> <p>Как бы вы создали схему с теми же условиями, но для списка неограниченного размера?</p> <h2>Определение новых ключевых слов проверки</h2> <p>Мы рассмотрели новые ключевые слова, которые предлагаются для версии 5 стандарта JSON-схемы. Вы можете использовать их сегодня, но иногда вам может понадобиться больше. Если вы выполнили задачу 5, вы, вероятно, заметили, что некоторые требования трудно выразить с помощью JSON-схемы.</p> <p>Некоторые валидаторы, включая Ajv, позволяют вам определять настраиваемые ключевые слова. Пользовательские ключевые слова:</p> <ul><li>позволяют создавать сценарии проверки, которые не могут быть выражены с помощью JSON-Schema</li> <li>упростить ваши схемы</li> <li>помочь вам привести большую часть логики проверки к вашим схемам</li> <li>сделать ваши схемы более выразительными, менее подробными и ближе к области вашего приложения</li> </ul><p>Один из разработчиков, который использует <span>Ajv</span>, написал в GitHub:</p> <blockquote> <p>«Ajv с пользовательскими ключевыми словами очень помог нам с проверкой бизнес-логики на нашем бэкэнде. Мы объединили целую кучу проверок уровня контроллера в JSON-Schema с пользовательскими ключевыми словами. Чистый эффект намного лучше, чем писать индивидуальный код проверки ».</p> </blockquote> <p>Озабоченность, которую вы должны учитывать при расширении стандарта JSON-схемы с помощью настраиваемых ключевых слов, - это переносимость и понимание ваших схем. Вам нужно будет поддерживать эти настраиваемые ключевые слова на других платформах и правильно документировать эти ключевые слова, чтобы каждый мог понять их в ваших схемах.</p> <p>Лучшим подходом здесь является определение новой мета-схемы, которая будет расширять мета-схему метаструктуры проекта 4 или метаданных предложений <span>«v5 предложений</span>», которая будет включать как проверку ваших дополнительных ключевых слов, так и их описание. Затем ваши схемы, которые используют эти настраиваемые ключевые слова, должны будут установить свойство <code class="inline">$schema</code> в URI новой мета-схемы.</p> <p>Теперь, когда мы вас предупредили, мы погрузимся и определим пару пользовательских ключевых слов, используя Ajv.</p> <p>Ajv предоставляет четыре способа определения пользовательских ключевых слов, которые вы можете видеть в <span>документации</span>. Мы рассмотрим два из них:</p> <ul><li>используя функцию, которая компилирует вашу схему в функцию проверки</li> <li>используя макрофункцию, которая принимает вашу схему и возвращает другую схему (с или без настраиваемых ключевых слов)</li> </ul><p>Начнем с простого примера ключевого слова range. Диапазон - это просто сочетание минимальных и максимальных ключевых слов, но если вам нужно определить многие диапазоны в вашей схеме, особенно если они имеют исключительные границы, это может легко стать скучным.</p> <p>Вот как должна выглядеть схема:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "range": [5, 10],  "exclusiveRange": true}</pre> <p>где, конечно, range будет опциональным. Код для определения этого ключевого слова приведен ниже:</p> <pre class="brush: javascript noskimlinks noskimwords">ajv.addKeyword("range", { type: "number", compile: compileRange });ajv.addKeyword("exclusiveRange"); // this is needed to reserve the keywordfunction compileRange(schema, parentSchema) {  var min = schema[0];  var max = schema[1];  return parentSchema.exclusiveRange === true          ? function (data) { return data &gt; min &amp;&amp; data &lt; max; }          : function (data) { return data &gt;= min &amp;&amp; data &lt;= max; }}</pre> <p>Вот и все! После этого кода вы можете использовать ключевое слово <code class="inline">range</code> в своих схемах:</p> <pre class="brush: javascript noskimlinks noskimwords">var schema = {  "range": [5, 10],  "exclusiveRange": true};var validate = ajv.compile(schema);console.log(validate(5)); // falseconsole.log(validate(5.1)); // trueconsole.log(validate(9.9)); // trueconsole.log(validate(10)); // false</pre> <p>Объект, переданный <code class="inline">addKeyword</code>, является определением ключевого слова. Он необязательно содержит тип (или тип как массив), к которому относится ключевое слово. Функция компиляции вызывается с помощью параметров <code class="inline">schema</code> и <code class="inline">parentSchema</code> и должна возвращать другую функцию, которая проверяет данные. Это делает его почти таким же эффективным, как и собственные ключевые слова, потому что схема анализируется во время ее компиляции, но во время проверки есть стоимость дополнительного вызова функции.</p> <p>Ajv позволяет избежать этих накладных расходов с ключевыми словами, которые возвращают код (как строку), который будет включен в функцию проверки, но он довольно сложный, поэтому мы не будем рассматривать его здесь. Более простой способ - использовать макрокоманды - вам нужно будет определить функцию, которая принимает схему и возвращает другую схему.</p> <p>Ниже приведена реализация ключевого слова range с функцией макроса:</p> <pre class="brush: javascript noskimlinks noskimwords">ajv.addKeyword("range", { type: "number", macro: macroRange });function macroRange(schema, parentSchema) {  var resultSchema = {    "minimum": schema[0],    "maximum": schema[1]  };  if (parentSchema.exclusiveRange === true) {    resultSchema.exclusiveMimimum = resultSchema.exclusiveMaximum = true;  }  return resultSchema;}</pre> <p>Вы можете видеть, что функция просто возвращает новую схему, эквивалентную ключевому слову <code class="inline">range</code>, который использует ключевые слова <code class="inline">maximum</code> и <code class="inline">minimum</code>.</p> <p>Давайте также посмотрим, как мы можем создать мета-схему, которая будет включать ключевое слово <code class="inline">range</code>. Мы будем использовать мета-схему проекта 4 в качестве отправной точки:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "id": "http://mynet.com/schemas/meta-schema-with.range.json#",  "$schema": "http://json-schema.org/draft-04/schema#",  "allOf": [    { "$ref": "http://json-schema.org/draft-04/schema#" },    {      "properties": {        "range": {          "description": "1st item is minimum, 2nd is maximum",          "type": "array",          "items": [ { "type": "number" }, { "type": "number" } ],          "additionalItems": false         },        "exclusiveRange": {          "type": "boolean",          "default": false        }      },      "dependencies": {        "exclusiveRange": [ "range" ]      }     }  ]}</pre> <p>Если вы хотите использовать ссылки <strong>«$data»</strong> с ключевым словом <code class="inline">range</code>, вам придется расширить мета-схему <span>предложений «v5»</span>, которая включена в <span>Ajv</span> (см. Ссылку выше), чтобы эти ссылки могли быть значениями <code class="inline">range</code> и <code class="inline">exclusiveRange</code> , И хотя наша первая реализация не будет поддерживать ссылки <strong>«$data»</strong>, вторая с макрофункцией будет поддерживать их.</p> <p>Теперь, когда у вас есть мета-схема, вам нужно добавить ее в Ajv и использовать ее в схемах с использованием ключевого слова <code class="inline">range</code>:</p> <pre class="brush: javascript noskimlinks noskimwords">ajv.addMetaSchema(require("./meta-schema-with-range.json"));var schema = {  "$schema": "http://mynet.com/schemas/meta-schema-with-range.json#",  "range": [5, 10],  "exclusiveRange": true};var validate = ajv.compile(schema);</pre> <p>В приведенном выше коде было бы исключение, если недопустимые значения были переданы в <code class="inline">range</code> или <code class="inline">exclusiveRange</code>.</p> <h3>Задача 6</h3> <p>Предположим, что вы определили ключевое слово <code class="inline">jsonPointers</code>, которое применяет схемы к глубоким свойствам, определенным указателями JSON, которые указывают на данные, начиная с текущего. Это ключевое слово полезно с ключевым словом <code class="inline">switch</code>, поскольку оно позволяет вам определять требования к глубоким свойствам и элементам. Например, эта схема с использованием ключевого слова <code class="inline">jsonPointers</code>:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "jsonPointers": {    "0/books/2/title": { "pattern": "json|Json|JSON" },  }}</pre> <p>эквивалентно:</p> <pre class="brush: javascript noskimlinks noskimwords">  {    "properties": {      "books": {        "items": [          {},          {},          {            "properties": {              "title": { "pattern": "json|Json|JSON" }            }          }        ]      }    }  }</pre> <p>Предположим, что вы также определили ключевое слово <code class="inline">requiredJsonPointers</code>, которое работает аналогично <code class="inline">required</code>, но с JSON-указателями вместо свойств.</p> <p>Если вам нравится, вы можете сами определить эти ключевые слова, или вы можете увидеть, как они определены в файле <code class="inline">part2/task6/json_pointers.js</code>.</p> <p>Ваша задача: использовать ключевые слова <code class="inline">jsonPointers</code> и <code class="inline">requiredJsonPointers</code>, определить ключевое слово <code class="inline">select</code>, аналогичный оператору <code class="inline">switch</code> JavaScript, и синтаксис ниже (<code class="inline">otherwise</code> и <code class="inline">fallthrough</code> необязательны):</p> <pre class="brush: javascript noskimlinks noskimwords">{  "select": {    "selector": "&lt;relative JSON-pointer that starts from "0/"&gt;",    "cases": [      { "case": &lt;value1&gt;, "schema": { &lt;schema1&gt; }, "fallthrough": true },      { "case": &lt;value2&gt;, "schema": { &lt;schema2&gt; } },      ...    ],    "otherwise": { &lt;defaultSchema&gt; }  }}</pre> <p>Этот синтаксис позволяет использовать значения любого типа. Обратите внимание, что <code class="inline">fallthrough</code> отличается от <code class="inline">continue</code> в ключевом слове <code class="inline">switch</code>. <code class="inline">fallthrough</code> применяет схему из следующего случая к данным, не проверяя, что селектор равен значению из следующего случая (поскольку он, скорее всего, не равен).</p> <p>Поместите свои ответы в <code class="inline">part2/task6/select_keyword.js</code> и <code class="inline">part2/task6/v5-meta-with-select.json</code> и запустите <code class="inline">node part2/task6/validate</code>, чтобы проверить их.</p> <p>Бонус 1: улучшите свою реализацию, чтобы также поддерживать этот синтаксис:</p> <pre class="brush: javascript noskimlinks noskimwords">{  "select": {    "selector": "&lt;relative JSON-pointer that starts from "0/"&gt;",    "cases": {      "&lt;value1&gt;": { &lt;schema1&gt; },      "&lt;value2&gt;": { &lt;schema2&gt; },      ...    },    "otherwise": { &lt;defaultSchema&gt; }  }}</pre> <p>Он может использоваться, если все значения являются разными строками, и нет <code class="inline">fallthrough</code>.</p> <p>Бонус 2: добавьте мета-схему предложений «v5 предложений», чтобы включить это ключевое слово.</p> <h2>Другие применения JSON-схем</h2> <p>Помимо проверки данных, JSON-схемы могут использоваться для:</p> <ul><li>generate UI</li> <li>генерировать данные</li> <li>изменять данные</li> </ul><p>Вы можете посмотреть <span>библиотеки</span>, которые генерируют пользовательский интерфейс и данные, если вы заинтересованы. Мы не будем изучать его, так как он выходит за рамки данного руководства.</p> <p>Мы рассмотрим использование JSON-схемы для изменения данных во время проверки.</p> <h3>Фильтрация данных</h3> <p>Одной из распространенных задач при проверке данных является удаление дополнительных свойств из данных. Это позволяет вам дезинфицировать данные перед их передачей в логику обработки без проверки валидации схемы:</p> <pre class="brush: javascript noskimlinks noskimwords">var ajv = Ajv({ removeAdditional: true });var schema = {  "type": "object",  "properties": {    "foo": { "type": "string" }  },  "additionalProperties": false};var validate = ajv.compile(schema);var data: { foo: 1, bar: 2 };console.log(validate(data)); // trueconsole.log(data); // { foo: 1 };</pre> <p>Без опции <code class="inline">removeAdditional</code> проверка не удалась бы, так как есть дополнительное свойство <code class="inline">bar</code>, которое не допускается схемой. С помощью этой опции выполняется проверка и свойство удаляется из объекта.</p> <p>Когда значение параметра <code class="inline">removeAdditional</code> равно <code class="inline">true</code>, дополнительные свойства удаляются, только если ключевое слово <code class="inline">extraProperties</code> является ложным. Ajv также позволяет удалить все дополнительные свойства, независимо от ключевого слова <code class="inline">AdditionalProperties</code>, или дополнительных свойств, которые не позволяют выполнить проверку (если ключевое слово <code class="inline">AdditionalProperties</code> является схемой). Дополнительную информацию см. в <span>документации Ajv</span>.</p> <h3>Присвоение значений по умолчанию свойствам и элементам</h3> <p>Стандарт JSON-схемы определяет ключевое слово <strong>«default»</strong>, которое содержит значение, которое должны иметь данные, если оно не определено в проверенных данных. Ajv позволяет назначать такие значения по умолчанию в процессе проверки:</p> <pre class="brush: javascript noskimlinks noskimwords">var ajv = Ajv({ useDefaults: true });var schema = {  "type": "object",  "properties": {    "foo": { "type": "number" },    "bar": { "type": "string", "default": "baz" }  },  "required": [ "foo", "bar" ]};var data = { "foo": 1 };var validate = ajv.compile(schema);console.log(validate(data)); // trueconsole.log(data); // { "foo": 1, "bar": "baz" }</pre> <p>Без опции <code class="inline">useDefaults</code> проверка не прошла бы, поскольку в проверяемом объекте не было требуемого свойства <code class="inline">bar</code>. С помощью этой опции выполняется проверка и добавляется свойство со значением по умолчанию.</p> <h3>Типы данных</h3> <p><strong>«type»</strong> является одним из наиболее часто используемых ключевых слов в JSON-схемах. Когда вы проверяете входные данные пользователя, все ваши свойства данных, которые вы получаете из форм, обычно являются строками. Ajv позволяет вам принуждать данные к типам, указанным в схеме, как для прохождения проверки, так и для использования правильно введенных данных:</p> <pre class="brush: javascript noskimlinks noskimwords">var ajv = Ajv({ coerceTypes: true });var schema = {  "type": "object",  "properties": {    "foo": { "type": "number" },    "bar": { "type": "boolean" }  },  "required": [ "foo", "bar" ]};var data = { "foo": "1", "bar": "false" };var validate = ajv.compile(schema);console.log(validate(data)); // trueconsole.log(data); // { "foo": 1, "bar": false }</pre> <h2>Сравнение JavaScript JSON-Schema Validators</h2> <p>Доступно более десяти активно поддерживаемых JavaScript-валидаторов. Какой из них вы должны использовать?</p> <p>Вы можете увидеть контрольные показатели производительности и того, как различные валидаторы передают набор тестов из стандарта JSON-схемы в проект <span>json-schema-benchmark</span>.</p> <p>Существуют также отличительные особенности, которые некоторые валидаторы имеют, что может сделать их наиболее подходящими для вашего проекта. Я сравню некоторые из них ниже.</p> <h3> <span>is-my-json-valid</span> и <span>jsen</span> </h3> <p>Эти два валидатора очень быстрые и имеют очень простые интерфейсы. Они компилируют схемы для функций JavaScript, как это делает Ajv.</p> <p>Их недостатком является то, что они оба имеют ограниченную поддержку удаленных ссылок.</p> <h3><span>schemasaurus</span></h3> <p>Это единственная в своем роде библиотека, где проверка JSON-схемы почти является побочным эффектом.</p> <p>Он построен как универсальный и легко расширяемый процессор / итератор JSON-схемы, который можно использовать для создания всех видов инструментов, которые используют JSON-схему: генераторы UI, шаблоны и т.д.</p> <p>В него уже включен относительно быстрый механизм проверки JSON-схемы.</p> <p>Однако он не поддерживает удаленные ссылки.</p> <h3><span>themis</span></h3> <p>Самый медленный в группе быстрых валидаторов, он имеет полный набор функций с ограниченной поддержкой удаленных ссылок.</p> <p>Там, где он действительно сияет, это реализация ключевого слова <code class="inline">default</code>. Хотя большинство валидаторов имеют ограниченную поддержку этого ключевого слова (Ajv не является исключением), Themis имеет очень сложную логику применения умолчаний с откатами внутри составных ключевых слов, таких как <code class="inline">anyOf</code>.</p> <h3><span>z-schema</span></h3> <p>С точки зрения производительности этот очень зрелый валидатор находится на границе между быстрыми и медленными валидаторами. Вероятно, это был один из самых быстрых, прежде чем появилась новая порода скомпилированных валидаторов (все вышеперечисленное и Ajv).</p> <p>Он проходит почти все тесты из набора тестов JSON-схемы для валидаторов, и он имеет довольно тщательную реализацию удаленных ссылок.</p> <p>Он имеет большой набор опций, позволяющий настроить поведение по умолчанию многих ключевых слов JSON (например, не принимать пустые массивы в виде массивов или пустых наборов строк) и накладывать дополнительные требования к схемам JSON (например, для этого требуется ключевое слово <code class="inline">minLength</code> для строк).</p> <p>Я думаю, что в большинстве случаев изменение поведения схемы и включение других сервисов в схему JSON - это неправильные вещи. Но бывают случаи, когда способность делать это упрощает многое.</p> <h3><span>TV4</span></h3> <p>Это один из старейших (и самых медленных) валидаторов, поддерживающих версию 4 стандарта. Таким образом, это часто выбор по умолчанию для многих проектов.</p> <p>Если вы используете его, очень важно понять то, как он сообщает об ошибках и недостающих ссылках и правильно их настраивает, иначе вы получите много ложных срабатываний (т. е. проверка прошла с недопустимыми данными или нерешенными удалёнными ссылками).</p> <p>Форматы не включены по умолчанию, но они доступны как отдельная библиотека.</p> <h3><span>Ajv</span></h3> <p>Я написал Ajv, потому что все существующие валидаторы были либо быстрыми, либо совместимыми со стандартом (особенно в отношении поддержки удаленных ссылок), но не одновременно. Ajv заполнил этот пробел.</p> <p>На данный момент это единственный валидатор, который:</p> <ul><li>проходит все тесты и полностью поддерживает удаленные ссылки</li> <li>поддерживает ключевые слова проверки, предложенные для <span>версии 5 стандартных</span> и ссылки <code class="inline">$data</code>.</li> <li>поддерживает асинхронную проверку пользовательских форматов и ключевых слов</li> </ul><p>Он имеет <span>опции</span> для изменения процесса проверки и изменения проверенных данных (фильтрация, назначение значений по умолчанию и типов принуждения - см. примеры выше).</p> <h3>Какой валидатор использовать?</h3> <p>Я думаю, что лучший подход - попробовать несколько и выбрать тот, который лучше всего подходит для вас.</p> <p>Я написал <span>json-schema-consolidate</span>, который предоставляет коллекцию адаптеров, которые унифицируют интерфейсы 12 валидаторов JSON-схемы. Используя этот инструмент, вы можете тратить меньше времени на переключение между валидаторами. Я рекомендую удалить его, как только вы решите, какой валидатор использовать, поскольку его сохранение отрицательно скажется на производительности.</p> <p>Все! Надеюсь, этот учебник был полезен. Вы узнали о:</p> <ul><li>структурировани ваших схем</li> <li>использовании ссылок и идентификаторов</li> <li>использовании ключевых слов для проверки и ссылок $data из предложений версии 5</li> <li>загрузке асинхронных удаленных схем</li> <li>определении пользовательских ключевых слов</li> <li>изменении данных в процессе проверки</li> <li>преимуществах и недостатках различных валидаторов JSON-схемы</li> </ul><p>Спасибо за прочтение!</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825289-proverka-dannyh-s-pomoschyu-json-shemy-chast-2" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="JSON" href="https://norma-studio.github.io/article5/220825289-proverka-dannyh-s-pomoschyu-json-shemy-chast-2" class="tm-article-body__tags-item-link">JSON</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
30950</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
519</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

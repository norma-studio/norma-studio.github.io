
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Работа с базой IndexedDB... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Работа с базой IndexedDB... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Работа с базой IndexedDB... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Работа с базой IndexedDB... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Одна из наиболее интересный разработок в области веб-стандартов за последнее время – спецификация Indexed Database (или IndexedDB, для краткости). Если хотите весело провести время, то можете ознакомиться со спецификацией самостоятельно. В этом руководстве я буду рассказывать вам о том, как работает эта функциональная возможность, и, надеюсь, слегк...">
<meta property="og:description" content="Одна из наиболее интересный разработок в области веб-стандартов за последнее время – спецификация Indexed Database (или IndexedDB, для краткости). Если хотите весело провести время, то можете ознакомиться со спецификацией самостоятельно. В этом руководстве я буду рассказывать вам о том, как работает эта функциональная возможность, и, надеюсь, слегк...">
<meta name="twitter:description" content="Одна из наиболее интересный разработок в области веб-стандартов за последнее время – спецификация Indexed Database (или IndexedDB, для краткости). Если хотите весело провести время, то можете ознакомиться со спецификацией самостоятельно. В этом руководстве я буду рассказывать вам о том, как работает эта функциональная возможность, и, надеюсь, слегк...">
<meta property="aiturec:description" content="Одна из наиболее интересный разработок в области веб-стандартов за последнее время – спецификация Indexed Database (или IndexedDB, для краткости). Если хотите весело провести время, то можете ознакомиться со спецификацией самостоятельно. В этом руководстве я буду рассказывать вам о том, как работает эта функциональная возможность, и, надеюсь, слегк...">
<meta property="og:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2013/09/s1.png">
<meta property="aiturec:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2013/09/s1.png">
<meta name="twitter:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2013/09/s1.png">
<meta property="vk:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2013/09/s1.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2013/09/s1.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825556-rabota-s-bazoj-indexeddb.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825556-rabota-s-bazoj-indexeddb.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825556-rabota-s-bazoj-indexeddb.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825556-rabota-s-bazoj-indexeddb.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825556-rabota-s-bazoj-indexeddb.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825556-rabota-s-bazoj-indexeddb.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825556-rabota-s-bazoj-indexeddb.html" title="Работа с базой IndexedDB... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Работа с базой IndexedDB... | envatomarket.ru | norma-studio.github.io" title="Работа с базой IndexedDB... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/64533jghfdd.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825556-rabota-s-bazoj-indexeddb.html" class="tm-user-info__username" title="
Д. Слесарев" aria-label="
Д. Слесарев">
Д. Слесарев</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Работа с базой IndexedDB...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825556-rabota-s-bazoj-indexeddb" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Web Development" href="https://norma-studio.github.io/article5/220825556-rabota-s-bazoj-indexeddb" class="tm-article-snippet__hubs-item-link"><span>Web Development</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825556-rabota-s-bazoj-indexeddb.html" />
    <link itemprop="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2013/09/s1.png">
    <meta itemprop="headline name" content="Работа с базой IndexedDB... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Одна из наиболее интересный разработок в области веб-стандартов за последнее время – спецификация Indexed Database (или IndexedDB, для краткости). Если хотите весело провести время, то можете ознакомиться со спецификацией самостоятельно. В этом руководстве я буду рассказывать вам о том, как работает эта функциональная возможность, и, надеюсь, слегк...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Одна из наиболее интересный разработок в области веб-стандартов за последнее время – спецификация Indexed Database (или IndexedDB, для краткости). Если хотите весело провести время, то можете ознакомиться со спецификацией самостоятельно. В этом руководстве я буду рассказывать вам о том, как работает эта функциональная возможность, и, надеюсь, слегк...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Одна из наиболее интересный разработок в области веб-стандартов за последнее время – спецификация Indexed Database (или IndexedDB, для краткости). Если хотите весело провести время, то можете ознакомиться со <span>спецификацией </span>самостоятельно. В этом руководстве я буду рассказывать вам о том, как работает эта функциональная возможность, и, надеюсь, слегка вдохновлять вас на то, чтобы вы сами использовали эту мощную функциональную возможность.</p> <p><!--more--></p> <hr><h2>Обзор</h2> <blockquote class="pullquote"> <p>Как спецификация IndexedDB в настоящее время находится на стадии Candidate Recommendation.</p> </blockquote> <p>В двух словах, IndexedDB предоставляет вам возможность хранения больших объемов данных в браузерах ваших пользователей. Любому приложению, которому необходимо отправлять большое количество данных по сети, была бы очень полезной возможность хранения данных на стороне клиента, а не сервера. Конечно же, вместилище для данных – только часть уравнения. IndexedDB также предоставляет мощный API для поиска данных, работающий на основе индексов, для получения необходимых вам данных. </p> <p>Вам, возможно, не совсем понятно, чем IndexedDB отличается от других инструментов для хранения данных? </p> <p>Куки очень хорошо поддерживаются браузерами, однако имеют правовые последствия и ограниченный объем памяти. Также они отправляются от сервера и обратно при выполнении каждого запроса, сводя на нуль преимущества вместилища, работающего на стороне клиента.</p> <p>Веб-хранилище (* Локальное хранилище, HTML5-хранилище, DOM-хранилище; встроенная возможность хранения данных на стороне клиента (объем данных значительно больше того, что предоставляется куки-файлами). Здесь и далее примеч. пер.) также хорошо поддерживается браузерами, однако оно ограничено с точки зрения доступного вам объема хранилища. Веб-хранилище не предоставляет вам настоящего «поискового» API, поскольку данные извлекаются только при помощи значений ключей. Веб-хранилище замечательно подходит для хранения "конкретных" вещей, например предпочтений пользователя, тогда как IndexedDB больше подходит для хранения произвольных данных (подобно базе данных). </p> <p>Перед тем как продолжить, давайте посмотрим, как обстоит ситуация с поддержкой IndexedDB браузерами. Как спецификация IndexedDB в настоящее время находится на стадии Candidate Recommendation (* Возможная рекомендация. Этот документ подтверждает, что предложения W3C (Консорциума World-Wide Web)) тщательно рассмотрены и удовлетворяют требованиям Рабочей Группы. IndexedDB была на этой стадии на момент написания оригинала руководства (2013). В данный момент (2018) находится на стадии Recommendation (R)). На данном этапе разработчики этой спецификации довольны ею, однако ожидают сейчас замечаний и предложений от сообщества разработчиков. Спецификация, вероятно, изменится на финальной стадии, W3C Recommendation, по сравнению с тем, какой она является сейчас. В целом, браузера, которые поддерживают IndexedDB, делают это довольно стабильно, однако разработчики должны быть готовы к использованию префиксов и появлению обновлений в будущем.</p> <p>Что касается тех браузеров, которые поддерживают IndexedDB, то у нас тут имеется своего рода дилемма (* положение, при котором выбор одной из двух противоположных возможностей одинаково затруднителен). Эту технологию довольно хорошо поддерживают десктопные браузера, однако в мобильных она почти отсутствует. Давайте взглянем на то, что на сообщает по этому поводу <em>великолепный </em>сайт CanIUse.com:</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2013/09/s1.png" alt="Работа с базой IndexedDB..." title="Работа с базой IndexedDB..." width="50" height="50"><br></figure><p>Chrome для Android действительно поддерживает IndexedDB, однако очень немногие люди сегодня используют этот браузер на устройствах Android. Означает ли отсутствие поддержки для мобильных устройств то, что вам не следует использовать эту технологию? Конечно же, нет! Надеюсь, что все наши читатели знакомы с концепцией прогрессивного улучшения (* предполагает, что веб-интерфейсы должны создаваться поэтапно, циклически, от простого к сложному. На каждом из этапов должен получаться законченный веб-интерфейс, который будет лучше, красивее и удобнее предыдущего; настаивает на важности содержания). Такие возможности как IndexedDB могут быть добавлены в ваше приложение таким образом, что не нарушат его работу в браузерах без поддержки этой технологии. Вы бы могли воспользоваться библиотеками-обертками для переключения на WebSQL при запуске приложения на мобильных устройствах или просто отказаться от локального  хранения данных на стороне клиентов мобильных устройств. Лично я считаю, что возможность кэширования больших блоков данных на стороне клиента достаточно важна, чтобы пользоваться ею сейчас, несмотря на отсутствие поддержки на стороне клиента. </p> <hr><h2>Давайте приступим</h2> <p>Мы рассмотрели спецификацию и поддержку, теперь давайте перейдем к использованию. Сначала нам нужно проверить, поддерживает ли браузер IndexedDB. Хотя и имеются инструменты, предоставляющие универсальные методы проверки поддержки возможностей браузеров, мы можем значительно упростить задачу, поскольку просто проверяем поддержку одной определенной возможности. </p> <pre class="brush: js noskimlinks noskimwords">document.addEventListener("DOMContentLoaded", function(){    if("indexedDB" in window) {        console.log("YES!!! I CAN DO IT!!! WOOT!!!");    } else {        console.log("I has a sad.");    }},false);</pre> <p>Во фрагменте кода выше (с которым вы можете ознакомиться в <code>test1.html</code>, если скачали прикрепленный к этому руководству архив) используется событие <code>DOMContentLoaded</code>, чтобы код выполнялся по окончанию загрузки страницы. (Ладно, это вполне очевидно, но я предполагаю, что разработчики, которые пользовались только jQuery, могут не знать этого.) Затем я просто проверяю наличие indexedDB в объекте <code>window</code>, и если это так, то можем продолжать. Это простейший пример, однако обычно нам, вероятно, нужно было бы сохранить результат проверки, чтобы знать позже, можем ли мы использовать indexedDB. Ниже приводится более продвинутый пример (<code>test2.html</code>).</p> <pre class="brush: js noskimlinks noskimwords">var idbSupported = false;document.addEventListener("DOMContentLoaded", function(){    if("indexedDB" in window) {        idbSupported = true;    }},false);</pre> <p>Я всего лишь создал глобальную переменную, <code>idbSupported</code>, которую можно использовать в качестве флажка для проверки поддержки текущим браузером IndexedDB. </p> <hr><h2>Подключение к базе данных</h2> <p>Как вы можете догадаться, в IndexedDB используются базы данных. Проясню, что такая база не является реализацией SQL Server. Она локальна для браузера и доступна только для пользователя. Базы данных IndexedDB работают согласно тем же правилам, что и куки с Веб-хранилищем. База данных привязывается конкретно к домену, с которого была загружена. Поэтому, например, база под названием "Foo", созданная для foo.com не будет конфликтовать с базой данных под тем же названием для goo.com. Она не только не будет конфликтовать, но и не будет доступна для других доменов. Вы можете хранить данные для вашего веб-сайта и быть уверены, что другой веб-сайт не сможет получить к ним доступ. </p> <p>Подключение к базе данных выполняется при помощи команды open. В простейшем случае вы указываете имя и версию. <em>Очень </em>важно, чтобы вы указали версию, по причинам, которые мы рассмотрим позже. Ниже приводиться простой пример:</p> <pre class="brush: js noskimlinks noskimwords">var openRequest = indexedDB.open("test",1);</pre> <p>Подключение к базе данных – асинхронная операция. Для обработки результата выполнения этой операции вам нужно будет добавить некоторые обработчики событий. Имеется четыре различных типа событий, которые могут быть сгенерированы:</p> <ul><li>success</li> <li>error</li> <li>upgradeneeded</li> <li>blocked</li> </ul><p>Вы, вероятно, можете догадаться о значении success и error. Событие upgradeneeded генерируется и тогда, когда пользователь подключается к базе данных впервые, и тогда, когда вы меняете версию. blocked не относится к событиям, которые будут обычно генерироваться, но может быть сгенерировано, если предыдущее соединение никогда не закрывалось.</p> <p>Обычно при первом обращении к вашему сайту будет сгенерировано событие upgradeneeded. После этого – только success. Давайте рассмотрим простой пример (<code>test3.html</code>):</p> <pre class="brush: js noskimlinks noskimwords">var idbSupported = false;var db;document.addEventListener("DOMContentLoaded", function(){    if("indexedDB" in window) {        idbSupported = true;    }    if(idbSupported) {        var openRequest = indexedDB.open("test",1);        openRequest.onupgradeneeded = function(e) {            console.log("Upgrading...");        }        openRequest.onsuccess = function(e) {            console.log("Success!");            db = e.target.result;        }        openRequest.onerror = function(e) {            console.log("Error");            console.dir(e);        }    }},false);</pre> <p>Опять-таки, мы проверяем, поддерживается ли собственно IndexedDB, и если да, то подключаемся к базе данных. Мы добавили в этом примере обработчики для трех событий: upgradeneeded, success и error. Сейчас давайте рассмотрим событие success. Оно передается в обработчик при помощи <code>target.result</code>. Мы скопировали его в глобальную переменную под названием <code>db</code>. Именно ею мы воспользуемся позже для, собственно, добавления данных. Если вы выполните этот код в вашем браузере (в одном из тех, что поддерживает IndexedDB, конечно же!), то при первом запуске скрипта должны будете увидеть в вашей консоли сообщения, выводимые при возникновении событий upgrade и success. При последующих запусках скрипта вы должны будете увидеть лишь сообщения, выводимые при возникновении события success.</p> <hr><h2>Хранилища объектов</h2> <p>Пока что мы проверили, поддерживает ли браузер IndexedDB, убедились, что это так, и подключились к базе данных. Теперь нам необходимо место, где будем хранить данные. В IndexedDB имеется концепция под названием «хранилище объектов". Вы можете считать его типичной таблицей базы данных. (Приблизительно, но пока не заморачивайтесь.) В хранилище объектов содержатся данные (не удивительно), а также ключевое поле и необязательный набор индексов (* файл в СУБД, хранящий список ключей, каждый из которых определяет уникальную запись в БД и содержит информацию о её физическом расположении. Служит для ускорения поиска и сортировки данных. Другими словами - таблица указателей для быстрого поиска записей в БД). Ключевые поля являются по сути уникальными идентификаторами для ваших данных и могут быть указаны в нескольких разных форматах. Мы рассмотрим индексы позднее, когда пойдет речь о извлечении данных. </p> <p>Теперь кое-что важное. Помните упомянутое выше событие upgradeneeded? Вы можете создать хранилища объектов только при возникновении события upgradeneeded. Знайте, что по умолчанию оно будет сгенерировано автоматически при первом обращении пользователя к сайту. Вы можете этим воспользоваться для создания ваших хранилищ объектов. Очень важно запомнить то, что если вам когда-либо нужно будет <em>изменить </em>ваши объекты хранилищ, вы должны будете обновить версию (в упомянутом ранее методе open) и внести необходимые изменения в код. Давайте посмотрим, как это реализуется на практике:</p> <pre class="brush: js noskimlinks noskimwords">var idbSupported = false;var db;document.addEventListener("DOMContentLoaded", function(){    if("indexedDB" in window) {        idbSupported = true;    }    if(idbSupported) {        var openRequest = indexedDB.open("test_v2",1);        openRequest.onupgradeneeded = function(e) {            console.log("running onupgradeneeded");            var thisDB = e.target.result;            if(!thisDB.objectStoreNames.contains("firstOS")) {                thisDB.createObjectStore("firstOS");            }        }        openRequest.onsuccess = function(e) {            console.log("Success!");            db = e.target.result;        }        openRequest.onerror = function(e) {            console.log("Error");            console.dir(e);        }    }},false);</pre> <p>Этот пример (<code>test4.html</code>) основан на предыдущих, поэтому мы просто сосредоточимся на том, что было добавлено. Я получил значение переменной базы данных, переданной в  событие upgradeneeded (<code>thisDB</code>). Одним из свойств этой переменной является список имеющихся хранилищ объектов под названием <code>objectStoreNames</code>. Для тех, кому интересно, это не простой массив, а "DOMStringList." Не спрашивайте меня, но это так. Мы можем воспользоваться методом <code>contains</code>, чтобы проверить, существует ли наше хранилище объектов, и если нет, то создать его. Это одна из немногих синхронных функций в IndexedDB, так что нам не нужно использовать слушатель события.</p> <p>Если обобщить, то вот что происходило бы при посещении пользователем вашего сайта. При первом посещении генерируется событие upgradeneeded. При помощи кода проверяется, существует ли хранилище объектов "firstOS". Его не будет. Поэтому оно создается. Затем запускается обработчик события success. При последующих посещениях сайта номер версии будет тем же, поэтому событие upgradeneeded <em>не </em>возникает. </p> <p>Теперь давайте представим, что вам нужно добавить второе хранилище объектов. Для этого вам необходимо увеличить номер версии и по сути продублировать приведенный выше блок кода, где использовались методы contains/createObjectStore. Классно то, что код, выполняемый при возникновении события upgradeneeded, будет корректно работать и для совершенно новых посетителей сайта, и для тех, у кого уже имеется первое хранилище объектов. Ниже приводится пример кода для этого случая (<code>test5.html</code>):</p> <pre class="brush: js noskimlinks noskimwords">var openRequest = indexedDB.open("test_v2",2);openRequest.onupgradeneeded = function(e) {    console.log("running onupgradeneeded");    var thisDB = e.target.result;    if(!thisDB.objectStoreNames.contains("firstOS")) {        thisDB.createObjectStore("firstOS");    }    if(!thisDB.objectStoreNames.contains("secondOS")) {        thisDB.createObjectStore("secondOS");    }}</pre> <hr><h2>Добавление данных</h2> <p>После подготовки хранилищ объектов можете приступить к добавлению данных. Это, вероятно, один из наиболее крутых аспектов IndexedDB. В отличие от традиционных баз данных, работающих на основе таблиц, IndexedDB позволяет вам сохранять объект, как есть. Это означает, что вы можете взять обычный объект JavaScript и просто его сохранить. Готово. Конечно же, не все так просто, но по большей части это так. </p> <p>Для работы с данными вам нужно использовать транзакцию. Транзакции принимают два аргумента. Первый – массив таблиц, с которыми вы будете работать. В большинстве случаев это будет одна таблица. Второй аргумент – тип транзакции. Имеется два типа транзакций: readonly и readwrite. Добавление данных будет относиться к операции типа readwrite. Давайте начнем с создания транзакции:</p> <pre class="brush: js noskimlinks noskimwords">//Assume db is a database variable opened earliervar transaction = db.transaction(["people"],"readwrite");</pre> <p>Обратите внимание на хранилище объектов "people", которое создали в примере выше. Мы будем его использовать в нашей следующей демоверсии. После получения транзакции вы запрашиваете указанное вами хранилище объектов:</p> <pre class="brush: js noskimlinks noskimwords">var store = transaction.objectStore("people");</pre> <p>Теперь, когда вы получили хранилище, можете добавить данные. Это выполняется при помощи – дождитесь-ка его – метода <code>add</code>. </p> <pre class="brush: js noskimlinks noskimwords">//Define a personvar person = {    name:name,    email:email,    created:new Date()}//Perform the addvar request = store.add(person,1);</pre> <p>Помните, как я ранее упомянул, что вы можете хранить какие-угодно данные (в целом). Так что мой объект person выше создан полностью произвольно. Я бы мог использовать firstName и lastName вместо просто name. Я бы мог использовать свойство gender. Вы уловили суть. Второй аргумент – ключ для однозначной идентификации данных. В нашем примере мы установили в качестве его значения 1, из-за чего у нас скоро возникнет проблема. Это нормально, скоро мы узнаем, как это поправить.</p> <p>Операция add является асинхронной, так что давайте добавим два обработчика событий для результата.</p> <pre class="brush: js noskimlinks noskimwords">request.onerror = function(e) {    console.log("Error",e.target.error.name);    //some type of error handler}request.onsuccess = function(e) {    console.log("Woot! Did it");}</pre> <p>У нас имеется обработчик <code>onerror</code> на случай возникновения ошибок, и <code>onsuccess</code> для обработки результата успешно выполненной операции. Вполне очевидно, но давайте взглянем на весь пример. Вы можете ознакомиться с ним в папке <code>test6.html</code>.</p>  &gt; <pre class="brush: html noskimlinks noskimwords">&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;var db;function indexedDBOk() {    return "indexedDB" in window;}document.addEventListener("DOMContentLoaded", function() {    //No support? Go in the corner and pout.    if(!indexedDBOk) return;    var openRequest = indexedDB.open("idarticle_people",1);    openRequest.onupgradeneeded = function(e) {        var thisDB = e.target.result;        if(!thisDB.objectStoreNames.contains("people")) {            thisDB.createObjectStore("people");        }    }    openRequest.onsuccess = function(e) {        console.log("running onsuccess");        db = e.target.result;        //Listen for add clicks        document.querySelector("#addButton").addEventListener("click", addPerson, false);    }    openRequest.onerror = function(e) {        //Do something for the error    }},false);function addPerson(e) {    var name = document.querySelector("#name").value;    var email = document.querySelector("#email").value;    console.log("About to add "+name+"/"+email);    var transaction = db.transaction(["people"],"readwrite");    var store = transaction.objectStore("people");    //Define a person    var person = {        name:name,        email:email,        created:new Date()    }    //Perform the add    var request = store.add(person,1);    request.onerror = function(e) {        console.log("Error",e.target.error.name);        //some type of error handler    }    request.onsuccess = function(e) {        console.log("Woot! Did it");    }}&lt;/script&gt;&lt;input type="text" id="name" placeholder="Name"&gt;&lt;br/&gt;&lt;input type="email" id="email" placeholder="Email"&gt;&lt;br/&gt;&lt;button id="addButton"&gt;Add Data&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;</pre> <p>В коде выше мы создаем небольшую форму с кнопкой, чтобы сгенерировать событие для сохранения данных в IndexedDB. Запустите его в вашем браузере, введите какой-то текст в поля формы и нажмите кнопку для добавления данных. Если у вас открыты инструменты разработчика, то вы должны будете увидеть нечто подобное:</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=394/net/uploads/2013/09/s2.png" alt="Работа с базой IndexedDB..." title="Работа с базой IndexedDB..." width="50" height="50"><br></figure><p>Сейчас уместно упомянуть, что в Chrome имеется замечательный инструмент для просмотра данных IndexedDB. Если вы откроете вкладу Resources, развернете раздел IndexedDB, то увидите созданную в нашем примере базу данных и только что добавленный объект.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2013/09/s3.png" alt="Работа с базой IndexedDB..." title="Работа с базой IndexedDB..." width="50" height="50"><br></figure><p>Давайте, ради интереса, опять нажмите ту кнопку Add Data. Вы должны будете увидеть в консоли сообщение об ошибке.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=492/net/uploads/2013/09/s4.png" alt="Работа с базой IndexedDB..." title="Работа с базой IndexedDB..." width="50" height="50"><br></figure><p>Сообщение об ошибке должно служить для вас подсказкой. ConstraintError означает, что мы только что попробовали добавить данные с тем же ключом, что уже существует. Если вы помните, мы установили то значение и <em>знали</em>, что из-за этого возникнет проблема. Пришло время поговорить о ключах.</p> <hr><h2>Ключи</h2> <p>Ключи – версия IndexedDB первичных ключей. В традиционных базах данных могут иметься таблицы без ключей, однако каждое хранилище объектов должно иметь ключ. В IndexedDB предусмотрено несколько различных типов ключей.</p> <p>Первый вариант – просто указываем ключ самостоятельно, как сделали это выше. Мы могли бы воспользоваться программной логикой для генерирования ключей. </p> <p>Второй вариант – ключевое поле, где в качестве ключа указывается свойство самих данных. В нашем примере с людьми мы могли бы использовать адреса электронной почты в качестве ключа.</p> <p>Ваш третий вариант, и на мой взгляд самый простой, – использование генератора ключей. Он подобен первичному ключу, работающему в автоинкрементном режиме (* с увеличением содержимого на единицу), и является наиболее простым методом задания ключей.</p> <p>Ключи указываются при создании хранилищ объектов. Ниже приведено два примера: в одном используется ключевое поле, в другом – генератор.</p> <pre class="brush: js noskimlinks noskimwords">thisDb.createObjectStore("test", { keyPath: "email" });  thisDb.createObjectStore("test2", { autoIncrement: true });</pre> <p>Мы можем изменить предыдущую демоверсию, создав хранилище объектов с ключом, работающим в автоинкрементном режиме:</p> <pre class="brush: js noskimlinks noskimwords">thisDB.createObjectStore("people", {autoIncrement:true});</pre> <p>Наконец, мы можем воспользоваться ранее упомянутым вызовом Add и удалить заданный нами ключ:</p> <pre class="brush: js noskimlinks noskimwords">var request = store.add(person);</pre> <p>Вот и все! Теперь вы можете добавлять данные весь день. Вы можете ознакомить с кодом этого примера в файле <code>test7.html</code>.</p> <hr><h2>Считывание данных</h2> <p>Теперь давайте перейдем к считыванию отдельных фрагментов данных (как считывать более крупные наборы данных, мы рассмотрим позже). Опять-таки, это асинхронная операция, которая будет выполнена в транзакции. Ниже приводится простой пример:</p> <pre class="brush: js noskimlinks noskimwords">var transaction = db.transaction(["test"], "readonly");var objectStore = transaction.objectStore("test");//x is some valuevar ob = objectStore.get(x);ob.onsuccess = function(e) {}</pre> <p>Обратите внимание, что указанная транзакция принадлежит к типу «только для чтения». В качестве вызова API используется простой вызов метода get, которому передан ключ. Вам на заметку: если вы считаете, что для использования IndexedDB требуется довольно много слов, то заметьте, что вы также можете сцепить многие из тех вызовов. Ниже приводиться тот же самый пример, написанный намного компактнее:</p> <pre class="brush: js noskimlinks noskimwords">db.transaction(["test"], "readonly").objectStore("test").get(X).onsuccess = function(e) {}</pre> <p>Лично я по-прежнему считаю IndexedDB довольно сложной технологией, так что я предпочитаю «развернутый» способ записи, что помогает мне уследить, что происходит в коде. </p> <p>Обработчику onsuccess передается сохраненный вами ранее объект. Как только вы получили тот объект, можете делать, что хотите. В нашем следующим примере (<code>test8.html</code>) мы добавили просто поле формы, чтобы вы могли ввести ключ и вывести результат. Ниже показан пример:</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2013/09/s5.png" alt="Работа с базой IndexedDB..." title="Работа с базой IndexedDB..." width="50" height="50"><br></figure><p>Код обработчика для кнопки Get Data приводится ниже:</p> <pre class="brush: js noskimlinks noskimwords">function getPerson(e) {    var key = document.querySelector("#key").value;    if(key === "" || isNaN(key)) return;    var transaction = db.transaction(["people"],"readonly");    var store = transaction.objectStore("people");    var request = store.get(Number(key));    request.onsuccess = function(e) {        var result = e.target.result;        console.dir(result);        if(result) {            var s = "&amp;lt;h2&gt;Key "+key+"&amp;lt;/h2&gt;&amp;lt;p&gt;";            for(var field in result) {                s+= field+"="+result[field]+"&amp;lt;br/&gt;";            }            document.querySelector("#status").innerHTML = s;        } else {            document.querySelector("#status").innerHTML = "&amp;lt;h2&gt;No match&amp;lt;/h2&gt;";        }       }   }</pre> <p>Значительная часть кода должна говорить сама за себя. Получаем значение, переданное в поле, и вызываем метод get хранилища объектов, полученного из транзакции. Обратите внимание, что при помощи кода для отображения данных мы просто получаем значения <em>всех</em> полей и выводим их. В приложении из реального мира разработки вы должны были бы (будем надеяться) знать, что содержится в ваших данных, и работать с определенными полями.</p> <hr><h2>Считывание более крупных наборов данных</h2> <p>Что ж, мы разобрались с тем, как получить один фрагмент данных. Как насчет получения <em>крупных наборов</em> данных? В IndexedDB имеется поддержка так называемого курсора. Курсор позволяет вам обходить данные. Вы можете создать курсоры, передавая необязательные диапазон (базовый фильтр) и направление. </p> <p>В качестве примера взгляните на следующий блок кода, при  помощи которого открывается курсор для извлечение всех данных из хранилища объектов. Как и все рассмотренное нами ранее, это асинхронная операция, выполняемая в транзакции.</p> <pre class="brush: js noskimlinks noskimwords">var transaction = db.transaction(["test"], "readonly");var objectStore = transaction.objectStore("test");var cursor = objectStore.openCursor();cursor.onsuccess = function(e) {    var res = e.target.result;    if(res) {        console.log("Key", res.key);        console.dir("Data", res.value);        res.continue();    }}</pre> <p>В обработчик, запускаемый в случае успешного выполнения операции, передается объект с результатом (который мы сохраняем в переменной res). В нем содержится ключ, объект с данными (в ключе value выше) и метод continue, используемый для перехода к следующему фрагменту данных.</p> <p>В следующей функции мы воспользовались курсором для обхода всех данных, содержащихся в хранилище объектов. Поскольку мы имеем дело с данными о «личностях», то назвали ее getPeople:</p> <pre class="brush: js noskimlinks noskimwords">function getPeople(e) {    var s = "";    db.transaction(["people"], "readonly").objectStore("people").openCursor().onsuccess = function(e) {        var cursor = e.target.result;        if(cursor) {            s += "&amp;lt;h2&gt;Key "+cursor.key+"&amp;lt;/h2&gt;&amp;lt;p&gt;";            for(var field in cursor.value) {                s+= field+"="+cursor.value[field]+"&amp;lt;br/&gt;";            }            s+="&amp;lt;/p&gt;";            cursor.continue();        }        document.querySelector("#status2").innerHTML = s;    }}</pre> <p>Вы можете ознакомиться с полным кодом демоверсии в скачанном вами архиве в файле <code>test9.html</code>. В нем используется та же логика для добавления личностей, как и в предыдущих примерах, так что просто создайте несколько людей и затем нажмите кнопку для отображения всех данных.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=450/net/uploads/2013/09/s7.png" alt="Работа с базой IndexedDB..." title="Работа с базой IndexedDB..." width="50" height="50"><br></figure><p>Что ж, теперь вы знаете, как получить один фрагмент данных и как получить все данные. Сейчас давайте перейдем к нашей последней теме – работе с индексами.</p> <hr><h2>Эта технология называется IndexedDB, верно?</h2> <p>Мы говорили об IndexedDB все это время, но не работали еще собственно с какими-либо, что ж, индексами. Индексы – ключевой момент хранилищ объектов IndexedDB. За счет них вы можете извлечь данные на основании их значения и указать, должно ли быть значение уникальным в пределах хранилища. Позже мы продемонстрируем, как использовать индексы для получения какого-то диапазона данных. </p> <p>Для начала рассмотрим, как создавать индексы. Как и все конструктивное, они должны создаваться в обработчике для события upgrade, в принципе тогда же, когда вы создаете ваш хранилище объектов. Ниже показан пример:</p> <pre class="brush: js noskimlinks noskimwords">var objectStore = thisDb.createObjectStore("people",                 { autoIncrement:true });//first arg is name of index, second is the path (col);objectStore.createIndex("name","name", {unique:false});objectStore.createIndex("email","email", {unique:true});</pre> <p>В первой строке мы создаем хранилище. Мы берем результат выполнения этой операции (объект objectStore) и вызываем метод <code>createIndex</code>. В качестве первого аргумента он принимает имя индекса, а в качестве второго – свойство, которое будет проиндексировано. Думаю, что в большинстве случаев вы будете использовать одинаковое название для обоих. Последний аргумент – набор опций. Пока что мы используем только одну – unique. Первый индекс для name – не уникальный. А второй для email – уникальный. При сохранении нами данных IndexedDB проверит эти индексы и удостоверится, что свойство email имеет уникальное значение. Также она обработает данные определенным образом скрыто от нас, чтобы гарантировать то, что мы можем извлечь данные при помощи этих индексов.</p> <p>Как это работает? После получения хранилища объектов через транзакцию вы можете затем получить индекс из того хранилища. Продолжая код выше, вот как это выполнить:</p> <pre class="brush: js noskimlinks noskimwords">var transaction = db.transaction(["people"],"readonly");var store = transaction.objectStore("people");var index = store.index("name");//name is some valuevar request = index.get(name);</pre> <p>Для начала мы получаем транзакцию, затем хранилище и индекс. Как мы видели ранее, вы могли бы сцепить те три первые строки, чтобы код выглядел более компактным. </p> <p>После получения объекта индекса вы можете вызвать его метод <code>get</code> для получения данных на основании имени. Мы могли бы выполнить нечто подобное и для email. Тот вызов является асинхронной операцией, к результату выполнения которой вы можете привязать обработчик onsuccess. Ниже приводится пример такого обработчика, код которого располагается в <code>test10.html</code>:</p> <pre class="brush: js noskimlinks noskimwords">request.onsuccess = function(e) {    var result = e.target.result;    if(result) {        var s = "&amp;lt;h2&gt;Name "+name+"&amp;lt;/h2&gt;&amp;lt;p&gt;";        for(var field in result) {            s+= field+"="+result[field]+"&amp;lt;br/&gt;";        }        document.querySelector("#status").innerHTML = s;    } else {        document.querySelector("#status").innerHTML = "&amp;lt;h2&gt;No match&amp;lt;/h2&gt;";    }   }</pre> <p>Обратите внимание, что метод объекта индекса <code>get</code> может возвращать множество объектов. Поскольку наше имя – не уникальное, нам, вероятно, следует изменить код, однако это необязательно. </p> <p>Теперь давайте усложним задачу. Вы видели, как использовать метод get API объекта индекса для получения значения проиндексированного свойства. Что если вам необходимо получить более обширный набор данных? Последний термин, который мы рассмотрим, – диапазоны. Диапазоны – способ выбора подмножества индекса. Например, если проиндексировано свойство name, то мы можем воспользоваться диапазоном для получения набора, который включает имена, начиная с тех, что начинаются на А, по те, что начинаются на С. Имеется несколько различных вариантов диапазонов. Это может быть диапазон, включающий «все значения ниже определенной метки», «все значения выше определенной метки» и «значения между нижней и верхней метками». Также, это просто вам на заметку, диапазоны могут быть включающими (* с … по … включительно) или исключающими. По сути это означает, что для диапазона A-C мы можем указать, хотим ли мы включить в него имена, начинающиеся на A и C, или же только имена, начинающиеся с букв, расположенных между ними. Наконец, вы можете также указать, нужно ли проводить итерацию при отборе значений по возрастанию или по убыванию.</p> <p>Диапазоны создаются при помощи объекта высшего уровня под названием IDBKeyRangeНа. Нам интересны три его метода: <code>lowerBound</code>, <code>upperBound</code> и <code>bound</code>. <code>lowerBound</code> используется для создания диапазона, который начинается с нижнего значения и при помощи которого возвращаются все значения «выше» него. <code>upperBound</code> работает наоборот. И, наконец, метод <code>bound</code> используется для указания диапазона, содержащего верхнюю и нижнюю границы. Давайте взглянем на некоторые примеры:</p> <pre class="brush: js noskimlinks noskimwords">//Values over 39var oldRange = IDBKeyRange.lowerBound(39);//Values 40a dn overvar oldRange2 = IDBKeyRange.lowerBound(40,true);//39 and smaller...var youngRange = IDBKeyRange.upperBound(40);//39 and smaller...var youngRange2 = IDBKeyRange.upperBound(39,true);//not young or old... you can also specify inclusive/exclusivevar okRange = IDBKeyRange.bound(20,40)</pre> <p>После получения диапазона вы можете передать его методу openCursor объекта индекса. В результате вы получаете итератор (* управляющая структура, определяющая порядок выполнения некоторых повторяющихся действий, устройство или программа организации циклов) для перебора значений, соответствующих тому диапазону. На деле вышеописанная операция не является поиском как таковым. Вы можете ей пользоваться для поиска контента на основании начала строки, но не ее середины или конца. Давайте взглянем на полный пример: Для начала мы создадим простую форму для поиска людей:</p> <pre class="brush: html noskimlinks noskimwords">Starting with: &lt;input type="text" id="nameSearch" placeholder="Name"&gt;&lt;br/&gt;Ending with: &lt;input type="text" id="nameSearchEnd" placeholder="Name"&gt;&lt;br/&gt;&lt;button id="getButton"&gt;Get By Name Range&lt;/button&gt;</pre> <p>Мы учтем варианты поиска, состоящие из любого типа диапазонов (опять-таки, значения выше метки, ниже метки и между двумя метками). Теперь давайте взглянем на обработчик событий для этой формы.</p> <pre class="brush: js noskimlinks noskimwords">function getPeople(e) {    var name = document.querySelector("#nameSearch").value;    var endname = document.querySelector("#nameSearchEnd").value;    if(name == "" &amp;amp;&amp;amp; endname == "") return;    var transaction = db.transaction(["people"],"readonly");    var store = transaction.objectStore("people");    var index = store.index("name");    //Make the range depending on what type we are doing    var range;    if(name != "" &amp;amp;&amp;amp; endname != "") {        range = IDBKeyRange.bound(name, endname);    } else if(name == "") {        range = IDBKeyRange.upperBound(endname);    } else {        range = IDBKeyRange.lowerBound(name);    }    var s = "";    index.openCursor(range).onsuccess = function(e) {        var cursor = e.target.result;        if(cursor) {            s += "&amp;lt;h2&gt;Key "+cursor.key+"&amp;lt;/h2&gt;&amp;lt;p&gt;";            for(var field in cursor.value) {                s+= field+"="+cursor.value[field]+"&amp;lt;br/&gt;";            }            s+="&amp;lt;/p&gt;";            cursor.continue();        }        document.querySelector("#status").innerHTML = s;    }}</pre> <p>Рассмотрим код сверху вниз. Мы начинаем с получения двух полей формы. Далее мы создаем транзакцию и получаем из нее хранилище и индекс. Теперь переходим к более сложной части. Поскольку нам необходимо поддерживать три типа диапазонов, мы должны добавить немного условной логики, чтобы выяснить, какой диапазон использовать. Мы выбираем тип на основании заполненных вами полей. Замечательно то, что после получения диапазона мы просто передаем его в индекс и открываем курсор. Вот и все! Вы можете ознакомиться с полным примером в <code>test11.html</code>. Убедитесь, что вначале ввели какие-то значения, чтобы у вас было что искать.</p> <hr><h2>Что дальше?</h2> <p>Хотите – верьте, хотите – нет, но мы только начали обсуждать IndexedDB. В следующем руководстве мы рассмотрим дополнительные вопросы, включая обновление и удаление данных, работу со свойствами, являющимися массивами, и некоторые общие советы по работе с IndexedDB.</p> 

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825556-rabota-s-bazoj-indexeddb" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Web Development" href="https://norma-studio.github.io/article5/220825556-rabota-s-bazoj-indexeddb" class="tm-article-body__tags-item-link">Web Development</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
41518</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
682</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

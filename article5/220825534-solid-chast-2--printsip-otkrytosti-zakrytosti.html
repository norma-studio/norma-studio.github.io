
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>SOLID Часть 2 - Принцип открытости/закрытости... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="SOLID Часть 2 - Принцип открытости/закрытости... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="SOLID Часть 2 - Принцип открытости/закрытости... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="SOLID Часть 2 - Принцип открытости/закрытости... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Принцип единственной ответственности (SPR), открытости/закрытости(OCP), подстановки Лисков, множественности интерфейсов и инверсии зависимостей. Пять гибких принципов, которыми вы должны руководствоваться каждый раз, когда пишете код....">
<meta property="og:description" content="Принцип единственной ответственности (SPR), открытости/закрытости(OCP), подстановки Лисков, множественности интерфейсов и инверсии зависимостей. Пять гибких принципов, которыми вы должны руководствоваться каждый раз, когда пишете код....">
<meta name="twitter:description" content="Принцип единственной ответственности (SPR), открытости/закрытости(OCP), подстановки Лисков, множественности интерфейсов и инверсии зависимостей. Пять гибких принципов, которыми вы должны руководствоваться каждый раз, когда пишете код....">
<meta property="aiturec:description" content="Принцип единственной ответственности (SPR), открытости/закрытости(OCP), подстановки Лисков, множественности интерфейсов и инверсии зависимостей. Пять гибких принципов, которыми вы должны руководствоваться каждый раз, когда пишете код....">
<meta property="og:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2014/01/violate1.png">
<meta property="aiturec:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2014/01/violate1.png">
<meta name="twitter:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2014/01/violate1.png">
<meta property="vk:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2014/01/violate1.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2014/01/violate1.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825534-solid-chast-2--printsip-otkrytosti-zakrytosti.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825534-solid-chast-2--printsip-otkrytosti-zakrytosti.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825534-solid-chast-2--printsip-otkrytosti-zakrytosti.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825534-solid-chast-2--printsip-otkrytosti-zakrytosti.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825534-solid-chast-2--printsip-otkrytosti-zakrytosti.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825534-solid-chast-2--printsip-otkrytosti-zakrytosti.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825534-solid-chast-2--printsip-otkrytosti-zakrytosti.html" title="SOLID Часть 2 - Принцип открытости/закрытости... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="SOLID Часть 2 - Принцип открытости/закрытости... | envatomarket.ru | norma-studio.github.io" title="SOLID Часть 2 - Принцип открытости/закрытости... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/64533gfdsgf.jpg" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825534-solid-chast-2--printsip-otkrytosti-zakrytosti.html" class="tm-user-info__username" title="
А. Лукичев" aria-label="
А. Лукичев">
А. Лукичев</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>SOLID Часть 2 - Принцип открытости/закрытости...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825534-solid-chast-2--printsip-otkrytosti-zakrytosti" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="PHP" href="https://norma-studio.github.io/article5/220825534-solid-chast-2--printsip-otkrytosti-zakrytosti" class="tm-article-snippet__hubs-item-link"><span>PHP</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825534-solid-chast-2--printsip-otkrytosti-zakrytosti.html" />
    <link itemprop="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2014/01/violate1.png">
    <meta itemprop="headline name" content="SOLID Часть 2 - Принцип открытости/закрытости... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Принцип единственной ответственности (SPR), открытости/закрытости(OCP), подстановки Лисков, множественности интерфейсов и инверсии зависимостей. Пять гибких принципов, которыми вы должны руководствоваться каждый раз, когда пишете код....">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Принцип единственной ответственности (SPR), открытости/закрытости(OCP), подстановки Лисков, множественности интерфейсов и инверсии зависимостей. Пять гибких принципов, которыми вы должны руководствоваться каждый раз, когда пишете код....</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Принцип единственной ответственности (SPR), открытости/закрытости(OCP), подстановки Лисков, множественности интерфейсов и инверсии зависимостей. Пять гибких принципов, которыми вы должны руководствоваться каждый раз, когда пишете код.</p> <h2>Определение</h2> <blockquote> <p>Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для изменения.</p> </blockquote> <p>Принцип открытости/закрытости (OCP) был создан <span>Бертраном Мейером</span>, французским программистом, который впервые опубликовал его в своей книге <span>Object-Oriented Software Construction</span> в 1988 году.</p> <p>Принцип получил широкую опулярность в ранних 2000-ых, он вошел в группу SOLID принципов, определенных <span>Робертом C. Мартином</span> в его книге <span>Agile Software Development, Principles, Patterns, and Practices</span>, а позже в версии для <span>C# Agile Principles, Patterns, and Practices in C#</span>.</p> <p>Вся суть того, о чем мы здесь говорим, заключается в разработке наших модулей, классов и функций таким образом, что, когда требуется новая функциональность, мы должны не изменять существующий код, а наоборот написать новый, который будет использовать уже существующий. Это может звучать немного странно, особенно если мы работаем в таких языках как Java, C, C++ или C#, когда это применимо не только к самому исходному коду, но и к бинарнику тоже. Мы хотим добавлять новые возможности таким способом, чтобы не потребовалось от нас пересобирать уже существующие двоичные файлы, исполняемые файлы или библиотеки DLL.</p> <h2>Принцип открытости/закрытости в контексте SOLID</h2> <p>По мере продвижения через эти уроки, мы можем рассматривать каждый новый принцип в контексте тех, о которых уже говорилось. Мы уже обсудили <span>Принцип единственной ответственности (SPR)</span>, который означает, что модуль должен иметь только одну причину для изменения. Если мы рассмотрим OCP и SPR, то можно заметить, что они оба являются взаимодополняющими. Код, написанный с соблюдением SPR, будет очень близок к OCP или его будет достаточно легко доделать, чтобы он соблюдал этот принцип. Когда у нас имеется код, который имеет только одну причину для изменения, добавление новой возможности, создаст вторую причину для изменения. Таким образом оба принципа: SPR и OCP будут нарушены. В другом случае, если у нас есть код, который следует изменять только в том случае, если его основная функция меняется, и должен оставаться неизменным, при добавлении новой возможности, таким образом соблюдая OCP, так же будет соблюден SPR.</p> <p>Это не означает что SPR всегда в итоге ведет к OCP и наоборот, но все же в большинстве случаев если один из них соблюдается, соблюсти второй не составит особого труда.</p> <h2>Очевидный пример нарушения OCP</h2> <p>С чисто технической точки зрения принцип открытости/закрытости очень прост. Простая связь между двумя классами, такая как представленная ниже, нарушает OCP.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2014/01/violate1.png" alt="SOLID Часть 2 - Принцип открытости/закрытости..." title="SOLID Часть 2 - Принцип открытости/закрытости..." width="50" height="50"><br></figure><p>Класс <code>User</code> использует класс <code>Logic</code> напрямую. Если нам потребуется реализовать второй класс <code>Logic</code> таким образом, чтобы можно было использовать оба: и текущий и новый, то существующий класс <code>Logic</code> следует изменить. Класс <code>User</code> напрямую привязан к реализации класса <code>Logic</code>, и нет никакой возможности нам предоставить новый класс <code>Logic</code>, без изменения текущего. И когда мы ведем разговор о статично типизированных языках, вполне вероятно что так же потребуется внести изменения и в класс <code>User</code>. Если же мы рассматриваем компилируемые языки, скорее всего оба класса <code>User</code> и <code>Logic</code> потребует перекомпиляции и доставки клиентам, а это именно тот процесс, которого мы хотим как можно чаще избегать.</p> <h2>Покажите мне код</h2> <p>Основываясь только на схеме выше, можно сделать вывод, что любой класс, непосредственно использующий другой класс, фактически нарушает принцип открытости/закрытости. И, строго говоря, это правильно. Я нашел это довольно интересным занятием - искать границы, где находится тот самый момент, что бы можно было нарисовать линию и решить, что будет сложнее: заставить этот код соблюдать OCP, или изменить его, если архитектурные изменения не оправдывают стоимость изменения существующего кода.</p> <p>Допустим, мы хотим написать класс, который будет показывать в процентах рогресс скачивания файла через наше приложение. У нас будет два основных класса <code>Progress</code> и <code>File</code>, и я хочу использовать их, как представлено в тесте ниже.</p> <pre class="brush: php noskimlinks noskimwords">function testItCanGetTheProgressOfAFileAsAPercent() {  $file = new File();$file-&gt;length = 200;$file-&gt;sent = 100;$progress = new Progress($file);$this-&gt;assertEquals(50, $progress-&gt;getAsPercent());}</pre> <p>В тесты мы - пользователь класс <code>Progress</code>. Мы хотим получить значение в процентах, независимо от того, каков реальный размер файла. Мы используем <code>File</code>, как источник информации для <code>Progress</code>. Файл содержит длинну в байтах и атрибут <code>sent</code>, которое представляет собой количество отправленных данных во время скачивания. Нам не важно, каким образом будут обновляться эти значения в приложении. Мы можем предположить, есть некая магические логика, которая делает это для нас, поэтому в тесте мы можем задать их явно.</p> <pre class="brush: php noskimlinks noskimwords">class File {public $length;public $sent;}</pre> <p>Класс <code>File</code> это простой объект данных, содержащий два атрибута. Конечно же в реальной жизни, он будет скорее всего содержать и другую информацию и возможно даже какое-нибудь поведение, например имя, путь, относительный путь, текущая директория, тип, права доступа, и др. </p> <pre class="brush: php noskimlinks noskimwords">class Progress {private $file;function __construct(File $file) {$this-&gt;file = $file;}function getAsPercent() {return $this-&gt;file-&gt;sent * 100 / $this-&gt;file-&gt;length;}}</pre> <p>Класс <code>Progress</code> просто получает <code>File</code> в своем конструкторе. Для ясности мы указали тип переменной в параметрах конструктора. Есть только один нужный метод к классе <code>Progress</code> - <code>getAsPercent()</code>, который берет значения отправленных данных и длину <code>File</code>, и преобразует их в процент. Довольно просто и это работает.</p> <pre class="brush: bash noskimlinks noskimwords">Testing started at 5:39 PM ...PHPUnit 3.7.28 by Sebastian Bergmann..Time: 15 ms, Memory: 2.50MbOK (1 test, 1 assertion)</pre> <p>Этот код кажется правильным, хотя он нарушает принцип открытости/закрытости. Но почему же? И как?</p> <h2>Изменения требований</h2> <p>В каждое приложение со временем потребуется добавить новые возможности. Одной из новых возможностей нашего приложения будет потоковая передача музыки, вместо простого скачивания файлов. Длина <code>File</code> представлена в байтах, а музыки в секундах. Мы хотим предоставить нашим слушателям симпатичный индикатор длинны, но можем ли мы повторно использовать тот, который уже есть?</p> <p>Нет, не можем. Наш прогресс жестко привязан к <code>File</code>. Он понимает только файлы, хотя он также может применяться и к музыке. Но чтобы получить такую возможность, мы должны его модифицировать, мы должны дать знание классу <code>Progress</code> о классах <code>Music</code> и <code>File</code>. Если бы наша архитектура соблюдала принцип принцип открытости/закрытости, нам не потребовалось вносить изменения в <code>File</code> или <code>Progress</code>. Мы могли бы просто повторно использовать уже существующий класс <code>Progress</code> и применить его к <code>Music</code>.</p> <h2>Решение 1: Воспользоваться приемуществом динамической природы PHP</h2> <p>Динамически типизированные языки имеют преимущество в узнавании типов объектов во время исполнения. Это позволяет убрать подсказку типа из конструктора <code>Progress</code>, и код попрежнему будет работать.</p> <pre class="brush: php noskimlinks noskimwords">class Progress {private $file;function __construct($file) {$this-&gt;file = $file;}function getAsPercent() {return $this-&gt;file-&gt;sent * 100 / $this-&gt;file-&gt;length;}}</pre> <p>Теперь мы можем передавать классу <code>Progress</code> что угодно. И под словом что угодно, я действительно имею в виду что угодно:</p> <pre class="brush: php noskimlinks noskimwords">class Music {public $length;public $sent;public $artist;public $album;public $releaseDate;function getAlbumCoverFile() {return "Images/Covers/" . $this-&gt;artist . "/" . $this-&gt;album . ".png";}}</pre> <p>И класс <code>Music</code> как и любой другой отлично подойдет. Мы можем легко это протестировать в тесте, очень похожем на тест <code>File</code>.</p> <pre class="brush: php noskimlinks noskimwords">function testItCanGetTheProgressOfAMusicStreamAsAPercent() {$music = new Music();$music-&gt;length = 200;$music-&gt;sent = 100;$progress = new Progress($music);$this-&gt;assertEquals(50, $progress-&gt;getAsPercent());}</pre> <p>Поэтому в основном, любой измеряемый объект может быть использован классом <code>Progress</code>. Может нам следует это выразить в коде, переименовав переменную:</p> <pre class="brush: php noskimlinks noskimwords">class Progress {private $measurableContent;function __construct($measurableContent) {$this-&gt;measurableContent = $measurableContent;}function getAsPercent() {return $this-&gt;measurableContent-&gt;sent * 100 / $this-&gt;measurableContent-&gt;length;}}</pre> <p>Хорошо, но теперь у нас появилась огромная проблема с таким подходом. Когда мы имели класс <code>File</code>, который был определен подсказкой типа, нам не стоило беспокоиться о том, что передается нашему классу. Это было явно выражено и если что-то шло не так, что мы получаем хорошую и понятную ошибку об этом.</p> <pre class="brush: bash noskimlinks noskimwords">Argument 1 passed to Progress::__construct()must be an instance of File,instance of Music given.</pre> <p>Но без определения типа, мы должны полагаться на тот факт, что любая переменная, переданная нам, должна иметь два публичных свойства "<code>length</code>" и "<code>sent</code>". В противном случае мы будем иметь отказ при наследовании.</p> <blockquote> <p>Отказ при наследовании: класс, который переопределеяет метод базового класса таким способом, то не соблюдается контракт исходного класса. ~ Источник Википедия.</p> </blockquote> <p>Это одна из <em>проблем в коде</em>, которые более детально представлены в курсе <span>Определение проблем в коде</span>. Если кратко, то мы не хотим вызывать методы или использовать свойства объектов, у которых этих методов или свойств по контракту нет. Когда у нас была подсказка типа, то она помогала соблюсти контракт. Свойства и методы класса <code>File</code>. Теперь когда ее нет, мы может отправить все что угодно, например строку, что в итоге выльется в уродливую ошибку.</p> <pre class="brush: php noskimlinks noskimwords">function testItFailsWithAParameterThatDoesNotRespectTheImplicitContract() {$progress = new Progress("some string");$this-&gt;assertEquals(50, $progress-&gt;getAsPercent());}</pre> <p>Тест, подобный этому, где мы отправляем простую строку, продемонстрирует отказ в наследовании.</p> <pre class="brush: bash noskimlinks noskimwords">Trying to get property of non-object.</pre> <p>В то время как результат в обоих случаях для разных классов один и тот же, и означает что код ломается, первый выводил красивое сообщение. Этот, однако, не выглядит достаточно ясным. Нет никакого способа узнать, чем является переменная, в нашем случае строкой, и какие свойства мы в ней искали и не нашли. Тяжело отлаживать и разрешить эту проблему. Программисту потребуется открыть класс <code>Progress</code>, прочитать и понять его. Когда мы не указываем подскажу типа, то контракт таким образом определяется поведением класса <code>Progress</code>. Это неявный контракт, известный только классу <code>Progress</code>. В нашем примере он определяется доступом к двум свойствам <code>sent</code> и <code>length</code> и методом <code>getAsPercent()</code>. В реальной жизни неявный контракт может быть очень сложным и его будет трудно обнаружить, просто взглянув несколько секунд на класс.</p> <p>Такое решение рекомендуется использовать только в случае, если ни одно из решений, предложенных ниже, невозможно будет легко реализовать или они потребуют значительных архитектурных изменений, которые не оправдают затраченных усилий.</p> <h2>Решение 2: Использовать шаблон проектирования Стратегия</h2> <p>Это наиболее общее и наверное наиболее подходящее решение для соблюдения принципа открытости/закрытости. Оно простое и эффективное.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2014/01/strategy.png" alt="SOLID Часть 2 - Принцип открытости/закрытости..." title="SOLID Часть 2 - Принцип открытости/закрытости..." width="50" height="50"><br></figure><p>Шаблон проектирования Стратегия просто вводит в использование интерфейс. Интерфейс - это специальный тип сущности в объектно-ориентированном программировании, который определяет контракт между клиентским кодом и классом. Оба класса будут придерживаться контракта для обеспечения ожидаемого поведения. Может быть несколько совершенно несвязанных классов, которые соблюдают один и тот же контракт, чтобы быть совместимыми с требованиями клиентского кода.</p> <pre class="brush: php noskimlinks noskimwords">interface Measurable {function getLength();function getSent();}</pre> <p>В интерфейсе мы можем определять только поведение. Вот почему вместо использования публичных свойств, нам потребуются геттеры и сеттеры. Таким образом адаптировать остальные классы не составим нам особого труда. Наша IDE может сделать почти всю работу за нас.</p> <pre class="brush: php noskimlinks noskimwords">function testItCanGetTheProgressOfAFileAsAPercent() {$file = new File();$file-&gt;setLength(200);$file-&gt;setSent(100);$progress = new Progress($file);$this-&gt;assertEquals(50, $progress-&gt;getAsPercent());}</pre> <p>Как обычно мы начнем с наших тестов. Нам потребуется использовать сеттеры и геттеры. Если необходимо то эти сеттеры можно также определить в <code>Measurable</code> интерфейсе. Однако будьте осторожны с тем, что вы положите в него. Интерфейс нужен для определения контракта между клиентским классом <code>Progress</code> и различными классами типа <code>File</code> и <code>Music</code>. Требуется ли классу <code>Progress</code> устанавливать в них значения? Очевидно что нет. Таким образом нежелательно определять сеттеры в этом интерфейсе. Так же, если мы определим там эти сеттеры, то мы принудим все остальные классы, которые будут использовать этот интерфейс, реализовывать эти сеттеры. Для некоторых из них может быть это окажется и логично, но другие могут вести себя совершенно по-другому. Что если мы захотим использовать наш класс <code>Progress</code> для отображения температуры печи? Класс OvenTemperature может быть инициализирован значениями через конструктор или получить информацию от стороннего класса. Кто знает? Было бы странно иметь сеттеры в этом классе.</p> <pre class="brush: php noskimlinks noskimwords">class File implements Measurable {private $length;private $sent;public $filename;public $owner;function setLength($length) {$this-&gt;length = $length;}function getLength() {return $this-&gt;length;}function setSent($sent) {$this-&gt;sent = $sent;}function getSent() {return $this-&gt;sent;}function getRelativePath() {return dirname($this-&gt;filename);}function getFullPath() {return realpath($this-&gt;getRelativePath());}}</pre> <p>Класс <code>File</code> был слегка изменен для удовлетворения указанных выше требований. Теперь он реализует интерфейс <code>Measurable</code> и имеет сеттеры и геттеры для свойств, в которых мы заинтересованы. Класс <code>Music</code> очень похож на предыдущий, вы можете проверить его содержимое в исходном коде из приложений к статье. Теперь у нас все почти готово.</p> <pre class="brush: php noskimlinks noskimwords">class Progress {private $measurableContent;function __construct(Measurable $measurableContent) {$this-&gt;measurableContent = $measurableContent;}function getAsPercent() {return $this-&gt;measurableContent-&gt;getSent() * 100 / $this-&gt;measurableContent-&gt;getLength();}}</pre> <p>Класс <code>Progress</code> тоже нуждается в небольшом обновлении. Мы теперь можем указать тип, используя подсказку типов в конструкторе. <code>Measurable</code> является ожидаемым типом. Теперь у нас есть явный контракт. Класс <code>Progress</code> может уверенно использовать методы, которые обязательно будут присутствовать, потому что они объявлены в <code>Measurable</code> интерфейсе. Классы <code>File</code> и <code>Music</code> также могут быть уверены в том, что они предоставляют классу <code>Progress</code> все необходимое для его работы, реализуя все методы интерфейса.</p> <p>Данный шаблон проекктирования наиболее подробно рассмотрен в курсе <span>Agile Design Patterns</span>.</p> <h3>Заметка об именовании интерфейсов</h3> <p>Люди привыкли именовать интерфейсы, начиная с заглавной буквы <code>I</code>, или со словом "<code>Interface</code>" в конце, например как <code>IFile</code> или <code>FileInterface</code>. Это является старой нотацией еще со времен некоторых устаревших стандартов. Мы слишком сильно увлеклись венгерской нотаций и необходимостью указывать тип переменной или объекта в его названии для того, чтобы было легче идентифицировать его. Наши IDE выявят все что нужно для нас в секунду. Это позволяет больше сконцентрироваться на абстракциях.</p> <p>Интерфейсы принадлежат своим клиентам. Да. Когда вы собираетесь выбрать имя для интерфейса, вам следует подумать о его клиенте и забыть о реализации. Когда мы назвали наш интерфейс Measurable, мы думали так о Progress. Если бы я был прогрессом, что бы мне понадобилось, чтобы я мог предоставить процент. Ответ прост - то, что можно измерить. Таким образом, названием было выбрано слово Measurable. </p> <p>Другой причиной является то, что реализация может быть в разных доменах. В нашем случае это файлы и музыка. Но мы так же можем легко использовать наш класс <code>Progress</code> к примеру в гоночном симуляторе. В этом случае измеряемым классами будут Speed, Fuel и т.д. Прекрасно, не так ли ?</p> <h2>Решение 3: Использовать Шаблон проектирования Шаблонный метод</h2> <p>Шаблонный метод очень похож на стратегию, но вместо интерфейса здесь используется абстрактный класс. Рекомендуется использовать шаблонный метод, кода есть клиент очень специфичный для нашего приложения, и когда у предоставляемых ему классов есть схожее поведение.</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2014/01/template_method.png" alt="SOLID Часть 2 - Принцип открытости/закрытости..." title="SOLID Часть 2 - Принцип открытости/закрытости..." width="50" height="50"><br></figure><p>Этот шаблон проектирования рассмотрен детально в курсе <span>Agile Design Patterns</span>.</p> <h2>Вид с высоты.</h2> <p>Итак, каким же образом все это отобразится на архитектуре?</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2014/01/HighLevelDesign.png" alt="SOLID Часть 2 - Принцип открытости/закрытости..." title="SOLID Часть 2 - Принцип открытости/закрытости..." width="50" height="50"><br></figure><p>Если картинка сверху представляет собой текущую архитектуру нашего приложения, добавление нового модуля из пяти классов (синяя часть) умеренно повлияет на наш дизайн (красный класс).</p> <figure><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/2014/01/HighLevelDesignWithNewClasses.png" alt="SOLID Часть 2 - Принцип открытости/закрытости..." title="SOLID Часть 2 - Принцип открытости/закрытости..." width="50" height="50"><br></figure><p>В большинстве систем не стоит ожидать полного отсутствия влияния новых классов на уже существующий код. Хотя соблюдение принципа открытости/закрытости значительно уменьшит количество классов и модулей, которые потребуется изменить. </p> <p>Как и с любым другим принципом, не следует сразу заранее обо всем задумываться. Если вы так сделаете, то в итоге получите по интерфейсу на каждый ваш класс. Такую архитектуру будет тяжело понять и поддерживать. Обычно самый безопасный способ задуматься о возможности добавлять интерфейсы - определить, будут ли в дальнейшем другие типы подобного класса. В большинстве случаев можно легко представить новую возможность или найти ее в бэклоге проекта, которую будет реализовывать другой класс. В таких случаях лучше сразу добавлять интерфейс. Если же сразу невозможно определить или есть сомнения - лучше в большинстве случаев не создавать интерфейсы. Предоставьте это другому программисту или вам в будущем, когда потребуется новыя реализация.</p> <h2>Заключительные мысли</h2> <p>Если вы достаточно дисциплинированы и добавляете интерфейс всякий раз, когда требуется новый класс с другой реализацией, то любая модификация становится легкой. Помните, если код требует изменений один раз, то вероятнее всего он снова их потребует. Когда это становится реальностью, принцип открытости/закрытости сохранит вам много времени.</p> <p>Спасибо за прочтение.</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825534-solid-chast-2--printsip-otkrytosti-zakrytosti" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="PHP" href="https://norma-studio.github.io/article5/220825534-solid-chast-2--printsip-otkrytosti-zakrytosti" class="tm-article-body__tags-item-link">PHP</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
41904</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
339</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

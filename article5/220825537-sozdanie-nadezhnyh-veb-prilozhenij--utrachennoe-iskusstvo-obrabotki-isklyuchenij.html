
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Создание надежных веб-приложений - утраченное искусство обработки исключений... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Создание надежных веб-приложений - утраченное искусство обработки исключений... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Создание надежных веб-приложений - утраченное искусство обработки исключений... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Создание надежных веб-приложений - утраченное искусство обработки исключений... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Как разработчики, мы хотим, чтобы приложения, которые мы строим, были устойчивыми, когда дело касается ошибки, но как вы достигаете этой цели? Если вы считаете, микросервисы и умный протокол связи - это ответ на все ваши проблемы или, возможно, автоматическое переключение DNS. Хотя этот материал и имеет мета быть и возможно с ним можно сделать инте...">
<meta property="og:description" content="Как разработчики, мы хотим, чтобы приложения, которые мы строим, были устойчивыми, когда дело касается ошибки, но как вы достигаете этой цели? Если вы считаете, микросервисы и умный протокол связи - это ответ на все ваши проблемы или, возможно, автоматическое переключение DNS. Хотя этот материал и имеет мета быть и возможно с ним можно сделать инте...">
<meta name="twitter:description" content="Как разработчики, мы хотим, чтобы приложения, которые мы строим, были устойчивыми, когда дело касается ошибки, но как вы достигаете этой цели? Если вы считаете, микросервисы и умный протокол связи - это ответ на все ваши проблемы или, возможно, автоматическое переключение DNS. Хотя этот материал и имеет мета быть и возможно с ним можно сделать инте...">
<meta property="aiturec:description" content="Как разработчики, мы хотим, чтобы приложения, которые мы строим, были устойчивыми, когда дело касается ошибки, но как вы достигаете этой цели? Если вы считаете, микросервисы и умный протокол связи - это ответ на все ваши проблемы или, возможно, автоматическое переключение DNS. Хотя этот материал и имеет мета быть и возможно с ним можно сделать инте...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/tecniek/profiles/2/skorks.jpg">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/tecniek/profiles/2/skorks.jpg">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/tecniek/profiles/2/skorks.jpg">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/tecniek/profiles/2/skorks.jpg">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/tecniek/profiles/2/skorks.jpg">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825537-sozdanie-nadezhnyh-veb-prilozhenij--utrachennoe-iskusstvo-obrabotki-isklyuchenij.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825537-sozdanie-nadezhnyh-veb-prilozhenij--utrachennoe-iskusstvo-obrabotki-isklyuchenij.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825537-sozdanie-nadezhnyh-veb-prilozhenij--utrachennoe-iskusstvo-obrabotki-isklyuchenij.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825537-sozdanie-nadezhnyh-veb-prilozhenij--utrachennoe-iskusstvo-obrabotki-isklyuchenij.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825537-sozdanie-nadezhnyh-veb-prilozhenij--utrachennoe-iskusstvo-obrabotki-isklyuchenij.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825537-sozdanie-nadezhnyh-veb-prilozhenij--utrachennoe-iskusstvo-obrabotki-isklyuchenij.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825537-sozdanie-nadezhnyh-veb-prilozhenij--utrachennoe-iskusstvo-obrabotki-isklyuchenij.html" title="Создание надежных веб-приложений - утраченное искусство обработки исключений... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Создание надежных веб-приложений - утраченное искусство обработки исключений... | envatomarket.ru | norma-studio.github.io" title="Создание надежных веб-приложений - утраченное искусство обработки исключений... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/543234456.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825537-sozdanie-nadezhnyh-veb-prilozhenij--utrachennoe-iskusstvo-obrabotki-isklyuchenij.html" class="tm-user-info__username" title="
А. Гаврилов" aria-label="
А. Гаврилов">
А. Гаврилов</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Создание надежных веб-приложений - утраченное искусство обработки исключений...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825537-sozdanie-nadezhnyh-veb-prilozhenij--utrachennoe-iskusstvo-obrabotki-isklyuchenij" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Ruby" href="https://norma-studio.github.io/article5/220825537-sozdanie-nadezhnyh-veb-prilozhenij--utrachennoe-iskusstvo-obrabotki-isklyuchenij" class="tm-article-snippet__hubs-item-link"><span>Ruby</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825537-sozdanie-nadezhnyh-veb-prilozhenij--utrachennoe-iskusstvo-obrabotki-isklyuchenij.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=80/uploads/users/tecniek/profiles/2/skorks.jpg">
    <meta itemprop="headline name" content="Создание надежных веб-приложений - утраченное искусство обработки исключений... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Как разработчики, мы хотим, чтобы приложения, которые мы строим, были устойчивыми, когда дело касается ошибки, но как вы достигаете этой цели? Если вы считаете, микросервисы и умный протокол связи - это ответ на все ваши проблемы или, возможно, автоматическое переключение DNS. Хотя этот материал и имеет мета быть и возможно с ним можно сделать инте...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Как разработчики, мы хотим, чтобы приложения, которые мы строим, были устойчивыми, когда дело касается ошибки, но как вы достигаете этой цели? Если вы считаете, микросервисы и умный протокол связи - это ответ на все ваши проблемы или, возможно, автоматическое переключение DNS. Хотя этот материал и имеет мета быть и возможно с ним можно сделать инте...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Как разработчики, мы хотим, чтобы приложения, которые мы строим, были устойчивыми, когда дело касается ошибки, но как вы достигаете этой цели? Если вы считаете, микросервисы и <span>умный протокол связи</span> - это ответ на все ваши проблемы или, возможно, <span>автоматическое переключение DNS</span>. Хотя этот материал и имеет мета быть и возможно с ним можно сделать <span>интересную презентацию на конференции</span>, но несколько менее гламурная правда заключается в том, что создание надежного приложения начинается с вашего кода. Но даже хорошо спроектированные и хорошо протестированные приложения часто не имеют жизненно важного компонента гибкого кода - обработки исключений.</p><p></p> <div> <strong>Спонсируемый контент</strong> <p>Данный контент был заказан <span>Engine Yard</span> и было написан и/или отредактирован командой Tuts +. Цель спонсируемого контента - публиковать актуальные и объективные обучающие материалы, тематические исследования и вдохновляющие интервью, которые предлагают истинную образовательную ценность для наших читателей и позволяют нам финансировать создание более полезного контента.</p> </div> <p>Я никогда не перестаю удивляться тому, как малоиспользуемая обработка исключений имеет тенденцию быть даже в пределах зрелых кодовых базах. Давайте посмотрим на пример.</p> <hr><h2>Что может пойти неправильно?</h2> <p>Скажем, у нас есть приложение на <span>Rails</span>, и одна из вещей, которые мы можем сделать с помощью этого приложения, - это получить список последних твитов для пользователя, учитывая их дескриптор. Наш <code>TweetsController</code> может выглядеть так:</p> <pre class="brush: ruby noskimlinks noskimwords">class TweetsController &lt; ApplicationController  def show    person = Person.find_or_create_by(handle: params[:handle])    if person.persisted?      @tweets = person.fetch_tweets    else      flash[:error] = "Unable to create person with handle: #{person.handle}"    end  endend</pre> <p>И модель <code>Person</code>, которую мы использовали, может быть похожа на следующее:</p> <pre class="brush: ruby noskimlinks noskimwords">class Person &lt; ActiveRecord::Base  def fetch_tweets    client = Twitter::REST::Client.new do |config|      config.consumer_key        = configatron.twitter.consumer_key      config.consumer_secret     = configatron.twitter.consumer_secret      config.access_token        = configatron.twitter.access_token      config.access_token_secret = configatron.twitter.access_token_secret    end    client.user_timeline(handle).map{|tweet| tweet.text}  endend</pre> <p>Этот код кажется вполне логичным, есть десятки приложений с кодом, похожим на этот в продакшене, но давайте рассмотрим его немного ближе.</p> <ul><li> <code>find_or_create_by</code> - это метод Rails, это не метод «bang», поэтому он не должен генерировать исключения, но если мы <span>посмотрим в документацию</span>, мы увидим, что благодаря тому, как работает этот метод, он может вызвать ошибку <code>ActiveRecord::RecordNotUnique</code> , Это случается не часто, но если наше приложение имеет приличный объем трафика, она может происходить чаще, чем вы могли ожидать (я видел, как это случалось много раз).</li> <li>Хотя мы обсуждаем эту тему, любая используемая вами библиотека может вызывать неожиданные ошибки из-за ошибок внутри самой библиотеки, и Rails не является исключением. В зависимости от нашего уровня паранойи мы можем ожидать, что наш <code>find_or_create_by</code> в любой момент выкинет любую неожиданную ошибку (здоровый уровень паранойи - это хорошая вещь, когда дело доходит до создания надежного программного обеспечения). Если у нас нет глобального способа обработки непредвиденных ошибок (мы обсудим это ниже), мы, возможно, захотим обработать их по отдельности.</li> <li>Есть еще <code>person.fetch_tweets</code>, который создает клиент <span>Twitter</span> и пытается получить некоторые твиты. Это будет сетевой вызов и он подвержен всевозможным сбоям. Мы можем прочитать документацию, чтобы выяснить, какие возможные ошибки мы можем ожидать, но мы знаем, что ошибки здесь не только возможны, но и вполне вероятны (например, <span>API-интерфейс Twitter</span> может быть недоступен, человек с этим дескриптором не существует и т.п.). Не помещая логику обработки исключений рядом с сетевыми вызовами, вы создаете себе проблемы.</li> </ul><p>У нашего крошечного кода есть некоторые серьезные проблемы, давайте попробуем и сделаем его лучше. </p> <hr><h2>Правильное количество обработчиков исключений</h2> <p>Мы обернем наш <code>find_or_create_by</code> и переносим его в модель <code>Person</code>:</p> <pre class="brush: ruby noskimlinks noskimwords">class Person &lt; ActiveRecord::Base  class &lt;&lt; self    def find_or_create_by_handle(handle)      begin        Person.find_or_create_by(handle: handle)      rescue ActiveRecord::RecordNotUnique        Rails.logger.warn { "Encountered a non-fatal RecordNotUnique error for: #{handle}" }        retry      rescue =&gt; e        Rails.logger.error { "Encountered an error when trying to find or create Person for: #{handle}, #{e.message} #{e.backtrace.join("\n")}" }        nil      end    end  endend</pre> <p>Мы обработали <code>ActiveRecord::RecordNotUnique</code> в соответствии с документацией, и теперь мы знаем, что мы либо получим объект <code>Person</code>, либо <code>nil</code>, если что-то пойдет не так. Этот код теперь надежный, но как насчет получения наших твитов:</p> <pre class="brush: ruby noskimlinks noskimwords">class Person &lt; ActiveRecord::Base  def fetch_tweets    client.user_timeline(handle).map{|tweet| tweet.text}  rescue =&gt; e    Rails.logger.error { "Error while fetching tweets for: #{handle}, #{e.message} #{e.backtrace.join("\n")}" }    nil  end  private  def client    @client ||= Twitter::REST::Client.new do |config|      config.consumer_key        = configatron.twitter.consumer_key      config.consumer_secret     = configatron.twitter.consumer_secret      config.access_token        = configatron.twitter.access_token      config.access_token_secret = configatron.twitter.access_token_secret    end  endend</pre> <p>Мы помещаем экземпляр клиента Twitter в его собственный приватный метод, и поскольку мы не знали, что конкретно может пойти не так, когда мы получаем твиты, мы спасаем все возможные случаи.</p> <p>Возможно, вы где-то слышали, что всегда должны <span>ловить определенные ошибки</span>. Это похвальная цель, но люди часто неправильно истолковывают ее так: «Если я не могу поймать что-то конкретное, я не буду ничего ловить». В действительности, если вы не можете поймать что-то конкретное, вы должны поймать все! Таким образом, по крайней мере, у вас есть возможность что-то сделать, даже если нужно только записать ошибку и повторно ее выбросить.</p> <h3>В дополнение к дизайну OO</h3> <p>Чтобы сделать наш код более надежным, мы были вынуждены провести небольшой рефакторинг, и теперь наш код, возможно, стал еще лучше, чем был раньше. Вы можете использовать свое стремление к более гибкому коду, чтобы сообщить свои дизайнерские решения.</p> <h3>В дополнение к тестированию</h3> <p>Каждый раз, когда вы добавляете логику обработки исключений в метод, это также дополнительный путь выполнения кода в этом методе, и его необходимо протестировать. Очень важно, чтобы вы проверяли путь с исключением, возможно, даже больше, чем тестирование <span>счастливого пути</span>. Если что-то пойдет не так на счастливом пути, у вас теперь есть дополнительная страховка <code>rescue</code> блока, чтобы ваше приложение не упало. Однако любая логика внутри самого блока спасения не имеет такого страхования. Протестируйте свой исключительный путь, так что всякие глупые мелочи, такие как неправильно написанное имя переменной внутри <code>rescue</code> блока, не приводят к падению вашего приложения (это случалось со мной так много раз - серьезно, просто проверяйте свои <code>rescue</code> блоки). </p> <hr><h2>Что делать с ошибками, которые мы получаем</h2> <p>Я видел такой код бесчисленное количество раз в течение многих лет:</p> <pre class="brush: ruby noskimlinks noskimwords">begin  widgetron.createrescue  # don"t need to do anythingend</pre> <p>Мы спасаем исключение и ничего не делаем с ним. Это почти всегда плохая идея. Когда вы шесть месяцев отлаживаете проблеме в продакшене, пытаясь понять, почему ваш «widgetron» не появляется в базе данных, вы не будете помнить, что последуют невинные комментарии и часы разочарования.</p> <p>Не проглатывайте исключения! По крайней мере, вы должны регистрировать любое исключение, которое вы ловите, например:</p> <pre class="brush: ruby noskimlinks noskimwords">begin  foo.barrescue =&gt; e  Rails.logger.error { "#{e.message} #{e.backtrace.join("\n")}" }end</pre> <p>Таким образом, мы сможем просмотреть логи, и у нас будет причина проблемы и трассировка ошибки.</p> <p>Еще лучше, вы будете использовать службу мониторинга ошибок, такую как <span>Rollbar</span>. У нее есть много преимуществ:</p> <ul><li>Ваши сообщения об ошибках не чередуются с другими сообщениями лога</li> <li>Вы получите статистику о том, как часто происходит одна и та же ошибка (так что вы можете выяснить, является ли это серьезной проблемой или нет)</li> <li>Вы можете отправить дополнительную информацию вместе с ошибкой, чтобы помочь себе диагностировать проблему</li> <li>Вы можете получать уведомления (по электронной почте, pagerduty и т.д.), Когда в вашем приложении возникают ошибки</li> <li>Вы можете отслеживать развертывания, чтобы увидеть, когда были введены или исправлены определенные ошибки</li> <li>и т.п.</li> </ul><pre class="brush: ruby noskimlinks noskimwords">begin  foo.barrescue =&gt; e  Rails.logger.error { "#{e.message} #{e.backtrace.join("\n")}" }  Rollbar.report_exception(e)end</pre> <p>Разумеется, вы можете использовать и логи и службу мониторинга, как указано выше.</p> <p>Если ваш <code>rescue</code> блок является последним в методе, я рекомендую использовать явный возврат:</p> <pre class="brush: ruby noskimlinks noskimwords">def my_method  begin    foo.bar  rescue =&gt; e    Rails.logger.error { "#{e.message} #{e.backtrace.join("\n")}" }    Rollbar.report_exception(e)    nil  endend</pre> <p>Вы не всегда можете возвращать <code>nil</code>, иногда вам может быть удобнее продолжить работу с <span>null объектом</span> или что-то еще будет иметь смысл в контексте вашего приложения. Постоянное использование явных возвращаемых значений сэкономит вам кучу времени.</p> <p>Вы также можете повторно выбросить ту же ошибку или другую в своем <code>rescue</code> спасательном. Один шаблон, который я часто считаю полезным, - это обернуть существующее исключение в новое и выбросить его, чтобы не потерять исходную трассировку стека (я даже написал для <span>этого gem</span>, поскольку Ruby не предоставляет эту функциональность из коробки ). Позже в статье, когда мы говорим о внешних сервисах, я покажу вам, почему это может быть полезно.</p> <hr><h2>Глобальная обработка ошибок</h2> <p>Rails позволяет указать, как обрабатывать запросы для ресурсов определенного формата (HTML, XML, JSON) с помощью <code>response_to</code> и <code>reply_with</code>. Я редко вижу приложения, которые правильно используют эту функциональность, ведь если вы не используете блок <code>response_to</code>, все работает отлично, а Rails правильно отображает ваш шаблон. Мы попали в наш контроллер твитов через <code>/tweets/yukihiro_matz</code> и получили HTML-страницу, полную последних твитов <span>Matzs</span>. То, что люди часто забывают, состоит в том, что очень легко попробовать и запросить другой формат того же ресурса, например. <code>/tweets/yukihiro_matz.json</code>. В этот момент Rails будет мужественно пытаться вернуть JSON-представление твитов Matzs, но это не будет хорошо, так как представление для него не существует. Будет выброшена ошибка <code>ActionView::MissingTemplate</code>, и наше приложение эффектно упадет. А JSON является вполне законным форматом, в приложении с высоким трафиком вы также можете получить запрос на <code>/tweets/yukihiro_matz.foobar</code>. <span>Tuts +</span> получает все такие запросы все время (вероятно, из-за ботов, пытающихся быть умными). </p> <p>Урок заключается в том, что если вы не планируете возвращать такой ответ для определенного формата, запретите вашим контроллерам пытаться выполнить запросы для этих форматов. В случае нашего <code>TweetsController</code>:</p> <pre class="brush: ruby noskimlinks noskimwords">class TweetsController &lt; ApplicationController  respond_to :html  def show    ...    respond_to do |format|      format.html    end  endend</pre> <p>Теперь, когда мы получаем запросы на ложные форматы, мы получим более релевантную ошибку <code>ActionController::UnknownFormat</code>. Наши контроллеры чувствуют себя несколько более напряженными, что очень важно, когда речь заходит о том, чтобы сделать их более надежными. </p> <h3>Обработка ошибок Rails Way</h3> <p>Проблема, которую мы имеем сейчас, заключается в том, что, несмотря на нашу семантически приятную ошибку, наше приложение все еще падает. Здесь на помощь происходит глобальная обработка исключений. Иногда наше приложение будет создавать ошибки, на которые мы хотим реагировать последовательно, независимо от того, откуда они происходят (например, наш <code>ActionController::UnknownFormat</code>). Есть также ошибки, которые могут быть выброшены фреймворком до того, как наш собственный код вступит в игру. Прекрасным примером этого является <code>ActionController::RoutingError</code>. Когда кто-то запрашивает URL-адрес, который не существует, например <code>/tweets2/yukihiro_matz</code>, нам некуда заходить, чтобы спасти эту ошибку, используя традиционную обработку исключений. Здесь появляется исключение <code>exceptions_app</code> Rails. </p> <p>Вы можете настроить приложение <span>Rack</span> в <code>application.rb</code> для вызова, когда создается ошибка, которую мы не обрабатываем (например, наша <code>ActionController::RoutingError</code> или <code>ActionController::UnknownFormat</code>). Обычно это <span>используется для настройки</span> маршрутов вашего приложения как <code>exceptions_app</code>, а затем вы определяете различные маршруты для ошибок, которые вы хотите обработать, и перенаправояете их на специальный созданный вами контроллер ошибок. Итак, наш <code>application.rb</code> будет выглядеть так:</p> <pre class="brush: ruby noskimlinks noskimwords">...config.exceptions_app = self.routes...</pre> <p>Затем наш <code>routes.rb</code> будет содержать следующее:</p> <pre class="brush: ruby noskimlinks noskimwords">...match "/404" =&gt; "errors#not_found", via: :allmatch "/406" =&gt; "errors#not_acceptable", via: :allmatch "/500" =&gt; "errors#internal_server_error", via: :all...</pre> <p>В этом случае наш <code>ActionController::RoutingError</code> будет вызван по маршруту <code>404</code>, а <code>ActionController::UnknownFormat</code> по маршруту <code>406</code>. Существует <span>много возможных ошибок</span>, которые могут возникнуть. Но пока вы обрабатываете общие (<code>404</code>, <code>500</code>, <code>422</code> и т.д.), Вы можете добавить другие по мере того как они будут возникать.</p> <p>Внутри нашего контроллера ошибок мы теперь можем отображать соответствующие шаблоны для каждого типа ошибок вместе с нашим макетом (если это не 500) для поддержания брендинга. Мы также можем регистрировать ошибки и отправлять их в <span>нашу службу мониторинга</span>, хотя большинство служб мониторинга автоматически подключаются к этому процессу, поэтому вам не нужно отправлять ошибки самостоятельно. Теперь, когда наше приложение падает, оно делает это нежно, с правильным кодом статуса в зависимости от ошибки и страницы, где мы можем дать пользователю некоторую информацию касательно того, что произошло, и что они могут сделать (контакты поддержки). Что еще более важно, так это то что наше приложение будет казаться (и будет на самом деле) гораздо более надежным.</p> <h3>Несколько ошибок одного типа в контроллере</h3> <p>В любом контроллере Rails мы можем определять конкретные ошибки, которые должны обрабатываться глобально внутри этого контроллера (независимо от того, какое действие они производят) - мы делаем это с помощью <span>rescue_from</span>. Вопрос в том, когда использовать <code>rescue_from</code>? Обычно я считаю, что хороший шаблон - использовать его для ошибок, которые могут возникать в нескольких действиях (например, одна и та же ошибка в нескольких действиях). Если ошибка будет произведена только одним действием, обработайте ее с помощью традиционного механизма <code>begin ... rescue ... end</code>, но если мы, вероятно, получим ту же ошибку в нескольких местах, и мы хотим обрабатывать ее таким же образом - это хороший кандидат на <code>rescue_from</code>. Допустим, что у нашего <code>TweetsController</code> также есть  действие <code>create</code>:</p> <pre class="brush: ruby noskimlinks noskimwords">class TweetsController &lt; ApplicationController  respond_to :html  def show    ...    respond_to do |format|      format.html    end  end  def create    ...  endend</pre> <p>Давайте также предположим, что оба эти действия могут столкнуться с <code>TwitterError</code>, и если это случится, мы хотим сообщить пользователю, что с Twitter что-то не так. Здесь <code>rescue_from</code> может оказаться очень удобным:</p> <pre class="brush: ruby noskimlinks noskimwords">class TweetsController &lt; ApplicationController  respond_to :html  rescue_from TwitterError, with: twitter_error  private  def twitter_error    render :twitter_error  endend</pre> <p>Теперь нам не нужно беспокоиться об этом в наших действиях, и они будут выглядеть намного чище, и мы можем/должны, конечно, регистрировать нашу ошибку и/или уведомлять нашу службу мониторинга ошибок в методе <code>twitter_error</code>. Если вы правильно используете <code>rescue_from</code>, это может не только помочь вам сделать ваше приложение более надежным, но и сделать ваш код контроллера более чистым. Это упростит поддержание и тестирование вашего кода, что сделает ваше приложение еще немного более гибким.</p> <hr><h2>Использование внешних служб в вашем приложении</h2> <p>В настоящее время сложно написать серьезное приложение без использования ряда внешних сервисов/API. В случае с нашим <code>TweetsController</code>, мы используем Twitter с помощью Ruby gem, который обертывает <span>API Twitter</span>. В идеале мы бы делали все наши внешние API-вызовы асинхронными, но мы не рассматриваем асинхронную обработку в этой статье.</p> <p>Выполнение сетевых вызовов - чрезвычайно сложная задача, и хорошая обработка исключений здесь является обязательной. Вы можете получить ошибки аутентификации, проблемы с конфигурацией и ошибки подключения. Библиотека, которую вы используете, может производить любое количество ошибок кода, а так же сведение может быть медленным. Я замалчиваю этот момент, но это так важно, так как вы не можете заниматься медленными соединениями с помощью обработки исключений. Вам необходимо соответствующим образом <span>настроить тайм-ауты</span> в своей сетевой библиотеке или если вы используете обертку API, убедитесь, что она предоставляет хуки для настройки тайм-аутов. Для пользователя нет худшего опыта, чем сидеть там, ожидая, пока ваше приложение не сообщит о том, что происходит. Почти каждый забывает настроить таймауты соответствующим образом (я знаю, что у меня есть), так что обратите внимание.</p> <p>Если вы используете внешнюю службу в нескольких местах в своем приложении (например, несколько моделей), вы подвергаете большую часть вашего приложения полному набору ошибок. Это неправильно. То, что мы хотим сделать, это ограничить такую возможность, и одним из способов, которым мы можем это сделать, является предоставление всего доступа к нашим внешним сервисам через <span>фасад</span>, ловить все ошибки там и повторно выбрасывать одну семантически соответствующую ошибку (например <code>TwitterError</code>, о которой мы говорили, когда пытаемся попасть в API Twitter). Затем мы можем легко использовать такие методы, как <code>rescue_from</code>, чтобы справиться с этими ошибками, и мы не раскрываем большую часть нашего приложения на неизвестное количество ошибок из внешних источников.</p> <p>Еще лучшая идея может заключаться в том, чтобы сделать ваш фасад API без ошибок. Верните все успешные ответы как есть и верните нулы или нулевые объекты, когда вы будете ловить какую-либо ошибку (нам все равно нужно регистрировать/уведомлять себя об ошибках с помощью некоторых методов, о которых мы говорили выше). Таким образом, нам не нужно смешивать различные типы потоков управления (поток управления исключением vs if ... else), что поможет нам получить значительно более чистый код. Например, давайте обернем наш доступ к API Twitter в объект <code>TwitterClient</code>:</p> <pre class="brush: ruby noskimlinks noskimwords">class TwitterClient  attr_reader :client  def initialize    @client = Twitter::REST::Client.new do |config|      config.consumer_key        = configatron.twitter.consumer_key      config.consumer_secret     = configatron.twitter.consumer_secret      config.access_token        = configatron.twitter.access_token      config.access_token_secret = configatron.twitter.access_token_secret    end  end  def latest_tweets(handle)    client.user_timeline(handle).map{|tweet| tweet.text}  rescue =&gt; e    Rails.logger.error { "#{e.message} #{e.backtrace.join("\n")}" }    nil  endend</pre> <p>Теперь мы можем сделать это: <code>TwitterClient.new.latest_tweets ("yukihiro_matz")</code> в любом месте нашего кода, и мы знаем, что этот вызов никогда не приведет к ошибке, или, скорее, никогда не будет распространять ошибку за пределами <code>TwitterClient</code>. Мы изолировали внешнюю систему, чтобы убедиться, что глюки в этой системе не поломают наше основное приложение.</p> <hr><h2>Но что, если у меня будет отличное покрытие тестами?</h2> <p>Если у вас есть хорошо протестированный код, я рекомендую вам приложить все усилия, и вам потребуется долгий путь к созданию более надежного приложения. Но хороший набор тестов часто может обеспечить ложное чувство безопасности. Хорошие тесты могут помочь вам реорганизовать с уверенностью и защитит вас от регрессии. Но вы можете писать тесты только для вещей, которые вы ожидаете. Ошибки по своей природе непредсказуемы. Чтобы использовать наш пример твитов, пока мы не захотим написать тест для нашего метода <code>fetch_tweets</code>, где <code>client.user_timeline(handle)</code> вызывает ошибку, заставляя нас обернуть <code>rescue</code> блок вокруг кода, все наши тесты будут зелеными, а наш код будет по-прежнему падать.</p> <p>Написание тестов не освобождает нас от ответственности за критический взгляд на наш код, чтобы выяснить, как этот код может сломаться. С другой стороны, такая оценка может определенно помочь нам написать лучшие, более полные наборы тестов.</p> <hr><h2>Заключение</h2> <p>Устойчивые приложения не пишутся за пару выходных дней. Обеспечение надежного приложения - это непрерывный процесс. Вы обнаруживаете ошибки, исправляете их и пишите тесты, чтобы убедиться, что они не вернутся. Когда ваше приложение падает из-за сбоя внешней системы, вы изолируете эту систему, чтобы убедиться, что сбой не сможет снова появиться. Обработка исключений - ваш лучший друг в этом деле. Даже самое подверженное ошибкам приложение может быть со временем ревращено в надежное, если вы будете последовательно применять хорошие практики обработки исключений.</p> <p>Конечно, обработка исключений - не единственный инструмент в вашем арсенале, когда нам нужно создавать устойчивые приложения. В последующих статьях мы расскажем об асинхронной обработке, о том, как и когда ее применять, и о том, что она может сделать с точки зрения устойчивости вашего приложения. Мы также рассмотрим некоторые рекомендации по развертыванию и инфраструктуре, которые могут оказать существенное влияние, не нарушая работу банка с точки зрения как денег, так и времени - следите за обновлениями. </p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825537-sozdanie-nadezhnyh-veb-prilozhenij--utrachennoe-iskusstvo-obrabotki-isklyuchenij" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Ruby" href="https://norma-studio.github.io/article5/220825537-sozdanie-nadezhnyh-veb-prilozhenij--utrachennoe-iskusstvo-obrabotki-isklyuchenij" class="tm-article-body__tags-item-link">Ruby</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
35050</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
479</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>


<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Далем тестирование проще вместе с Mockery... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Далем тестирование проще вместе с Mockery... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Далем тестирование проще вместе с Mockery... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Далем тестирование проще вместе с Mockery... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Горькой правдой является то, что хотя базовый принцип тестирования и выглядит довольно просто, но может оказаться довольно трудным занятием - использовать его в своем рабочем процессе изо дня в день. А разнообразный жаргон при этом еще больше все усугубляет! К счастью есть много инструментов, которые смогут упростить процесс тестирования. Mockery, ...">
<meta property="og:description" content="Горькой правдой является то, что хотя базовый принцип тестирования и выглядит довольно просто, но может оказаться довольно трудным занятием - использовать его в своем рабочем процессе изо дня в день. А разнообразный жаргон при этом еще больше все усугубляет! К счастью есть много инструментов, которые смогут упростить процесс тестирования. Mockery, ...">
<meta name="twitter:description" content="Горькой правдой является то, что хотя базовый принцип тестирования и выглядит довольно просто, но может оказаться довольно трудным занятием - использовать его в своем рабочем процессе изо дня в день. А разнообразный жаргон при этом еще больше все усугубляет! К счастью есть много инструментов, которые смогут упростить процесс тестирования. Mockery, ...">
<meta property="aiturec:description" content="Горькой правдой является то, что хотя базовый принцип тестирования и выглядит довольно просто, но может оказаться довольно трудным занятием - использовать его в своем рабочем процессе изо дня в день. А разнообразный жаргон при этом еще больше все усугубляет! К счастью есть много инструментов, которые смогут упростить процесс тестирования. Mockery, ...">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/legacy-premium-tutorials/posts/69600/images/69600_4a03bca3f7e49cbca093817a346da105.png">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/legacy-premium-tutorials/posts/69600/images/69600_4a03bca3f7e49cbca093817a346da105.png">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/legacy-premium-tutorials/posts/69600/images/69600_4a03bca3f7e49cbca093817a346da105.png">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/legacy-premium-tutorials/posts/69600/images/69600_4a03bca3f7e49cbca093817a346da105.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/legacy-premium-tutorials/posts/69600/images/69600_4a03bca3f7e49cbca093817a346da105.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825578-dalem-testirovanie-prosche-vmeste-s-mockery.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825578-dalem-testirovanie-prosche-vmeste-s-mockery.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825578-dalem-testirovanie-prosche-vmeste-s-mockery.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825578-dalem-testirovanie-prosche-vmeste-s-mockery.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825578-dalem-testirovanie-prosche-vmeste-s-mockery.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825578-dalem-testirovanie-prosche-vmeste-s-mockery.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825578-dalem-testirovanie-prosche-vmeste-s-mockery.html" title="Далем тестирование проще вместе с Mockery... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Далем тестирование проще вместе с Mockery... | envatomarket.ru | norma-studio.github.io" title="Далем тестирование проще вместе с Mockery... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/54332343.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825578-dalem-testirovanie-prosche-vmeste-s-mockery.html" class="tm-user-info__username" title="
В. Бухтеев" aria-label="
В. Бухтеев">
В. Бухтеев</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Далем тестирование проще вместе с Mockery...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825578-dalem-testirovanie-prosche-vmeste-s-mockery" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="PHP" href="https://norma-studio.github.io/article5/220825578-dalem-testirovanie-prosche-vmeste-s-mockery" class="tm-article-snippet__hubs-item-link"><span>PHP</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825578-dalem-testirovanie-prosche-vmeste-s-mockery.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/legacy-premium-tutorials/posts/69600/images/69600_4a03bca3f7e49cbca093817a346da105.png">
    <meta itemprop="headline name" content="Далем тестирование проще вместе с Mockery... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Горькой правдой является то, что хотя базовый принцип тестирования и выглядит довольно просто, но может оказаться довольно трудным занятием - использовать его в своем рабочем процессе изо дня в день. А разнообразный жаргон при этом еще больше все усугубляет! К счастью есть много инструментов, которые смогут упростить процесс тестирования. Mockery, ...">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Горькой правдой является то, что хотя базовый принцип тестирования и выглядит довольно просто, но может оказаться довольно трудным занятием - использовать его в своем рабочем процессе изо дня в день. А разнообразный жаргон при этом еще больше все усугубляет! К счастью есть много инструментов, которые смогут упростить процесс тестирования. Mockery, ...</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Горькой правдой является то, что хотя базовый принцип тестирования и выглядит довольно просто, но может оказаться довольно трудным занятием - использовать его в своем рабочем процессе изо дня в день. А разнообразный жаргон при этом еще больше все усугубляет! К счастью есть много инструментов, которые смогут упростить процесс тестирования. Mockery, главный фреймворк для создания mock объектов в PHP, является одним из таких инструментов!</p><p>В этой статье мы рассмотрим что вообще из себя представляют mock-объекты, чем они могут быть полезны и как внедрить Mockery в свой процесс тестирования.</p> <p><!--more--></p> <hr><h2>Разбираемся с mock-объектами</h2> <p>Mock-объект это ничто иное как просто тестовый жаргон, который означает симуляцию поведения реальных объектов. Проще говоря, часто во время тестирования, нам мы не хотим выполнять определенный метод. Вместо этого нам нужно просто убедиться, что метод был вызван.</p> <p>Рассмотрим на примере. Представим, что наш код дергает метод, который логирует данные в файл. Во время тестирования этой логики, вы скорее всего не захотите физически трогать файловую систему. Так как это может значительно замедлить скорость выполнения ваших тестов. В таких ситуациях лучше всего сделать mock вашего класса для работы с файловой системой, и вместо того, чтобы вручную прочитать файл и убедиться, что он был обновлен, мы просто проверяем что был вызван нужный метод в этом классе. Это и есть создание mock объекта! Этот термин больше ничего в себе не содержит. Просто симуляция поведения других объектов.</p> <blockquote> <p>Помните: жаргон - это всего лишь жаргон. Некогда не позволяйте запутанной терминологии сбить вас с пути изучения новых навыков.</p> </blockquote> <p>Особенно по мере развития процесса разработки - в том числе когда вы начинаете применять принцип единственной ответственности и использовать внедрение зависимостей - знакомство с mock-объектами быстро станет необходимым.</p> <blockquote> <p><strong>Mocks против Stubs</strong>: скорее всего вы все чаще будете встречать такие термины как <em>mock</em> и <em>stub</em>, часто причем они друг друга будут заменять. В действительности оба они используются для разных целей. Первый относится больше к процессу определения ожиданий и проверке требуемого поведения. Другими словами, mock-объект потенциально может привести к падению теста. С другой стороны stub объект - это просто набор данных в виде заглушки, который можно просто передать, чтобы удовлетворить определенные требования.</p> </blockquote> <p>Тестовая библиотека де-факто для PHP - PHPUnit поставляется со своим собственным API для создания mock-объектов, которое однако может оказаться весьма обременительным в использовании. Как вы наверняка успели убедиться, что чем сложнее будет тестировании, тем вероятнее всего, что разработчик его просто не будет делать.</p> <p>К счастью есть большое кол-во сторонних решеней, доступных через Packagist (репозиторий пакетов для Composer), которые позволяют повысить читабельность тестов, а так же упростить само их <em>написание</em>. И наверно самым значимым среди этих решений является библиотека Mockery, фреймворк для создания mock-объектов.</p> <p>Библиотека создана как альтернатива для тех, кто устал от слишком перегруженного синтаксиса PHPUnit, и является очень простой, но мощной. Как вы вскоре обнаружите, эта библиотека уже стала стандартом в индустрии современной разработки на PHP.</p> <hr><h2>Установка</h2> <div class="tutorial_image"> <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/legacy-premium-tutorials/posts/69600/images/69600_4a03bca3f7e49cbca093817a346da105.png" alt="Далем тестирование проще вместе с Mockery..." title="Далем тестирование проще вместе с Mockery..." width="50" height="50"><div><em>Как и множество других современных инструментов PHP, Mockery можно установить через Composer.</em></div> </div> <p>Как и большинство инструментов PHP в наши дни рекомендуется устанавливать библиотеку Mockery через Composer.</p> <blockquote> <p>Так, погодите, а что еще за <span>Composer</span>? Это сейчас предпочитаемый в PHP сообществе менеджер зависимостей. Он предоставляет простой способ определения зависимостей проекта, а так же возможность установить их всех одной командой. Как современный PHP-разработчик важно, что у вас есть базовое понимание является композитор и как его использовать.</p> </blockquote> <p>Если до этого никогда им не пользовались, то в целях обучения добавьте новый файл <code>composer.json</code> в пустой проект и заполните его следующим:</p> <pre class="brush: js noskimlinks noskimwords">    {        "require-dev": {            "mockery/mockery": "dev-master"        }    }</pre> <p>Первая часть JSON определяет, что для разработки вам требуется библиотека Mockery. Из командной строки выполняем команду <code>composer install --dev</code> и скачиваем библиотеку.</p> <pre class="brush: bash noskimlinks noskimwords">$ composer install --devLoading composer repositories with package informationInstalling dependencies (including require-dev)  - Installing mockery/mockery (dev-master 5a71299)    Cloning 5a712994e1e3ee604b0d355d1af342172c6f475fWriting lock file  Generating autoload files</pre> <blockquote> <p>И в качестве дополнительного бонуса Composer поставляется со своим собственным автозагрузчиком. Либо укажите список директорий в classmap и выполните <code>composer dump-autoload</code> или просто следуйте стандарту PSR-0 и просто следите за соблюдением структуры папок. Перейдите <span>сюда</span>, чтобы узнать побольше. Если вы до сих пор вручную подключается бесконечное количество файлов в каждом вашем PHP файле, то вероятнее всего вы что-то не так делаете.</p> </blockquote> <hr><h2>Дилемма</h2> <p>Перед тем как мы начнем реализацию решения, лучше всего еще раз просмотреть саму проблему. Допустим нам нужно реализовать систему для управления процессом генерации контента и записи его в лог файл. Возможно генератор выдает данные из разных источников, как например локальные файлы, так и веб сервисы, а затем данные записываются на файловую систему.</p> <p>Cледуя принципу единственной ответственности, который требует, <em>чтобы каждый класс имел только одну причину для изменения</em>, мы должны поделить нашу логику между двумя классами: один для генерации нужного контента, а другой - для физической записи данных в файл. Для этого нам потребуются классы <code>Generator</code> и <code>File</code>.</p> <blockquote> <p><strong>Совет:</strong> почему бы не использовать <code>file_put_contents</code> прямо в классе <code>Generator</code>? Хорошо, только сначала спросите себя: <em>"А как я это буду тестировать?"</em> Существуют различные техники, которые позволяют переопределить такие вещи, но хорошим тоном считается вместо этого сделать обертку над этот функционалом, чтобы потом можно было легко ее подменить, например с помощью Mockery!</p> </blockquote> <p>Вот базовая структура (с небольшой порцией псевдокода) нашего класса <code>Generator</code>.</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php // src/Generator.phpclass Generator {    protected $file;    public function __construct(File $file)    {        $this-&gt;file = $file;    }    protected function getContent()    {        // simplified for demo        return "foo bar";    }    public function fire()    {        $content = $this-&gt;getContent();        $this-&gt;file-&gt;put("foo.txt", $content);    }}</pre> <h3>Инъекция зависимости</h3> <p>Этот код использует то, что мы называем инъекцией зависимости. И еще раз, это всего лишь жаргон программистов для вставки зависимостей класса  через конструктор, вместо того чтобы их жестко прописывать в коде.</p> <p>Почему это выгодно? Потому что, в противном случае мы не сможем подменить класс <code>File</code>! Конечно мы сможем сделать заглушку для класса <code>File</code>, но если его инициализация жестко прописана в классе, который мы тестируем, то не будет никакой возможности подменить этот объект заглушкой.</p> <pre class="brush: php noskimlinks noskimwords">public function __construct(){    // anti-pattern    $this-&gt;file = new File;}</pre> <p>Лучший способ создания легко-тестируемого приложения- это перед каждым новым вызовом метода, задавать себе вопрос <em>"Каким образом я буду это тестировать?"</em> Хотя и существуют приемы для тестирования захардкоденных зависимостей, но использование их считается плохим тоном. Вместо этого лучше всегда встраивать зависимости через конструктор или через сеттер.</p> <p>Инъекция через сеттеры более-менее идентична инъекции через конструктор. Принцип совершенно одинаковый, единственная разница только в том, что зависимость встраивается не через метод конструктора, а через сеттер:</p> <pre class="brush: php noskimlinks noskimwords">public function setFile(File $file){    $this-&gt;file = $file;}</pre> <p>Общая критика инъекции зависимости сводится к тому, что такой подходит приводит к дополнительной сложности приложения, и все ради того, чтобы сделать его более тестируемым. Хотя сложность является спорным аргументом, по мнению автора, если вам нужно, можно внедрить инъекции зависимостей, при этом по-прежнему указывая резервные значения по умолчанию. Вот пример:</p> <pre class="brush: php noskimlinks noskimwords">class Generator {    public function __construct(File $file = null)    {        $this-&gt;file = $file ?: new File;    }}</pre> <p>Теперь если объект класса <code>File</code> будет передан через конструктор, то он и будет использоваться в классе. С другой стороны, если ничего не было передано, то класс <code>Generator</code> <em>сам инициализирует</em> нужный класс. Это позволяет делать такие вариации, как:</p> <pre class="brush: php noskimlinks noskimwords"># Class instantiates Filenew Generator;# Inject Filenew Generator(new File);# Inject a mock of File for testingnew Generator($mockedFile);</pre> <p>Продолжим дальше, и для целей этой статьи, сделаем класс <code>File</code> ничем иным, как простой оберткой над PHP функцией <code>file_put_contents</code>.</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php // src/File.phpclass File{    /**     * Write data to a given file     *     * @param  string $path     * @param  string $content     * @return mixed     */    public function put($path, $content)    {        return file_put_contents($path, $content);    }}</pre> <p>Разве не просто? Давайте напишем тест, чтобы увидеть в чем была проблема.</p> <pre class="brush: php noskimlinks noskimwords">&lt;?php // tests/GeneratorTest.phpclass GeneratorTest extends PHPUnit_Framework_TestCase {    public function testItWorks()    {        $file = new File;        $generator = new Generator($file);        $generator-&gt;fire();    }}</pre> <blockquote> <p>Обратите внимание, что данные примеры подразумевают, что необходимые классы были автоматически загружены с помощью Composer. В вашем файле <code>composer.json</code> можно дополнительно определить объект <code>autoload</code>, в котором можно объявить какие директории или классы нужно автоматически загружать. Никаких больше громоздких <code>require</code> выражений!</p> </blockquote> <p>Запускаем теперь <code>phpunit</code>, который вернет следующее:</p> <pre class="brush: bash noskimlinks noskimwords">OK (1 test, 0 assertions)</pre> <p>Зеленый. Это значит, чтоб мы можем перейти к следующей задаче, так ведь? Ну, не совсем. Хотя в действительности код и работает, но каждый раз при запуске наших тестов, в файловой системе будет создавать файл <code>foo.txt</code>. А что будет, когда у вас будут еще десятки тестов? Легко представить, что очень быстро скорость выполнения ваших тестов от этого пострадает.</p> <div class="tutorial_image"> <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/legacy-premium-tutorials/posts/69600/images/69600_10903430b2785e5bacfae77b9575c7ab.png" alt="Далем тестирование проще вместе с Mockery..." title="Далем тестирование проще вместе с Mockery..." width="50" height="50"><div><em>Хотя тесты и завершились успешно, но они затронули файловую систему.</em></div> </div> <p>Все еще сомневаетесь? Если вас не стесняет уменьшение скорости выполнения тестов, то рассмотрим общий случай. Подумайте об этом: мы тестируем класс <code>Generator</code>; так зачем мы выполняем код в классе <code>File</code>? Он же должен иметь свои собственные тесты! Так с чего ради мы будем дублировать их?</p> <hr><h2>Решение</h2> <p>Надеюсь, что предыдущий раздел дал исчерпывающее объяснение того, зачем нужные mock-объекты. Как и было упомянуто ранее, хотя мы и можем использовать нативное API от PHPUnit, но оно является не самым удобным в работе. Чтобы продемонстрировать это, вот пример проверки того, что mock-объект получает вызов метода <code>getName</code> и возвращает <code>John Doe</code>.</p> <pre class="brush: php noskimlinks noskimwords">public function testNativeMocks(){    $mock = $this-&gt;getMock("SomeClass");    $mock-&gt;expects($this-&gt;once())         -&gt;method("getName")         -&gt;will($this-&gt;returnValue("John Doe"));}</pre> <p>А теперь добавим в проверку условие, что метод <code>getName</code> будет вызван только один раз и вернет <em>John Doe</em> - реализация PHPUnit выглядит уж слишком громоздкой. С помощью Mockery мы можем значительно повысить читабельность.</p> <pre class="brush: php noskimlinks noskimwords">public function testMockery(){    $mock = Mockery::mock("SomeClass");    $mock-&gt;shouldReceive("getName")         -&gt;once()         -&gt;andReturn("John Doe");}</pre> <p>Обратите внимание как предыдущий пример теперь гораздо легче читается.</p> <p>В продолжение примера из предыдущего раздела "<em>Дилемма</em>", на этот раз в классе <code>GeneratorTest</code>, давайте сделаем mock объект и симулируем поведение класса <code>File</code> с помощью библиотеки Mockery. Вот обновленный код:</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass GeneratorTest extends PHPUnit_Framework_TestCase {    public function tearDown()    {        Mockery::close();    }    public function testItWorks()    {        $mockedFile = Mockery::mock("File");        $mockedFile-&gt;shouldReceive("put")                   -&gt;with("foo.txt", "foo bar")                   -&gt;once();        $generator = new Generator($mockedFile);        $generator-&gt;fire();    }}</pre> <blockquote> <p>Вас смущает вызов <code>Mockery::close()</code>  в методе <code>tearDown</code>? Этот статический вызов очищает контейнер Mockery, который используется в тестах, и выполняет все задачи по проверки ваших утверждений.</p> </blockquote> <p>Можно получить mock-объект класса с помощью метода <code>Mockery::mock()</code>. Затем, обычно нужно указать какие методы у этого объекта мы ожидаем, что будут вызваны, вместе с любыми необходимыми аргументами. Это можно сделать с помощью методов <code>shouldReceive(METHOD)</code> и <code>with(ARG)</code>.</p> <p>В это случае, когда мы вызываем <code>$generate-&gt;fire()</code>, то проверяем, что будет вызван метод <code>put</code> у экземпляра <code>File</code>, которому будет передан путь к файлу <code>foo.txt</code> и данные <code>foo bar</code>.</p> <pre class="brush: php noskimlinks noskimwords">// libraries/Generator.phppublic function fire(){    $content = $this-&gt;getContent();    $this-&gt;file-&gt;put("foo.txt", $content);}</pre> <p>Так как мы используем инъекцию зависимости, то теперь мы используем заглушку вместо реального объекта <code>File</code>.</p> <pre class="brush: php noskimlinks noskimwords">$generator = new Generator($mockedFile);</pre> <p>Если мы снова запустим тесты, они снова будут зеленые, хотя класс <code>File</code> и соответственно сама файловая система не были задействованы. Так как нет никакой необходимости в вызове класса <code>File</code>. У него должны быть свои собственные тесты! Делаем закглушки до победы!</p> <h3>Простые Mock Объекты</h3> <p>Mock-объекты не обязаны всегда ссылаться на какой-либо класс. Если требуется только простой объект, например пользователь, то можно просто передать массив в метод <code>mock</code> - где для каждой пары ключ-значение будет создан соответсвующий метод, который будет возвращать соответствующее значение.</p> <pre class="brush: php noskimlinks noskimwords">public function testSimpleMocks(){    $user = Mockery::mock(["getFullName" =&gt; "Jeffrey Way"]);    $user-&gt;getFullName(); // Jeffrey Way}</pre> <h3>Возвращение Значений Из Закоманных Методов</h3> <p>Наверняка будет такая ситуация, когда потребуется из замоканного метода класса вернуть значение. Продолжая на нашем примере с Generator/File классами, что если нам нужно будет убедиться, что если файл уже существует, то он не будет перезаписан? Как мы это сможем реализовать?</p> <p>Решением этого будет использование метода <code>andReturn</code> у замоканного объекта для имитации различных <em>состояний</em>. Вот обновленный пример:</p> <pre class="brush: php noskimlinks noskimwords">public function testDoesNotOverwriteFile(){    $mockedFile = Mockery::mock("File");    $mockedFile-&gt;shouldReceive("exists")               -&gt;once()               -&gt;andReturn(true);    $mockedFile-&gt;shouldReceive("put")               -&gt;never();    $generator = new Generator($mockedFile);    $generator-&gt;fire();}</pre> <p>Этот обновленный код теперь проверяет, что метод <code>exists</code> будет вызван у замоканного класса <code>File</code>, и для целей прохождения теста, он должен будет вернуть <code>true</code>, тем самым показывая что файл уже существует и не должен быть перезаписан. Затем мы проверяем, что в подобных этой ситуациях, метод <code>put</code> у класса <code>File</code> никогда не будет вызван. В Mockery это легко сделать с помощью метода <code>never()</code>.</p> <pre class="brush: php noskimlinks noskimwords">$mockedFile-&gt;shouldReceive("put")           -&gt;never();</pre> <p>Нам следует запустить тесты снова, и будет возвращена ошибка:</p> <pre class="brush: php noskimlinks noskimwords">Method exists() from File should be called exactly 1 times but called 0 times.</pre> <p>Ага! тест ожидает, что будет вызван метод <code>$this-&gt;file-&gt;exists()</code>, но этого никогда не происходит. И поэтому тест завершается неудачей. Исправим это!</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass Generator {    protected $file;    public function __construct(File $file)    {        $this-&gt;file = $file;    }    protected function getContent()    {        // simplified for demo        return "foo bar";    }    public function fire()    {        $content = $this-&gt;getContent();        $file = "foo.txt";        if (! $this-&gt;file-&gt;exists($file))        {            $this-&gt;file-&gt;put($file, $content);        }    }}</pre> <p>Это все, что потребуется сделать! Хотя мы и не следовали циклу разработки через тестирование (TDD), но наши тесты снова зеленые!</p> <blockquote> <p>Важно помнить, что подобный стиль тестирования эффективен, если вы так же хорошо тестируете зависимости ваших классов! Иначе, несмотря на то, что тести зеленые, на боевом сервере код может сломаться. Наша демонстрация проверяет только то, что класс <code>Generator</code> работает, как и ожидается. Не забудьте также протестировать и класс <code>File</code>!</p> </blockquote> <hr><h2>Ожидания</h2> <p>Давайте поглубже рассорим объявления различных ожиданий в Mockery. Вы уже знакомы с <code>shouldReceive</code>. Будьте осторожны с ним, так как его имя может немного ввести в заблуждение. Когда он один используется, то это не означает что метод обязательно следует вызвать. По умолчанию ожидается ноль или более раз (<code>zeroOrMoreTimes()</code>). Чтобы проверить требования к методу, быть вызванным один или более раз, есть несколько опций на выбор:</p> <pre class="brush: php noskimlinks noskimwords">$mock-&gt;shouldReceive("method")-&gt;once();$mock-&gt;shouldReceive("method")-&gt;times(1);$mock-&gt;shouldReceive("method")-&gt;atLeast()-&gt;times(1);</pre> <p>Могут быть случаи, когда понадобятся дополнительные ограничения. Как было показано ранее, они могут оказаться полезными в тех случаях, когда нужно проверить, что был вызван определенный метод с необходимым аргументами. Важно помнить, кто ожидание будет верным, то если метод будет вызван именно с этими аргументами.</p> <p>Вот несколько примеров.</p> <pre class="brush: php noskimlinks noskimwords">$mock-&gt;shouldReceive("get")-&gt;withAnyArgs()-&gt;once(); // the default$mock-&gt;shouldReceive("get")-&gt;with("foo.txt")-&gt;once();$mock-&gt;shouldReceive("put")-&gt;with("foo.txt", "foo bar")-&gt;once();</pre> <p>Этот пример можно расширить еще больше и сделать значения аргументов динамическими. Например, нам нужно проверить, что в метод была передана строка:</p> <pre class="brush: php noskimlinks noskimwords">$mock-&gt;shouldReceive("get")-&gt;with(Mockery::type("string"))-&gt;once();</pre> <p>Или же аргумент нужно проверить с помощью регулярного выражения. Проверим, чтобы имя файла заканчивалось на <code>.txt</code>.</p> <pre class="brush: php noskimlinks noskimwords">$mockedFile-&gt;shouldReceive("put")           -&gt;with("/\.txt$/", Mockery::any())           -&gt;once();</pre> <p>Ну и в последнем примере позволим использовать массив доступных значений для аргумента с помощью <code>anyOf</code>.</p> <pre class="brush: php noskimlinks noskimwords">$mockedFile-&gt;shouldReceive("get")           -&gt;with(Mockery::anyOf("log.txt", "cache.txt"))           -&gt;once();</pre> <p>В этом примере ожидание будет истинно, только если аргумент, переданный в метод <code>get</code> будет иметь значение <code>log.txt</code> или <code>cache.txt</code>. Иначе Mockery выбросит исключение во время выполнения тестов.</p> <pre class="brush: bash noskimlinks noskimwords">Mockery\Exception\NoMatchingExpectationException: No matching handler found...</pre> <blockquote> <p><strong>Совет:</strong> не забывайте, что вы всегда можете задать псевдоним для <code>Mockery</code>, например <code>m</code>, чтобы сделать код более локаничным: <code>use Mockery as m</code>; Теперь можно использовать более лакончиные конструкции: <code>m:mock()</code>.</p> </blockquote> <p>И наконец у нас есть множество способов указать, что замоканный метод должен возвращать. Например, нам нужно, чтобы он возвращал булево значение. Запросто:</p> <pre class="brush: php noskimlinks noskimwords">$mock-&gt;shouldReceive("method")     -&gt;once()     -&gt;andReturn(false);</pre> <hr><h2>Частичные Моки</h2> <p>Могут быть ситуации, когда необходимо сделать заглушку только для одного единственного метода, а не всего объекта целиком. Представим, для целей нашего примера, что метод в нашем классе ссылается на глобальную функцию, чтобы получить значение из файла с конфигурацией.</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass MyClass {    public function getOption($option)    {        return config($option);    }    public function fire()    {        $timeout = $this-&gt;getOption("timeout");        // do something with $timeout    }}</pre> <p>Хотя и существуют разные техники, чтобы сделать заглушки глобальных функций. Но все же, лучше избежать вызова этого метода. Именно в такие моменты приходят на помощь частичные моки.</p> <pre class="brush: php noskimlinks noskimwords">public function testPartialMockExample(){    $mock = Mockery::mock("MyClass[getOption]");    $mock-&gt;shouldReceive("getOption")         -&gt;once()         -&gt;andReturn(10000);    $mock-&gt;fire();}</pre> <p>Обратите внимание, как мы передали в квадратных скобках имя метода, который необходимо замокать. Если таких методов несколько, то просто перечислим их через запятую:</p> <pre class="brush: php noskimlinks noskimwords">$mock = Mockery::mock("MyClass[method1, method2]");</pre> <p>С таким объявлением остальные методы объекта будут вести себя при вызове как обычно. Обратите внимание, что всегда нужно определить поведение ваших замоканных методов, как мы делали это выше. В данном случае, когда будет вызван метод <code>getOption</code>, то вместо того, чтобы выполнять код внутри него, мы просто вернем <code>10000</code>.</p> <p>Альтернативным вариантом использования частичных моков, может быть состояние замоканного объекта по умолчанию: когда все методы ссылаются на родительский класс, пока для них не будет указано какое-нибудь ожидание.</p> <p>Предыдущий код можно переписать так:</p> <pre class="brush: php noskimlinks noskimwords">public function testPassiveMockExample(){    $mock = Mockery::mock("MyClass")-&gt;makePartial();    $mock-&gt;shouldReceive("getOption")         -&gt;once()         -&gt;andReturn(10000);    $mock-&gt;fire();}</pre> <p>В этом примере все методы класса <code>MyClass</code> будут вести себя как обычно, кроме метода <code>getOption</code>, который будет подделан и будет возвращать 10000.</p> <hr><h2>Hamcrest</h2> <div class="tutorial_image"> <img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" class="lazy07" data-src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/legacy-premium-tutorials/posts/69600/images/69600_ef393034bb1449a04d276109860436df.png" alt="Далем тестирование проще вместе с Mockery..." title="Далем тестирование проще вместе с Mockery..." width="50" height="50"><div><em>Библиотека Hamcrest предоставляет дополнительный набор проверок для определения ожиданий.</em></div> </div> <p>Как только вы хорошо освоитесь с Mockery API, рекомендуется так же начать использовать библиотеку Hamcrest, которая предоставляет дополнительный набор конструкций для определения хорошо читальных ожиданий. Как и Mockery, ее можно установить через Composer.</p> <pre class="brush: js noskimlinks noskimwords">"require-dev": {    "mockery/mockery": "dev-master",    "davedevelopment/hamcrest-php": "dev-master"}</pre> <p>После установки, вы сможете начать использовать более читабельные конструкции в ваших тестах. Ниже приведено несколько примеров, включая небольшие вариации для достижения одного результата.</p> <pre class="brush: php noskimlinks noskimwords">&lt;?phpclass HamCrestTest extends PHPUnit_Framework_TestCase {    public function testHamcrestMatchers()    {        $name = "Jeffrey";        $age = 28;        $hobbies = ["coding", "guitar", "chess"];        assertThat($name, is("Jeffrey"));        assertThat($name, is(not("Joe")));        assertThat($age, is(greaterThan(20)));        assertThat($age, greaterThan(20));        assertThat($age, is(integerValue()));        assertThat(new Foo, is(anInstanceOf("Foo")));        assertThat($hobbies, is(arrayValue()));        assertThat($hobbies, arrayValue());        assertThat($hobbies, hasKey("coding"));    }}</pre> <p>Обратите внимание, как Hamcrest позволяет записывать ваши проверки таким образом, что они максимально отражают ваши ожидания. Использование функции <code>is()</code> является всего лишь синтаксическим сахаром для достижения лучшей читабельности.</p> <p>Вы вскоре обнаружите, что Mockery достаточно хорошо сосчитается вместе с Hamcrest. Например, если использовать только Mockery, то чтобы записать, что замоканный метод нужно будет вызвать с одним только аргументом типа <code>string</code>, следует выполнить следующее:</p> <pre class="brush: php noskimlinks noskimwords">$mock-&gt;shouldReceive("method")     -&gt;with(Mockery::type("string"))     -&gt;once();</pre> <p>Используя же Hamcrest, конструкцию <code>Mockery::type</code> можно заменить на <code>stringValue()</code> следующим образом:</p> <pre class="brush: php noskimlinks noskimwords">$mock-&gt;shouldReceive("method")     -&gt;with(stringValue())     -&gt;once();</pre> <p>Hamcrest позволяет использовать <em>resourceValue</em>-соглашение для сравнения типа значения.</p> <ul><li><code>nullValue</code></li> <li><code>integerValue</code></li> <li><code>arrayValue</code></li> <li><em>rinse и repeat</em></li> </ul><p>Альтернативой для <code>Mockery::any()</code> при проверке на любой аргумент может стать <code>anything()</code>.</p> <pre class="brush: php noskimlinks noskimwords">$file-&gt;shouldReceive("put")     -&gt;with("foo.txt", anything())     -&gt;once();</pre> <hr><h2>Заключение</h2> <blockquote class="pullquote"><p>Самым большим препятствием для использования Mockery, является не само API.</p></blockquote> <p>А понимание того, зачем и когда использовать моки в ваших тестах.</p> <p>Суть заключается в том, чтобы изучить и начать соблюдать принцип единственной ответственности в рабочем процессе написания кода. По определению Боба Мартина принцип единственной ответственности гласит, что класс <em>должен иметь только одну причину для изменения</em>. Иными словами нельзя вносит в класс изменения, чтобы удовлетворить различные, несвязанные между собой изменения в приложении, как например изменения в бизнес процессах, или то, как форматируется вывод, или каким образом хранятся данные. В своей самой простой форме, такой как метод, класс должен делать только одну вещь.</p> <p>Класс <code>File</code> у нас занимается взаимодействием с файловой системой. Репозиторий <code>MysqlDb</code> сохраняет данные. Класс <code>Email</code> занимается отправкой писем. Обратите внимание, что ни в одном из этих примеров не использовалось слово <em>И</em>.</p> <p>Как только вы это поймете, то процесс тестирования станет гораздо проще. Для всех операций, который не попадают под <em>тень</em> класса, следует использовать инъекцию зависимостей. При тестировании, важно сфокусироваться на одном классе, и замокать всего необходимые зависимости. Вы не должны тестировать их все, для остальных классов должны быть свои собственные тесты!</p> <p>Хотя ничто не может препятствовать вам использовать родную реализацию создания моков в PHPUnit, но почему мы не воспользоваться гораздо более читабельной и удобной версией от Mockery?</p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825578-dalem-testirovanie-prosche-vmeste-s-mockery" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="PHP" href="https://norma-studio.github.io/article5/220825578-dalem-testirovanie-prosche-vmeste-s-mockery" class="tm-article-body__tags-item-link">PHP</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
36519</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
352</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

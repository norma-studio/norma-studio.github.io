
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>SQL для начинающих Часть 2... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="SQL для начинающих Часть 2... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="SQL для начинающих Часть 2... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="SQL для начинающих Часть 2... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="Для каждого веб-разработчика важно знать взаимодействие с базами данных. Во второй части курса мы продолжим изучение языка SQL и применим то, что мы узнали в базе данных MySQL. Мы узнаем об индексах, типах данных и более сложных структурах запросов....">
<meta property="og:description" content="Для каждого веб-разработчика важно знать взаимодействие с базами данных. Во второй части курса мы продолжим изучение языка SQL и применим то, что мы узнали в базе данных MySQL. Мы узнаем об индексах, типах данных и более сложных структурах запросов....">
<meta name="twitter:description" content="Для каждого веб-разработчика важно знать взаимодействие с базами данных. Во второй части курса мы продолжим изучение языка SQL и применим то, что мы узнали в базе данных MySQL. Мы узнаем об индексах, типах данных и более сложных структурах запросов....">
<meta property="aiturec:description" content="Для каждого веб-разработчика важно знать взаимодействие с базами данных. Во второй части курса мы продолжим изучение языка SQL и применим то, что мы узнали в базе данных MySQL. Мы узнаем об индексах, типах данных и более сложных структурах запросов....">
<meta property="og:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_1.png">
<meta property="aiturec:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_1.png">
<meta name="twitter:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_1.png">
<meta property="vk:image" content="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_1.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_1.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825737-sql-dlya-nachinayuschih-chast-2.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825737-sql-dlya-nachinayuschih-chast-2.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825737-sql-dlya-nachinayuschih-chast-2.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825737-sql-dlya-nachinayuschih-chast-2.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825737-sql-dlya-nachinayuschih-chast-2.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825737-sql-dlya-nachinayuschih-chast-2.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825737-sql-dlya-nachinayuschih-chast-2.html" title="SQL для начинающих Часть 2... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="SQL для начинающих Часть 2... | envatomarket.ru | norma-studio.github.io" title="SQL для начинающих Часть 2... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/54332343.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825737-sql-dlya-nachinayuschih-chast-2.html" class="tm-user-info__username" title="
В. Бухтеев" aria-label="
В. Бухтеев">
В. Бухтеев</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>SQL для начинающих Часть 2...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825737-sql-dlya-nachinayuschih-chast-2" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="Databases" href="https://norma-studio.github.io/article5/220825737-sql-dlya-nachinayuschih-chast-2" class="tm-article-snippet__hubs-item-link"><span>Databases</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825737-sql-dlya-nachinayuschih-chast-2.html" />
    <link itemprop="image" href="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_1.png">
    <meta itemprop="headline name" content="SQL для начинающих Часть 2... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="Для каждого веб-разработчика важно знать взаимодействие с базами данных. Во второй части курса мы продолжим изучение языка SQL и применим то, что мы узнали в базе данных MySQL. Мы узнаем об индексах, типах данных и более сложных структурах запросов....">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">Для каждого веб-разработчика важно знать взаимодействие с базами данных. Во второй части курса мы продолжим изучение языка SQL и применим то, что мы узнали в базе данных MySQL. Мы узнаем об индексах, типах данных и более сложных структурах запросов....</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>Для каждого веб-разработчика важно знать взаимодействие с базами данных. Во второй части <span>курса</span> мы продолжим изучение языка SQL и применим то, что мы узнали в базе данных MySQL. Мы узнаем об индексах, типах данных и более сложных структурах запросов.</p><p><!--more--></p> <h3>Что вам понадобится</h3> <p>Пожалуйста, обратитесь к разделу «Что вам понадобится» в первой статье здесь: <span>SQL для начинающих (часть 1)</span>.</p> <p>Если вы хотите следовать примерам в этой статье на своем собственном сервере разработки, выполните следующие действия:</p> <ol><li>Откройте консоль MySQL и войдите в систему.</li> <li>Если вы еще этого не сделали, создайте базу данных с именем «my_first_db» запросом CREATE.</li> <li>Переключитесь в базу данных с помощью оператора USE.</li> </ol><div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_1.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <h3>Индексы базы данных</h3> <p>Индексы (или ключи) в основном используются для повышения скорости операций поиска данных (например, SELECT) в таблицах.</p> <p>Они являются важной частью хорошего дизайна базы данных, ее сложно классифицировать как «оптимизацию». В большинстве случаев они включаются в начальный проект, но их также можно добавить позже запросом ALTER TABLE.</p> <p>Наиболее распространенными причинами индексирования столбцов базы данных являются:</p> <ul><li>Почти каждая таблица должна иметь индекс PRIMARY KEY, обычно как столбец «id».</li> <li>Если ожидается, что столбец содержит уникальные значения, он должен иметь индекс UNIQUE.</li> <li>Если вы часто будете выполнять поиск по столбцу (с использованием WHERE), он должен иметь регулярный индекс.</li> <li>Если столбец используется для связи с другой таблицей, он должен иметь FOREIGN KEY, если это возможно, или иметь обычный индекс в противном случае.</li> </ul><h4>PRIMARY KEY</h4> <p>Почти каждая таблица должна иметь PRIMARY KEY, в большинстве случаев как INT с опцией AUTO_INCREMET.</p> <p>Если вы вспомнили <span>первую статью</span>, мы создали поле user_id в таблице users, и это был PRIMARY KEY. Таким образом, в веб-приложении мы можем ссылаться на всех пользователей по их номерам идентификаторов. </p> <p>Значения, хранящиеся в столбце PRIMARY KEY, должны быть уникальными. Кроме того, на каждой таблице не может быть больше одного PRIMARY KEY.</p> <p>Давайте посмотрим пример запроса, создав таблицу для списка штатов США:</p> <pre class="brush: html noskimlinks noskimwords">CREATE TABLE states (  id INT AUTO_INCREMENT PRIMARY KEY,name VARCHAR(20));</pre> <p>Он также может быть записан следующим образом:</p> <pre class="brush: html noskimlinks noskimwords">CREATE TABLE states (id INT AUTO_INCREMENT,name VARCHAR(20),PRIMARY KEY (id));</pre> <h4>UNIQUE</h4> <p>Поскольку мы ожидаем, что поле name будет уникальным значением, мы должны немного изменить предыдущий пример запроса:</p> <pre class="brush: html noskimlinks noskimwords">CREATE TABLE states (id INT AUTO_INCREMENT,name VARCHAR(20),PRIMARY KEY (id),UNIQUE (name));</pre> <p>По умолчанию индекс будет именоваться по имени столбца. Если вы хотите, вы можете присвоить ему другое имя:</p> <pre class="brush: html noskimlinks noskimwords">CREATE TABLE states (id INT AUTO_INCREMENT,name VARCHAR(20),PRIMARY KEY (id),UNIQUE state_name (name));</pre> <p>Теперь индекс называется «state_name» вместо «name».</p> <h4>INDEX</h4> <p>Предположим, мы хотим добавить столбец для представления года, в котором присоединился каждый штат.</p> <pre class="brush: html noskimlinks noskimwords">CREATE TABLE states (id INT AUTO_INCREMENT,name VARCHAR(20),join_year INT,PRIMARY KEY (id),UNIQUE (name),INDEX (join_year));</pre> <p>Я просто добавил столбец join_year и проиндексировал его. Этот тип индекса не имеет ограничения уникальности.</p> <p>Вы также можете назвать его KEY вместо INDEX.</p> <pre class="brush: html noskimlinks noskimwords">CREATE TABLE states (id INT AUTO_INCREMENT,name VARCHAR(20),join_year INT,PRIMARY KEY (id),UNIQUE (name),KEY (join_year));</pre> <h4>Подробнее о производительности</h4> <p>Добавление индекса уменьшает производительность запросов INSERT и UPDATE. Поскольку каждый раз, когда новые данные добавляются в таблицу, данные индекса также обновляются автоматически, что требует дополнительной работы. Производительность на запросы SELECT обычно намного превышает это. Но, тем не менее, не просто добавляйте индексы в каждый столбец таблицы, не задумываясь о запросах, которые вы будете запускать.</p> <h3>Пример таблицы</h3> <p>Прежде чем идти дальше с большим количеством запросов, я хотел бы создать примерную таблицу с некоторыми данными.</p> <p>Это будет список штатов США с их датами присоединения (дата, когда государство приняло Конституцию Соединенных Штатов или было принято в Союз) и их нынешнее население. Вы можете скопировать в консоль MySQL следующее:</p> <pre class="brush: html noskimlinks noskimwords">CREATE TABLE states (  id INT AUTO_INCREMENT,  name VARCHAR(20),  join_year INT,  population INT,  PRIMARY KEY (id),  UNIQUE (name),  KEY (join_year));INSERT INTO states VALUES(1, "Alabama", 1819, 4661900),(2, "Alaska", 1959, 686293),(3, "Arizona", 1912, 6500180),(4, "Arkansas", 1836, 2855390),(5, "California", 1850, 36756666),(6, "Colorado", 1876, 4939456),(7, "Connecticut", 1788, 3501252),(8, "Delaware", 1787, 873092),(9, "Florida", 1845, 18328340),(10, "Georgia", 1788, 9685744),(11, "Hawaii", 1959, 1288198),(12, "Idaho", 1890, 1523816),(13, "Illinois", 1818, 12901563),(14, "Indiana", 1816, 6376792),(15, "Iowa", 1846, 3002555),(16, "Kansas", 1861, 2802134),(17, "Kentucky", 1792, 4269245),(18, "Louisiana", 1812, 4410796),(19, "Maine", 1820, 1316456),(20, "Maryland", 1788, 5633597),(21, "Massachusetts", 1788, 6497967),(22, "Michigan", 1837, 10003422),(23, "Minnesota", 1858, 5220393),(24, "Mississippi", 1817, 2938618),(25, "Missouri", 1821, 5911605),(26, "Montana", 1889, 967440),(27, "Nebraska", 1867, 1783432),(28, "Nevada", 1864, 2600167),(29, "New Hampshire", 1788, 1315809),(30, "New Jersey", 1787, 8682661),(31, "New Mexico", 1912, 1984356),(32, "New York", 1788, 19490297),(33, "North Carolina", 1789, 9222414),(34, "North Dakota", 1889, 641481),(35, "Ohio", 1803, 11485910),(36, "Oklahoma", 1907, 3642361),(37, "Oregon", 1859, 3790060),(38, "Pennsylvania", 1787, 12448279),(39, "Rhode Island", 1790, 1050788),(40, "South Carolina", 1788, 4479800),(41, "South Dakota", 1889, 804194),(42, "Tennessee", 1796, 6214888),(43, "Texas", 1845, 24326974),(44, "Utah", 1896, 2736424),(45, "Vermont", 1791, 621270),(46, "Virginia", 1788, 7769089),(47, "Washington", 1889, 6549224),(48, "West Virginia", 1863, 1814468),(49, "Wisconsin", 1848, 5627967),(50, "Wyoming", 1890, 532668);</pre> <h3>GROUP BY: Группирование данных</h3> <p>GROUP BY группирует результирующие строки данных в группы. Вот пример:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=598/net/uploads/legacy/523_sql/ss_3.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>Так что же произошло? У нас есть 50 строк в таблице, но 34 результата были возвращены этим запросом. Это связано с тем, что результаты были сгруппированы по столбцу «join_year». Другими словами, мы видим только одну строку для каждого отдельного значения join_year. Так как в некоторых штатах есть одно и то же join_year, мы получили менее 50 результатов.</p> <p>Например, для 1787 года была только одна строка, но в этой группе есть 3 штата:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_4.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>Итак, здесь есть три штата, но только имя Delaware появилось после запроса GROUP BY. Фактически, это мог быть любой из трех штатов, и мы не можем полагаться на эту часть данных. Тогда в чем смысл использования предложения GROUP BY?</p> <p>Это было бы бесполезно, если бы не использовать <span>функцию агрегат</span>, такую как COUNT(). Давайте посмотрим, что делают некоторые из этих функций и как они могут получить нам полезные данные.</p> <h4>COUNT(*): Подсчет строк</h4> <p>Это, пожалуй, наиболее часто используемая функция вместе с запросами GROUP BY. Он возвращает количество строк в каждой группе.</p> <p>Например, мы можем использовать его для просмотра количества состояний для каждого join_year:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=599/net/uploads/legacy/523_sql/ss_5.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <h4>Группируем все</h4> <p>Если вы используете агрегированную функцию GROUP BY и не указываете конструкцию GROUP BY, все результаты будут помещаться в одну группу.</p> <p>Количество всех строк в таблице:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_6.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>Количество строк, удовлетворяющих WHERE:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_7.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <h4>MIN(), MAX() и AVG()</h4> <p>Эти функции возвращают минимальные, максимальные и средние значения:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=598/net/uploads/legacy/523_sql/ss_8.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <h4>GROUP_CONCAT()</h4> <p>Эта функция объединяет все значения внутри группы в одну строку с заданным разделителем.</p> <p>В первом примере запроса GROUP BY мы могли видеть только одно имя штата для года. Вы можете использовать эту функцию для просмотра всех имен в каждой группе:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_9.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>Если изображение с измененным размером трудно читать, вот запрос:</p> <pre class="brush: html noskimlinks noskimwords">SELECT GROUP_CONCAT(name SEPARATOR ", "), join_yearFROM states GROUP BY join_year;</pre> <h4>SUM()</h4> <p>Это можно использовать для суммирования числовых значений.</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=601/net/uploads/legacy/523_sql/ss_10.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <h3>IF() &amp; CASE: управление потоком</h3> <p>Подобно другим языкам программирования, SQL поддерживает поддержку управления потоком.</p> <h4>IF()</h4> <p>Это функция, которая принимает три аргумента. Первый аргумент - это условие, второй аргумент используется, если условие истинно, а третий аргумент используется, если условие ложно.</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_11.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>Вот практический пример, где мы используем его с помощью функции SUM():</p> <pre class="brush: html noskimlinks noskimwords">SELECTSUM(IF(population &gt; 5000000, 1, 0)) AS big_states,SUM(IF(population &lt;= 5000000, 1, 0)) AS small_statesFROM states;</pre> <p>Первый вызов SUM() подсчитывает количество больших штатов (население более 5 миллионов), а второе - количество малых штатов. Вызов IF() внутри этих вызовов SUM() возвращает 1 или 0 на основе условия.</p> <p>Вот результат:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_12.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <h4>CASE</h4> <p>Это работает аналогично операторам switch-case, которые могут быть знакомы из программирования.</p> <p>Предположим, мы хотим классифицировать каждое состояние в одну из трех возможных категорий.</p> <pre class="brush: html noskimlinks noskimwords">SELECTCOUNT(*),CASEWHEN population &gt; 5000000 THEN "big"WHEN population &gt; 1000000 THEN "medium"ELSE "small" ENDAS state_sizeFROM states GROUP BY state_size;</pre> <p>Как вы можете видеть, мы можем фактически сгруппировать по значениям, возвращаемым из оператора CASE. Вот что происходит:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_13.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <h3>HAVING: Условия на скрытых полях</h3> <p>Конструкция HAVING позволяет применять условия к «скрытым» полям, таким как возвращаемые результаты агрегатных функций. Поэтому она обычно используется вместе с GROUP BY.</p> <p>Например, давайте посмотрим на запрос, который мы использовали для подсчета числа штатов по году:</p> <pre class="brush: html noskimlinks noskimwords">SELECT COUNT(*), join_year FROM states GROUP BY join_year;</pre> <p>В результате 34 строки.</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=599/net/uploads/legacy/523_sql/ss_5.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>Однако предположим, что нас интересуют только строки с числом выше 1. Мы не можем использовать WHERE для этого:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_14.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>Здесь HAVING становится полезным:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_15.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>Имейте в виду, что эта функция может быть недоступна во всех системах баз данных.</p> <h3>Вложенные запросы</h3> <p>Можно получить результаты одного запроса и использовать его для другого запроса.</p> <p>В этом примере мы получим штат с самым высоким населением:</p> <pre class="brush: html noskimlinks noskimwords">SELECT * FROM states WHERE population = (SELECT MAX(population) FROM states);</pre> <p>Внутренний запрос возвращает наибольшее население среди всех штатов. И внешний запрос снова будет искать по таблице, используя это значение.</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=599/net/uploads/legacy/523_sql/ss_16.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>Возможно, вы думаете, что это плохой пример, и я несколько согласен. Тот же запрос можно было бы более эффективно записать следующим образом:</p> <pre class="brush: html noskimlinks noskimwords">SELECT * FROM states ORDER BY population DESC LIMIT 1;</pre> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_17.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>Результаты в этом случае одинаковы, однако существует существенное различие между этими двумя типами запросов. Возможно, другой пример продемонстрирует это лучше.</p> <p>В этом примере мы получим последние штаты, которые присоединились к Союзу:</p> <pre class="brush: html noskimlinks noskimwords">SELECT * FROM states WHERE join_year = (SELECT MAX(join_year) FROM states);</pre> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=598/net/uploads/legacy/523_sql/ss_18.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>На этот раз в результатах есть две строки. Если бы мы использовали запрос ORDER BY ... LIMIT 1 здесь, мы бы не получили тот же результат.</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=599/net/uploads/legacy/523_sql/ss_19.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <h4>IN()</h4> <p>Иногда вы можете использовать несколько результатов, возвращаемых внутренним запросом.</p> <p>Следующий запрос находит годы, когда несколько штатов присоединились к Союзу и возвращает список этих штатов:</p> <pre class="brush: html noskimlinks noskimwords">SELECT * FROM states WHERE join_year IN (SELECT join_year FROM statesGROUP BY join_yearHAVING COUNT(*) &gt; 1) ORDER BY join_year;</pre> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=601/net/uploads/legacy/523_sql/ss_20.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <h4>Еще больше вложенных запросов</h4> <p>Подзапросы могут стать довольно сложными, поэтому я не буду углубляться в них в этой статье. Если вы хотите узнать больше о них, ознакомьтесь с <span>руководством по MySQL</span>.</p> <p>Также стоит отметить, что подзапросы иногда могут иметь плохую производительность, поэтому их следует использовать с осторожностью.</p> <h3>UNION: объединение данных</h3> <p>С помощью запроса UNION мы можем объединить результаты нескольких запросов SELECT.</p> <p>Этот пример объединяет штаты, начинающиеся с буквы «N» и штаты с большими группами населения:</p> <pre class="brush: html noskimlinks noskimwords">(SELECT * FROM states WHERE name LIKE "n%")UNION(SELECT * FROM states WHERE population &gt; 10000000);</pre> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=601/net/uploads/legacy/523_sql/ss_21.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>Обратите внимание, что Нью-Йорк является большим и его имя начинается с буквы «N». Но он появляется только один раз, потому что дублирующиеся строки удаляются из результатов автоматически.</p> <p>Еще одна приятная вещь в UNION заключается в том, что вы можете комбинировать запросы в разных таблицах.</p> <p>Предположим, у нас есть таблицы для сотрудников, менеджеров и клиентов. И каждая таблица имеет поле электронной почты. Если мы хотим получить все электронные адреса с помощью одного запроса, мы можем запустить это:</p> <pre class="brush: html noskimlinks noskimwords">(SELECT email FROM employees)UNION(SELECT email FROM managers)UNION(SELECT email FROM customers WHERE subscribed = 1);</pre> <p>Он будет получать все электронные адреса всех сотрудников и менеджеров, и только электронные адреса клиентов, подписавшихся на получение электронных писем.</p> <h3>INSERT Продолжение</h3> <p>Мы уже говорили о запросе INSERT в последней статье. Теперь, когда мы исследовали индексы базы данных сегодня, мы можем поговорить о более сложных функциях запроса INSERT.</p> <h4>INSERT ... ON DUPLICATE KEY UPDATE</h4> <p>Это почти как условное утверждение. Сначала запрос пытается выполнить заданный INSERT, и если он терпит неудачу из-за двойного значения для PRIMARY KEY или UNIQUE KEY, вместо этого он выполняет UPDATE.</p> <p>Давайте сначала создадим тестовую таблицу.</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=598/net/uploads/legacy/523_sql/ss_22.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>Это таблица для хранения продуктов. Столбец «stock» - это количество продуктов, которые мы имеем на складе.</p> <p>Теперь попробуйте вставить дублирующее значение и посмотреть, что произойдет.</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=601/net/uploads/legacy/523_sql/ss_23.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>Мы получили сообщение об ошибке, как ожидалось.</p> <p>Предположим, мы получили новую хлебопечку и хотим обновить базу данных, и мы не знаем, есть ли для нее запись. Мы можем проверить существующие записи, а затем выполнить другой запрос на основе этого. Или мы могли бы просто сделать все это одним простым запросом:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=601/net/uploads/legacy/523_sql/ss_24.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <h4>REPLACE INTO</h4> <p>Это работает точно так же, как INSERT с одним важным исключением. Если найдена повторяющаяся строка, он сначала удаляет ее, а затем выполняет INSERT, поэтому мы не получаем сообщений об ошибках.</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=599/net/uploads/legacy/523_sql/ss_25.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>Обратите внимание: поскольку это действительно совершенно новая строка, идентификатор увеличился.</p> <h4>INSERT IGNORE</h4> <p>Это способ подавления повторяющихся ошибок, как правило, для предотвращения ошибок в приложении. Иногда вы можете попытаться вставить новую строку и просто позволить ошибку без каких-либо сообщений в случае обнаружения дубликата.</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/net/uploads/legacy/523_sql/ss_26.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <p>Ошибок не было, и строки не обновлялись.</p> <h3>Типы данных</h3> <p>Каждый столбец таблицы должен иметь тип данных. До сих пор мы использовали типы INT, VARCHAR и DATE, но мы не говорили о них подробно. Также есть несколько других типов данных, которые мы должны изучить.</p> <p>Сначала начнем с числовых типов данных. Мне нравится помещать их в две отдельные группы: целые числа и нецелые.</p> <h4>Целочисленные типы данных</h4> <p>Целочисленный столбец может содержать только натуральные числа (без десятичных знаков). По умолчанию они могут быть отрицательными или положительными. Но если установлен параметр UNSIGNED, он может содержать только положительные числа.</p> <p>MySQL поддерживает 5 типов целых чисел с различными размерами и диапазонами:</p> <div class="tutorial_image"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" border="0" class="lazy07" data-src="https://cdn.tutsplus.com/cdn-cgi/image/width=436/net/uploads/legacy/523_sql/ss_2.png" alt="SQL для начинающих Часть 2..." title="SQL для начинающих Часть 2..." width="50" height="50"></div> <h4>Не целочисленные числовые типы данных</h4> <p>Эти типы данных могут содержать десятичные числа: FLOAT, DOUBLE и DECIMAL.</p> <p><span>FLOAT</span> - 4 байта, <span>DOUBLE</span> - 8 байтов, и они работают аналогично. Однако DOUBLE имеет лучшую точность.</p> <p><span>DECIMAL(M,N)</span> имеет различный размер, основанный на уровне точности, который можно настроить. M - максимальное количество цифр, а N - число цифр справа от десятичной точки.</p> <p>Например, DECIMAL(13,4) имеет максимум 9 целых цифр и 4 дробных цифры.</p> <h4>Строковые типы данных</h4> <p>Как следует из названия, мы можем хранить строки в столбцах этого типа данных.</p> <p><span>CHAR(N)</span> может содержать до N символов и имеет фиксированный размер. Например, CHAR(50) всегда будет содержать 50 символов в строке, независимо от размера строки в ней. Абсолютный максимум - 255 символов</p> <p><span>VARCHAR(N)</span> работает так же, но размер хранилища не фиксирован. N используется только для максимального размера. Если строка, длина которой меньше N символов, будет сохранена на жестком диске, это займет меньше места. Абсолютный максимальный размер - 65535 символов.</p> <p>Вариации типа данных <span>TEXT</span> более подходят для длинных строк. TEXT имеет предел 65535 символов, MEDIUMTEXT - 16,7 миллиона символов, а LONGTEXT - 4,3 миллиарда символов. Обычно MySQL хранит их в разных местах на сервере, так что основное хранилище для таблицы остается относительно небольшим и быстрым.</p> <h4>Типы даты</h4> <p><span>DATE</span> хранит даты и отображает их в этом формате «YYYY-MM-DD», но не содержит информацию о времени. Он имеет диапазон от 1001-01-01 до 9999-12-31.</p> <p><span>DATETIME</span> содержит как дату, так и время и отображается в этом формате: «YYYY-MM-DD HH:MM:SS». Он имеет диапазон «1000-01-01 00:00:00» до «9999-12-31 23:59:59». Он занимает 8 байт.</p> <p>За несколькими исключениями <span>TIMESTAMP</span> работает как DATETIME. Он занимает всего 4 байта, а диапазон - "1970-01-01 00:00:01" UTC по "2038-01-19 03:14:07" UTC. Так, например, это может быть плохо для хранения дат рождения.</p> <p><span>TIME</span> хранит время, и <span>YEAR</span> сохраняет только год.</p> <h4>Другие</h4> <p>Существуют и другие типы данных, поддерживаемые MySQL. Вы можете увидеть их список <span>здесь</span>. <span>Здесь </span>вы также должны проверить размеры хранилища для каждого типа данных.</p> <h3>Заключение</h3> <p>Благодарю вас за чтение статьи. SQL является важным языком и инструментом в арсенале веб-разработчиков.</p> <p>Пожалуйста, оставьте ваши комментарии и вопросы и хорошего дня!</p> <ul class="webroundup"><li>Следуйте за нами в <span>Твиттере</span> или подпишитесь на <span>Nettuts+ RSS Feed</span> для учебных пособий по веб-разработке в Интернете. Готовы </li> </ul><p><strong>Готовы ли вы перевести свои навыки на следующий уровень и начать получать прибыль от ваших скриптов и компонентов? Посмотрите наш рынок, CodeCanyon.</strong></p> <div class="tutorial_image"><span></span></div> <p> </p>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825737-sql-dlya-nachinayuschih-chast-2" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="Databases" href="https://norma-studio.github.io/article5/220825737-sql-dlya-nachinayuschih-chast-2" class="tm-article-body__tags-item-link">Databases</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
44539</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
338</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>

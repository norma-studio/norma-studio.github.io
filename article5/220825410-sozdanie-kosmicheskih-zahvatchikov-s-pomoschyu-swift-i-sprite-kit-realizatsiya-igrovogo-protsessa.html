
<!DOCTYPE html>
<html lang="ru"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<title>Создание космических захватчиков с помощью Swift и Sprite Kit: реализация игрового процесса... | envatomarket.ru | norma-studio.github.io</title>
<meta name="twitter:card" content="summary_large_image">
<meta property="og:title" content="Создание космических захватчиков с помощью Swift и Sprite Kit: реализация игрового процесса... | envatomarket.ru | norma-studio.github.io">
<meta name="twitter:title" content="Создание космических захватчиков с помощью Swift и Sprite Kit: реализация игрового процесса... | envatomarket.ru | norma-studio.github.io">
<meta name="aiturec:title" content="Создание космических захватчиков с помощью Swift и Sprite Kit: реализация игрового процесса... | envatomarket.ru | norma-studio.github.io">
<meta name="description" content="В предыдущей части этой серии мы реализовали заглушки для основных классов игры. В этом уроке мы получим перемещение захватчиков, пули, стреляющие как для захватчиков, так и для игрока, и реализуем обнаружение столкновения. Давайте начнем....">
<meta property="og:description" content="В предыдущей части этой серии мы реализовали заглушки для основных классов игры. В этом уроке мы получим перемещение захватчиков, пули, стреляющие как для захватчиков, так и для игрока, и реализуем обнаружение столкновения. Давайте начнем....">
<meta name="twitter:description" content="В предыдущей части этой серии мы реализовали заглушки для основных классов игры. В этом уроке мы получим перемещение захватчиков, пули, стреляющие как для захватчиков, так и для игрока, и реализуем обнаружение столкновения. Давайте начнем....">
<meta property="aiturec:description" content="В предыдущей части этой серии мы реализовали заглушки для основных классов игры. В этом уроке мы получим перемещение захватчиков, пули, стреляющие как для захватчиков, так и для игрока, и реализуем обнаружение столкновения. Давайте начнем....">
<meta property="og:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/211/posts/23372/final_image/game_shot.png">
<meta property="aiturec:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/211/posts/23372/final_image/game_shot.png">
<meta name="twitter:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/211/posts/23372/final_image/game_shot.png">
<meta property="vk:image" content="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/211/posts/23372/final_image/game_shot.png">
<meta property="og:type" content="article">
<link image_src="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/211/posts/23372/final_image/game_shot.png">
<meta property="og:locale" content="ru_RU"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="robots" content="all">
<meta name="author" content="https://norma-studio.github.io/article5/220825410-sozdanie-kosmicheskih-zahvatchikov-s-pomoschyu-swift-i-sprite-kit-realizatsiya-igrovogo-protsessa.html">
<meta name="copyright" lang="ru" content="https://norma-studio.github.io/article5/220825410-sozdanie-kosmicheskih-zahvatchikov-s-pomoschyu-swift-i-sprite-kit-realizatsiya-igrovogo-protsessa.html">
<link rel="canonical" href="https://norma-studio.github.io/article5/220825410-sozdanie-kosmicheskih-zahvatchikov-s-pomoschyu-swift-i-sprite-kit-realizatsiya-igrovogo-protsessa.html">
<meta property="og:url" content="https://norma-studio.github.io/article5/220825410-sozdanie-kosmicheskih-zahvatchikov-s-pomoschyu-swift-i-sprite-kit-realizatsiya-igrovogo-protsessa.html">
<meta name="twitter:site" content="https://norma-studio.github.io/article5/220825410-sozdanie-kosmicheskih-zahvatchikov-s-pomoschyu-swift-i-sprite-kit-realizatsiya-igrovogo-protsessa.html">
<meta name="twitter:creator" content="https://norma-studio.github.io/article5/220825410-sozdanie-kosmicheskih-zahvatchikov-s-pomoschyu-swift-i-sprite-kit-realizatsiya-igrovogo-protsessa.html">

<meta name="apple-mobile-web-app-status-bar-style" content="#303b44"><meta name="msapplication-TileColor" content="#629FBC">
<link rel="shortcut icon" type="image/ico" sizes="64x64" href="https://norma-studio.github.io//norma-logo-64.png">
<link rel="shortcut icon" href="https://norma-studio.github.io//favicon.ico" type="image/x-icon">
<style>body{opacity: 0;}</style>
<meta name="yandex-verification" content="da91da9b0b6d5dba"><meta name="google-site-verification" content="_BCz7bv6IKv32EI5NSdb9dPwP4PnhlsToVoSOpbZlZI"></head><body>
<div id="app"><div class="tm-layout__wrapper"><div></div>
<header id="extop" class="tm-header"><div class="tm-page-width"><div class="tm-header__container">

<span class="tm-header__logo-wrap"><a aria-label="norma-studio.github.io" href="https://norma-studio.github.io/" class="tm-header__logo tm-header__logo_ru" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге norma-studio.github.io">norma-studio.github.io</a></span><div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title><svg id="arrow-down" viewBox="0 0 24 24"><path d="m6.47 9.47c.293-.293.768-.293 1.061 0l4.47 4.47 4.47-4.47c.293-.293.768-.293 1.061 0s.293.768 0 1.061l-5 5c-.293.293-.768.293-1.061 0l-5-5c-.293-.293-.293-.768 0-1.061z"></path></svg></svg></button></div></div><a aria-label="Написать нам" href="https://wa.me/79603570433?text=https://norma-studio.github.io/_Добрый_день" class="tm-header__become-author-btn" title="Подборка эксклюзивных материалов о создании и продвижении сайтов, дизайне сайтов и интернет-маркетинге. Как создать и продвигать сайт, как выбрать дизайн сайта и интернет-стратегию, как защитить свои права в интернете, как продать контент для сайтов? Все ответы в блоге envatomarket.ru.">Написать нам</a><div class="tm-feature tm-header__feature tm-feature_variant-inline"></div></div></div></header>

<div class="tm-layout">
<main class="tm-layout__container"><div class="tm-page"><div class="tm-page-width"><div class="tm-page__wrapper">
<div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down">
<div class="tm-page-article__body data-container" style="background-color: #f0f0f0;" id="data-container">


<article class="tm-page-article__content tm-page-article__content_inner" style="background-color: #fff;">
<!-- article-header -->
<div class="tm-page-article__head-wrapper"><div class="tm-article-snippet tm-page-article__snippet">

<div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a aria-label="author-image" href="https://norma-studio.github.io/article5/220825410-sozdanie-kosmicheskih-zahvatchikov-s-pomoschyu-swift-i-sprite-kit-realizatsiya-igrovogo-protsessa.html" title="Создание космических захватчиков с помощью Swift и Sprite Kit: реализация игрового процесса... | envatomarket.ru | norma-studio.github.io" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="Создание космических захватчиков с помощью Swift и Sprite Kit: реализация игрового процесса... | envatomarket.ru | norma-studio.github.io" title="Создание космических захватчиков с помощью Swift и Sprite Kit: реализация игрового процесса... | envatomarket.ru | norma-studio.github.io" height="24" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/i3/31231313312.webp" width="24" class="tm-entity-image__pic lazy07"></div></a><span class="tm-user-info__user">
<a href="https://norma-studio.github.io/article5/220825410-sozdanie-kosmicheskih-zahvatchikov-s-pomoschyu-swift-i-sprite-kit-realizatsiya-igrovogo-protsessa.html" class="tm-user-info__username" title="
Д. Грунин" aria-label="
Д. Грунин">
Д. Грунин</a>
</span></span><span class="tm-article-snippet__datetime-published"><time datetime="2023-12-09T15:24:38.000Z" title="22023-12-09, 19:24"> 09.12.2023</time></span></div></div>
<h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1" itemprop="name"><span><span>Создание космических захватчиков с помощью Swift и Sprite Kit: реализация игрового процесса...</span></span></h1>
<div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825410-sozdanie-kosmicheskih-zahvatchikov-s-pomoschyu-swift-i-sprite-kit-realizatsiya-igrovogo-protsessa" class="tm-article-snippet__hubs-item-link"><span>Code</span></a></span><span class="tm-article-snippet__hubs-item"><a aria-label="SpriteKit" href="https://norma-studio.github.io/article5/220825410-sozdanie-kosmicheskih-zahvatchikov-s-pomoschyu-swift-i-sprite-kit-realizatsiya-igrovogo-protsessa" class="tm-article-snippet__hubs-item-link"><span>SpriteKit</span></a></span><br></div></div>

<div itemscope itemtype="https://schema.org/Article" style="display:none;">
    <link itemprop="mainEntityOfPage" href="https://norma-studio.github.io/article5/220825410-sozdanie-kosmicheskih-zahvatchikov-s-pomoschyu-swift-i-sprite-kit-realizatsiya-igrovogo-protsessa.html" />
    <link itemprop="image" href="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads/users/211/posts/23372/final_image/game_shot.png">
    <meta itemprop="headline name" content="Создание космических захватчиков с помощью Swift и Sprite Kit: реализация игрового процесса... | envatomarket.ru | norma-studio.github.io">
    <meta itemprop="description" content="В предыдущей части этой серии мы реализовали заглушки для основных классов игры. В этом уроке мы получим перемещение захватчиков, пули, стреляющие как для захватчиков, так и для игрока, и реализуем обнаружение столкновения. Давайте начнем....">
    <meta itemprop="author" content="norma-studio.github.io">
    <meta itemprop="datePublished" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <meta itemprop="dateModified" datetime="2023-12-09T15:24:38.000Z" content="09.12.2023">
    <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
        <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <img class="lazy07" itemprop="url image" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-src="https://envatomarket.ru/apple-touch-icon-120.ico" alt="Шаблоны сайтов | Лендинги" title="Шаблоны сайтов | Лендинги" style="display:none;"/>
        </div>
        <meta itemprop="name" content="https://norma-studio.github.io/">
        <meta itemprop="telephone" content="">
        <meta itemprop="address" content="Россия">
    </div>
    <p>Интро</p>
    <span itemprop="articleBody">В предыдущей части этой серии мы реализовали заглушки для основных классов игры. В этом уроке мы получим перемещение захватчиков, пули, стреляющие как для захватчиков, так и для игрока, и реализуем обнаружение столкновения. Давайте начнем....</span>
</div>


<!-- article-body -->

<div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-2">



<p>В <span>предыдущей части этой серии</span> мы реализовали заглушки для основных классов игры. В этом уроке мы получим перемещение захватчиков, пули, стреляющие как для захватчиков, так и для игрока, и реализуем обнаружение столкновения. Давайте начнем.</p><h2> 1.<span class="sectionnum"> </span>Перемещение захватчиков</h2><p>Мы будем использовать метод <code class="inline">update</code> сцены для перемещения захватчиков. Всякий раз, когда вы хотите переместить что-то вручную, метод <code class="inline">update</code> обычно используется там, где вы хотите это сделать.</p><p>Прежде чем мы это сделаем, нам нужно обновить свойство <code class="inline">rightBounds</code>. Первоначально он был установлен в <strong>0</strong>, потому что нам нужно использовать <code class="inline">size</code> сцены для установки переменной. Мы не смогли сделать это за пределами любого из методов класса, поэтому мы обновим это свойство в методе <code class="inline">didMoveToView(_:)</code>.</p><pre class="brush: javascript noskimlinks noskimwords">override func didMoveToView(view: SKView) {    backgroundColor = SKColor.blackColor()    rightBounds = self.size.width - 30    setupInvaders()    setupPlayer()}</pre><p>Затем реализуем метод <code class="inline">moveInvaders</code> ниже метода <code class="inline">setupPlayer</code>, который вы создали в <span>предыдущем учебнике</span>.</p><pre class="brush: javascript noskimlinks noskimwords">func moveInvaders(){    var changeDirection = false    enumerateChildNodesWithName("invader") { node, stop in        let invader = node as SKSpriteNode        let invaderHalfWidth = invader.size.width/2        invader.position.x -= CGFloat(self.invaderSpeed)        if(invader.position.x &gt; self.rightBounds - invaderHalfWidth || invader.position.x &lt; self.leftBounds + invaderHalfWidth){                changeDirection = true            }                        }                    if(changeDirection == true){            self.invaderSpeed *= -1            self.enumerateChildNodesWithName("invader") { node, stop in            let invader = node as SKSpriteNode            invader.position.y -= CGFloat(46)        }            changeDirection = false    }                }</pre><p>Мы объявляем переменную <code class="inline">changeDirection</code>, чтобы отслеживать, когда оккупанты должны менять направление, перемещаться влево или двигаться вправо. Затем мы используем метод <code class="inline">enumerateChildNodesWithName(usingBlock:)</code>, который ищет дочерние узлы и вызывает замыкание один раз для каждого соответствующего узла, который он находит, с соответствующим именем <strong>"invader"</strong>. Закрытие принимает два параметра, <code class="inline">node</code> - это узел, который соответствует <code class="inline">name</code> , а <code class="inline">stop</code> - указатель на логическую переменную, чтобы завершить перечисление. Мы не будем здесь использовать <code class="inline">stop</code>, но будем знать, для чего он используется.<br></p><p>Мы приводим <code class="inline">node</code> в экземпляр <code class="inline">SKSpriteNode</code>, который является подклассом, <code class="inline">invader</code> половину его ширины <code class="inline">invaderHalfWidth</code> и обновляет свою позицию. Затем мы проверяем, находится ли его <code class="inline">позиция </code>в границах, <code class="inline">leftBounds</code> и <code class="inline">rightBounds</code>, а если нет, мы устанавливаем <code class="inline">changeDirection</code> в <code class="inline">true</code>.</p><p>Если <code class="inline">changeDirection</code> <code class="inline">правильное</code>, мы отрицаем <code class="inline">invaderSpeed</code>, который изменит направление, в которое движется захватчик. Затем мы перечисляем через захватчиков и обновляем их позицию y. И наконец, мы изменим <code class="inline">changeDirection</code> на <code class="inline">false</code>.</p><p>Метод <code class="inline">moveInvaders</code> вызывается в методе <code class="inline">update(_:)</code>.</p><pre class="brush: javascript noskimlinks noskimwords">override func update(currentTime: CFTimeInterval) {    moveInvaders()}</pre><p>Если вы протестируете приложение сейчас, вы должны увидеть, что захватчики перемещаются влево, вправо, а затем вниз, если они достигают границ, которые мы установили с обеих сторон.<br></p><h2> 2.<span class="sectionnum"> </span>Стрельба пулями</h2><h3>Шаг 1: <code class="inline">fireBullet</code><br></h3><p>Как часто мы хотим, чтобы один из захватчиков выпустил пулю. В настоящее время захватчики в нижней строке настроены на запуск пули, поскольку они находятся в массиве <code class="inline">invadersWhoCanFire</code>.</p><p>Когда захватчик попадает пулей в игрока, то захват одной строки вверх и в том же столбце будет добавлен в массив <code class="inline">invadersWhoCanFire</code>, а игрок, получивший удар, будет удален. Таким образом, только самый нижний захватчик каждого столбца может стрелять пулями.</p><p>Добавьте метод <code class="inline">fireBullet</code> в класс <code class="inline">InvaderBullet</code> в <strong>InvaderBullet.swift</strong>.</p><pre class="brush: javascript noskimlinks noskimwords">func fireBullet(scene: SKScene){    let bullet = InvaderBullet(imageName: "laser",bulletSound: nil)    bullet.position.x = self.position.x    bullet.position.y = self.position.y - self.size.height/2    scene.addChild(bullet)    let moveBulletAction = SKAction.moveTo(CGPoint(x:self.position.x,y: 0 - bullet.size.height), duration: 2.0)    let removeBulletAction = SKAction.removeFromParent()    bullet.runAction(SKAction.sequence([moveBulletAction,removeBulletAction]))}</pre><p>В методе <code class="inline">fireBullet</code> мы создаем экземпляр <code class="inline">InvaderBullet</code>, передавая <strong>"laser"</strong> для <code class="inline">imageName</code>, и поскольку мы не хотим, чтобы звук воспроизводился, мы передаем <code class="inline">nil</code> для <code class="inline">bulletSound</code>. Мы устанавливаем его <code class="inline">position</code> таким же, как у захватчика, с небольшим смещением по позиции y и добавляем его в сцену.</p><p>Мы создаем два экземпляра <code class="inline">SKAction</code>, <code class="inline">moveBulletAction</code> и <code class="inline">removeBulletAction</code>. Действие <code class="inline">moveBulletAction</code> перемещает пулю в определенную точку за определенную продолжительность, в то время как действие <code class="inline">removeBulletAction</code> удаляет ее из сцены. Вызывая <code class="inline">sequence(_:)</code> метода для этих действий, они будут запускаться последовательно. Вот почему я упомянул метод<code class="inline"> waitForDuration</code> при воспроизведении звука в предыдущей части этой серии. Если вы создаете объект <code class="inline">SKAction</code>, вызывая <code class="inline">playSoundFileNamed(_:waitForCompletion:)</code> и устанавливая <code class="inline">waitForCompletion</code> в <code class="inline">true</code>, тогда продолжительность этого действия будет до тех пор, пока звук будет воспроизводиться, иначе он сразу перейдет к следующему действию в последовательности.<br></p><h3>Шаг 2: <code class="inline">invokeInvaderFire</code> </h3><p>Добавьте метод <code class="inline">invokeInvaderFire</code> ниже других методов, которые вы создали в <strong>GameScence.swift</strong>.</p><pre class="brush: javascript noskimlinks noskimwords">func invokeInvaderFire(){    let fireBullet = SKAction.runBlock(){        self.fireInvaderBullet()    }    let waitToFireInvaderBullet = SKAction.waitForDuration(1.5)    let invaderFire = SKAction.sequence([fireBullet,waitToFireInvaderBullet])    let repeatForeverAction = SKAction.repeatActionForever(invaderFire)    runAction(repeatForeverAction)}</pre><p>Метод <code class="inline">runBlock(_:)</code> класса <code class="inline">SKAction</code> создает экземпляр <code class="inline">SKAction</code> и немедленно вызывает замыкание, переданное методу <code class="inline">runBlock(_:)</code>. В закрытии мы вызываем метод <code class="inline">fireInvaderBullet</code>. Поскольку мы вызываем этот метод в закрытии, мы должны использовать <code class="inline">self</code> для его вызова.</p><p>Затем мы создаем экземпляр <code class="inline">SKAction</code> с именем <code class="inline">waitToFireInvaderBullet</code>, вызывая <code class="inline">waitForDuration(_:)</code>, передавая количество секунд ожидания перед тем, как двигаться дальше. Затем мы создаем экземпляр <code class="inline">SKAction</code>, <code class="inline">invaderFire</code>, вызывая метод <code class="inline">sequence(_:)</code>. Этот метод принимает набор действий, которые вызывается действием <code class="inline">invaderFire</code>. Мы хотим, чтобы эта последовательность повторялась постоянно, поэтому мы создаем действие с именем <code class="inline">repeatForeverAction</code>, передаем объекты <code class="inline">SKAction</code> для повторения и вызываем <code class="inline">runAction</code>, передавая действие <code class="inline">repeatForeverAction</code>. Метод runAction объявлен в классе <code class="inline">SKNode</code>.<br></p><h3>Шаг 3: <code class="inline">fireInvaderBullet</code> </h3><p>Добавьте метод <code class="inline">fireInvaderBullet</code> ниже метода <code class="inline">invokeInvaderFire</code>, введенного на предыдущем шаге.</p><pre class="brush: javascript noskimlinks noskimwords"> func fireInvaderBullet(){    let randomInvader = invadersWhoCanFire.randomElement()    randomInvader.fireBullet(self)}</pre><p>В этом методе мы называем метод, называемый <code class="inline">randomElement</code>, который возвращает случайный элемент из массива <code class="inline">invadersWhoCanFire</code>, а затем вызывает его метод <code class="inline">fireBullet</code>. К сожалению, нет встроенного метода <code class="inline">randomElement</code> в структуре <code class="inline">Array</code>. Однако мы можем создать расширение <code class="inline">Array</code> для предоставления этой функции.</p><h3>Шаг 4: Реализация <code class="inline">randomElement</code><br></h3><p>Откройте <strong>File</strong>&gt; <strong>New</strong>&gt; <strong>File ...</strong> и выберите <strong>Swift File</strong>. Мы делаем что-то другое, чем раньше, поэтому просто убедитесь, что вы выбираете <strong>Swift File</strong>, а не <strong>Cocoa Touch Class</strong>. Нажмите <strong>Next</strong> и назовите файл <strong>Утилиты</strong>. Добавьте следующий код в <strong>Utilities.swift</strong>.</p><pre class="brush: javascript noskimlinks noskimwords">import Foundationextension Array {    func randomElement() -&gt; T {        let index = Int(arc4random_uniform(UInt32(self.count)))        return self[index]    }}</pre><p>Мы расширяем структуру <code class="inline">Array</code>, чтобы иметь метод с именем <code class="inline">randomElement</code>. Функция <code class="inline">arc4random_uniform</code> возвращает число от 0 до того, что вы проходите. Поскольку Swift неявно не конвертирует числовые типы, мы должны сами сделать преобразование. Наконец, мы возвращаем элемент массива по индексу <code class="inline">index</code>.</p><p>Этот пример иллюстрирует, как легко добавлять функциональные возможности в структуру и классы. Вы можете больше узнать о создании расширений на <span>языке Swift Programming</span>.</p><h3>Шаг 5: Стрельба пулей</h3><p>С этим все в порядке, теперь мы можем стрелять из пуль. Добавьте к методу <code class="inline">didMoveToView(_:)</code>.</p><pre class="brush: plain noskimlinks noskimwords"> override func didMoveToView(view: SKView) {    ...    setupPlayer()    invokeInvaderFire()}</pre><p>Если вы протестируете приложение сейчас, каждую секунду или около того вы должны увидеть, что один из захватчиков из нижней строки выстрелил в пулю.</p><h2> 3.<span class="sectionnum"> </span>Стрельба игровыми пулями</h2><h3>Шаг 1: <code class="inline">fireBullet(scene:)</code> </h3><p>Добавьте в класс <code class="inline">Player</code> в <strong>Player.swift</strong> следующее свойство.</p><pre class="brush: javascript noskimlinks noskimwords">class Player: SKSpriteNode {   private var canFire = true</pre><p>Мы хотим ограничить, как часто игрок может стрелять из пули. Свойство <code class="inline">canFire</code> будет использоваться для его регулирования. Затем добавьте следующее к методу <code class="inline">fireBullet(scene:)</code> в классе <code class="inline">Player</code>.</p><pre class="brush: javascript noskimlinks noskimwords">func fireBullet(scene: SKScene){    if(!canFire){        return    }else{        canFire = false        let bullet = PlayerBullet(imageName: "laser",bulletSound: "laser.mp3")        bullet.position.x = self.position.x        bullet.position.y = self.position.y + self.size.height/2        scene.addChild(bullet)        let moveBulletAction = SKAction.moveTo(CGPoint(x:self.position.x,y:scene.size.height + bullet.size.height), duration: 1.0)        let removeBulletAction = SKAction.removeFromParent()        bullet.runAction(SKAction.sequence([moveBulletAction,removeBulletAction]))        let waitToEnableFire = SKAction.waitForDuration(0.5)        runAction(waitToEnableFire,completion:{        self.canFire = true        })    }}</pre><p>Сначала мы убеждаемся, что игрок способен стрелять, проверяя, установлено ли для параметра <code class="inline">canFire</code> значение <code class="inline">true</code>. Если это не так, мы немедленно возвращаемся из метода.</p><p>Если игрок может стрелять, мы устанавливаем <code class="inline">canFire</code> на <code class="inline">false</code>, чтобы они не могли сразу запустить другую пулю. Затем мы создаем экземпляр <code class="inline">PlayerBullet</code>, передавая <strong>"laser"</strong> для параметра <code class="inline">imageNamed</code>. Поскольку мы хотим, чтобы звук воспроизводился, когда игрок запускает пулю, мы передаем <strong>"laser.mp3"</strong> для параметра <code class="inline">bulletSound</code>.</p><p>Затем мы устанавливаем позицию пули и добавляем ее на экран. Следующие несколько строк такие же, как метод <code class="inline"><strong>FireBullet</strong></code><code class="inline"> Invader</code>, поскольку мы перемещаем маркер и удаляем его из сцены. Затем мы создаем экземпляр <code class="inline">SKAction</code>, <code class="inline">waitToEnableFire</code>, вызывая метод <code class="inline">waitForDuration(_:)</code>. Наконец, мы вызываем <code class="inline">runAction</code>, переходя в <code class="inline">waitToEnableFire</code>, и по завершении установки <code class="inline">canFire</code> возвращается к <code class="inline">true</code>.<br></p><h3>Шаг 2: Стрельба игровой пулей</h3><p>Всякий раз, когда пользователь прикасается к экрану, мы хотим запустить пулю. Это так же просто, как вызов <code class="inline">fireBullet</code> в объекте <code class="inline">player</code> в методе <code class="inline">touchhesBegan(_:withEvent:)</code> класса <code class="inline">GameScene</code>.<br></p><pre class="brush: javascript noskimlinks noskimwords"> override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {        /* Called when a touch begins */    for touch: AnyObject in touches {        player.fireBullet(self)    }}</pre><p>Если вы протестируете приложение сейчас, вы должны будете запустить пулю при нажатии на экран. Кроме того, каждый раз, когда пуля выстрелила, вы должны слышать лазерный звук.<br></p><h2> 4.<span class="sectionnum"> </span>Категории столкновений</h2><p>Чтобы обнаружить, когда узлы сталкиваются или контактируют друг с другом, мы будем использовать встроенный физический движок Sprite Kit. Тем не менее, поведение по умолчанию в физическом движке состоит в том, что все сталкивается со всем, когда у них есть физическое тело, добавленное к ним. Нам нужен способ отделить то, что мы хотим взаимодействовать друг с другом, и мы можем сделать это, создав категории, к которым принадлежат определенные физические тела.</p><p>Вы определяете эти категории с использованием битовой маски, в которой используется 32-разрядное целое число с 32 отдельными флагами, которые могут быть включены или выключены. Это также означает, что у вас может быть только 32 категории для вашей игры. Это не должно представлять проблемы для большинства игр, но это то, что нужно иметь в виду.<br></p><p>Добавьте следующее определение структуры в класс <code class="inline">GameScene</code>, ниже объявления <code class="inline">invaderNum</code> в <strong>GameScene.swift</strong>.</p><pre class="brush: javascript noskimlinks noskimwords">struct CollisionCategories{    static let Invader : UInt32 = 0x1 &lt;&lt; 0    static let Player: UInt32 = 0x1 &lt;&lt; 1    static let InvaderBullet: UInt32 = 0x1 &lt;&lt; 2    static let PlayerBullet: UInt32 = 0x1 &lt;&lt; 3}</pre><p>Мы используем структуру <code class="inline">CollsionCategories</code> для создания категорий для классов <code class="inline">Invader</code>, <code class="inline">Player</code>, <code class="inline">InvaderBullet</code> и <code class="inline">PlayerBullet</code>. Мы используем битовое смещение, чтобы включить бит.</p><h2> 5.<span class="sectionnum"> </span>Столкновение <code class="inline">игроков </code>и <code class="inline">захватчиков</code></h2><h3>Шаг 1: Настройка <code class="inline">InvaderBullet</code> для Collision</h3><p>Добавьте следующий код в метод <code class="inline">init(imageName: bulletSound:)</code> в <strong>InvaderBullet.swift</strong>.</p><pre class="brush: javascript noskimlinks noskimwords"> override init(imageName: String, bulletSound:String?){    super.init(imageName: imageName, bulletSound: bulletSound)    self.physicsBody = SKPhysicsBody(texture: self.texture, size: self.size)    self.physicsBody?.dynamic = true    self.physicsBody?.usesPreciseCollisionDetection = true    self.physicsBody?.categoryBitMask = CollisionCategories.InvaderBullet    self.physicsBody?.contactTestBitMask = CollisionCategories.Player    self.physicsBody?.collisionBitMask = 0x0}</pre><p>Существует несколько способов создания физического тела. В этом примере мы используем инициализатор <code class="inline">init(texture:size:)</code>, который заставит обнаружение столкновения использовать форму текстуры, которую мы передаем. Существует несколько других инициализаторов, которые вы можете увидеть в <span>ссылке класса SKPhysicsBody</span>.</p><p>Мы могли бы легко использовать инициализатор <code class="inline">init(rectangleOfSize:)</code>, поскольку пули имеют прямоугольную форму. В этой небольшой игре это не имеет значения. Однако имейте в виду, что использование метода <code class="inline">init(texture:size:)</code> может быть дорогостоящим, поскольку оно должно вычислять точную форму текстуры. Если у вас есть объекты прямоугольной или круглой формы, вы должны использовать эти типы инициализаторов, если производительность игры становится проблемой.<br></p><p>Для обнаружения столкновения для работы, по крайней мере одно из тел, которое вы тестируете, должно быть отмечено как динамическое. Установив для свойства <code class="inline">usesPreciseCollisionDetection</code> значение <code class="inline">true</code>, Sprite Kit использует более точное обнаружение столкновений. Установите для этого свойства значение <code class="inline">true</code> на маленьких, быстро движущихся телах, таких как наши пули.<br></p><p>Каждое тело будет принадлежать к категории, и вы определяете это, установив его <code class="inline">categoryBitMask</code>. Поскольку это класс <code class="inline">InvaderBullet</code>, мы устанавливаем его в <code class="inline">CollisionCategories.InvaderBullet</code>.</p><p>Чтобы сообщить, когда это тело коснулось другого тела, которое вас интересует, вы устанавливаете <code class="inline">contactBitMask</code>. Здесь мы хотим знать, когда <code class="inline">InvaderBullet</code> установил контакт с игроком, поэтому мы используем <code class="inline">CollisionCategories.Player</code>. Поскольку столкновение не должно вызывать никаких физических сил, мы устанавливаем <code class="inline">collisionBitMask</code> в <code class="inline">0x0</code>.</p><h3>Шаг 2: Настройка <code class="inline">Player</code> для столкновения<br></h3><p>Добавьте в метод <code class="inline">init</code> в <strong>Player.swift</strong> следующее.</p><pre class="brush: plain noskimlinks noskimwords">  override init() {    let texture = SKTexture(imageNamed: "player1")    super.init(texture: texture, color: SKColor.clearColor(), size: texture.size())    self.physicsBody =    SKPhysicsBody(texture: self.texture,size:self.size)    self.physicsBody?.dynamic = true    self.physicsBody?.usesPreciseCollisionDetection = false    self.physicsBody?.categoryBitMask = CollisionCategories.Player    self.physicsBody?.contactTestBitMask = CollisionCategories.InvaderBullet | CollisionCategories.Invader    self.physicsBody?.collisionBitMask = 0x0    animate()}</pre><p>Большая часть этого должна быть знакома с предыдущего шага, поэтому я не буду перефразировать его здесь. Однако есть две отличия. Один из них заключается в том, что <code class="inline">usePreciseCollsionDetection</code> имеет значение <code class="inline">false</code>, которое является значением по умолчанию. Важно понимать, что только одно из контактирующих органов требует, чтобы это свойство было <code class="inline">true</code> (это была пуля). Другое отличие состоит в том, что мы также хотим знать, когда игрок связывается с захватчиком. Вы можете иметь более одной категории <code class="inline">contactBitMask</code>, разделяя их с помощью побитового <em>или </em>(<code class="inline">|</code>) оператора. Кроме этого, вы должны заметить, что это просто в основном противоположно <code class="inline">InvaderBullet</code>.</p><h2> 6.<span class="sectionnum"> </span><code class="inline">Invader</code> and <code class="inline">PlayerBullet</code> столкновение</h2><h3>Шаг 1. Настройка <code class="inline">Invader</code> для столкновения</h3><p>Добавьте метод <code class="inline">init</code> в <strong>Invader.swift</strong>.<br></p><pre class="brush: javascript noskimlinks noskimwords"> override init() {    let texture = SKTexture(imageNamed: "invader1")    super.init(texture: texture, color: SKColor.clearColor(), size: texture.size())    self.name = "invader"    self.physicsBody =    SKPhysicsBody(texture: self.texture, size: self.size)    self.physicsBody?.dynamic = true    self.physicsBody?.usesPreciseCollisionDetection = false    self.physicsBody?.categoryBitMask = CollisionCategories.Invader    self.physicsBody?.contactTestBitMask = CollisionCategories.PlayerBullet | CollisionCategories.Player    self.physicsBody?.collisionBitMask = 0x0}</pre><p>Это должно иметь смысл, если вы следовали. Мы создали <code class="inline">physicsBody</code>, <code class="inline">categoryBitMask</code> и <code class="inline">contactBitMask</code>.</p><h3>Шаг 2: Настройка <code class="inline">PlayerBullet</code> для столкновения</h3><p>Добавьте в <code class="inline">init(imageName:bulletSound:)</code> в <strong>PlayerBullet.swift</strong> следующее. Опять же, реализация должна быть в настоящем времени.</p><pre class="brush: javascript noskimlinks noskimwords"> override init(imageName: String, bulletSound:String?){    super.init(imageName: imageName, bulletSound: bulletSound)    self.physicsBody = SKPhysicsBody(texture: self.texture, size: self.size)    self.physicsBody?.dynamic = true    self.physicsBody?.usesPreciseCollisionDetection = true    self.physicsBody?.categoryBitMask = CollisionCategories.PlayerBullet    self.physicsBody?.contactTestBitMask = CollisionCategories.Invader    self.physicsBody?.collisionBitMask = 0x0}</pre><h2>7. Настройка физики для <code class="inline">GameScene</code> </h2><h3>Шаг 1. Настройка физического мира</h3><p>Мы должны создать класс <code class="inline">GameScene</code> для реализации <code class="inline">SKPhysicsContactDelegate</code>, чтобы мы могли ответить, когда сталкиваются два тела. Добавьте следующее, чтобы класс <code class="inline">GameScene</code> соответствовал протоколу <code class="inline">SKPhysicsContactDelegate</code>.</p><pre class="brush: javascript noskimlinks noskimwords">class GameScene: SKScene, SKPhysicsContactDelegate{</pre><p>Затем мы должны создать некоторые свойства на <code class="inline">physicsWorld</code> сцены. Введите в верхней части метода <code class="inline">didMoveToView(_:)</code> в <strong>GameScene.swift</strong> следующее.<br></p><pre class="brush: javascript noskimlinks noskimwords">override func didMoveToView(view: SKView) {    self.physicsWorld.gravity = CGVectorMake(0, 0)    self.physicsWorld.contactDelegate = self    ...}</pre><p>Мы устанавливаем <code class="inline">gravity</code> свойство <code class="inline">physicsWorld</code>  равным <strong>0</strong>, так что ни одно физическое тело на сцене не влияет на гравитацию. Вы также можете сделать это на основе тела, вместо того, чтобы заставить весь мир не иметь силы тяжести, установив свойство <code class="inline">affectedByGravity</code>. Мы также установили свойство <code class="inline">contactDelegate</code> в физическом мире для <code class="inline">self</code>- экземпляра <code class="inline">GameScene</code>.</p><h3>Шаг 2: Внедрение <code class="inline">SKPhysicsContactDelegate</code> протокола</h3><p>Чтобы соответствовать классу <code class="inline">GameScene</code> протоколу <code class="inline">SKPhysicsContactDelegate</code>, нам необходимо реализовать метод <code class="inline">didBeginContact(_:)</code>. Этот метод вызывается при контакте двух тел. Реализация метода <code class="inline">didBeginContact(_:)</code> выглядит так.</p><pre class="brush: plain noskimlinks noskimwords">func didBeginContact(contact: SKPhysicsContact) {            var firstBody: SKPhysicsBody    var secondBody: SKPhysicsBody    if contact.bodyA.categoryBitMask &lt; contact.bodyB.categoryBitMask {        firstBody = contact.bodyA        secondBody = contact.bodyB    } else {        firstBody = contact.bodyB        secondBody = contact.bodyA    }            if ((firstBody.categoryBitMask &amp; CollisionCategories.Invader != 0) &amp;&amp;        (secondBody.categoryBitMask &amp; CollisionCategories.PlayerBullet != 0)){            NSLog("Invader and Player Bullet Conatact")    }            if ((firstBody.categoryBitMask &amp; CollisionCategories.Player != 0) &amp;&amp;        (secondBody.categoryBitMask &amp; CollisionCategories.InvaderBullet != 0)) {        NSLog("Player and Invader Bullet Contact")    }            if ((firstBody.categoryBitMask &amp; CollisionCategories.Invader != 0) &amp;&amp;        (secondBody.categoryBitMask &amp; CollisionCategories.Player != 0)) {            NSLog("Invader and Player Collision Contact")                   }        }</pre><p>Сначала объявляем две переменные <code class="inline">firstBody</code> и <code class="inline">secondBody</code>. Когда два объекта контактируют, мы не знаем, какое именно тело есть. Это означает, что сначала нам нужно сделать некоторые проверки, чтобы убедиться, что <code class="inline">firstBody</code> - это тот, у которого нижняя <code class="inline">categoryBitMask</code>.</p><p>Затем мы рассмотрим каждый возможный сценарий, используя побитовый <code class="inline">&amp;</code>оператор и категории столкновений, которые мы определили ранее, чтобы проверить, что делает контакт. Мы регистрируем результат на экране, чтобы убедиться, что все работает так, как должно. Если вы протестируете приложение, все контакты должны работать правильно.</p><h2>Заключение</h2><p>Это был довольно длинный материал, но теперь у нас есть захватчики, стреляющие игроки и захватчики, а также обнаружение контакта с использованием контактных бит масок . Мы находимся на домашнем участке до финальной игры. В следующей и последней части этой серии у нас будет завершенная игра.</p><br><br><br><br>

</div></div>

<div class="tm-article-body__tags"><div class="tm-article-body__tags-links tm-article-body__tags-links2"><span class="tm-article-body__tags-title">Теги:</span><span class="tm-article-body__tags-item"><a aria-label="Code" href="https://norma-studio.github.io/article5/220825410-sozdanie-kosmicheskih-zahvatchikov-s-pomoschyu-swift-i-sprite-kit-realizatsiya-igrovogo-protsessa" class="tm-article-body__tags-item-link">Code</a></span><span class="tm-article-body__tags-item"><a aria-label="SpriteKit" href="https://norma-studio.github.io/article5/220825410-sozdanie-kosmicheskih-zahvatchikov-s-pomoschyu-swift-i-sprite-kit-realizatsiya-igrovogo-protsessa" class="tm-article-body__tags-item-link">SpriteKit</a></span></div></div></div></article>

<div class="tm-article__icons-wrapper"><div class="tm-data-icons tm-page-article__counters-panel"><div class="tm-article-rating tm-data-icons__item"><div class="v-portal" style="display:none;"></div></div><span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title><svg id="counter-views" viewBox="0 0 56 32"><path d="M28 0c18.368 0 28 13.81 28 16s-9.632 16-28 16c-18.368 0-28-13.81-28-16s9.632-16 28-16zm0 28.309c6.874 0 12.446-5.511 12.446-12.309s-5.572-12.309-12.446-12.309-12.446 5.511-12.446 12.309 5.572 12.309 12.446 12.309zM28 16c.084-1.721 5.596-3.019 4.284-4.352-2.429-2.468-6.317-2.521-8.684-.117s-2.314 6.354.116 8.821c2.429 2.468 6.317 2.521 8.683.117 1.089-1.106-4.47-3.008-4.399-4.469z"></path></svg></svg><span class="tm-icon-counter__value">
34984</span></span><button aria-label="Добавить в закладки" title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item" onclick="return addBookmark(this);"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title><svg id="counter-favorite" viewBox="0 0 12 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 0C0.734784 0 0.48043 0.105357 0.292893 0.292893C0.105357 0.48043 0 0.734784 0 1V15C0 15.3603 0.193793 15.6927 0.507301 15.8702C0.82081 16.0477 1.20556 16.0429 1.5145 15.8575L6 13.1662L10.4855 15.8575C10.7944 16.0429 11.1792 16.0477 11.4927 15.8702C11.8062 15.6927 12 15.3603 12 15V1C12 0.447715 11.5523 0 11 0H1Z"></path></svg></svg></span><span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
437</span></button><div title="Поделиться" class="tm-sharing tm-data-icons__item">
<button aria-label="sharing" type="button" class="tm-sharing__button sharer button btn5242" data-sharer="vk" data-url="none"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button></div><div class="v-portal" style="display:none;"></div></div></div>
</div>

<div class="tm-page-article__additional-blocks wr55"></div>
<!-- pagination -->
 </div></div>
<!-- sidebar -->
<div class="tm-page__sidebar"><div id="572480" class="tm-layout-sidebar">

<div class="tm-sexy-sidebar tm-sexy-sidebar_stick-top wr54" style="margin-top: 0px;">
<section class="tm-block tm-block_spacing-bottom wr12a"></section>
<section class="tm-block tm-block_spacing-bottom wr12">

</section>
</div></div></div></div></div></div></main></div><div id="exbottom" class="tm-footer wr56"></div></div><div class="vue-portal-target"></div></div>
<link rel="stylesheet" href="../style.css">
<script src="../jquery-3.7.0.min.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y9PLTD9XQE"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag("js", new Date());gtag("config", "G-Y9PLTD9XQE");</script><script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");ym(63258550, "init", {clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/63258550" style="position:absolute; left:-9999px;" alt="" /></div></noscript></body></html>
